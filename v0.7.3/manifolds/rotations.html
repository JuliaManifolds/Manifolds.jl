<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotations ¬∑ Manifolds.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Manifolds.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../interface.html">ManifoldsBase.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/manifold.html">How to implement a Manifold</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="centeredmatrices.html">Centered matrices</a></li><li><a class="tocitem" href="choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="circle.html">Circle</a></li><li><a class="tocitem" href="elliptope.html">Elliptope</a></li><li><a class="tocitem" href="essentialmanifold.html">Essential manifold</a></li><li><a class="tocitem" href="euclidean.html">Euclidean</a></li><li><a class="tocitem" href="fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="grassmann.html">Grassmann</a></li><li><a class="tocitem" href="hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="multinomialdoublystochastic.html">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="multinomialsymmetric.html">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="probabilitysimplex.html">Probability simplex</a></li><li><a class="tocitem" href="positivenumbers.html">Positive numbers</a></li><li><a class="tocitem" href="projectivespace.html">Projective space</a></li><li class="is-active"><a class="tocitem" href="rotations.html">Rotations</a><ul class="internal"><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="skewhermitian.html">Skew-Hermitian matrices</a></li><li><a class="tocitem" href="spectrahedron.html">Spectrahedron</a></li><li><a class="tocitem" href="sphere.html">Sphere</a></li><li><a class="tocitem" href="stiefel.html">Stiefel</a></li><li><a class="tocitem" href="symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="symmetricpsdfixedrank.html">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="torus.html">Torus</a></li><li><a class="tocitem" href="tucker.html">Tucker</a></li><li><a class="tocitem" href="spheresymmetricmatrices.html">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="graph.html">Graph manifold</a></li><li><a class="tocitem" href="power.html">Power manifold</a></li><li><a class="tocitem" href="product.html">Product manifold</a></li><li><a class="tocitem" href="vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="connection.html">Connection manifold</a></li><li><a class="tocitem" href="group.html">Group manifold</a></li><li><a class="tocitem" href="metric.html">Metric manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="../features/atlases.html">Atlases and charts</a></li><li><a class="tocitem" href="../features/differentiation.html">Differentiation</a></li><li><a class="tocitem" href="../features/distributions.html">Distributions</a></li><li><a class="tocitem" href="../features/statistics.html">Statistics</a></li><li><a class="tocitem" href="../features/testing.html">Testing</a></li><li><a class="tocitem" href="../features/utilities.html">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="../misc/about.html">About</a></li><li><a class="tocitem" href="../misc/contributing.html">Contributing</a></li><li><a class="tocitem" href="../misc/internals.html">Internals</a></li><li><a class="tocitem" href="../misc/notation.html">Notation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manifolds</a></li><li><a class="is-disabled">Basic manifolds</a></li><li class="is-active"><a href="rotations.html">Rotations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="rotations.html">Rotations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/manifolds/rotations.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Rotations"><a class="docs-heading-anchor" href="#Rotations">Rotations</a><a id="Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Rotations" title="Permalink"></a></h1><p>The manifold <span>$\mathrm{SO}(n)$</span> of orthogonal matrices with determinant <span>$+1$</span> in <span>$‚Ñù^{n √ó n}$</span>, i.e.</p><p class="math-container">\[\mathrm{SO}(n) = \bigl\{R ‚àà ‚Ñù^{n √ó n} \big| R R^{\mathrm{T}} =
R^{\mathrm{T}}R = I_n, \det(R) = 1 \bigr\}\]</p><p>The Lie group <span>$\mathrm{SO}(n)$</span> is a subgroup of the orthogonal group <span>$\mathrm{O}(n)$</span> and also known as the special orthogonal group or the set of rotations group. See also <a href="group.html#Manifolds.SpecialOrthogonal"><code>SpecialOrthogonal</code></a>, which is this manifold equipped with the group operation.</p><p>Tangent vectors are represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.</p><p>Let <span>$L_R: \mathrm{SO}(n) ‚Üí \mathrm{SO}(n)$</span> where <span>$R ‚àà \mathrm{SO}(n)$</span> be the left-multiplication by <span>$R$</span>, that is <span>$L_R(S) = RS$</span>. The tangent space at rotation <span>$R$</span>, <span>$T_R \mathrm{SO}(n)$</span>, is related to the tangent space at the identity rotation <span>$I_n$</span> by the differential of <span>$L_R$</span> at identity, <span>$(\mathrm{d}L_R)_{I_n} : T_{I_n} \mathrm{SO}(n) ‚Üí T_R \mathrm{SO}(n)$</span>. For a tangent vector at the identity rotation <span>$X ‚àà T_{I_n} \mathrm{SO}(n)$</span> the matrix representation of the corresponding tangent vector <span>$Y$</span> at a rotation <span>$R$</span> can be obtained by matrix multiplication: <span>$Y = RX ‚àà T_R \mathrm{SO}(n)$</span>. You can compare the functions <a href="rotations.html#Base.log-Tuple{Rotations, Vararg{Any, N} where N}"><code>log</code></a> and <a href="rotations.html#Base.exp-Tuple{Rotations, Vararg{Any, N} where N}"><code>exp</code></a> to see how it works in practice.</p><article class="docstring"><header><a class="docstring-binding" id="Manifolds.NormalRotationDistribution" href="#Manifolds.NormalRotationDistribution"><code>Manifolds.NormalRotationDistribution</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)</code></pre><p>Distribution that returns a random point on the manifold <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>. Random point is generated using base distribution <code>d</code> and the type of the result is adjusted to <code>TResult</code>.</p><p>See <a href="rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N}, Any, Real}} where N"><code>normal_rotation_distribution</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L18-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.Rotations" href="#Manifolds.Rotations"><code>Manifolds.Rotations</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rotations{N} &lt;: AbstractManifold{‚Ñù}</code></pre><p>The special orthogonal manifold <span>$\mathrm{SO}(n)$</span> represented by <span>$n √ó n$</span> real-valued orthogonal matrices with determinant <span>$+1$</span> is the manifold of <code>Rotations</code>, since these matrices represent all rotations of points in <span>$‚Ñù^n$</span>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Rotations(n)</code></pre><p>Generate the <span>$\mathrm{SO}(n) \subset ‚Ñù^{n √ó n}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{Rotations, Vararg{Any, N} where N}" href="#Base.exp-Tuple{Rotations, Vararg{Any, N} where N}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::Rotations, p, X)</code></pre><p>Compute the exponential map on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> from <code>p</code> into direction <code>X</code>, i.e.</p><p class="math-container">\[\exp_p X = p \operatorname{Exp}(X),\]</p><p>where <span>$\operatorname{Exp}(X)$</span>  denotes the matrix exponential of <span>$X$</span>.</p><pre><code class="nohighlight hljs">exp(M::Rotations{4}, p, X)</code></pre><p>Compute the exponential map of tangent vector <code>X</code> at point <code>p</code> from <span>$\mathrm{SO}(4)$</span> manifold <code>M</code>.</p><p>The algorithm used is a more numerically stable form of those proposed in <sup class="footnote-reference"><a id="citeref-Gallier2002" href="#footnote-Gallier2002">[Gallier2002]</a></sup> and <sup class="footnote-reference"><a id="citeref-Andrica2013" href="#footnote-Andrica2013">[Andrica2013]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L129-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{Rotations, Vararg{Any, N} where N}" href="#Base.log-Tuple{Rotations, Vararg{Any, N} where N}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::Rotations, p, q)</code></pre><p>Compute the logarithmic map on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code><span>$=\mathrm{SO}(n)$</span>, which is given by</p><p class="math-container">\[\log_p q =
  \frac{1}{2} \bigl(\operatorname{Log}(p^{\mathrm{T}}q)
  - (\operatorname{Log}(p^{\mathrm{T}}q)^{\mathrm{T}}),\]</p><p>where <span>$\operatorname{Log}$</span> denotes the matrix logarithm.</p><p>For antipodal rotations the function returns deterministically one of the tangent vectors that point at <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L461-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Rotations, Any, Any}" href="#LinearAlgebra.norm-Tuple{Rotations, Any, Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::Rotations, p, X)</code></pre><p>Compute the norm of a tangent vector <code>X</code> from the tangent space at <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>. The formula reads</p><p class="math-container">\[\lVert X \rVert_p = \lVert X \rVert,\]</p><p>i.e. the Frobenius norm of <code>X</code>, where tangent vectors are represented by elements from the Lie algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L552-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}" href="#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}"><code>Manifolds.angles_4d_skew_sym_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles_4d_skew_sym_matrix(A)</code></pre><p>The Lie algebra of <a href="rotations.html#Manifolds.Rotations"><code>Rotations(4)</code></a> in <span>$‚Ñù^{4 √ó 4}$</span>, <span>$ùî∞ùî¨(4)$</span>, consists of <span>$4 √ó 4$</span> skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than <code>eigvals</code>.</p><p>By convention, the returned values are sorted in decreasing order (corresponding to the same ordering of <em>angles</em> as <a href="rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}"><code>cos_angles_4d_rotation_matrix</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}" href="#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}"><code>Manifolds.cos_angles_4d_rotation_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cos_angles_4d_rotation_matrix(R)</code></pre><p>4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles <span>$Œ±,Œ≤$</span> of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system</p><p class="math-container">\[\begin{aligned}
\cos Œ± + \cos Œ≤ &amp;= \frac{1}{2} \operatorname{tr}(R)\\
\cos Œ± + \cos Œ≤ &amp;= \frac{1}{8} \operatorname{tr}(R)^2
                 - \frac{1}{16} \operatorname{tr}((R - R^T)^2) - 1.
\end{aligned}\]</p><p>By convention, the returned values are sorted in increasing order. See <a href="rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}"><code>angles_4d_skew_sym_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L102-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N}, Any, Real}} where N" href="#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N}, Any, Real}} where N"><code>Manifolds.normal_rotation_distribution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_rotation_distribution(M::Rotations, p, œÉ::Real)</code></pre><p>Return a random point on the manifold <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> by generating a (Gaussian) random orthogonal matrix with determinant <span>$+1$</span>. Let</p><p class="math-container">\[QR = A\]</p><p>be the QR decomposition of a random matrix <span>$A$</span>, then the formula reads</p><p class="math-container">\[p = QD\]</p><p>where <span>$D$</span> is a diagonal matrix with the signs of the diagonal entries of <span>$R$</span>, i.e.</p><p class="math-container">\[D_{ij}=\begin{cases} \operatorname{sgn}(R_{ij}) &amp; \text{if} \; i=j \\ 0 &amp; \, \text{otherwise} \end{cases}.\]</p><p>It can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.</p><p>The argument <code>p</code> is used to determine the type of returned points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L567-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Union{Tuple{N}, Tuple{Rotations{N}, Any}} where N" href="#ManifoldsBase.check_point-Union{Tuple{N}, Tuple{Rotations{N}, Any}} where N"><code>ManifoldsBase.check_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>, i.e. is an array of size <a href="../interface.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a><code>(M)</code> and represents a valid rotation. The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Union{Tuple{N}, Tuple{Rotations{N}, Any, Any}} where N" href="#ManifoldsBase.check_vector-Union{Tuple{N}, Tuple{Rotations{N}, Any, Any}} where N"><code>ManifoldsBase.check_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> space <code>M</code>, i.e. after <a href="../interface.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a><code>(M,p)</code>, <code>X</code> has to be of same dimension and orthogonal to <code>p</code>. The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_coordinates-Tuple{Rotations, Vararg{Any, N} where N}" href="#ManifoldsBase.get_coordinates-Tuple{Rotations, Vararg{Any, N} where N}"><code>ManifoldsBase.get_coordinates</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_coordinates(M::Rotations, p, X)</code></pre><p>Extract the unique tangent vector components <span>$X^i$</span> at point <code>p</code> on <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <span>$\mathrm{SO}(n)$</span> from the matrix representation <code>X</code> of the tangent vector.</p><p>The basis on the Lie algebra <span>$ùî∞ùî¨(n)$</span> is chosen such that for <span>$\mathrm{SO}(2)$</span>, <span>$X^1 = Œ∏ = X_{21}$</span> is the angle of rotation, and for <span>$\mathrm{SO}(3)$</span>, <span>$(X^1, X^2, X^3) = (X_{32}, X_{13}, X_{21}) = Œ∏ u$</span> is the angular velocity and axis-angle representation, where <span>$u$</span> is the unit vector along the axis of rotation.</p><p>For <span>$\mathrm{SO}(n)$</span> where <span>$n ‚â• 4$</span>, the additional elements of <span>$X^i$</span> are <span>$X^{j (j - 3)/2 + k + 1} = X_{jk}$</span>, for <span>$j ‚àà [4,n], k ‚àà [1,j)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L224-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_vector-Tuple{Rotations, Vararg{Any, N} where N}" href="#ManifoldsBase.get_vector-Tuple{Rotations, Vararg{Any, N} where N}"><code>ManifoldsBase.get_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vector(M::Rotations, p, X‚Å±, B::DefaultOrthogonalBasis)</code></pre><p>Convert the unique tangent vector components <code>X‚Å±</code> at point <code>p</code> on <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> group <span>$\mathrm{SO}(n)$</span> to the matrix representation <span>$X$</span> of the tangent vector. See <a href="rotations.html#ManifoldsBase.get_coordinates-Tuple{Rotations, Vararg{Any, N} where N}"><code>get_coordinates</code></a> for the conventions used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L286-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{Rotations}" href="#ManifoldsBase.injectivity_radius-Tuple{Rotations}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::Rotations)
injectivity_radius(M::Rotations, p)</code></pre><p>Return the injectivity radius on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>, which is globally</p><p class="math-container">\[    \operatorname{inj}_{\mathrm{SO}(n)}(p) = œÄ\sqrt{2}.\]</p><pre><code class="nohighlight hljs">injectivity_radius(M::Rotations, p, ::PolarRetraction)</code></pre><p>Return the radius of injectivity for the <a href="../interface.html#ManifoldsBase.PolarRetraction"><code>PolarRetraction</code></a> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> which is <span>$\frac{œÄ}{\sqrt{2}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L358-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{Rotations, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{Rotations, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::Rotations, p, X, Y)</code></pre><p>Compute the inner product of the two tangent vectors <code>X</code>, <code>Y</code> from the tangent plane at <code>p</code> on the special orthogonal space <code>M=</code><span>$\mathrm{SO}(n)$</span> using the restriction of the metric from the embedding, i.e.</p><p class="math-container">\[g_p(X, Y) = \operatorname{tr}(X^\mathrm{T} Y),\]</p><p>Tangent vectors are represented by matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L388-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, PolarInverseRetraction}" href="#ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, PolarInverseRetraction}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M, p, q, ::PolarInverseRetraction)</code></pre><p>Compute a vector from the tangent space <span>$T_p\mathrm{SO}(n)$</span> of the point <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code> with which the point <code>q</code> can be reached by the <a href="../interface.html#ManifoldsBase.PolarRetraction"><code>PolarRetraction</code></a> from the point <code>p</code> after time 1.</p><p>The formula reads</p><p class="math-container">\[\operatorname{retr}^{-1}_p(q)
= -\frac{1}{2}(p^{\mathrm{T}}qs - (p^{\mathrm{T}}qs)^{\mathrm{T}})\]</p><p>where <span>$s$</span> is the solution to the Sylvester equation</p><p class="math-container">\[p^{\mathrm{T}}qs + s(p^{\mathrm{T}}q)^{\mathrm{T}} + 2I_n = 0.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L403-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, QRInverseRetraction}" href="#ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, QRInverseRetraction}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::Rotations, p, q, ::QRInverseRetraction)</code></pre><p>Compute a vector from the tangent space <span>$T_p\mathrm{SO}(n)$</span> of the point <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code> with which the point <code>q</code> can be reached by the <a href="../interface.html#ManifoldsBase.QRRetraction"><code>QRRetraction</code></a> from the point <code>q</code> after time 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L423-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N" href="#ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N"><code>ManifoldsBase.manifold_dimension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::Rotations)</code></pre><p>Return the dimension of the manifold <span>$\mathrm{SO}(n)$</span>, i.e.</p><p class="math-container">\[\dim_{\mathrm{SO}(n)} = \frac{n(n-1)}{2}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L524-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{Rotations, Any, Any}" href="#ManifoldsBase.project-Tuple{Rotations, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::Rotations, p, X)</code></pre><p>Project the matrix <code>X</code> onto the tangent space by making <code>X</code> skew symmetric,</p><p class="math-container">\[\operatorname{proj}_p(X) = \frac{X-X^{\mathrm{T}}}{2},\]</p><p>where tangent vectors are represented by elements from the Lie group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L625-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{Rotations, Any}" href="#ManifoldsBase.project-Tuple{Rotations, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::Rotations, p; check_det = true)</code></pre><p>Project <code>p</code> to the nearest point on manifold <code>M</code>.</p><p>Given the singular value decomposition <span>$p = U Œ£ V^\mathrm{T}$</span>, with the singular values sorted in descending order, the projection is</p><p class="math-container">\[\operatorname{proj}_{\mathrm{SO}(n)}(p) =
U\operatorname{diag}\left[1,1,‚Ä¶,\det(U V^\mathrm{T})\right] V^\mathrm{T}\]</p><p>The diagonal matrix ensures that the determinant of the result is <span>$+1$</span>. If <code>p</code> is expected to be almost special orthogonal, then you may avoid this check with <code>check_det = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L594-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Union{Tuple{Rotations{N}}, Tuple{N}} where N" href="#ManifoldsBase.representation_size-Union{Tuple{Rotations{N}}, Tuple{N}} where N"><code>ManifoldsBase.representation_size</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">representation_size(M::Rotations)</code></pre><p>Return the <code>size()</code> of a point on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>, i.e. for the <span>$\mathrm{SO}(n)$</span> it&#39;s <code>(n,n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L640-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{Rotations, Any, Any, PolarRetraction}" href="#ManifoldsBase.retract-Tuple{Rotations, Any, Any, PolarRetraction}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::Rotations, p, X, ::PolarRetraction)</code></pre><p>Compute the SVD-based retraction on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> from <code>p</code> in direction <code>X</code> (as an element of the Lie group) and is a second-order approximation of the exponential map. Let</p><p class="math-container">\[USV = p + pX\]</p><p>be the singular value decomposition, then the formula reads</p><p class="math-container">\[\operatorname{retr}_p X = UV^\mathrm{T}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L678-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{Rotations, Any, Any, QRRetraction}" href="#ManifoldsBase.retract-Tuple{Rotations, Any, Any, QRRetraction}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M, p, X, ::QRRetraction)</code></pre><p>Compute the QR-based retraction on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> from <code>p</code> in direction <code>X</code> (as an element of the Lie group), which is a first-order approximation of the exponential map.</p><p>This is also the default retraction on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L697-L704">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction-Tuple{Rotations, Any, Any, Any}" href="#ManifoldsBase.vector_transport_direction-Tuple{Rotations, Any, Any, Any}"><code>ManifoldsBase.vector_transport_direction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction(M::Rotations, p, X, d)</code></pre><p>Compute parallel transport of vector <code>X</code> tangent at <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold in the direction <code>d</code>. The formula, provided in <sup class="footnote-reference"><a id="citeref-Rentmeesters" href="#footnote-Rentmeesters">[Rentmeesters]</a></sup>, reads:</p><p class="math-container">\[\mathcal P_{q\gets p}X = q^\mathrm{T}p \operatorname{Exp}(d/2) X \operatorname{Exp}(d/2)\]</p><p>where <span>$q=\exp_p d$</span>.</p><p>The formula simplifies to identity for 2-D rotations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L723-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{Rotations, Any}" href="#ManifoldsBase.zero_vector-Tuple{Rotations, Any}"><code>ManifoldsBase.zero_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(M::Rotations, p)</code></pre><p>Return the zero tangent vector from the tangent space art <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> as an element of the Lie group, i.e. the zero matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L761-L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{Rotations, Any}" href="#Statistics.mean-Tuple{Rotations, Any}"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(
    M::Rotations,
    x::AbstractVector,
    [w::AbstractWeights,]
    method = GeodesicInterpolationWithinRadius(œÄ/2/‚àö2);
    kwargs...,
)</code></pre><p>Compute the Riemannian <a href="../features/statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any, N} where N}"><code>mean</code></a> of <code>x</code> using <a href="../features/statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f3e1ff5fe567d1df9dac327de22ae913dc8a20f1/src/manifolds/Rotations.jl#L534-L545">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Gallier2002"><a class="tag is-link" href="#citeref-Gallier2002">Gallier2002</a><blockquote><p>Gallier J.; Xu D.; Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation (2002), 17(4), pp. 1-11. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.3205">pdf</a>.</p></blockquote></li><li class="footnote" id="footnote-Andrica2013"><a class="tag is-link" href="#citeref-Andrica2013">Andrica2013</a><blockquote><p>Andrica D.; Rohan R.-A.; Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications (2013), 18(2), pp. 1-2. <a href="https://www.emis.de/journals/BJGA/v18n2/B18-2-an.pdf">pdf</a>.</p></blockquote></li><li class="footnote" id="footnote-Rentmeesters"><a class="tag is-link" href="#citeref-Rentmeesters">Rentmeesters</a><blockquote><p>Rentmeesters Q., ‚ÄúA gradient method for geodesic data fitting on some symmetric Riemannian manifolds,‚Äù in 2011 50th IEEE Conference on Decision and Control and European Control Conference, Dec. 2011, pp. 7141‚Äì7146. doi: 10.1109/CDC.2011.6161280.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="projectivespace.html">¬´ Projective space</a><a class="docs-footer-nextpage" href="skewhermitian.html">Skew-Hermitian matrices ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Friday 4 February 2022 12:26">Friday 4 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
