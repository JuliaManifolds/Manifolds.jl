<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotations ¬∑ Manifolds.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manifolds.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../interface.html">ManifoldsBase.jl</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/manifold.html">implement a Manifold</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="centeredmatrices.html">Centered matrices</a></li><li><a class="tocitem" href="choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="circle.html">Circle</a></li><li><a class="tocitem" href="elliptope.html">Elliptope</a></li><li><a class="tocitem" href="euclidean.html">Euclidean</a></li><li><a class="tocitem" href="fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="grassmann.html">Grassmann</a></li><li><a class="tocitem" href="hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="probabilitysimplex.html">Probability simplex</a></li><li class="is-active"><a class="tocitem" href="rotations.html">Rotations</a><ul class="internal"><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="skewsymmetric.html">Skew-symmetric matrices</a></li><li><a class="tocitem" href="sphere.html">Sphere</a></li><li><a class="tocitem" href="stiefel.html">Stiefel</a></li><li><a class="tocitem" href="symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="torus.html">Torus</a></li><li><a class="tocitem" href="spheresymmetricmatrices.html">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="graph.html">Graph manifold</a></li><li><a class="tocitem" href="power.html">Power manifold</a></li><li><a class="tocitem" href="product.html">Product manifold</a></li><li><a class="tocitem" href="vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="metric.html">Metric manifold</a></li><li><a class="tocitem" href="group.html">Group manifold</a></li></ul></li></ul></li><li><a class="tocitem" href="../statistics.html">Statistics</a></li><li><a class="tocitem" href="../distributions.html">Distributions</a></li><li><a class="tocitem" href="../about.html">About</a></li><li><a class="tocitem" href="../generated/contributing.html">Contributing</a></li><li><a class="tocitem" href="../notation.html">Notation</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../lib/public.html">Public</a></li><li><a class="tocitem" href="../lib/internals.html">Internals</a></li><li><a class="tocitem" href="../lib/differentiation.html">Differentiation</a></li><li><a class="tocitem" href="../lib/testing.html">Testing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manifolds</a></li><li><a class="is-disabled">Basic manifolds</a></li><li class="is-active"><a href="rotations.html">Rotations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="rotations.html">Rotations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/manifolds/rotations.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Rotations"><a class="docs-heading-anchor" href="#Rotations">Rotations</a><a id="Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Rotations" title="Permalink"></a></h1><p>The manifold <span>$\mathrm{SO}(n)$</span> of orthogonal matrices with determinant <span>$+1$</span> in <span>$‚Ñù^{n √ó n}$</span>, i.e.</p><div>\[\mathrm{SO}(n) = \bigl\{R ‚àà ‚Ñù^{n √ó n} \big| R R^{\mathrm{T}} =
R^{\mathrm{T}}R = I_n, \det(R) = 1 \bigr\}\]</div><p>The Lie group <span>$\mathrm{SO}(n)$</span> is a subgroup of the orthogonal group <span>$\mathrm{O}(n)$</span> and also known as the special orthogonal group or the set of rotations group. See also <a href="group.html#Manifolds.SpecialOrthogonal"><code>SpecialOrthogonal</code></a>, which is this manifold equipped with the group operation.</p><p>Tangent vectors are represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.</p><p>Let <span>$L_R: \mathrm{SO}(n) ‚Üí \mathrm{SO}(n)$</span> where <span>$R ‚àà \mathrm{SO}(n)$</span> be the left-multiplication by <span>$R$</span>, that is <span>$L_R(S) = RS$</span>. The tangent space at rotation <span>$R$</span>, <span>$T_R \mathrm{SO}(n)$</span>, is related to the tangent space at the identity rotation <span>$I_n$</span> by the differential of <span>$L_R$</span> at identity, <span>$(\mathrm{d}L_R)_{I_n} : T_{I_n} \mathrm{SO}(n) ‚Üí T_R \mathrm{SO}(n)$</span>. For a tangent vector at the identity rotation <span>$X ‚àà T_{I_n} \mathrm{SO}(n)$</span> the matrix representation of the corresponding tangent vector <span>$Y$</span> at a rotation <span>$R$</span> can be obtained by matrix multiplication: <span>$Y = RX ‚àà T_R \mathrm{SO}(n)$</span>. You can compare the functions <a href="rotations.html#Base.log-Tuple{Rotations,Vararg{Any,N} where N}"><code>log</code></a> and <a href="rotations.html#Base.exp-Tuple{Rotations,Vararg{Any,N} where N}"><code>exp</code></a> to see how it works in practice.</p><article class="docstring"><header><a class="docstring-binding" id="Manifolds.NormalRotationDistribution" href="#Manifolds.NormalRotationDistribution"><code>Manifolds.NormalRotationDistribution</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)</code></pre><p>Distribution that returns a random point on the manifold <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>. Random point is generated using base distribution <code>d</code> and the type of the result is adjusted to <code>TResult</code>.</p><p>See <a href="rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N},Any,Real}} where N"><code>normal_rotation_distribution</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L18-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.Rotations" href="#Manifolds.Rotations"><code>Manifolds.Rotations</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rotations{N} &lt;: Manifold{‚Ñù}</code></pre><p>The special orthogonal manifold <span>$\mathrm{SO}(n)$</span> represented by <span>$n √ó n$</span> real-valued orthogonal matrices with determinant <span>$+1$</span> is the manifold of <code>Rotations</code>, since these matrices represent all rotations of points in <span>$‚Ñù^n$</span>.</p><p><strong>Constructor</strong></p><pre><code class="language-none">Rotations(n)</code></pre><p>Generate the <span>$\mathrm{SO}(n) \subset ‚Ñù^{n √ó n}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{Rotations,Vararg{Any,N} where N}" href="#Base.exp-Tuple{Rotations,Vararg{Any,N} where N}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(M::Rotations, p, X)</code></pre><p>Compute the exponential map on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> from <code>p</code> into direction <code>X</code>, i.e.</p><div>\[\exp_p X = p \operatorname{Exp}(X),\]</div><p>where <span>$\operatorname{Exp}(X)$</span>  denotes the matrix exponential of <span>$X$</span>.</p><pre><code class="language-none">exp(M::Rotations{4}, p, X)</code></pre><p>Compute the exponential map of tangent vector <code>X</code> at point <code>p</code> from <span>$\mathrm{SO}(4)$</span> manifold <code>M</code>.</p><p>The algorithm used is a more numerically stable form of those proposed in <sup class="footnote-reference"><a id="citeref-Gallier2002" href="#footnote-Gallier2002">[Gallier2002]</a></sup> and <sup class="footnote-reference"><a id="citeref-Andrica2013" href="#footnote-Andrica2013">[Andrica2013]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L149-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{Rotations,Vararg{Any,N} where N}" href="#Base.log-Tuple{Rotations,Vararg{Any,N} where N}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log(M::Rotations, p, q)</code></pre><p>Compute the logarithmic map on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code><span>$=\mathrm{SO}(n)$</span>, which is given by</p><div>\[\log_p q =
  \frac{1}{2} \bigl(\operatorname{Log}(p^{\mathrm{T}}q)
  - (\operatorname{Log}(p^{\mathrm{T}}q)^{\mathrm{T}}),\]</div><p>where <span>$\operatorname{Log}$</span> denotes the matrix logarithm.</p><p>For antipodal rotations the function returns deterministically one of the tangent vectors that point at <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L454-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Rotations,Any,Any}" href="#LinearAlgebra.norm-Tuple{Rotations,Any,Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(M::Rotations, p, X)</code></pre><p>Compute the norm of a tangent vector <code>X</code> from the tangent space at <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>. The formula reads</p><div>\[\lVert X \rVert_p = \lVert X \rVert,\]</div><p>i.e. the Frobenius norm of <code>X</code>, where tangent vectors are represented by elements from the Lie algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L545-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}" href="#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}"><code>Manifolds.angles_4d_skew_sym_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angles_4d_skew_sym_matrix(A)</code></pre><p>The Lie algebra of <a href="rotations.html#Manifolds.Rotations"><code>Rotations(4)</code></a> in <span>$‚Ñù^{4 √ó 4}$</span>, <span>$ùî∞ùî¨(4)$</span>, consists of <span>$4 √ó 4$</span> skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than <code>eigvals</code>.</p><p>By convention, the returned values are sorted in decreasing order (corresponding to the same ordering of <em>angles</em> as <a href="rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}"><code>cos_angles_4d_rotation_matrix</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}" href="#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}"><code>Manifolds.cos_angles_4d_rotation_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cos_angles_4d_rotation_matrix(R)</code></pre><p>4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles <span>$Œ±,Œ≤$</span> of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system</p><div>\[\begin{aligned}
\cos Œ± + \cos Œ≤ &amp;= \frac{1}{2} \operatorname{tr}(R)\\
\cos Œ± + \cos Œ≤ &amp;= \frac{1}{8} \operatorname{tr}(R)^2
                 - \frac{1}{16} \operatorname{tr}((R - R^T)^2) - 1.
\end{aligned}\]</div><p>By convention, the returned values are sorted in increasing order. See <a href="rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}"><code>angles_4d_skew_sym_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L122-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N},Any,Real}} where N" href="#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N},Any,Real}} where N"><code>Manifolds.normal_rotation_distribution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal_rotation_distribution(M::Rotations, p, œÉ::Real)</code></pre><p>Return a random point on the manifold <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> by generating a (Gaussian) random orthogonal matrix with determinant <span>$+1$</span>. Let</p><div>\[QR = A\]</div><p>be the QR decomposition of a random matrix <span>$A$</span>, then the formula reads</p><div>\[p = QD\]</div><p>where <span>$D$</span> is a diagonal matrix with the signs of the diagonal entries of <span>$R$</span>, i.e.</p><div>\[D_{ij}=\begin{cases} \operatorname{sgn}(R_{ij}) &amp; \text{if} \; i=j \\ 0 &amp; \, \text{otherwise} \end{cases}.\]</div><p>It can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.</p><p>The argument <code>p</code> is used to determine the type of returned points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L560-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.normal_tvector_distribution-Tuple{Rotations,Any,Any}" href="#Manifolds.normal_tvector_distribution-Tuple{Rotations,Any,Any}"><code>Manifolds.normal_tvector_distribution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal_tvector_distribution(M::Rotations, p, œÉ)</code></pre><p>Normal distribution in ambient space with standard deviation <code>œÉ</code> projected to tangent space at <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L587-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{Rotations{N},Any}} where N" href="#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{Rotations{N},Any}} where N"><code>ManifoldsBase.check_manifold_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_manifold_point(M, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>, i.e. is an array of size <a href="../interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>manifold_dimension</code></a><code>(M)</code> and represents a valid rotation. The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Rotations{N},Any,Any}} where N" href="#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Rotations{N},Any,Any}} where N"><code>ManifoldsBase.check_tangent_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_tangent_vector(M, p, X; check_base_point = true, kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> space <code>M</code>, i.e. after <a href="../interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point</code></a><code>(M,p)</code>, <code>X</code> has to be of same dimension and orthogonal to <code>p</code>. The optional parameter <code>check_base_point</code> indicates, whether to call <a href="../interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point</code></a>  for <code>p</code>. The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L87-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_coordinates-Tuple{Rotations,Vararg{Any,N} where N}" href="#ManifoldsBase.get_coordinates-Tuple{Rotations,Vararg{Any,N} where N}"><code>ManifoldsBase.get_coordinates</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_coordinates(M::Rotations, p, X)</code></pre><p>Extract the unique tangent vector components <span>$X^i$</span> at point <code>p</code> on <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <span>$\mathrm{SO}(n)$</span> from the matrix representation <code>X</code> of the tangent vector.</p><p>The basis on the Lie algebra <span>$ùî∞ùî¨(n)$</span> is chosen such that for <span>$\mathrm{SO}(2)$</span>, <span>$X^1 = Œ∏ = X_{21}$</span> is the angle of rotation, and for <span>$\mathrm{SO}(3)$</span>, <span>$(X^1, X^2, X^3) = (X_{32}, X_{13}, X_{21}) = Œ∏ u$</span> is the angular velocity and axis-angle representation, where <span>$u$</span> is the unit vector along the axis of rotation.</p><p>For <span>$\mathrm{SO}(n)$</span> where <span>$n ‚â• 4$</span>, the additional elements of <span>$X^i$</span> are <span>$X^{j (j - 3)/2 + k + 1} = X_{jk}$</span>, for <span>$j ‚àà [4,n], k ‚àà [1,j)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L252-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_vector-Tuple{Rotations,Vararg{Any,N} where N}" href="#ManifoldsBase.get_vector-Tuple{Rotations,Vararg{Any,N} where N}"><code>ManifoldsBase.get_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_vector(M::Rotations, p, X‚Å±, B:: DefaultOrthogonalBasis)</code></pre><p>Convert the unique tangent vector components <code>X‚Å±</code> at point <code>p</code> on <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> group <span>$\mathrm{SO}(n)$</span> to the matrix representation <span>$X$</span> of the tangent vector. See <a href="rotations.html#ManifoldsBase.get_coordinates-Tuple{Rotations,Vararg{Any,N} where N}"><code>get_coordinates</code></a> for the conventions used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L296-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{Rotations}" href="#ManifoldsBase.injectivity_radius-Tuple{Rotations}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">injectivity_radius(M::Rotations)
injectivity_radius(M::Rotations, p)</code></pre><p>Return the injectivity radius on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>, which is globally</p><div>\[    \operatorname{inj}_{\mathrm{SO}(n)}(p) = œÄ\sqrt{2}.\]</div><pre><code class="language-none">injectivity_radius(M::Rotations, p, ::PolarRetraction)</code></pre><p>Return the radius of injectivity for the <a href="../interface.html#ManifoldsBase.PolarRetraction"><code>PolarRetraction</code></a> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> which is <span>$\frac{œÄ}{\sqrt{2}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L350-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{Rotations,Any,Any,Any}" href="#ManifoldsBase.inner-Tuple{Rotations,Any,Any,Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner(M::Rotations, p, X, Y)</code></pre><p>Compute the inner product of the two tangent vectors <code>X</code>, <code>Y</code> from the tangent plane at <code>p</code> on the special orthogonal space <code>M=</code><span>$\mathrm{SO}(n)$</span> using the restriction of the metric from the embedding, i.e.</p><div>\[g_p(X, Y) = \operatorname{tr}(X^\mathrm{T} Y),\]</div><p>Tangent vectors are represented by matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L380-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{Rotations,Any,Any,PolarInverseRetraction}" href="#ManifoldsBase.inverse_retract-Tuple{Rotations,Any,Any,PolarInverseRetraction}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract(M, p, q, ::PolarInverseRetraction)</code></pre><p>Compute a vector from the tangent space <span>$T_p\mathrm{SO}(n)$</span> of the point <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code> with which the point <code>q</code> can be reached by the <a href="../interface.html#ManifoldsBase.PolarRetraction"><code>PolarRetraction</code></a> from the point <code>p</code> after time 1.</p><p>The formula reads</p><div>\[\operatorname{retr}^{-1}_p(q)
= -\frac{1}{2}(p^{\mathrm{T}}qs - (p^{\mathrm{T}}qs)^{\mathrm{T}})\]</div><p>where <span>$s$</span> is the solution to the Sylvester equation</p><div>\[p^{\mathrm{T}}qs + s(p^{\mathrm{T}}q)^{\mathrm{T}} + 2I_n = 0.\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L395-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{Rotations,Any,Any,QRInverseRetraction}" href="#ManifoldsBase.inverse_retract-Tuple{Rotations,Any,Any,QRInverseRetraction}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract(M::Rotations, p, q, ::QRInverseRetraction)</code></pre><p>Compute a vector from the tangent space <span>$T_p\mathrm{SO}(n)$</span> of the point <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code> with which the point <code>q</code> can be reached by the <a href="../interface.html#ManifoldsBase.QRRetraction"><code>QRRetraction</code></a> from the point <code>q</code> after time 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L415-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N" href="#ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N"><code>ManifoldsBase.manifold_dimension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">manifold_dimension(M::Rotations)</code></pre><p>Return the dimension of the manifold <span>$\mathrm{SO}(n)$</span>, i.e.</p><div>\[\dim_{\mathrm{SO}(n)} = \frac{n(n-1)}{2}.\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L517-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{Rotations,Any,Any}" href="#ManifoldsBase.project-Tuple{Rotations,Any,Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(M::Rotations, p, X)</code></pre><p>Project the matrix <code>X</code> onto the tangent space by making <code>X</code> skew symmetric,</p><div>\[\operatorname{proj}_p(X) = \frac{X-X^{\mathrm{T}}}{2},\]</div><p>where tangent vectors are represented by elements from the Lie group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L629-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{Rotations,Any}" href="#ManifoldsBase.project-Tuple{Rotations,Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(M::Rotations, p; check_det = true)</code></pre><p>Project <code>p</code> to the nearest point on manifold <code>M</code>.</p><p>Given the singular value decomposition <span>$p = U Œ£ V^\mathrm{T}$</span>, with the singular values sorted in descending order, the projection is</p><div>\[\operatorname{proj}_{\mathrm{SO}(n)}(p) =
U\operatorname{diag}\left[1,1,‚Ä¶,\det(U V^\mathrm{T})\right] V^\mathrm{T}\]</div><p>The diagonal matrix ensures that the determinant of the result is <span>$+1$</span>. If <code>p</code> is expected to be almost special orthogonal, then you may avoid this check with <code>check_det = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L598-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Union{Tuple{Rotations{N}}, Tuple{N}} where N" href="#ManifoldsBase.representation_size-Union{Tuple{Rotations{N}}, Tuple{N}} where N"><code>ManifoldsBase.representation_size</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representation_size(M::Rotations)</code></pre><p>Return the <code>size()</code> of a point on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>, i.e. for the <span>$\mathrm{SO}(n)$</span> it&#39;s <code>(n,n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L644-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{Rotations,Any,Any,PolarRetraction}" href="#ManifoldsBase.retract-Tuple{Rotations,Any,Any,PolarRetraction}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract(M::Rotations, p, X, ::PolarRetraction)</code></pre><p>Compute the SVD-based retraction on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> from <code>p</code> in direction <code>X</code> (as an element of the Lie group) and is a second-order approximation of the exponential map. Let</p><div>\[USV = p + pX\]</div><p>be the singular value decomposition, then the formula reads</p><div>\[\operatorname{retr}_p X = UV^\mathrm{T}.\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L684-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{Rotations,Any,Any,QRRetraction}" href="#ManifoldsBase.retract-Tuple{Rotations,Any,Any,QRRetraction}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract(M, p, X, ::QRRetraction)</code></pre><p>Compute the QR-based retraction on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> from <code>p</code> in direction <code>X</code> (as an element of the Lie group), which is a first-order approximation of the exponential map.</p><p>This is also the default retraction on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L703-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_tangent_vector-Tuple{Rotations,Any}" href="#ManifoldsBase.zero_tangent_vector-Tuple{Rotations,Any}"><code>ManifoldsBase.zero_tangent_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_tangent_vector(M::Rotations, p)</code></pre><p>Return the zero tangent vector from the tangent space art <code>p</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> as an element of the Lie group, i.e. the zero matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L727-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{Rotations,Any}" href="#Statistics.mean-Tuple{Rotations,Any}"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean(
    M::Rotations,
    x::AbstractVector,
    [w::AbstractWeights,]
    method = GeodesicInterpolationWithinRadius(œÄ/2/‚àö2);
    kwargs...,
)</code></pre><p>Compute the Riemannian <a href="../statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> of <code>x</code> using <a href="../statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/206baf15ff48233681922ebf6fe308416dc09d6a/src/manifolds/Rotations.jl#L527-L538">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Gallier2002"><a class="tag is-link" href="#citeref-Gallier2002">Gallier2002</a><blockquote><p>Gallier J.; Xu D.; Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation (2002), 17(4), pp. 1-11. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.3205">pdf</a>.</p></blockquote></li><li class="footnote" id="footnote-Andrica2013"><a class="tag is-link" href="#citeref-Andrica2013">Andrica2013</a><blockquote><p>Andrica D.; Rohan R.-A.; Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications (2013), 18(2), pp. 1-2. <a href="https://www.emis.de/journals/BJGA/v18n2/B18-2-an.pdf">pdf</a>.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="probabilitysimplex.html">¬´ Probability simplex</a><a class="docs-footer-nextpage" href="skewsymmetric.html">Skew-symmetric matrices ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 25 July 2020 11:38">Saturday 25 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
