<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Statistics · Manifolds.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manifolds.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="interface.html">ManifoldsBase.jl</a></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="manifolds/fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="manifolds/generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="manifolds/generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="manifolds/grassmann.html">Grassmann</a></li><li><a class="tocitem" href="manifolds/hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="manifolds/lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="manifolds/multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="manifolds/oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="manifolds/probabilitysimplex.html">Probability simplex</a></li><li><a class="tocitem" href="manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="manifolds/skewsymmetric.html">Skew-symmetric matrices</a></li><li><a class="tocitem" href="manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="manifolds/symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="manifolds/symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="manifolds/torus.html">Torus</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/graph.html">Graph manifold</a></li><li><a class="tocitem" href="manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/metric.html">Metric manifold</a></li><li><a class="tocitem" href="manifolds/group.html">Group manifold</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href="statistics.html">Statistics</a><ul class="internal"><li><a class="tocitem" href="#Literature-1"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><a class="tocitem" href="about.html">About</a></li><li><a class="tocitem" href="generated/contributing.html">Contributing</a></li><li><a class="tocitem" href="notation.html">Notation</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/public.html">Public</a></li><li><a class="tocitem" href="lib/internals.html">Internals</a></li><li><a class="tocitem" href="lib/autodiff.html">Automatic differentiation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="statistics.html">Statistics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="statistics.html">Statistics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/statistics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Statistics-1"><a class="docs-heading-anchor" href="#Statistics-1">Statistics</a><a class="docs-heading-anchor-permalink" href="#Statistics-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Manifolds.AbstractEstimationMethod" href="#Manifolds.AbstractEstimationMethod"><code>Manifolds.AbstractEstimationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEstimationMethod</code></pre><p>Abstract type for defining statistical estimation methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.CyclicProximalPointEstimation" href="#Manifolds.CyclicProximalPointEstimation"><code>Manifolds.CyclicProximalPointEstimation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CyclicProximalPointEstimation &lt;: AbstractEstimationMethod</code></pre><p>Method for estimation using the cyclic proximal point technique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.ExtrinsicEstimation" href="#Manifolds.ExtrinsicEstimation"><code>Manifolds.ExtrinsicEstimation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExtrinsicEstimation &lt;: AbstractEstimationMethod</code></pre><p>Method for estimation in the ambient space and projecting to the manifold.</p><p>For <a href="manifolds/circle.html#Statistics.mean-Tuple{Circle,Any}"><code>mean</code></a> estimation, <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> is used for mean estimation in the ambient space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.GeodesicInterpolation" href="#Manifolds.GeodesicInterpolation"><code>Manifolds.GeodesicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeodesicInterpolation &lt;: AbstractEstimationMethod</code></pre><p>Repeated weighted geodesic interpolation method for estimating the Riemannian center of mass.</p><p>The algorithm proceeds with the following simple online update:</p><div>\[\begin{aligned}
μ_1 &amp;= x_1\\
t_k &amp;= \frac{w_k}{\sum_{i=1}^k w_i}\\
μ_{k} &amp;= γ_{μ_{k-1}}(x_k; t_k),
\end{aligned}\]</div><p>where <span>$x_k$</span> are points, <span>$w_k$</span> are weights, <span>$μ_k$</span> is the <span>$k$</span>th estimate of the mean, and <span>$γ_x(y; t)$</span> is the point at time <span>$t$</span> along the <a href="interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>shortest_geodesic</code></a> between points <span>$x,y ∈ \mathcal M$</span>. The algorithm terminates when all <span>$x_k$</span> have been considered. In the <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> case, this exactly computes the weighted mean.</p><p>The algorithm has been shown to converge asymptotically with the sample size for the following manifolds equipped with their default metrics when all sampled points are in an open geodesic ball about the mean with corresponding radius (see <a href="statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a>):</p><ul><li>All simply connected complete Riemannian manifolds with non-positive sectional curvature at radius <span>$∞$</span> <sup class="footnote-reference"><a id="citeref-Cheng2016" href="#footnote-Cheng2016">[Cheng2016]</a></sup>, in particular:<ul><li><a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a></li><li><a href="manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite"><code>SymmetricPositiveDefinite</code></a> <sup class="footnote-reference"><a id="citeref-Ho2013" href="#footnote-Ho2013">[Ho2013]</a></sup></li></ul></li><li>Other manifolds:<ul><li><a href="manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a>: <span>$\frac{π}{2}$</span> <sup class="footnote-reference"><a id="citeref-Salehian2015" href="#footnote-Salehian2015">[Salehian2015]</a></sup></li><li><a href="manifolds/grassmann.html#Manifolds.Grassmann"><code>Grassmann</code></a>: <span>$\frac{π}{4}$</span> <sup class="footnote-reference"><a id="citeref-Chakraborty2015" href="#footnote-Chakraborty2015">[Chakraborty2015]</a></sup></li><li><a href="manifolds/stiefel.html#Manifolds.Stiefel"><code>Stiefel</code></a>/<a href="manifolds/rotations.html#Manifolds.Rotations"><code>Rotations</code></a>: <span>$\frac{π}{2 \sqrt 2}$</span> <sup class="footnote-reference"><a id="citeref-Chakraborty2019" href="#footnote-Chakraborty2019">[Chakraborty2019]</a></sup></li></ul></li></ul><p>For online variance computation, the algorithm additionally uses an analogous recursion to the weighted Welford algorithm <sup class="footnote-reference"><a id="citeref-West1979" href="#footnote-West1979">[West1979]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L34-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.GeodesicInterpolationWithinRadius" href="#Manifolds.GeodesicInterpolationWithinRadius"><code>Manifolds.GeodesicInterpolationWithinRadius</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeodesicInterpolationWithinRadius{T} &lt;: AbstractEstimationMethod</code></pre><p>Estimation of Riemannian center of mass using <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> with fallback to <a href="statistics.html#Manifolds.GradientDescentEstimation"><code>GradientDescentEstimation</code></a> if any points are outside of a geodesic ball of specified <code>radius</code> around the mean.</p><p><strong>Constructor</strong></p><pre><code class="language-none">GeodesicInterpolationWithinRadius(radius)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L112-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.GradientDescentEstimation" href="#Manifolds.GradientDescentEstimation"><code>Manifolds.GradientDescentEstimation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GradientDescentEstimation &lt;: AbstractEstimationMethod</code></pre><p>Method for estimation using gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean!-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.mean!-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.mean!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)
mean!(
    M::Manifold,
    y,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
)</code></pre><p>Compute the <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> in-place in <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L223-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolationWithinRadius}" href="#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolationWithinRadius}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean(
    M::Manifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::GeodesicInterpolationWithinRadius;
    kwargs...,
)</code></pre><p>Estimate the Riemannian center of mass of <code>x</code> using <a href="statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a>.</p><p>See <a href="statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolation}"><code>mean</code></a> for a description of <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L343-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolation}" href="#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolation}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean(
    M::Manifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::GeodesicInterpolation;
    shuffle_rng=nothing,
    retraction::AbstractRetractionMethod = ExponentialRetraction(),
    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),
    kwargs...,
)</code></pre><p>Estimate the Riemannian center of mass of <code>x</code> in an online fashion using repeated weighted geodesic interpolation. See <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> for details.</p><p>If <code>shuffle_rng</code> is provided, it is used to shuffle the order in which the points are considered for computing the mean.</p><p>Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L285-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)</code></pre><p>Compute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector <code>x</code> of points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, defined as the point that satisfies the minimizer</p><div>\[\argmin_{y ∈ \mathcal M} \frac{1}{2 \sum_{i=1}^n w_i} \sum_{i=1}^n w_i\mathrm{d}_{\mathcal M}^2(y,x_i),\]</div><p>where <span>$\mathrm{d}_{\mathcal M}$</span> denotes the Riemannian <a href="interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>distance</code></a>.</p><p>In the general case, the <a href="statistics.html#Manifolds.GradientDescentEstimation"><code>GradientDescentEstimation</code></a> is used to compute the mean.     mean(         M::Manifold,         x::AbstractVector,         [w::AbstractWeights,]         method::AbstractEstimationMethod;         kwargs...,     )</p><p>Compute the mean using the specified <code>method</code>.</p><pre><code class="language-none">mean(
    M::Manifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::GradientDescentEstimation;
    p0=x[1],
    stop_iter=100,
    retraction::AbstractRetractionMethod = ExponentialRetraction(),
    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),
    kwargs...,
)</code></pre><p>Compute the mean using the gradient descent scheme <a href="statistics.html#Manifolds.GradientDescentEstimation"><code>GradientDescentEstimation</code></a>.</p><p>Optionally, provide <code>p0</code>, the starting point (by default set to the first data point). <code>stop_iter</code> denotes the maximal number of iterations to perform and the <code>kwargs...</code> are passed to <a href="interface.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>isapprox</code></a> to stop, when the minimal change between two iterates is small. For more stopping criteria check the <a href="https://manoptjl.org"><code>Manopt.jl</code></a> package and use a solver therefrom.</p><p>Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p><p>The Theory stems from<sup class="footnote-reference"><a id="citeref-Karcher1977" href="#footnote-Karcher1977">[Karcher1977]</a></sup> and is also described in<sup class="footnote-reference"><a id="citeref-PennecArsigny2013" href="#footnote-PennecArsigny2013">[PennecArsigny2013]</a></sup> as the exponential barycenter. The algorithm is further described in<sup class="footnote-reference"><a id="citeref-Afsari2013" href="#footnote-Afsari2013">[Afsari2013]</a></sup>.</p><p><sup class="footnote-reference"><a id="citeref-PennecArsigny2013" href="#footnote-PennecArsigny2013">[PennecArsigny2013]</a></sup>     &gt; Pennec X., Arsigny V.: Exponential Barycenters of the Canonical Cartan Connection and     &gt; Invariant Means on Lie Groups.     &gt; In: Nielsen F., Bhatia R. (eds) Matrix Information Geometry, (2013), pp. 123-166.     &gt; doi: <a href="https://doi.org/10.1007/978-3-642-30232-9_7">10.1007/978-3-642-30232-9_7</a>,     &gt; hal: <a href="https://hal.inria.fr/hal-00699361/document">https://hal.inria.fr/hal-00699361/document</a> <sup class="footnote-reference"><a id="citeref-Karcher1997" href="#footnote-Karcher1997">[Karcher1997]</a></sup>     &gt; Karcher, H.: Riemannian center of mass and mollifier smoothing.     &gt; Communications on Pure Applied Mathematics (1997), 30, pp. 509–541.     &gt; doi <a href="https://doi.org/10.1002/cpa.3160300502">10.1002/cpa.3160300502</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L136-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.median!-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.median!-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.median!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">median!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)
median!(
    M::Manifold,
    y,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
)</code></pre><p>computes the <a href="statistics.html#Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}"><code>median</code></a> in-place in <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L512-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">median(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)</code></pre><p>Compute the (optionally weighted) Riemannian median of the vector <code>x</code> of points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, defined as the point that satisfies the minimizer</p><div>\[\argmin_{y ∈ \mathcal M} \frac{1}{\sum_{i=1}^n w_i} \sum_{i=1}^n w_i\mathrm{d}_{\mathcal M}(y,x_i),\]</div><p>where <span>$\mathrm{d}_{\mathcal M}$</span> denotes the Riemannian <a href="interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>distance</code></a>. This function is nonsmooth (i.e nondifferentiable).</p><p>In the general case, the <a href="statistics.html#Manifolds.CyclicProximalPointEstimation"><code>CyclicProximalPointEstimation</code></a> is used to compute the median. However, this default may be overloaded for specific manifolds.</p><pre><code class="language-none">median(
    M::Manifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
)</code></pre><p>Compute the median using the specified <code>method</code>.</p><pre><code class="language-none">median(
    M::Manifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::CyclicProximalPointEstimation;
    p0=x[1],
    stop_iter=1000000,
    retraction::AbstractRetractionMethod = ExponentialRetraction(),
    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),
    kwargs...,
)</code></pre><p>Compute the median using <a href="statistics.html#Manifolds.CyclicProximalPointEstimation"><code>CyclicProximalPointEstimation</code></a>.</p><p>Optionally, provide <code>p0</code>, the starting point (by default set to the first data point). <code>stop_iter</code> denotes the maximal number of iterations to perform and the <code>kwargs...</code> are passed to <a href="interface.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>isapprox</code></a> to stop, when the minimal change between two iterates is small. For more stopping criteria check the <a href="https://manoptjl.org"><code>Manopt.jl</code></a> package and use a solver therefrom.</p><p>Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p><p>The algorithm is further described in <sup class="footnote-reference"><a id="citeref-Bačák2014" href="#footnote-Bačák2014">[Bačák2014]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L436-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.std-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.std-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">std(M, x, m=mean(M, x); corrected=true, kwargs...)
std(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)</code></pre><p>compute the optionally weighted standard deviation of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, i.e.</p><div>\[\sqrt{\frac{1}{c} \sum_{i=1}^n w_i d_{\mathcal M}^2 (x_i,m)},\]</div><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.std">Statistics.std</a>. The mean of <code>x</code> can be specified as <code>m</code>, and the corrected variance can be activated by setting <code>corrected=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L623-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.var-Tuple{Manifold,Any}" href="#Statistics.var-Tuple{Manifold,Any}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">var(M, x, m=mean(M, x); corrected=true, kwargs...)
var(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)</code></pre><p>compute the (optionally weighted) variance of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, i.e.</p><div>\[\frac{1}{c} \sum_{i=1}^n w_i d_{\mathcal M}^2 (x_i,m),\]</div><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.var">Statistics.var</a>. The mean of <code>x</code> can be specified as <code>m</code>, and the corrected variance can be activated by setting <code>corrected=true</code>. All further <code>kwargs...</code> are passed to the computation of the mean (if that is not provided).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L582-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.kurtosis-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}" href="#StatsBase.kurtosis-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}"><code>StatsBase.kurtosis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kurtosis(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))</code></pre><p>Compute the excess kurtosis of points in <code>x</code> on manifold <code>M</code>. Optionally provide weights <code>w</code> and/or a precomputed <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L861-L867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.mean_and_std-Tuple{Manifold,Vararg{Any,N} where N}" href="#StatsBase.mean_and_std-Tuple{Manifold,Vararg{Any,N} where N}"><code>StatsBase.mean_and_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_and_std(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -&gt; (mean, std)</code></pre><p>Compute the <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> and the standard deviation <a href="statistics.html#Statistics.std-Tuple{Manifold,Vararg{Any,N} where N}"><code>std</code></a> simultaneously.</p><pre><code class="language-none">mean_and_std(
    M::Manifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use the <code>method</code> for simultaneously computing the mean and standard deviation. To use a mean-specific method, call <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> and then <a href="statistics.html#Statistics.std-Tuple{Manifold,Vararg{Any,N} where N}"><code>std</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L795-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolationWithinRadius}" href="#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolationWithinRadius}"><code>StatsBase.mean_and_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_and_var(
    M::Manifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::GeodesicInterpolationWithinRadius;
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.</p><p>See <a href="statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a> and <a href="statistics.html#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolation}"><code>mean_and_var</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L749-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolation}" href="#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolation}"><code>StatsBase.mean_and_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_and_var(
    M::Manifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::GeodesicInterpolation;
    shuffle_rng::Union{AbstractRNG,Nothing} = nothing,
    retraction::AbstractRetractionMethod = ExponentialRetraction(),
    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use the repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.</p><p>If <code>shuffle_rng</code> is provided, it is used to shuffle the order in which the points are considered. Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p><p>See <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> for details on the geodesic interpolation method.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Welford algorithm for the variance is experimental and is not guaranteed to give accurate results except on <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L683-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.mean_and_var-Tuple{Manifold,Vararg{Any,N} where N}" href="#StatsBase.mean_and_var-Tuple{Manifold,Vararg{Any,N} where N}"><code>StatsBase.mean_and_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_and_var(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -&gt; (mean, var)</code></pre><p>Compute the <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> and the <a href="statistics.html#Statistics.var-Tuple{Manifold,Any}"><code>var</code></a>iance simultaneously. See those functions for a description of the arguments.</p><pre><code class="language-none">mean_and_var(
    M::Manifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use the <code>method</code> for simultaneously computing the mean and variance. To use a mean-specific method, call <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> and then <a href="statistics.html#Statistics.var-Tuple{Manifold,Any}"><code>var</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L640-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.moment" href="#StatsBase.moment"><code>StatsBase.moment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">moment(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))</code></pre><p>Compute the <code>k</code>th central moment of points in <code>x</code> on manifold <code>M</code>. Optionally provide weights <code>w</code> and/or a precomputed <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L818-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.skewness-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}" href="#StatsBase.skewness-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}"><code>StatsBase.skewness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">skewness(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))</code></pre><p>Compute the standardized skewness of points in <code>x</code> on manifold <code>M</code>. Optionally provide weights <code>w</code> and/or a precomputed <a href="statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>mean</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/1f6868bc748bb112c59965d358ae45ba1f31883f/src/statistics.jl#L842-L848">source</a></section></article><h2 id="Literature-1"><a class="docs-heading-anchor" href="#Literature-1">Literature</a><a class="docs-heading-anchor-permalink" href="#Literature-1" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Ho2013"><a class="tag is-link" href="#citeref-Ho2013">Ho2013</a><blockquote><p>Ho J.; Cheng G.; Salehian H.; Vemuri B. C.; Recursive Karcher expectation estimators and geometric law of large numbers. Proceedings of the 16th International Conference on Artificial Intelligence and Statistics (2013), pp. 325–332. <a href="http://proceedings.mlr.press/v31/ho13a.pdf">pdf</a>.</p></blockquote></li><li class="footnote" id="footnote-Salehian2015"><a class="tag is-link" href="#citeref-Salehian2015">Salehian2015</a><blockquote><p>Salehian H.; Chakraborty R.; Ofori E.; Vaillancourt D.; An efficient recursive estimator of the Fréchet mean on a hypersphere with applications to Medical Image Analysis. Mathematical Foundations of Computational Anatomy (2015). <a href="https://www-sop.inria.fr/asclepios/events/MFCA15/Papers/MFCA15_4_2.pdf">pdf</a>.</p></blockquote></li><li class="footnote" id="footnote-Chakraborty2015"><a class="tag is-link" href="#citeref-Chakraborty2015">Chakraborty2015</a><blockquote><p>Chakraborty R.; Vemuri B. C.; Recursive Fréchet Mean Computation on the Grassmannian and Its Applications to Computer Vision. Proceedings of the IEEE International Conference on Computer Vision (ICCV) (2015), pp. 4229-4237. doi: <a href="https://doi.org/10.1109/ICCV.2015.481">10.1109/ICCV.2015.481</a>, <a href="http://openaccess.thecvf.com/content_iccv_2015/html/Chakraborty_Recursive_Frechet_Mean_ICCV_2015_paper.html">link</a>.</p></blockquote></li><li class="footnote" id="footnote-Cheng2016"><a class="tag is-link" href="#citeref-Cheng2016">Cheng2016</a><blockquote><p>Cheng G.; Ho J.; Salehian H.; Vemuri B. C.; Recursive Computation of the Fréchet Mean on Non-positively Curved Riemannian Manifolds with Applications. Riemannian Computing in Computer Vision. Springer, Cham (2016), pp. 21-43. doi: <a href="https://doi.org/10.1007/978-3-319-22957-7_2">10.1007/978-3-319-22957-7_2</a>, <a href="https://www.cise.ufl.edu/~vemuri/paperphp/article.php?y=2016&amp;i=5">pdf</a>.</p></blockquote></li><li class="footnote" id="footnote-Chakraborty2019"><a class="tag is-link" href="#citeref-Chakraborty2019">Chakraborty2019</a><blockquote><p>Chakraborty R.; Vemuri B. C.; Statistics on the (compact) Stiefel manifold: Theory and Applications. The Annals of Statistics (2019), 47(1), pp. 415-438. doi: <a href="https://doi.org/10.1214/18-AOS1692">10.1214/18-AOS1692</a>, arxiv: <a href="https://arxiv.org/abs/1708.00045">1708.00045</a>.</p></blockquote></li><li class="footnote" id="footnote-West1979"><a class="tag is-link" href="#citeref-West1979">West1979</a><blockquote><p>West D. H. D.; Updating Mean and Variance Estimates: An Improved Method. Communications of the ACM (1979), 22(9), pp. 532–535. doi: <a href="https://doi.org/10.1145/359146.359153">10.1145/359146.359153</a>.</p></blockquote></li><li class="footnote" id="footnote-Afsari2013"><a class="tag is-link" href="#citeref-Afsari2013">Afsari2013</a><blockquote><p>Afsari, B; Tron, R.; Vidal, R.: On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass, SIAM Journal on Control and Optimization (2013), 51(3), pp. 2230–2260, doi: <a href="https://doi.org/10.1137/12086282X">10.1137/12086282X</a>, arxiv: <a href="https://arxiv.org/abs/1201.0925">1201.0925</a></p></blockquote></li><li class="footnote" id="footnote-Bačák2014"><a class="tag is-link" href="#citeref-Bačák2014">Bačák2014</a><blockquote><p>Bačák, M: Computing Medians and Means in Hadamard Spaces. SIAM Journal on Optimization (2014), 24(3), pp. 1542–1566, doi: <a href="https://doi.org/10.1137/140953393">10.1137/140953393</a>, arxiv: <a href="https://arxiv.org/abs/1210.2145">1210.2145</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="manifolds/group.html">« Group manifold</a><a class="docs-footer-nextpage" href="distributions.html">Distributions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 2 May 2020 12:21">Saturday 2 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
