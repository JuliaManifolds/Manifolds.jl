var documenterSearchIndex = {"docs":
[{"location":"tutorials/hand-gestures/#Hand-gesture-analysis","page":"perform Hand gesture analysis","title":"Hand gesture analysis","text":"","category":"section"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"In this tutorial we will learn how to use Kendall’s shape space to analyze hand gesture data.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"Let’s start by loading libraries required for our work.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"using Manifolds, CSV, DataFrames, Plots, MultivariateStats","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"Precompiling packages...\n   1866.2 ms  ✓ QuartoNotebookWorkerTablesExt (serial)\n  1 dependency successfully precompiled in 2 seconds\nPrecompiling packages...\n    856.0 ms  ✓ QuartoNotebookWorkerLaTeXStringsExt (serial)\n  1 dependency successfully precompiled in 1 seconds\nPrecompiling packages...\n   1073.0 ms  ✓ QuartoNotebookWorkerJSONExt (serial)\n  1 dependency successfully precompiled in 1 seconds\nPrecompiling packages...\n   2319.6 ms  ✓ QuartoNotebookWorkerPlotsExt (serial)\n  1 dependency successfully precompiled in 2 seconds","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"Our first function loads dataset of hand gestures, described here.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"\nfunction load_hands()\n    hands_url = \"https://raw.githubusercontent.com/geomstats/geomstats/master/geomstats/datasets/data/hands/hands.txt\"\n    hand_labels_url = \"https://raw.githubusercontent.com/geomstats/geomstats/master/geomstats/datasets/data/hands/labels.txt\"\n\n    hands = Matrix(CSV.read(download(hands_url), DataFrame, header=false))\n    hands = reshape(hands, size(hands, 1), 3, 22)\n    hand_labels = CSV.read(download(hand_labels_url), DataFrame, header=false).Column1\n    return hands, hand_labels\nend","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"load_hands (generic function with 1 method)","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"The following code plots a sample gesture as a 3D scatter plot of points.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"hands, hand_labels = load_hands()\nscatter3d(hands[1, 1, :], hands[1, 2, :], hands[1, 3, :])","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"(Image: )","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"Each gesture is represented by 22 landmarks in ℝ³, so we use the appropriate Kendall’s shape space","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"Mshape = KendallsShapeSpace(3, 22)","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"KendallsShapeSpace(3, 22)","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"Hands read from the dataset are projected to the shape space to remove translation and scaling variability. Rotational variability is then handled using the quotient structure of KendallsShapeSpace","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"hands_projected = [project(Mshape, hands[i, :, :]) for i in axes(hands, 1)]","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"In the next part let’s do tangent space PCA. This starts with computing a mean point and computing logithmic maps at mean to each point in the dataset.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"mean_hand = mean(Mshape, hands_projected)\nhand_logs = [log(Mshape, mean_hand, p) for p in hands_projected]","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"For a tangent PCA, we need coordinates in a basis. Some libraries skip this step because the representation of tangent vectors forms a linear subspace of an Euclidean space so PCA automatically detects which directions have no variance but this is a more generic way to solve this issue.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"B = get_basis(Mshape, mean_hand, ProjectedOrthonormalBasis(:svd))\nhand_log_coordinates = [get_coordinates(Mshape, mean_hand, X, B) for X in hand_logs]","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"This code prepares data for MultivariateStats – mean=0 is set because we’ve centered the data geometrically to mean_hand in the code above.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"red_coords = reduce(hcat, hand_log_coordinates)\nfp = fit(PCA, red_coords; mean=0)","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"PCA(indim = 59, outdim = 19, principalratio = 0.9913454778626318)\n\nPattern matrix (unstandardized loadings):\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n             PC1           PC2           PC3           PC4           PC5           PC6           PC7           PC8           PC9          PC10          PC11          PC12          PC13          PC14          PC15          PC16          PC17          PC18          PC19\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n1    0.0225725    -0.025823      0.00247119   -0.00194504    0.011187      0.00865122   -0.00432       0.00232697   -0.00133113   -0.00603743    0.00279173    0.00459607    0.0026104    -0.00194346   -0.0010809     0.00371279   -0.0026941    -0.00336716   -4.78115e-6\n2   -0.0298018     0.012855     -0.0253788    -0.0107526    -0.000642301   0.00243343   -0.0129186     0.0117729     0.0159723     0.00107763   -0.00131555    0.00285026    0.00463989   -0.00216125    0.00161956    0.00105094    0.00029935   -0.000818863   0.000226847\n3   -0.00496432   -0.0149723    -0.00377204    0.0160204    -0.0052388     0.00212934   -0.00568703   -0.00338036    0.000889778  -0.00214546   -0.000896225  -0.00137907   -0.00247179    0.00239153   -0.000377108  -0.00215105    0.0027909     0.000117751  -0.00127213\n4    0.0056335    -0.0129395     0.00752466    0.00555847   -0.00280322    0.00782194    0.00111858    0.0085054    -0.00273334   -0.00581609    0.00450121   -0.00038663    0.00167242    0.00231527    0.000307966  -0.00131181    0.000720744   0.00111114    0.00361935\n5   -0.0113838     0.0232298    -0.00547126   -0.0179074    -0.00225183   -0.0123001    -0.00379069    0.00375553   -0.0110292     0.00304722   -0.00459228   -0.00477702   -0.000442113   0.00166295    0.00238507    0.00489784   -0.00261756    0.00101093   -0.00178457\n6   -0.0345859    -0.0233477     0.0296546     0.00689836    0.003326     -0.00135883   -0.0119614     0.00329535   -0.00698649   -0.00493814    0.00376636    0.000613432  -0.00149234   -0.000250127   0.00623361    0.00254364   -0.000999917   9.66511e-6   -0.000225613\n7   -0.0374342    -0.0209963     0.00235653    0.000683237   0.00758501   -0.00999398    0.00657121    0.00782893   -0.00406903   -0.00581627   -0.00079722    0.0041202     0.00319899    0.00585783   -0.00167581    0.0030249     0.00322473   -0.00108314   -0.00116042\n8    0.02496       0.00943876    0.011668     -0.00772333    0.00960598   -0.00142074    0.00211964   -0.000840499  -0.000234754  -0.000749657   0.000307986   0.0066857    -0.000133384   0.00300887    0.0022704     0.00120301    0.00203841    0.000966472   0.00120561\n9    0.0296003     0.0472131     0.00210213   -0.00393545   -0.00142636   -0.00236192   -0.00533011   -0.00345383   -0.00439341   -0.00852948   -0.000396924  -0.000150678   0.00330386    0.00089967    0.00388721   -0.00199243   -0.00161544    0.00329972   -0.00160867\n10   0.0187554     0.00337061    0.0254247     0.00182716   -0.00726025    0.00345359    0.0118753     0.00392614   -0.00737372   -0.000261283  -0.0044591     0.000623762  -0.00123177   -0.00187434    0.00347221    0.00122414    0.00162647    0.000179093  -0.000639519\n11  -0.0276189    -0.000868697   0.00124921   -0.0271846    -0.0182645    -0.00654734   -0.00377689   -0.00309552    0.00263585    0.0083263     0.0117277    -0.000277824  -0.0013572    -0.00171603   -0.00248708    0.0002054    -0.00129968    0.000538015   0.000635364\n12   0.0742252    -0.0111949    -0.00393113   -0.00375025   -0.00466852    0.00718482   -0.00421926   -0.000133097  -0.00285935    0.00220137   -0.0063239     0.00591546   -0.00391862   -0.00220676   -0.000179801   0.00446115   -0.000848733  -0.00206532    0.00226783\n13   0.0426582     0.00910716    0.0199886     0.00477317    0.000139353   0.00719425   -0.0105414    -0.00511285   -0.00217195    0.0106759    -0.000717452   0.00304458   -0.00227829    0.00118983    0.00302885    0.00259039    0.000590182  -0.00113679   -0.0014884\n14   0.0473028     0.00651493    0.00140138    0.00225381    0.00439764   -0.00750531    0.0193882    -0.00406276    0.0131133    -0.00935677    0.00405362   -0.00109819   -0.000160323   0.00193398    0.00109956    0.000814692   0.000914761   0.00198064    0.00125932\n15   0.0332915     0.0221761     0.0200686    -0.000418236  -0.00238077    0.0136492    -0.00572773   -0.00525892    0.00565712   -0.00186374    0.00193716   -0.00251317    0.00147158   -0.00144082   -0.0036298     0.00233316   -0.000552749  -0.00117945   -0.00143965\n16  -0.019766     -0.0126687    -0.0327939    -0.00786485    0.00374512    0.00537198   -0.0105409    -0.0120939    -4.87631e-5   -0.000200912   0.00649485    0.00341607    0.00856351   -0.000627434   0.00512775    0.00157364    0.0025359    -0.000340485   0.00302362\n17  -0.0163038     0.00392205    0.00368172   -0.00108868   -0.00403097   -0.00250602   -0.00154047   -0.0091664     0.012208     -0.00212529   -0.00249079    0.00425261   -0.0009888     0.000699026   0.00159838    0.00182519   -0.00268461    0.0024567    -0.00287173\n18   0.0315265     0.014339     -0.0281659     0.0188983     0.00116313    0.00517276   -0.012306      0.00964101    0.00378792    0.003776     -0.00471276   -0.00276278    0.00073812   -0.0018049    -0.00110501   -0.00142815   -0.00324852    0.00125496    0.00036833\n19  -0.01342      -0.0266179     0.00692541   -0.00394567    0.00696648    0.00546101    0.0107503     0.00161672    0.00243154    0.0111542    -0.00859616   -0.0022637    -0.00125188   -0.00218111    0.00418941   -0.00245702    0.00109089    0.00262105    0.000894704\n20  -0.000739408   0.00263129    0.00124919    0.000518372  -0.00405283   -0.00980204   -0.00494474   -0.00280603   -0.00543177   -0.00590718    0.00579551    0.00110744   -0.00812888    0.00441085   -0.00391783    0.00174295   -0.000252033  -0.00209523    0.00204457\n21   0.0504932    -0.0110797    -0.0026189    -0.00962761   -0.0153567    -0.00273023    0.00361822    0.00201177   -0.00445139   -0.000379839   0.00688118   -0.000391294  -0.000934333  -0.00118075   -0.00270666   -0.000350291   0.000905076   0.00117337   -0.000755983\n22  -0.046736      0.00232599   -0.0170992    -0.00282647   -0.014517      0.00487345    0.00150701   -0.00101275   -0.00475473    0.00292961    0.00419816    0.0025307     0.00131901    0.00431956   -0.00200533   -0.00153549   -0.000850689  -0.000199973  -0.000797035\n23  -0.0173763    -0.0135675    -0.0235186    -0.00469928   -0.010083      0.00622843    0.00612574    0.000719204  -0.00473516   -0.00170497   -0.0088133    -0.00339875    0.0030805     0.00313125   -0.00334306    0.00617814    0.00103001    0.00544743    0.000548909\n24  -0.00826661    0.0167308     0.00865901   -0.00214922    0.0150335     0.00823526   -0.000297993  -0.00237168   -0.000986393   0.00220198   -0.000681713  -0.000197612   0.000283165   0.00363122    0.000841859  -0.000161184  -0.00456144    0.000377615   0.000890576\n25  -0.00644559    0.010877      0.00278186   -0.00911345   -0.0107489     0.0243946     0.00709473    0.0105892    -0.00627612   -0.00400938    0.00573931   -0.000879342  -0.00421579   -0.00280443    0.00183861   -0.00101372    0.00165889   -0.00303974    0.0016519\n26   0.0441278     0.0158065    -0.00400205   -0.000325081   0.00203837    0.0080049     0.00759341    0.00350391   -0.00106124    0.000470616   0.000231166   0.000781562   0.000640405   0.00106251   -0.00165851    0.0036525     0.00222514   -0.00223304   -0.00322942\n27  -0.0185767     0.0125668     0.0141537     0.0144925     0.00211121   -0.0084411    -0.00693538    0.00588689    0.00509395   -0.000498211  -8.28981e-5   -0.00196856    0.000165433   0.00150428    0.00217742    0.00406355    0.00266332    0.000538881   0.000787166\n28  -0.0288949     0.0285503    -0.00938241    0.00314241    0.00451199   -0.000322886   0.0102419    -0.0057291     0.00452652   -0.00434567    0.00333208    0.000768434   0.000697567  -0.000947317   0.00197396    0.00231527   -0.00262045   -0.0052142    -0.0022789\n29   0.054652      0.016176      0.0233463    -0.00263117    0.0140462    -0.00251733    0.00410277    0.00636276    0.00827887    0.00558304    0.00735049    0.00273341    0.00209918   -0.00136746   -0.00493028    0.0020373     0.00130772    0.00142239   -0.00115467\n30  -0.0234619     0.0175726     0.0109159     0.0120296    -0.00457707   -0.0145693    -7.70199e-5   -0.00427574   -0.00308155    0.0048407    -0.000529341  -0.00208163   -0.00219104   -0.00363319   -0.00608362    0.00641312    7.09267e-5    0.00118223    0.00326152\n31  -0.00743661   -0.0210373    -0.0126597    -0.00541652    0.00933005    0.00815691    0.00468841    0.00631952    0.0111953     0.00090758    0.000217408  -0.0062275    -0.00622832    0.000955856   0.00072591    0.00169066   -0.00115975   -0.00147563   -0.00250162\n32   0.00942946    0.0348065    -0.00344763    0.00870651   -0.0074523    -0.00813785    0.00974278    0.00503949   -0.0115295     0.00778616    0.00187608   -6.06739e-5    0.0101328    -0.00379749    0.00144605   -0.000102658  -0.00132698   -0.00276075    0.00106114\n33   0.0632112    -0.0391171    -0.00200189   -0.0220903    -0.0144734    -0.0113132     0.0077086    -0.000969037   0.00503636    0.00706564    0.00437077    0.00130097    0.00340908    0.0051326     0.00253346    0.000507903  -0.000707207  -0.00056295   -0.00194977\n34   0.0207818    -0.0135932     0.000771381   0.0036835     0.0213596    -0.00486239    0.00157098   -0.00771602   -0.00359822   -0.00378203   -0.0016533    -0.0110685    -0.000753667  -0.00229644   -0.00150167   -0.000303523   0.00158846   -0.000607838   0.000615078\n35  -0.000379201  -0.0120639     0.0297885    -0.00270901    0.00650958   -0.000380978  -0.00121355    0.0101664    -0.00517949   -0.000558258   0.00197674    0.000277632   0.00797185   -0.000760715  -0.00264005   -0.00348748   -0.00231271    0.00137201    0.0015573\n36   0.00115252    0.000667601  -0.000336516   0.0137512    -0.00182112    0.000312716   0.0107091    -0.0131901    -0.000686853   0.00429926   -0.00405865   -0.00152666    0.00779814    0.00289293    0.000712759  -0.00290687    0.000187923  -0.00341138   -0.00143035\n37  -0.0710484    -0.0120054    -0.00742916    0.0315282     0.000899437   0.00447448    0.00873192   -0.00168979    0.00408006    0.0081241     0.0111211    -0.00380385   -0.0027588     0.000382961   0.000901206   0.00209142   -0.00297548    0.000369737   0.000194095\n38   0.0173624    -0.00401998    0.00476487   -0.000229019   0.00277068    0.0121718    -0.00471613   -0.00762391    0.00490114    6.67001e-5   -0.00184396    0.00294105    0.00142187    0.00170863    0.00048986   -0.000522409   0.00089876    0.00154977   -0.00243131\n39  -0.0132061     0.0340923    -0.00256571   -0.00165163   -0.0056104    -0.00854407   -0.00256856    0.00640797    0.00421851    0.00576642   -0.00326446    0.00247372   -0.00086705   -0.003962      0.00141905   -0.000994299   0.00542489    0.000229981  -0.00130346\n40   0.0201995     0.00167282   -0.015568      0.000124091   0.00826228    0.00495587    0.0025755     0.0135085     0.0068398    -0.00135169   -0.000719346  -0.000414134   0.00126898   -0.00109902   -0.00309125    0.00299976   -0.00179919    0.000209681   0.00138728\n41   0.0311951    -0.00349583   -0.000650444   0.00225274   -0.0202231     0.00133542    0.000267878  -0.00500205    0.00441379    4.99341e-6   -0.00226762   -0.00423897   -0.00153824   -0.00378025   -0.00351691   -0.000162936  -0.0024964     0.000454088   0.000183778\n42   0.00295307   -0.00780823    0.00723101    0.0102236    -0.00344839    0.0073579    -0.00253667   -0.00139851   -0.00143191    0.00254803    0.00531096    0.00456018   -0.00235568   -0.00376306   -0.00340022   -0.00172833    0.00121904    0.00142326   -0.000685875\n43   0.0194641    -0.0113322    -0.00277425    0.00886678    0.010623     -0.0172909    -0.00366068    0.00715197    0.00562361    0.00432699    0.00736201    0.00317588   -0.00247544   -0.00147035    0.00388555   -0.00220526    0.00103274    0.00163166    0.000317339\n44  -0.0404226    -0.0150374     0.0122555    -0.00944404    0.0105142     0.000430679  -0.00492254   -0.0094228     0.0056596     0.000305474  -0.00401212    0.00405241    0.00754805   -0.0016228    -0.00720144    0.000628635   0.00159903   -0.00156151    0.00249425\n45   0.019093      0.0161417    -0.0106445     0.00289789   -0.00179217   -0.00983076    0.00218895    0.00481717    0.0085834    -0.00607766    0.000501381  -0.00255306   -0.000130565   0.00217908    0.00346562   -0.000368367   0.00076262   -0.000891547   0.00282931\n46   0.0260759     0.00663921   -0.0162865    -0.000305536   0.011383     -0.00196883   -0.00363319   -0.0036993    -0.00455917   -0.00290846    0.00888095   -0.00789423    0.00304331   -0.00740744    0.00050636   -0.000302411   0.0030843     0.00049445   -0.00284163\n47  -0.0221746    -0.0199404     0.000534764   0.00477627    0.0141621     0.000433482   0.000167613   0.00463961   -0.00399233    0.00393828   -0.000758662  -0.00181117    0.00373518   -0.00279076   -0.000500963   0.00307397    0.0025922    -0.00118273   -0.00313347\n48  -0.0550543     0.0363964    -0.00742737    0.00509457    0.00478327    0.00596863    0.0123141     0.00319395    0.00032336    0.00227062    0.00182639    0.0089813    -0.00131728    0.00282792   -0.00285173    0.000575806   0.000630176   0.00142055   -0.000739086\n49   0.00913939   -0.0112506     0.00275407   -0.000108444   0.0175965    -0.00720219    0.0028736    -0.00852751   -0.00367575    0.00224067    0.00306352    0.00371249   -0.0013583    -0.00438014    0.00156735    0.00259369   -0.00342623    0.00252017   -0.000817948\n50  -0.00233578   -0.0202756     0.0265616     0.0127293    -0.0118266     0.00893602    0.00197975    0.00795907    0.00501867    0.00222461    0.00222965   -0.00193209    0.00671279    0.000512806  -0.000123589   0.00127378   -0.00139443    0.001997     -0.0018316\n51  -0.0153559    -0.0100082     0.0139632     0.00493122   -0.0222626     0.000493596   0.00833022   -0.0038709     0.00743823   -0.00699599   -0.0016895     0.00127742    0.00430974   -0.00836289    0.00714681    0.00356698   -0.000744286   0.000825278   0.00269039\n52   0.0263224    -0.017408     -0.0229181    -0.00281498    0.00866802   -0.0019128     0.00195427    0.00439744   -0.00584011    0.00819845    0.000279562   0.000429365  -0.000174549   0.00240462    0.00358596    0.00083813   -0.00110688   -0.000486164   0.00155618\n53   0.0340365     0.0249426    -0.000528411   0.00975803    0.0137844     0.0129551     0.00420257   -0.00700206   -0.00177581    0.00589381    0.00212311    0.00317137   -0.00186415    0.00236349    0.00271734   -0.000199331   0.000225671   0.00280694    0.00416741\n54  -0.0117798     0.00903529    0.0387701     0.00454727   -0.00907697   -0.00488634   -0.00773384   -6.19644e-6    0.0089247     0.00618783   -0.00347535   -0.00495008   -0.000644665   0.00498122    0.00158708   -0.000299986   0.00137401   -0.00415685    0.00151692\n55   0.040961     -0.0047418    -0.00467653    0.0299573    -0.010076     -0.00532661   -0.00871529    0.0040513    -0.00358455   -0.00462993    0.00250156    0.00223835    0.0054579     0.00519887   -0.000305873   0.000448611  -0.00211423    0.00125517   -0.00247527\n56   0.0102925     0.013984      0.000812639  -0.00373706   -0.00349584    0.0124504    -0.00441857   -0.0044716     0.00140511    0.00328495    0.00684282   -0.00884618    0.0042292     0.00577289   -0.00200728    0.00248224    0.00354552    0.00261187    0.00147238\n57   0.0477407     1.14678e-5   -0.00662024    0.00219729    0.00430952   -0.00449388    0.00119093    0.000191644   0.00325373    0.00379379   -0.000464058  -0.00390622    0.00283012    0.00361447   -0.000321092   0.000398221  -0.00180963   -0.00322221    0.00339463\n58   0.0399973    -0.0189741    -0.0247896     0.0297376    -0.013145     -0.00537322    0.000798352  -0.00376624   -0.00048942    0.0013669    -0.00261489    0.00622029   -0.00186308   -0.00227817   -0.00329716    6.72505e-6    0.00269157   -0.00133317    0.000372921\n59  -0.00330724    0.000903053   0.00809613   -0.00496936    0.00629712   -0.00809498    0.00396068    0.0024341     0.00266899   -0.00182288   -0.00357433    0.00138473    0.00143361   -0.00171682   -0.00717317   -0.00423229   -0.00252162    0.00019209    0.000617265\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\nImportance of components:\n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n                                 PC1        PC2        PC3         PC4         PC5         PC6         PC7         PC8         PC9        PC10        PC11         PC12         PC13         PC14         PC15         PC16         PC17         PC18        PC19\n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\nSS Loadings (Eigenvalues)  0.0571665  0.0189413  0.0127985  0.00692343  0.00559569  0.00374975  0.00277789  0.00221675  0.00204783  0.00136863  0.00118197  0.000853869  0.000786129  0.000575358  0.000561562  0.000342726  0.000253164  0.000229252  0.00020354\nVariance explained         0.477945   0.15836    0.107003   0.0578838   0.0467831   0.0313501   0.0232248   0.0185333   0.017121    0.0114425   0.00988197  0.00713883   0.00657249   0.00481032   0.00469498   0.00286538   0.00211659   0.00191668   0.00170171\nCumulative variance        0.477945   0.636305   0.743308   0.801192    0.847975    0.879325    0.90255     0.921083    0.938204    0.949647    0.959528    0.966667     0.97324      0.97805      0.982745     0.98561      0.987727     0.989644     0.991345\nProportion explained       0.482117   0.159743   0.107937   0.0583891   0.0471916   0.0316238   0.0234275   0.0186951   0.0172705   0.0115424   0.00996824  0.00720116   0.00662987   0.00485231   0.00473597   0.0028904    0.00213507   0.00193341   0.00171657\nCumulative proportion      0.482117   0.64186    0.749797   0.808186    0.855378    0.887002    0.910429    0.929124    0.946395    0.957937    0.967905    0.975106     0.981736     0.986589     0.991325     0.994215     0.99635      0.998283     1.0\n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"Now let’s show explained variance of each principal component.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"plot(principalvars(fp), title=\"explained variance\", label=\"Tangent PCA\")","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"(Image: )","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"The next plot shows how projections on the first two principal components look like.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"fig = plot(; title=\"coordinates per gesture of the first two principal components\")\nfor label_num in [0, 1]\n    mask = hand_labels .== label_num\n    cur_hand_logs = red_coords[:, mask]\n    cur_t = MultivariateStats.transform(fp, cur_hand_logs)\n    scatter!(fig, cur_t[1, :], cur_t[2, :], label=\"gesture \" * string(label_num))\nend\nxlabel!(fig, \"principal component 1\")\nylabel!(fig, \"principal component 2\")\nfig","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"(Image: )","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"The following heatmap displays pairwise distances between gestures. We can use them for clustering, classification, etc.","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"hand_distances = [\n    distance(Mshape, hands_projected[i], hands_projected[j]) for\n    i in eachindex(hands_projected), j in eachindex(hands_projected)\n]\nheatmap(hand_distances, aspect_ratio=:equal)","category":"page"},{"location":"tutorials/hand-gestures/","page":"perform Hand gesture analysis","title":"perform Hand gesture analysis","text":"(Image: )","category":"page"},{"location":"features/statistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"features/statistics/#Statistics.cov-Tuple{AbstractManifold, AbstractVector}","page":"Statistics","title":"Statistics.cov","text":"Statistics.cov(\n    M::AbstractManifold,\n    x::AbstractVector;\n    basis::AbstractBasis=DefaultOrthonormalBasis(),\n    tangent_space_covariance_estimator::CovarianceEstimator=SimpleCovariance(;\n        corrected=true,\n    ),\n    mean_estimation_method::AbstractApproximationMethod=GradientDescentEstimation(),\n    inverse_retraction_method::AbstractInverseRetractionMethod=default_inverse_retraction_method(\n        M, eltype(x),\n    ),\n)\n\nEstimate the covariance matrix of a set of points x on manifold M. Since the covariance matrix on a manifold is a rank 2 tensor, the function returns its coefficients in basis induced by the given tangent space basis. See Section 5 of [Pen06] for details.\n\nThe mean is calculated using the specified mean_estimation_method using [mean](@ref Statistics.mean(::AbstractManifold, ::AbstractVector, ::AbstractApproximationMethod), and tangent vectors at this mean are calculated using the provided inverse_retraction_method. Finally, the covariance matrix in the tangent plane is estimated using the Euclidean space  estimator tangent_space_covariance_estimator. The type CovarianceEstimator is defined  in StatsBase.jl  and examples of covariance estimation methods can be found in  CovarianceEstimation.jl.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.mean!-Tuple{AbstractManifold, Vararg{Any}}","page":"Statistics","title":"Statistics.mean!","text":"mean!(M::AbstractManifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmean!(\n    M::AbstractManifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractApproximationMethod;\n    kwargs...,\n)\n\nCompute the mean in-place in y.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, ExtrinsicEstimation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::ExtrinsicEstimation;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using ExtrinsicEstimation, i.e. by computing the mean in the embedding and projecting the result back.\n\nSee mean for a description of the remaining kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolationWithinRadius}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using GeodesicInterpolationWithinRadius.\n\nSee mean for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng=nothing,\n    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x)),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x)),\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x in an online fashion using repeated weighted geodesic interpolation. See GeodesicInterpolation for details.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered for computing the mean.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}","page":"Statistics","title":"Statistics.mean","text":"mean(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\n\nCompute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector x of points on the AbstractManifold  M, defined as the point that satisfies the minimizer\n\noperatornameargmin_y  mathcal M frac12 sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M^2(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance.\n\nIn the general case, the GradientDescentEstimation is used to compute the mean.     mean(         M::AbstractManifold,         x::AbstractVector,         [w::AbstractWeights,]         method::AbstractApproximationMethod=defaultapproximationmethod(M, mean);         kwargs...,     )\n\nCompute the mean using the specified method.\n\nmean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GradientDescentEstimation;\n    p0=x[1],\n    stop_iter=100,\n    retraction::AbstractRetractionMethod = default_retraction_method(M),\n    inverse_retraction::AbstractInverseRetractionMethod = default_retraction_method(M, eltype(x)),\n    kwargs...,\n)\n\nCompute the mean using the gradient descent scheme GradientDescentEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe Theory stems from [Kar77] and is also described in [PA12] as the exponential barycenter. The algorithm is further described in[ATV13].\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.median!-Tuple{AbstractManifold, Vararg{Any}}","page":"Statistics","title":"Statistics.median!","text":"median!(M::AbstractManifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian!(\n    M::AbstractManifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractApproximationMethod;\n    kwargs...,\n)\n\ncomputes the median in-place in y.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, CyclicProximalPointEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::CyclicProximalPointEstimation;\n    p0=x[1],\n    stop_iter=1000000,\n    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x),),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x),),\n    kwargs...,\n)\n\nCompute the median using CyclicProximalPointEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe algorithm is further described in [Bac14].\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, ExtrinsicEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::ExtrinsicEstimation;\n    kwargs...,\n)\n\nEstimate the median of x using ExtrinsicEstimation, i.e. by computing the median in the embedding and projecting the result back.\n\nSee median for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, WeiszfeldEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::WeiszfeldEstimation;\n    α = 1.0,\n    p0=x[1],\n    stop_iter=2000,\n    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x)),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x)),\n    kwargs...,\n)\n\nCompute the median using WeiszfeldEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nThe parameter αin (02 is a step size.\n\nThe algorithm is further described in [FVJ08], especially the update rule in Eq. (6), i.e. Let q_k denote the current iterate, n the number of points x_1ldotsx_n, and\n\nI_k = bigl i in 1ldotsn big x_i neq q_k bigr\n\nall indices of points that are not equal to the current iterate. Then the update reads q_k+1 = exp_q_k(αX), where\n\nX = frac1ssum_iin I_k fracw_id_mathcal M(q_kx_i)log_q_kx_i\nquad\ntext with \nquad\ns = sum_iin I_k fracw_id_mathcal M(q_kx_i)\n\nand where mathrmd_mathcal M denotes the Riemannian distance.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction, which by default use the exponential and logarithmic map, respectively.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.median-Tuple{AbstractManifold, Vararg{Any}}","page":"Statistics","title":"Statistics.median","text":"median(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractApproximationMethod;\n    kwargs...,\n)\n\nCompute the (optionally weighted) Riemannian median of the vector x of points on the AbstractManifold  M, defined as the point that satisfies the minimizer\n\noperatornameargmin_y  mathcal M frac1sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance. This function is nonsmooth (i.e nondifferentiable).\n\nIn the general case, the CyclicProximalPointEstimation is used to compute the median. However, this default may be overloaded for specific manifolds.\n\nCompute the median using the specified method.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.std-Tuple{AbstractManifold, Vararg{Any}}","page":"Statistics","title":"Statistics.std","text":"std(M, x, m=mean(M, x); corrected=true, kwargs...)\nstd(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)\n\ncompute the optionally weighted standard deviation of a Vector x of n data points on the AbstractManifold  M, i.e.\n\nsqrtfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.std. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Statistics.var-Tuple{AbstractManifold, Any}","page":"Statistics","title":"Statistics.var","text":"var(M, x, m=mean(M, x); corrected=true)\nvar(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false)\n\ncompute the (optionally weighted) variance of a Vector x of n data points on the AbstractManifold  M, i.e.\n\nfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.var. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true. All further kwargs... are passed to the computation of the mean (if that is not provided).\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#StatsBase.kurtosis-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.kurtosis","text":"kurtosis(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the excess kurtosis of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#StatsBase.mean_and_std-Tuple{AbstractManifold, Vararg{Any}}","page":"Statistics","title":"StatsBase.mean_and_std","text":"mean_and_std(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, std)\n\nCompute the mean and the standard deviation std simultaneously.\n\nmean_and_std(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractApproximationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and standard deviation. To use a mean-specific method, call mean and then std.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights, GeodesicInterpolationWithinRadius}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n) -> (mean, var)\n\nUse repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nSee GeodesicInterpolationWithinRadius and mean_and_var for more information.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights, GeodesicInterpolation}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng::Union{AbstractRNG,Nothing} = nothing,\n    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x)),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x)),\n    kwargs...,\n) -> (mean, var)\n\nUse the repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered. Optionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nSee GeodesicInterpolation for details on the geodesic interpolation method.\n\nnote: Note\nThe Welford algorithm for the variance is experimental and is not guaranteed to give accurate results except on Euclidean.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#StatsBase.mean_and_var-Tuple{AbstractManifold, Vararg{Any}}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, var)\n\nCompute the mean and the variance simultaneously. See those functions for a description of the arguments.\n\nmean_and_var(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractApproximationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and variance. To use a mean-specific method, call mean and then var.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#StatsBase.moment","page":"Statistics","title":"StatsBase.moment","text":"moment(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the kth central moment of points in x on manifold M. Optionally provide weights w and/or a precomputed mean.\n\n\n\n\n\n","category":"function"},{"location":"features/statistics/#StatsBase.skewness-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.skewness","text":"skewness(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the standardized skewness of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics/#Literature","page":"Statistics","title":"Literature","text":"","category":"section"},{"location":"features/statistics/","page":"Statistics","title":"Statistics","text":"B. Afsari, R. Tron and R. Vidal. On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass. SIAM Journal on Control and Optimization 51, 2230–2260 (2013), arXiv:1201.0925.\n\n\n\nM. Bačák. Computing medians and means in Hadamard spaces. SIAM Journal on Optimization 24, 1542–1566 (2014), arXiv:1210.2145.\n\n\n\nP. T. Fletcher, S. Venkatasubramanian and S. Joshi. Robust statistics on Riemannian manifolds via the geometric median. In: 2008 IEEE Conference on Computer Vision and Pattern Recognition (2008).\n\n\n\nH. Karcher. Riemannian center of mass and mollifier smoothing. Communications on Pure and Applied Mathematics 30, 509–541 (1977).\n\n\n\nX. Pennec. Intrinsic Statistics on Riemannian Manifolds: Basic Tools for Geometric Measurements. Journal of Mathematical Imaging and Vision 25, 127–154 (2006).\n\n\n\nX. Pennec and V. Arsigny. Exponential Barycenters of the Canonical Cartan Connection and Invariant Means on Lie Groups. In: Matrix Information Geometry (Springer, Berlin, Heidelberg, 2012); pp. 123–166, arXiv:00699361.\n\n\n\n","category":"page"},{"location":"manifolds/spectrahedron/#Spectrahedron","page":"Spectrahedron","title":"Spectrahedron","text":"","category":"section"},{"location":"manifolds/spectrahedron/#Manifolds.Spectrahedron","page":"Spectrahedron","title":"Manifolds.Spectrahedron","text":"Spectrahedron{T} <: AbstractDecoratorManifold{ℝ}\n\nThe Spectrahedron manifold, also known as the set of correlation matrices (symmetric positive semidefinite matrices) of rank k with unit trace.\n\nbeginaligned\nmathcal S(nk) =\nbiglp  ℝ^nn big a^mathrmTpa geq 0 text for all  a  ℝ^n\noperatornametr(p) = sum_i=1^n p_ii = 1\ntextand  p = qq^mathrmT text for  q in  ℝ^nk\ntext with  operatornamerank(p) = operatornamerank(q) = k\nbigr\nendaligned\n\nThis manifold is working solely on the matrices q. Note that this q is not unique, indeed for any orthogonal matrix A we have (qA)(qA)^mathrmT = qq^mathrmT = p, so the manifold implemented here is the quotient manifold. The unit trace translates to unit Frobenius norm of q.\n\nThe tangent space at p, denoted T_pmathcal E(nk), is also represented by matrices Yin ℝ^nk and reads as\n\nT_pmathcal S(nk) = bigl\nX  ℝ^nnX = qY^mathrmT + Yq^mathrmT\ntext with  operatornametr(X) = sum_i=1^nX_ii = 0\nbigr\n\nendowed with the Euclidean metric from the embedding, i.e. from the ℝ^nk\n\nThis manifold was for example investigated in [JBAS10].\n\nConstructor\n\nSpectrahedron(n::Int, k::Int; parameter::Symbol=:type)\n\ngenerates the manifold mathcal S(nk) subset ℝ^nn.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spectrahedron/#ManifoldsBase.check_point-Tuple{Spectrahedron, Any}","page":"Spectrahedron","title":"ManifoldsBase.check_point","text":"check_point(M::Spectrahedron, q; kwargs...)\n\nchecks, whether q is a valid representation of a point p=qq^mathrmT on the Spectrahedron M, i.e. is a matrix of size (N,K), such that p is symmetric positive semidefinite and has unit trace, i.e. q has to have unit frobenius norm. Since by construction p is symmetric, this is not explicitly checked. Since p is by construction positive semidefinite, this is not checked. The tolerances for positive semidefiniteness and unit trace can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{Spectrahedron, Any, T}} where T","page":"Spectrahedron","title":"ManifoldsBase.check_vector","text":"check_vector(M::Spectrahedron, q, Y; kwargs...)\n\nCheck whether X = qY^mathrmT + Yq^mathrmT is a tangent vector to p=qq^mathrmT on the Spectrahedron M, i.e. atfer check_point of q, Y has to be of same dimension as q and a X has to be a symmetric matrix with trace. The tolerance for the base point check and zero diagonal can be set using the kwargs.... Note that symmetry of X holds by construction and is not explicitly checked.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.is_flat-Tuple{Spectrahedron}","page":"Spectrahedron","title":"ManifoldsBase.is_flat","text":"is_flat(::Spectrahedron)\n\nReturn false. Spectrahedron is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.manifold_dimension-Tuple{Spectrahedron}","page":"Spectrahedron","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Spectrahedron)\n\nreturns the dimension of Spectrahedron M=mathcal S(nk) nk  ℕ, i.e.\n\ndim mathcal S(nk) = nk - 1 - frack(k-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.project-Tuple{Spectrahedron, Any}","page":"Spectrahedron","title":"ManifoldsBase.project","text":"project(M::Spectrahedron, q)\n\nproject q onto the manifold Spectrahedron M, by normalizing w.r.t. the Frobenius norm\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.project-Tuple{Spectrahedron, Vararg{Any}}","page":"Spectrahedron","title":"ManifoldsBase.project","text":"project(M::Spectrahedron, q, Y)\n\nProject Y onto the tangent space at q, i.e. row-wise onto the Spectrahedron manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.representation_size-Tuple{Spectrahedron}","page":"Spectrahedron","title":"ManifoldsBase.representation_size","text":"representation_size(M::Spectrahedron)\n\nReturn the size of an array representing an element on the Spectrahedron manifold M, i.e. nk, the size of such factor of p=qq^mathrmT on mathcal M = mathcal S(nk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.retract-Tuple{Spectrahedron, Any, Any, ProjectionRetraction}","page":"Spectrahedron","title":"ManifoldsBase.retract","text":"retract(M::Spectrahedron, q, Y, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting q+Y back onto the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.vector_transport_to-Tuple{Spectrahedron, Any, Any, Any, ProjectionTransport}","page":"Spectrahedron","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Spectrahedron, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#ManifoldsBase.zero_vector-Tuple{Spectrahedron, Vararg{Any}}","page":"Spectrahedron","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Spectrahedron,p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the Spectrahedron manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron/#Literature","page":"Spectrahedron","title":"Literature","text":"","category":"section"},{"location":"manifolds/choleskyspace/#Cholesky-space","page":"Cholesky space","title":"Cholesky space","text":"","category":"section"},{"location":"manifolds/choleskyspace/","page":"Cholesky space","title":"Cholesky space","text":"The Cholesky space is a Riemannian manifold on the lower triangular matrices. Its metric is based on the cholesky decomposition. The CholeskySpace is used to define the LogCholeskyMetric on the manifold of  SymmetricPositiveDefinite matrices.","category":"page"},{"location":"manifolds/choleskyspace/#Manifolds.CholeskySpace","page":"Cholesky space","title":"Manifolds.CholeskySpace","text":"CholeskySpace{T} <: AbstractManifold{ℝ}\n\nThe manifold of lower triangular matrices with positive diagonal and a metric based on the Cholesky decomposition. The formulae for this manifold are for example summarized in Table 1 of [Lin19].\n\nConstructor\n\nCholeskySpace(n; parameter::Symbol=:type)\n\nGenerate the manifold of nn lower triangular matrices with positive diagonal.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/choleskyspace/#Base.exp-Tuple{CholeskySpace, Vararg{Any}}","page":"Cholesky space","title":"Base.exp","text":"exp(M::CholeskySpace, p, X)\n\nCompute the exponential map on the CholeskySpace M emanating from the lower triangular matrix with positive diagonal p towards the lower triangular matrix X The formula reads\n\nexp_p X =  p  +  X  + operatornamediag(p)\noperatornamediag(p)expbigl( operatornamediag(X)operatornamediag(p)^-1bigr)\n\nwhere  denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#Base.log-Tuple{LinearAlgebra.Cholesky, Vararg{Any}}","page":"Cholesky space","title":"Base.log","text":"log(M::CholeskySpace, X, p, q)\n\nCompute the logarithmic map on the CholeskySpace M for the geodesic emanating from the lower triangular matrix with positive diagonal p towards q. The formula reads\n\nlog_p q =  p  -  q  + operatornamediag(p)logbigl(operatornamediag(q)operatornamediag(p)^-1bigr)\n\nwhere  denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.check_point-Union{Tuple{T}, Tuple{CholeskySpace, T}} where T","page":"Cholesky space","title":"ManifoldsBase.check_point","text":"check_point(M::CholeskySpace, p; kwargs...)\n\nCheck whether the matrix p lies on the CholeskySpace M, i.e. it's size fits the manifold, it is a lower triangular matrix and has positive entries on the diagonal. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.check_vector-Tuple{CholeskySpace, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.check_vector","text":"check_vector(M::CholeskySpace, p, X; kwargs... )\n\nCheck whether v is a tangent vector to p on the CholeskySpace M, i.e. after check_point(M,p), X has to have the same dimension as p and a symmetric matrix. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.distance-Tuple{CholeskySpace, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.distance","text":"distance(M::CholeskySpace, p, q)\n\nCompute the Riemannian distance on the CholeskySpace M between two matrices p, q that are lower triangular with positive diagonal. The formula reads\n\nd_mathcal M(pq) = sqrtsum_ij (p_ij-q_ij)^2 +\nsum_j=1^m (log p_jj - log q_jj)^2\n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.inner-Tuple{CholeskySpace, Any, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.inner","text":"inner(M::CholeskySpace, p, X, Y)\n\nCompute the inner product on the CholeskySpace M at the lower triangular matrix with positive diagonal p and the two tangent vectors X,Y, i.e they are both lower triangular matrices with arbitrary diagonal. The formula reads\n\ng_p(XY) = sum_ij X_ijY_ij + sum_j=1^m X_iiY_iip_ii^-2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.is_flat-Tuple{CholeskySpace}","page":"Cholesky space","title":"ManifoldsBase.is_flat","text":"is_flat(::CholeskySpace)\n\nReturn true. CholeskySpace is a flat manifold. See Proposition 8 of [Lin19].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.manifold_dimension-Tuple{CholeskySpace}","page":"Cholesky space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::CholeskySpace)\n\nReturn the manifold dimension for the CholeskySpace M, i.e.\n\n    dim(mathcal M) = fracN(N+1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.parallel_transport_to-Tuple{CholeskySpace, Any, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::CholeskySpace, p, X, q)\n\nParallely transport the tangent vector X at p along the geodesic to q on the CholeskySpace manifold M. The formula reads\n\nmathcal P_qp(X) =  X \n+ operatornamediag(q)operatornamediag(p)^-1operatornamediag(X)\n\nwhere  denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.representation_size-Tuple{CholeskySpace}","page":"Cholesky space","title":"ManifoldsBase.representation_size","text":"representation_size(M::CholeskySpace)\n\nReturn the representation size for the CholeskySpace{N} M, i.e. (N,N).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#ManifoldsBase.zero_vector-Tuple{CholeskySpace, Vararg{Any}}","page":"Cholesky space","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::CholeskySpace, p)\n\nReturn the zero tangent vector on the CholeskySpace M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace/#Literature","page":"Cholesky space","title":"Literature","text":"","category":"section"},{"location":"features/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"features/utilities/#Ease-of-notation","page":"Utilities","title":"Ease of notation","text":"","category":"section"},{"location":"features/utilities/","page":"Utilities","title":"Utilities","text":"The following terms introduce a nicer notation for some operations, for example using the ∈ operator, p  mathcal M to determine whether p is a point on the AbstractManifold  mathcal M.","category":"page"},{"location":"features/utilities/#Base.in","page":"Utilities","title":"Base.in","text":"Base.in(p, M::AbstractManifold; kwargs...)\np ∈ M\n\nCheck, whether a point p is a valid point (i.e. in) a AbstractManifold  M. This method employs is_point deactivating the error throwing option.\n\n\n\n\n\nBase.in(p, TpM::TangentSpace; kwargs...)\nX ∈ TangentSpace(M, p)\n\nCheck whether X is a tangent vector from (in) the tangent space T_pmathcal M, i.e. the TangentSpace at p on the AbstractManifold  M. This method uses is_vector deactivating the error throw option.\n\n\n\n\n\n","category":"function"},{"location":"features/utilities/#Public-documentation","page":"Utilities","title":"Public documentation","text":"","category":"section"},{"location":"features/utilities/#Manifolds.sectional_curvature_matrix","page":"Utilities","title":"Manifolds.sectional_curvature_matrix","text":"sectional_curvature_matrix(M::AbstractManifold, p, B::AbstractBasis)\n\nCompute the matrix of sectional curvatures of manifold M at point p. Entry (i, j) corresponds to sectional curvature of the surface spanned by vectors i  and j from basis B.\n\n\n\n\n\n","category":"function"},{"location":"features/utilities/#Specific-exception-types","page":"Utilities","title":"Specific exception types","text":"","category":"section"},{"location":"features/utilities/","page":"Utilities","title":"Utilities","text":"For some manifolds it is useful to keep an extra index, at which point on the manifold, the error occurred as well as to collect all errors that occurred on a manifold. This page contains the manifold-specific error messages this package introduces.","category":"page"},{"location":"manifolds/oblique/#Oblique-manifold","page":"Oblique manifold","title":"Oblique manifold","text":"","category":"section"},{"location":"manifolds/oblique/","page":"Oblique manifold","title":"Oblique manifold","text":"The oblique manifold mathcalOB(nm) is modeled as an AbstractPowerManifold  of the (real-valued) Sphere and uses ArrayPowerRepresentation. Points on the torus are hence matrices, x  ℝ^nm.","category":"page"},{"location":"manifolds/oblique/#Manifolds.Oblique","page":"Oblique manifold","title":"Manifolds.Oblique","text":"Oblique{𝔽, T, S} <: AbstractPowerManifold{𝔽}\n\nThe oblique manifold mathcalOB(nm) is the set of 𝔽-valued matrices with unit norm column endowed with the metric from the embedding. This yields exactly the same metric as considering the product metric of the unit norm vectors, i.e. PowerManifold of the (n-1)-dimensional Sphere.\n\nThe Sphere is stored internally within M.manifold, such that all functions of AbstractPowerManifold  can be used directly.\n\nConstructor\n\nOblique(n::Int, m::Int, field::AbstractNumbers=ℝ; parameter::Symbol=:type)\n\nGenerate the manifold of matrices mathbb R^nm such that the m columns are unit vectors, i.e. from the Sphere(n-1).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/oblique/#Functions","page":"Oblique manifold","title":"Functions","text":"","category":"section"},{"location":"manifolds/oblique/","page":"Oblique manifold","title":"Oblique manifold","text":"Most functions are directly implemented for an AbstractPowerManifold  with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/oblique/#ManifoldsBase.check_point-Tuple{Oblique, Any}","page":"Oblique manifold","title":"ManifoldsBase.check_point","text":"check_point(M::Oblique, p)\n\nChecks whether p is a valid point on the Oblique{m,n} M, i.e. is a matrix of m unit columns from mathbb R^n, i.e. each column is a point from Sphere(n-1).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/oblique/#ManifoldsBase.check_vector-Tuple{Oblique, Any, Any}","page":"Oblique manifold","title":"ManifoldsBase.check_vector","text":"check_vector(M::Oblique p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the Oblique M. This means, that p is valid, that X is of correct dimension and columnswise a tangent vector to the columns of p on the Sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/oblique/#ManifoldsBase.parallel_transport_to-Tuple{Oblique, Any, Any, Any}","page":"Oblique manifold","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Oblique, p, X, q)\n\nCompute the parallel transport on the Oblique manifold by doing a column wise parallel transport on the Sphere\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Orthogonal-and-Unitary-matrices","page":"Orthogonal and Unitary Matrices","title":"Orthogonal and Unitary matrices","text":"","category":"section"},{"location":"manifolds/generalunitary/","page":"Orthogonal and Unitary Matrices","title":"Orthogonal and Unitary Matrices","text":"Both OrthogonalMatrices and UnitaryMatrices have similar formulae and implementations, as are Rotations, as well as unitary matrices with determinant equal to one. These share a common implementation.","category":"page"},{"location":"manifolds/generalunitary/#Orthogonal-matrices","page":"Orthogonal and Unitary Matrices","title":"Orthogonal matrices","text":"","category":"section"},{"location":"manifolds/generalunitary/#Manifolds.OrthogonalMatrices","page":"Orthogonal and Unitary Matrices","title":"Manifolds.OrthogonalMatrices","text":" OrthogonalMatrices{n} = GeneralUnitaryMatrices{ℝ, n, AbsoluteDeterminantOneMatrixType}\n\nThe manifold of (real) orthogonal nn matrices mathrmO(n). They are precisely the nn real matrices M that satisfy\n\n    M^TM=MM^T= mathrmI_n\n\nwhere M^T is the transpose of M and mathrmI_n is the nn identity matrix. Thus, their columns and rows represent n pairwise orthonormal vectors. Such matrices M have the property that lVert det(M) rVert = 1.\n\nThis is the same manifold as the Stiefel(n, n, ℂ) manifold.\n\nConstructor\n\nOrthogonalMatrices(n)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalunitary/#Unitary-matrices","page":"Orthogonal and Unitary Matrices","title":"Unitary matrices","text":"","category":"section"},{"location":"manifolds/generalunitary/#Manifolds.UnitaryMatrices","page":"Orthogonal and Unitary Matrices","title":"Manifolds.UnitaryMatrices","text":"const UnitaryMatrices{𝔽, T} = GeneralUnitaryMatrices{𝔽, T, AbsoluteDeterminantOneMatrixType}\n\nThe manifold U(n𝔽) of nn complex matrices (when 𝔽=ℂ) or quaternionic matrices (when 𝔽=ℍ) such that\n\n    p^mathrmHp = mathrmI_n\n\nwhere p^mathrmH is the conjugate transpose of p and mathrmI_n is the nn identity matrix. Such matrices p have a property that lVert det(p) rVert = 1.\n\nThe tangent spaces are given by\n\n    T_pU(n) coloneqq bigl\n    X big pY text where  Y text is skew symmetric i e  Y = -Y^mathrmH\n    bigr\n\nBut note that tangent vectors are represented in the Lie algebra, i.e. just using Y in the representation above. If you prefer the representation as X you can use the Stiefel(n, n, ℂ) manifold.\n\nConstructor\n\nUnitaryMatrices(n, 𝔽::AbstractNumbers=ℂ)\n\nsee also OrthogonalMatrices for the real valued case.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalunitary/#Base.rand-Tuple{UnitaryMatrices}","page":"Orthogonal and Unitary Matrices","title":"Base.rand","text":"rand(::Unitary; vector_at=nothing, σ::Real=1.0)\n\nGenerate a random point on the UnitaryMatrices manifold, if vector_at is nothing, by computing the QR decomposition of an nn matrix.\n\nGenerate a tangent vector at vector_at by projecting a normally distributed matrix onto the tangent space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldDiff.riemannian_Hessian-Tuple{UnitaryMatrices, Vararg{Any, 4}}","page":"Orthogonal and Unitary Matrices","title":"ManifoldDiff.riemannian_Hessian","text":"riemannian_Hessian(M::UnitaryMatrices, p, G, H, X)\n\nThe Riemannian Hessian can be computed by adopting Eq. (5.6) [Ngu23], so very similar to the complex Stiefel manifold. The only difference is, that here the tangent vectors are stored in the Lie algebra, i.e. the update direction is actually pX instead of just X (in Stiefel). and that means the inverse has to be applied to the (Euclidean) Hessian to map it into the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.Weingarten-Tuple{UnitaryMatrices, Any, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.Weingarten","text":"Weingarten(M::UnitaryMatrices, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the Stiefel M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nThe formula is due to [AMT13] given by\n\nmathcal W_p(XV) = -frac12pbigl(V^mathrmHX - X^mathrmHVbigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.manifold_dimension-Tuple{UnitaryMatrices{ℂ}}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::UnitaryMatrices{n,ℂ}) where {n}\n\nReturn the dimension of the manifold unitary matrices.\n\ndim_mathrmU(n) = n^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.manifold_dimension-Tuple{UnitaryMatrices{ℍ}}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::UnitaryMatrices{<:Any,ℍ})\n\nReturn the dimension of the manifold unitary matrices.\n\ndim_mathrmU(n ℍ) = n(2n+1)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Special-Unitary-matrices","page":"Orthogonal and Unitary Matrices","title":"Special Unitary matrices","text":"","category":"section"},{"location":"manifolds/generalunitary/#Manifolds.SpecialUnitaryMatrices","page":"Orthogonal and Unitary Matrices","title":"Manifolds.SpecialUnitaryMatrices","text":"const SpecialUnitaryMatrices{T} = GeneralUnitaryMatrices{ℂ, T, DeterminantOneMatrixType}\n\nThe manifold SU(n) of nn complex matrices such that\n\n    p^mathrmHp = mathrmI_n text and  det(p) = 1\n\nwhere p^mathrmH is the conjugate transpose of p and mathrmI_n is the nn identity matrix.\n\nThe tangent spaces are given by\n\n    T_pU(n) coloneqq bigl\n    X big pY text where  Y text is skew symmetric and traceless i e  Y = -Y^mathrmH text and  operatornametr(Y) = 0\n    bigr\n\nBut note that tangent vectors are represented in the Lie algebra, i.e. just using Y in the representation above.\n\nConstructor\n\nSpecialUnitaryMatrices(n; parameter::Symbol = :type)\n\nsee also Rotations for the real valued case.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalunitary/#Manifolds.manifold_volume-Tuple{SpecialUnitaryMatrices}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.manifold_volume","text":"manifold_volume(::SpecialUnitaryMatrices)\n\nVolume of the manifold of complex general unitary matrices of determinant one. The formula reads [BST03]\n\nsqrtn 2^n-1 π^(n-1)(n+2)2 prod_k=1^n-1frac1k\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.injectivity_radius-Tuple{SpecialUnitaryMatrices}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::SpecialUnitaryMatrices)\n\nReturn the injectivity radius for general complex unitary matrix manifolds, where the determinant is +1, which is[1]\n\n    operatornameinj_mathrmSU(n) = π sqrt2\n\n[1]     > For a derivation of the injectivity radius, see sethaxen.com/blog/2023/02/the-injectivity-radii-of-the-unitary-groups/.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.manifold_dimension-Tuple{SpecialUnitaryMatrices}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SpecialUnitaryMatrices)\n\nReturn the dimension of the manifold of special unitary matrices.\n\ndim_mathrmSU(n) = n^2-1\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#generalunitarymatrices","page":"Orthogonal and Unitary Matrices","title":"Common functions","text":"","category":"section"},{"location":"manifolds/generalunitary/#Manifolds.AbsoluteDeterminantOneMatrixType","page":"Orthogonal and Unitary Matrices","title":"Manifolds.AbsoluteDeterminantOneMatrixType","text":"AbsoluteDeterminantOneMatrixType <: AbstractMatrixType\n\nA type to indicate that we require (orthogonal / unitary) matrices with normed determinant, i.e. that the absolute value of the determinant is 1.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalunitary/#Manifolds.AbstractMatrixType","page":"Orthogonal and Unitary Matrices","title":"Manifolds.AbstractMatrixType","text":"AbstractMatrixType\n\nA plain type to distinguish different types of matrices, for example DeterminantOneMatrixType and AbsoluteDeterminantOneMatrixType.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalunitary/#Manifolds.DeterminantOneMatrixType","page":"Orthogonal and Unitary Matrices","title":"Manifolds.DeterminantOneMatrixType","text":"DeterminantOneMatrixType <: AbstractMatrixType\n\nA type to indicate that we require special (orthogonal / unitary) matrices, i.e. of determinant 1.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalunitary/#Manifolds.GeneralUnitaryMatrices","page":"Orthogonal and Unitary Matrices","title":"Manifolds.GeneralUnitaryMatrices","text":"GeneralUnitaryMatrices{𝔽, T, S<:AbstractMatrixType} <: AbstractDecoratorManifold\n\nA common parametric type for matrices with a unitary property of size nn over the field 𝔽 which additionally have the AbstractMatrixType, e.g. are DeterminantOneMatrixType.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalunitary/#Base.exp-Tuple{Manifolds.GeneralUnitaryMatrices, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"Base.exp","text":"exp(M::Rotations, p, X)\nexp(M::OrthogonalMatrices, p, X)\nexp(M::UnitaryMatrices, p, X)\n\nCompute the exponential map, that is, since X is represented in the Lie algebra,\n\nexp_p(X) = pmathrme^X\n\nFor different sizes, like n=234, there are specialized implementations.\n\nThe algorithm used is a more numerically stable form of those proposed in [GX02] and [AR13].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Base.log-Tuple{Manifolds.GeneralUnitaryMatrices, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"Base.log","text":"log(M::Rotations, p, X)\nlog(M::OrthogonalMatrices, p, X)\nlog(M::UnitaryMatrices, p, X)\n\nCompute the logarithmic map, that is, since the resulting X is represented in the Lie algebra,\n\nlog_p q = log(p^mathrmHq)\n\nwhich is projected onto the skew symmetric matrices for numerical stability.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Base.log-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ}, Vararg{Any}}","page":"Orthogonal and Unitary Matrices","title":"Base.log","text":"log(M::Rotations, p, q)\n\nCompute the logarithmic map on the Rotations manifold M which is given by\n\nlog_p q = log(p^mathrmTq)\n\nwhere log denotes the matrix logarithm. For numerical stability, the result is projected onto the set of skew symmetric matrices.\n\nFor antipodal rotations the function returns deterministically one of the tangent vectors that point at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles αβ of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned\ncos α + cos β = frac12 operatornametr(R)\ncos α cos β = frac18 operatornametr(R)^2\n                 - frac116 operatornametr((R - R^T)^2) - 1\nendaligned\n\nBy convention, the returned values are sorted in decreasing order. See also angles_4d_skew_sym_matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Manifolds.manifold_volume-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ, <:Any, Manifolds.AbsoluteDeterminantOneMatrixType}}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.manifold_volume","text":"manifold_volume(::GeneralUnitaryMatrices{ℝ,<:Any,AbsoluteDeterminantOneMatrixType})\n\nVolume of the manifold of real orthogonal matrices of absolute determinant one. The formula reads [BST03]:\n\nbegincases\nfrac2^k(2pi)^k^2prod_s=1^k-1 (2s)  text if  n = 2k \n\nfrac2^k+1(2pi)^k(k+1)prod_s=1^k-1 (2s+1)  text if  n = 2k+1\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Manifolds.manifold_volume-Tuple{Rotations}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.manifold_volume","text":"manifold_volume(::GeneralUnitaryMatrices{ℝ,<:Any,DeterminantOneMatrixType})\n\nVolume of the manifold of real orthogonal matrices of determinant one. The formula reads [BST03]:\n\nbegincases\n2  text if  n = 0 \nfrac2^k-12(2pi)^k^2prod_s=1^k-1 (2s)  text if  n = 2k+2 \nfrac2^k+12(2pi)^k(k+1)prod_s=1^k-1 (2s+1)  text if  n = 2k+1\nendcases\n\nIt differs from the paper by a factor of sqrt(2) due to a different choice of normalization.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Manifolds.manifold_volume-Tuple{UnitaryMatrices{ℂ}}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.manifold_volume","text":"manifold_volume(::GeneralUnitaryMatrices{ℂ,<:Any,AbsoluteDeterminantOneMatrixType})\n\nVolume of the manifold of complex general unitary matrices of absolute determinant one. The formula reads [BST03]\n\nsqrtn 2^n+1 π^n(n+1)2 prod_k=1^n-1frac1k\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Manifolds.volume_density-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.volume_density","text":"volume_density(M::GeneralUnitaryMatrices{ℝ, TypeParameter{Tuple{2}}}, p, X)\n\nVolume density on O(2)/SO(2) is equal to 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Manifolds.volume_density-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.volume_density","text":"volume_density(M::GeneralUnitaryMatrices{ℝ, TypeParameter{Tuple{3}}}, p, X)\n\nCompute the volume density on O(3)/SO(3). The formula reads [FdHDF19]\n\nfrac1-1cos(sqrt2lVert X rVert)lVert X rVert^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Manifolds.volume_density-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ}, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"Manifolds.volume_density","text":"volume_density(M::GeneralUnitaryMatrices{<:Any,ℝ}, p, X)\n\nCompute volume density function of a sphere, i.e. determinant of the differential of exponential map exp(M, p, X). It is derived from Eq. (4.1) and Corollary 4.4 in [CLLD22]. See also Theorem 4.1 in [FdHDF19], (note that it uses a different convention).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{Manifolds.GeneralUnitaryMatrices{𝔽, <:Any, Manifolds.DeterminantOneMatrixType}, Any}} where 𝔽","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.check_point","text":"check_point(M::Rotations, p; kwargs...)\n\nCheck whether p is a valid point on the UnitaryMatrices M, i.e. that p has a determinant of absolute value one, i.e. that p^mathrmHp = mathrmI_n\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{UnitaryMatrices{𝔽}, Any}} where 𝔽","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.check_point","text":"check_point(M::UnitaryMatrices, p; kwargs...)\ncheck_point(M::OrthogonalMatrices, p; kwargs...)\ncheck_point(M::GeneralUnitaryMatrices, p; kwargs...)\n\nCheck whether p is a valid point on the UnitaryMatrices or [OrthogonalMatrices] M, i.e. that p has a determinant of absolute value one.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{Manifolds.GeneralUnitaryMatrices{𝔽}, Any, Any}} where 𝔽","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::UnitaryMatrices, p, X; kwargs... )\ncheck_vector(M::OrthogonalMatrices, p, X; kwargs... )\ncheck_vector(M::Rotations, p, X; kwargs... )\ncheck_vector(M::GeneralUnitaryMatrices, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the UnitaryMatrices space M, i.e. after check_point(M,p), X has to be skew symmetric (Hermitian) and orthogonal to p.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.embed-Tuple{Manifolds.GeneralUnitaryMatrices, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.embed","text":"embed(M::GeneralUnitaryMatrices, p, X)\n\nEmbed the tangent vector X at point p in M from its Lie algebra representation (set of skew matrices) into the Riemannian submanifold representation\n\nThe formula reads\n\nX_textembedded = p * X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.get_coordinates-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ}, Vararg{Any}}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Rotations, p, X)\nget_coordinates(M::OrthogonalMatrices, p, X)\nget_coordinates(M::UnitaryMatrices, p, X)\n\nExtract the unique tangent vector components X^i at point p on Rotations mathrmSO(n) from the matrix representation X of the tangent vector.\n\nThe basis on the Lie algebra 𝔰𝔬(n) is chosen such that for mathrmSO(2), X^1 = θ = X_21 is the angle of rotation, and for mathrmSO(3), (X^1 X^2 X^3) = (X_32 X_13 X_21) = θ u is the angular velocity and axis-angle representation, where u is the unit vector along the axis of rotation.\n\nFor mathrmSO(n) where n  4, the additional elements of X^i are X^j (j - 3)2 + k + 1 = X_jk, for j  4n k  1j).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.get_embedding-Union{Tuple{Manifolds.GeneralUnitaryMatrices{𝔽, ManifoldsBase.TypeParameter{Tuple{n}}}}, Tuple{𝔽}, Tuple{n}} where {n, 𝔽}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::OrthogonalMatrices)\nget_embedding(M::Rotations)\nget_embedding(M::UnitaryMatrices)\n\nReturn the embedding, i.e. The mathbb F^nn, where mathbb F = mathbb R for the first two and mathbb F = mathbb C for the unitary matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.get_vector-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ}, Vararg{Any}}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.get_vector","text":"get_vector(M::OrthogonalMatrices, p, Xⁱ, B::DefaultOrthogonalBasis)\nget_vector(M::Rotations, p, Xⁱ, B::DefaultOrthogonalBasis)\n\nConvert the unique tangent vector components Xⁱ at point p on Rotations or OrthogonalMatrices to the matrix representation X of the tangent vector. See get_coordinates for the conventions used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.injectivity_radius-Tuple{Manifolds.GeneralUnitaryMatrices}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::GeneraliUnitaryMatrices)\n\nReturn the injectivity radius for general unitary matrix manifolds, which is[1]\n\n    operatornameinj_mathrmU(n) = π\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.injectivity_radius-Union{Tuple{Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{n}}}}, Tuple{n}} where n","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::SpecialOrthogonal)\ninjectivity_radius(G::Orthogonal)\ninjectivity_radius(M::Rotations)\ninjectivity_radius(M::Rotations, ::ExponentialRetraction)\n\nReturn the radius of injectivity on the Rotations manifold M, which is πsqrt2. [1]\n\n[1]: For a derivation of the injectivity radius, see sethaxen.com/blog/2023/02/the-injectivity-radii-of-the-unitary-groups/.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.is_flat-Tuple{Manifolds.GeneralUnitaryMatrices}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.is_flat","text":"is_flat(M::GeneralUnitaryMatrices)\n\nReturn true if GeneralUnitaryMatrices M is SO(2) or U(1) and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.manifold_dimension-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ}}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Rotations)\nmanifold_dimension(M::OrthogonalMatrices)\n\nReturn the dimension of the manifold orthogonal matrices and of the manifold of rotations\n\ndim_mathrmO(n) = dim_mathrmSO(n) = fracn(n-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.project-Tuple{Manifolds.GeneralUnitaryMatrices, Any, Any}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.project","text":"project(M::OrthogonalMatrices, p, X)\nproject(M::Rotations, p, X)\nproject(M::UnitaryMatrices, p, X)\n\nOrthogonally project the tangent vector X  𝔽^nn, mathbb F  mathbb R mathbb C to the tangent space of M at p, and change the representer to use the corresponding Lie algebra, i.e. we compute\n\n    operatornameproj_p(X) = fracp^mathrmH X - (p^mathrmH X)^mathrmH2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.project-Union{Tuple{𝔽}, Tuple{UnitaryMatrices{𝔽}, Any}} where 𝔽","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.project","text":" project(G::UnitaryMatrices, p)\n project(G::OrthogonalMatrices, p)\n\nProject the point p  𝔽^nn to the nearest point in mathrmU(n𝔽)=UnitaryMatrices(n,𝔽) under the Frobenius norm. If p = U S V^mathrmH is the singular value decomposition of p, then the projection is\n\n  operatornameproj_mathrmU(n𝔽) colon p  U V^mathrmH\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.retract-Tuple{Manifolds.GeneralUnitaryMatrices, Any, Any, PolarRetraction}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.retract","text":"retract(M::Rotations, p, X, ::PolarRetraction)\nretract(M::OrthogonalMatrices, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction on the Rotations and OrthogonalMatrices M from p in direction X (as an element of the Lie group) and is a second-order approximation of the exponential map. Let\n\nUSV = p + pX\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_p X = UV^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.retract-Tuple{Manifolds.GeneralUnitaryMatrices, Any, Any, QRRetraction}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.retract","text":"retract(M::Rotations, p, X, ::QRRetraction)\nretract(M::OrthogonalMatrices, p. X, ::QRRetraction)\n\nCompute the QR-based retraction on the Rotations and OrthogonalMatrices M from p in direction X (as an element of the Lie group), which is a first-order approximation of the exponential map.\n\nThis is also the default retraction on these manifolds.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#ManifoldsBase.riemann_tensor-Tuple{Manifolds.GeneralUnitaryMatrices, Vararg{Any, 4}}","page":"Orthogonal and Unitary Matrices","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(::GeneralUnitaryMatrices, p, X, Y, Z)\n\nCompute the value of Riemann tensor on the GeneralUnitaryMatrices manifold. The formula reads [Ren11]\n\nR(XY)Z=frac14Z X Y\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Statistics.mean-Tuple{Manifolds.GeneralUnitaryMatrices{ℝ}, Any}","page":"Orthogonal and Unitary Matrices","title":"Statistics.mean","text":"mean(\n    M::Rotations,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2/√2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalunitary/#Footnotes-and-References","page":"Orthogonal and Unitary Matrices","title":"Footnotes and References","text":"","category":"section"},{"location":"tutorials/integration/#Integration","page":"integrate on manifolds and handle probability densities","title":"Integration","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"This part of documentation covers integration of scalar functions defined on manifolds f colon mathcalM to ℝ:","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"int_mathcal M f(p) mathrmdp","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"The basic concepts are derived from geometric measure theory. In principle, there are many ways in which a manifold can be equipped with a measure that can be later used to define an integral. One of the most popular ways is based on pushing the Lebesgue measure on a tangent space through the exponential map. Any other suitable atlas could be used, not just the one defined by normal coordinates, though each one requires different volume density corrections due to the Jacobian determinant of the pushforward. Manifolds.jl provides the function volume_density that calculates that quantity, denoted theta_p(X). See for example [BP19], Definition 11, for a precise description using Jacobi fields.","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"While many sources define volume density as a function of two points, Manifolds.jl decided to use the more general point-tangent vector formulation. The two-points variant can be implemented as","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"using Manifolds\nvolume_density_two_points(M::AbstractManifold, p, q) = volume_density(M, p, log(M, p, q))","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"volume_density_two_points (generic function with 1 method)","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"The simplest way to of integrating a function on a compact manifold is through a Monte Carlo integrator. A simple variant can be implemented as follows (assuming uniform distribution of rand):","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"using LinearAlgebra, Distributions, SpecialFunctions\nfunction simple_mc_integrate(M::AbstractManifold, f; N::Int = 1000)\n    V = manifold_volume(M)\n    sum = 0.0\n    q = rand(M)\n    for i in 1:N\n        sum += f(M, q)\n        rand!(M, q)\n    end\n    return V * sum/N\nend","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"simple_mc_integrate (generic function with 1 method)","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"We used the function manifold_volume to get the volume of the set over which the integration is performed, as described in the linked Wikipedia article.","category":"page"},{"location":"tutorials/integration/#Distributions","page":"integrate on manifolds and handle probability densities","title":"Distributions","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"We will now try to verify that volume density correction correctly changes probability density of an exponential-wrapped normal distribution. pdf_tangent_space (defined in the next code block) represents probability density of a normally distributed random variable X_T in the tangent space T_p mathcalM. Its probability density (with respect to the Lebesgue measure of the tangent space) is f_X_Tcolon T_p mathcalM to ℝ.","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"pdf_manifold (defined below) refers to the probability density of the distribution X_M from the tangent space T_p mathcalM wrapped using exponential map on the manifold. The formula for probability density with respect to pushforward measure of the Lebesgue measure in the tangent space reads","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"f_X_M(q) = sum_X in T_pmathcalM exp_p(X)=q fracf_X_T(X)theta_p(X)","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"volume_density function calculates the correction theta_p(X).","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"function pdf_tangent_space(M::AbstractManifold, p)\n    return pdf(MvNormal(zeros(manifold_dimension(M)), 0.2*I), p)\nend\n\nfunction pdf_manifold(M::AbstractManifold, q)\n    p = [1.0, 0.0, 0.0]\n    X = log(M, p, q)\n    Xc = get_coordinates(M, p, X, DefaultOrthonormalBasis())\n    vd = abs(volume_density(M, p, X))\n    if vd > eps()\n        return pdf_tangent_space(M, Xc) / vd\n    else\n        return 0.0\n    end\nend\n\nprintln(simple_mc_integrate(Sphere(2), pdf_manifold; N=1000000))","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"1.0008911808819319","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"The function simple_mc_integrate, defined in the previous section, is used to verify that the density integrates to 1 over the manifold.","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"Note that our pdf_manifold implements a simplified version of f_X_M which assumes that the probability mass of pdf_tangent_space outside of (local) injectivity radius at p is negligible. In such case there is only one non-zero summand in the formula for f_X_M(q), namely X=log_p(q). Otherwise we would have to consider other vectors Yin T_p mathcalM such that exp_p(Y) = q in that sum.","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"Remarkably, exponential-wrapped distributions possess three important qualities [CLLD22]:","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"Densities of X_M are explicit. There is no normalization constant that needs to be computed like in truncated distributions.\nSampling from X_M is easy. It suffices to get a sample from X_T and pass it to the exponential map.\nIf mean of X_T is 0, then there is a simple correspondence between moments of X_M and X_T, for example p is the mean of X_M.","category":"page"},{"location":"tutorials/integration/#Kernel-density-estimation","page":"integrate on manifolds and handle probability densities","title":"Kernel density estimation","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"We can also make a Pelletier’s isotropic kernel density estimator. Given points p_1 p_2 dots p_n on d-dimensional manifold mathcal M the density at point q is defined as","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"f(q) = frac1n h^d sum_i=1^n frac1theta_q(log_q(p_i))Kleft( fracd(q p_i)h right)","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"where h is the bandwidth, a small positive number less than the injectivity radius of mathcal M and Kcolonℝtoℝ is a kernel function. Note that Pelletier’s estimator can only use radially-symmetric kernels. The radially symmetric multivariate Epanechnikov kernel used in the example below is described in [LW19].","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"struct PelletierKDE{TM<:AbstractManifold,TPts<:AbstractVector}\n    M::TM\n    bandwidth::Float64\n    pts::TPts\nend\n\n(kde::PelletierKDE)(::AbstractManifold, p) = kde(p)\nfunction (kde::PelletierKDE)(p)\n    n = length(kde.pts)\n    d = manifold_dimension(kde.M)\n    sum_kde = 0.0\n    function epanechnikov_kernel(x)\n        if x < 1\n            return gamma(2+d/2) * (1-x^2)/(π^(d/2))\n        else\n            return 0.0\n        end\n    end\n    for i in 1:n\n        X = log(kde.M, p, kde.pts[i])\n        Xn = norm(kde.M, p, X)\n        sum_kde += epanechnikov_kernel(Xn / kde.bandwidth) / volume_density(kde.M, p, X)\n    end\n    sum_kde /= n * kde.bandwidth^d\n    return sum_kde\nend\n\nM = Sphere(2)\npts = rand(M, 8)\nkde = PelletierKDE(M, 0.7, pts)\nprintln(simple_mc_integrate(Sphere(2), kde; N=1000000))\nprintln(kde(rand(M)))","category":"page"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"1.0001380861343723\n0.13954347011221996","category":"page"},{"location":"tutorials/integration/#Technical-notes","page":"integrate on manifolds and handle probability densities","title":"Technical notes","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"This section contains a few technical notes that are relevant to the problem of integration on manifolds but can be freely skipped on the first read of the tutorial.","category":"page"},{"location":"tutorials/integration/#Conflicting-statements-about-volume-of-a-manifold","page":"integrate on manifolds and handle probability densities","title":"Conflicting statements about volume of a manifold","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"manifold_volume and volume_density are closely related to each other, though very few sources explore this connection, and some even claiming a certain level of arbitrariness in defining manifold_volume. Volume is sometimes considered arbitrary because Riemannian metrics on some spaces like the manifold of rotations are defined with arbitrary constants. However, once a constant is picked (and it must be picked before any useful computation can be performed), all geometric operations must follow in a consistent way: inner products, exponential and logarithmic maps, volume densities, etc. Manifolds.jl consistently picks such constants and provides a unified framework, though it sometimes results in picking a different constant than what is the most popular in some sub-communities.","category":"page"},{"location":"tutorials/integration/#Haar-measures","page":"integrate on manifolds and handle probability densities","title":"Haar measures","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"On Lie groups the situation regarding integration is more complicated. Invariance under left or right group action is a desired property that leads one to consider Haar measures [Tor20]. It is, however, unclear what are the practical benefits of considering Haar measures over the Lebesgue measure of the underlying manifold, which often turns out to be invariant anyway.","category":"page"},{"location":"tutorials/integration/#Integration-in-charts","page":"integrate on manifolds and handle probability densities","title":"Integration in charts","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"Integration through charts is an approach currently not supported by Manifolds.jl. One has to define a suitable set of disjoint charts covering the entire manifold and use a method for multivariate Euclidean integration. Note that ranges of parameters have to be adjusted for each manifold and scaling based on the metric needs to be applied. See [BST03] for some considerations on symmetric spaces.","category":"page"},{"location":"tutorials/integration/#References","page":"integrate on manifolds and handle probability densities","title":"References","text":"","category":"section"},{"location":"tutorials/integration/#Literature","page":"integrate on manifolds and handle probability densities","title":"Literature","text":"","category":"section"},{"location":"tutorials/integration/","page":"integrate on manifolds and handle probability densities","title":"integrate on manifolds and handle probability densities","text":"L. J. Boya, E. Sudarshan and T. Tilma. Volumes of compact manifolds. Reports on Mathematical Physics 52, 401–422 (2003).\n\n\n\nA. L. Brigant and S. Puechmorel. Approximation of Densities on Riemannian Manifolds. Entropy 21, 43 (2019).\n\n\n\nE. Chevallier, D. Li, Y. Lu and D. B. Dunson. Exponential-wrapped distributions on symmetric spaces. ArXiv Preprint (2022).\n\n\n\nN. Langrené and X. Warin. Fast and Stable Multivariate Kernel Density Estimation by Fast Sum Updating. Journal of Computational and Graphical Statistics 28, 596–608 (2019).\n\n\n\nS. Tornier. Haar Measures (2020).\n\n\n\n","category":"page"},{"location":"misc/NEWS/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"misc/NEWS/#[0.11.4](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.11.4)-(2025-11-07)","page":"Changelog","title":"0.11.4 (2025-11-07)","text":"","category":"section"},{"location":"misc/NEWS/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Random tangent vectors on Hyperbolic are now much shorter (their norm is on the order of 1) to guide users away from numerical issues with long vectors.","category":"page"},{"location":"misc/NEWS/#[0.11.3](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.11.3)-(2025-11-04)","page":"Changelog","title":"0.11.3 (2025-11-04)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"fixes a few inconsistencies regarding get_embedding, which now consistently uses a point type as positional second argument.","category":"page"},{"location":"misc/NEWS/#[0.11.2](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.11.2)-(2025-10-30)","page":"Changelog","title":"0.11.2 (2025-10-30)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"fixed the default_retraction_method for AbstractSphere to be the stabilized exponential map to avoid accumulations of rounding errors when the tangent vector is not exactly tangent.\nfixed the contributing.md to mention runic as the code formatter.","category":"page"},{"location":"misc/NEWS/#[0.11.1](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.11.1)-(2025-10-24)","page":"Changelog","title":"0.11.1 (2025-10-24)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"fix a few small errors regarding the forwarding of retract, retract_fused, and inverse_retract when using a MetricManifold.jl (cf (#823))\ndocument why we kept that vector_transport_direction and vector_transport_to are not automatically forwarded in MetricManifold.jl","category":"page"},{"location":"misc/NEWS/#[0.11.0](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.11.0)-(2025-10-02)","page":"Changelog","title":"0.11.0 (2025-10-02)","text":"","category":"section"},{"location":"misc/NEWS/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"a function metric(M) analogous to embedding(M) and connection(M) that returns the metric of the manifold M.\na DefaultMetric() type to specify that the manifold uses some specific metric, that is not further named.","category":"page"},{"location":"misc/NEWS/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Switch to using Runic.jl as code formatter\nrefactored all manifolds to use a parameter order of {𝔽, T} where 𝔽 is the number type and T the type of size parameter (either a TypeParameter or a Tuple). this changed internally\nArraySphere{T<:Tuple,𝔽} to ArraySphere{𝔽, T<:Tuple}\nCenteredMatrices{T, 𝔽} to CenteredMatrices{𝔽, T}\nEuclidean{T, 𝔽} to Euclidean{𝔽, T}\nFixedRankMatrices{T, 𝔽} to FixedRankMatrices{𝔽, T}\nGeneralizedGrassmann{T, 𝔽, B} to GeneralizedGrassmann{𝔽, T, B}\nGeneralizedStiefel{T, 𝔽, B} to GeneralizedStiefel{𝔽, T, B}\nGrassmann{T, 𝔽, B} to Grassmann{𝔽, T, B}\nGeneralUnitaryMatrices{T, 𝔽, S} to GeneralUnitaryMatrices{𝔽, T, S}\nGraphManifold{G <: AbstractGraph, 𝔽, TM, T <: GraphManifoldType} to GraphManifold{𝔽, G <: AbstractGraph, TM, T <: GraphManifoldType}\nGrassmann{T, 𝔽} to Grassmann{𝔽, T}\nHamiltonianMatrices{T, 𝔽} to HamiltonianMatrices{𝔽, T}\nOblique{T, 𝔽, S} to Oblique{𝔽, T, S}\nSkewHermitianMatrices{T, 𝔽} to SkewHermitianMatrices{𝔽, T}\nSphere{T, 𝔽} to Sphere{𝔽, T}\nSphereSymmetricMatrices{T, 𝔽} to SphereSymmetricMatrices{𝔽, T}\nStiefel{T, 𝔽} to Stiefel{𝔽, T}\nSymmetricMatrices{T, 𝔽} to SymmetricMatrices{𝔽, T}\nSymplecticGrassmann{T, 𝔽} to SymplecticGrassmann{𝔽, T}\nSymplecticStiefel{T, 𝔽} to SymplecticStiefel{𝔽, T}\nTucker{T, D, 𝔽} to Tucker{𝔽, T, D}\nUnitaryMatrices{T, 𝔽} to UnitaryMatrices{𝔽, T}\nthe functions canoncial_project, differential_canonical_project, horizontal_lift, horizontal_component, get_total_space, and vertical_component have been moved upstream to ManifoldsBase.jl","category":"page"},{"location":"misc/NEWS/#Removed","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"the trait system that was present additionally to the wrapper types for metric, embedding and connections. Those were moved to default_X functions and the dispatch was adapted to still obtain the same logic/behaviour.\nthe QuotientManifold type, since it was not really used and its proper definition would require functionality from LieGroups.jl\nall functions related to the GroupManifolds type and corresponding traits using the old trait system have been removed here after being deprecated for a while now. These have been redesigned and introduced in the new package LieGroups.jl, see their How to transition from GroupManifolds tutorial for all details.\nall deprecated tangent vector types that had TVector in their name\ninstead of HyperboloidTVectoruseHyperboloidTangentVector\ninstead of OrthogonalTVector useOrthogonalTangentVector\ninstead of PoincareBallTVector use PoincareBallTangentVector\ninstead of PoincareHalfSpaceTVector use PoincareHalfSpaceTangentVector\ninstead of ProjectorTVector use ProjectorTangentVector\ninstead of StiefelTVector use StiefelTangentVector\ninstead of TuckerTVector use TuckerTangentVector\ninstead of UMVTVector use UMVTangentVector\nThe QuotientManifold type has been removed, the API for general (implicit) quotient manifolds is now already in ManifoldsBase.jl.\nThe  retract_exp_ode! and retract_exp_ode_fused! functions were removed. The cases in which they were correct are covered by solve_chart_exp_ode, and it was too easy to use retract_exp_ode! incorrectly.","category":"page"},{"location":"misc/NEWS/#[0.10.23](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.23)-(2025-07-19)","page":"Changelog","title":"0.10.23 (2025-07-19)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"fix a small bug in the point checks of general unitary matrices.","category":"page"},{"location":"misc/NEWS/#[0.10.22](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.22)-(2025-06-25)","page":"Changelog","title":"0.10.22 (2025-06-25)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Support for ForwardDiff.jl v1","category":"page"},{"location":"misc/NEWS/#[0.10.21](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.21)-(2025-06-24)","page":"Changelog","title":"0.10.21 (2025-06-24)","text":"","category":"section"},{"location":"misc/NEWS/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Support for ForwardDiff.jl v1","category":"page"},{"location":"misc/NEWS/#[0.10.20](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.20)-(2025-06-16)","page":"Changelog","title":"0.10.20 (2025-06-16)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fix in-place computation of exp! for GeneralLinear.","category":"page"},{"location":"misc/NEWS/#[0.10.19](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.19)-(2025-06-14)","page":"Changelog","title":"0.10.19 (2025-06-14)","text":"","category":"section"},{"location":"misc/NEWS/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"riemannian_gradient for the GeneralLinear manifold\nriemannian_gradient method for ProductManifold.","category":"page"},{"location":"misc/NEWS/#Fixed-7","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fix the projection and embedding of tangent vectors on GeneralLinear.","category":"page"},{"location":"misc/NEWS/#[0.10.18](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.18)-(2025-05-29)","page":"Changelog","title":"0.10.18 (2025-05-29)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-8","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fix the supertype of PoincareBallTangentVector to be AbstractTangentVector\nFix the supertype of StiefelTangentVector to be AbstractTangentVector\nFix riemannian_gradient for fixed rank matrices, which did not work due to a small bug in the default fallback and a missing metric specification.","category":"page"},{"location":"misc/NEWS/#[0.10.17](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.17)-(2025-04-21)","page":"Changelog","title":"0.10.17 (2025-04-21)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"deprecate GroupManifolds and its concrete subtypes as well as all functions related to Lie groups. They can now be found in the new package LieGroups.jl, see their How to transition from GroupManifolds tutorial for all details.","category":"page"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Note that while it is currently not so easy to use Manifolds.jl and LieGroups.jl together due to the common definitions that are here now deprecated, it might still take a reasonable time to do a breaking release here, since we do not have a very good reason to yet.","category":"page"},{"location":"misc/NEWS/#[0.10.16](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.16)-(2025-04-08)","page":"Changelog","title":"0.10.16 (2025-04-08)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Added all [compat] entries also for the docs/ and tutorials/ environments\nget_vector on Circle no longer returns SArray when no static arrays are passed as arguments.","category":"page"},{"location":"misc/NEWS/#Fixed-9","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"a copy pase error in the new determinant one manifold from the last release.","category":"page"},{"location":"misc/NEWS/#[0.10.15](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.15)-(2025-03-28)","page":"Changelog","title":"0.10.15 (2025-03-28)","text":"","category":"section"},{"location":"misc/NEWS/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"a DeterminantOneMatrices manifold of matrices of determinant one.","category":"page"},{"location":"misc/NEWS/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"the following internal types were renamed since their super type also uses the singular\nAbsoluteDeterminantOneMatrices to AbsoluteDeterminantOneMatrixType\nDeterminantOneMatrices to DeterminantOneMatrixType","category":"page"},{"location":"misc/NEWS/#Fixed-10","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"fix rand! to also work on the Circle(ℂ)","category":"page"},{"location":"misc/NEWS/#[0.10.14](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.14)-(-2025-02-18)","page":"Changelog","title":"0.10.14 (- 2025-02-18)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-6","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Introduced new implementation of parallel transport on Rotations(3) based on Rodrigues' rotation","category":"page"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"formula.","category":"page"},{"location":"misc/NEWS/#[0.10.13](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.13)-(-2025-02-10)","page":"Changelog","title":"0.10.13 (- 2025-02-10)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-7","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Bumped dependency of ManifoldsBase.jl to 1.0, split exp into exp (without optional argument t) and exp_fused (with argument t) and similarly retract to retract and retract_fused.\nManifoldsBase.jl 1.0 also moved from TVector to TangentVectors in type names. The following names are adapted\nRenamed HyperboloidTVector (now deprecated) to HyperboloidTangentVector\nRenamed OrthogonalTVector (now deprecated) to OrthogonalTangentVector\nRenamed PoincareBallTVector (now deprecated) to PoincareBallTangentVector\nRenamed PoincareHalfSpaceTVector (now deprecated) to PoincareHalfSpaceTangentVector\nRenamed ProjectorTVector (now deprecated) to ProjectorTangentVector\nRenamed StiefelTVector (now deprecated) to StiefelTangentVector\nRenamed TuckerTVector (now deprecated) to TuckerTangentVector\nRenamed UMVTVector (now deprecated) to UMVTangentVector\nThe internal access array_value is now called internal_value, compare to its renaming in ManifoldsBase","category":"page"},{"location":"misc/NEWS/#[0.10.12](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.12)-(-2025-01-10)","page":"Changelog","title":"0.10.12 (- 2025-01-10)","text":"","category":"section"},{"location":"misc/NEWS/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Orthonormal bases for CholeskySpace and LogCholesky metric for SymmetricPositiveDefinite.\nrand for CholeskySpace.","category":"page"},{"location":"misc/NEWS/#Changed-8","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Improved performance of selected get_vector and get_coordinates methods for complex Euclidean manifold.","category":"page"},{"location":"misc/NEWS/#[0.10.11](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.11)-(-2025-01-02)","page":"Changelog","title":"0.10.11 (- 2025-01-02)","text":"","category":"section"},{"location":"misc/NEWS/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Bases and rand for HeisenbergMatrices and InvertibleMatrices.","category":"page"},{"location":"misc/NEWS/#[0.10.10](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.10)-(-2024-12-20)","page":"Changelog","title":"0.10.10 (- 2024-12-20)","text":"","category":"section"},{"location":"misc/NEWS/#Added-7","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"the Segre manifold\nthe WarpedMetric for the Segremanifold","category":"page"},{"location":"misc/NEWS/#[0.10.9](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.9)-(-2024-12-16)","page":"Changelog","title":"0.10.9 (- 2024-12-16)","text":"","category":"section"},{"location":"misc/NEWS/#Added-8","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"the Segre manifold\nthe WarpedMetric for the Segremanifold\nThe manifold HeisenbergMatrices as the underlying manifold of HeisenbergGroup.","category":"page"},{"location":"misc/NEWS/#Changed-9","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"about.md now also lists contributors of manifolds and a very short history of the package.","category":"page"},{"location":"misc/NEWS/#[0.10.8](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.8)-(–-2024-11-27)","page":"Changelog","title":"0.10.8 (– 2024-11-27)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-10","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Some methods related to get_vector for GeneralUnitaryMatrices now have AbstractVector upper bound for coefficients.\nMinimum Julia version is now 1.10 (the LTS which replaced 1.6)\nThe dependency ManifoldDiff.jl has been upgraded from v0.3 to v0.4, to bring compatibility with DifferentiationInterface.jl.","category":"page"},{"location":"misc/NEWS/#[0.10.7](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.7)-(–-2024-11-16)","page":"Changelog","title":"0.10.7 (– 2024-11-16)","text":"","category":"section"},{"location":"misc/NEWS/#Added-9","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"adjoint_matrix for Lie groups, with optimized implementations for SO(2), SO(3), SE(2) and SE(3).","category":"page"},{"location":"misc/NEWS/#[0.10.6](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.6)-(–-2024-11-06)","page":"Changelog","title":"0.10.6 (– 2024-11-06)","text":"","category":"section"},{"location":"misc/NEWS/#Added-10","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Two new actions: ComplexPlanarRotation, QuaternionRotation.\nNew function quaternion_rotation_matrix for converting quaternions to rotation matrices.\nmake.jl script now has more command line arguments, for example --exclude-tutorials when you do not want to build the tutorials but still look at the docs. See make.jl --help for more information.","category":"page"},{"location":"misc/NEWS/#[0.10.5](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.5)-(–-2024-10-24)","page":"Changelog","title":"0.10.5 (– 2024-10-24)","text":"","category":"section"},{"location":"misc/NEWS/#Added-11","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"the manifold InvertibleMatrices of invertible matrices","category":"page"},{"location":"misc/NEWS/#Changed-11","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"rewrote the CONTRIBUTING.md and adapt it to today's links and references.","category":"page"},{"location":"misc/NEWS/#[0.10.4](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.4)-(-2024-10-20)","page":"Changelog","title":"0.10.4 (- 2024-10-20)","text":"","category":"section"},{"location":"misc/NEWS/#Added-12","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"uniform_distribution now has an error hint explaining what has to be done to make it work.\nEuclidean now follows the new has_components function from ManifoldsBase.jl (0.15.18) and can handle also the r-norms now.\nUnion type MatrixGroup\nColumnwise group action with arbitrary matrix groups\nuniform_distribution now has an error hint explaining what has to be done to make it work.\nlie_bracket is exactly zero on orthogonal Lie algebra in 2D","category":"page"},{"location":"misc/NEWS/#[0.10.3](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.3)-(-2024-10-04)","page":"Changelog","title":"0.10.3 (- 2024-10-04)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-12","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Mildly breaking: the number system parameter now corresponds to the coefficients standing in front of basis vectors in a linear combination instead of components of a vector. For example, DefaultOrthonormalBasis() == DefaultOrthonormalBasis(ℝ) of Euclidean(3, field=ℂ) now has 6 vectors, and DefaultOrthonormalBasis(ℂ) of the same manifold has 3 basis vectors.","category":"page"},{"location":"misc/NEWS/#Fixed-11","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fixed solve_exp_ode only returning the starting position (#744)\nFixed documentation of solve_exp_ode function signature (#740)","category":"page"},{"location":"misc/NEWS/#[0.10.2](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.2)-(-2024-09-24)","page":"Changelog","title":"0.10.2 (- 2024-09-24)","text":"","category":"section"},{"location":"misc/NEWS/#Added-13","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"GroupManifold can now be called with two arguments, the third one defaulting to LeftInvariantRepresentation.","category":"page"},{"location":"misc/NEWS/#Changed-13","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"fixes a few typographical errors.","category":"page"},{"location":"misc/NEWS/#[0.10.1](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.1)-(–-2024-08-29)","page":"Changelog","title":"0.10.1 (– 2024-08-29)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-14","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"identity_element on ProductManifold without RecursiveArrayTools.jl now prints a useful error message.","category":"page"},{"location":"misc/NEWS/#[0.10.0](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.10.0)-(–-2024-08-24)","page":"Changelog","title":"0.10.0 (– 2024-08-24)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-15","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Distributions.jl, RecursiveArrayTools.jl and HybridArrays.jl were moved to weak dependencies to reduce load time and improve extensibility.\ntranslate_diff, inv_diff and thus apply_diff_group, are available for all the groups with invariant tangent vector storage.\nSpecialEuclidean group now has a different default tangent vector representation, the left-invariant one; to get the old representation pass vectors=HybridTangentRepresentation() to the constructor of SpecialEuclidean.\nadjoint_action takes a direction argument; by default it is LeftAction.\nadjoint_action! is the necessary method to implement in groups with left-invariant tangent vector representation.\nFixed a few typos in the doc string of the SPD fixed determinant description.\nRandom point on the MultinomialSymmetricPositiveDefinite manifold was improved to make it more robust.","category":"page"},{"location":"misc/NEWS/#Added-14","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Introduced exp_inv and log_inv based on exp_lie and log_lie. They are invariant to the group operation.\nA tutorial about usage of group-related functionality.","category":"page"},{"location":"misc/NEWS/#Removed-2","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Deprecated bindings:\nExtrinsicEstimation() (should be replaced with ExtrinsicEstimation(EfficientEstimator())),\nSymplectic (renamed to SymplecticMatrices),\nSymplecticMatrix (renamed to SymplecticElement).\nAbstractEstimationMethod (renamed to AbstractApproximationMethod).\nVectorBundleVectorTransport (renamed to FiberBundleProductVectorTransport).\nrand on SymplecticMatrices and SymplecticStiefel no longer accepts hamiltonian_norm as an alias for σ.\nmean! and median! no longer accept extrinsic_method (should be replaced with e = ExtrinsicEstimation(extrinsic_method)).\nAs a result of making Distributions.jl and RecursiveArrayTools.jl weak dependencies the following symbols are no longer exported from Manifolds.jl. Essential functionality is still available but distribution-related features may change in the future without a breaking release.\nArrayPartition (RecursiveArrayTools.jl needs to be explicitly imported),\nProjectedPointDistribution (not exported),\nnormal_tvector_distribution (not exported),\nprojected_distribution (not exported),\nuniform_distribution (not exported).\nAbility to create non-real SymplecticStiefel and SymplecticGrassmann manifolds; essential functionality was missing so it was removed until a more developed version is developed.","category":"page"},{"location":"misc/NEWS/#[0.9.20](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.20)-(–-2024-06-17)","page":"Changelog","title":"0.9.20 (– 2024-06-17)","text":"","category":"section"},{"location":"misc/NEWS/#Added-15","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"implemented parallel transport on the Grassmann manifold with respect to Stiefel representation","category":"page"},{"location":"misc/NEWS/#Changed-16","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"since now all exp/log/parallel transport are available for all representations of Grassmann, these are now also set as defaults, since they are more exact.","category":"page"},{"location":"misc/NEWS/#[0.9.19](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.19)-(–-2024-06-12)","page":"Changelog","title":"0.9.19 (– 2024-06-12)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-17","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Updated Project.toml compatibility entries.\nUpdated CI for Julia 1.11-beta","category":"page"},{"location":"misc/NEWS/#Fixed-12","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"a few typos in the doc string of the SPD fixed determinant description\nseveral other typographical errors throughout the documentation","category":"page"},{"location":"misc/NEWS/#[0.9.18](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.18)-(–-2024-05-07)","page":"Changelog","title":"0.9.18 (– 2024-05-07)","text":"","category":"section"},{"location":"misc/NEWS/#Added-16","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"added the injectivity radius for the Stiefel manifold with Euclidean metric","category":"page"},{"location":"misc/NEWS/#[0.9.17](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.17)-(–-2024-04-23)","page":"Changelog","title":"0.9.17 (– 2024-04-23)","text":"","category":"section"},{"location":"misc/NEWS/#Added-17","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Hyperrectangle manifold with boundary.","category":"page"},{"location":"misc/NEWS/#[0.9.16](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.16)-(–-2024-04-01)","page":"Changelog","title":"0.9.16 (– 2024-04-01)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-18","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"NonlinearSolve.jl and PythonCall.jl are no longer an upper bounded dependency (bugs were fixed).","category":"page"},{"location":"misc/NEWS/#[0.9.15](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.15)-(–-2024-03-24)","page":"Changelog","title":"0.9.15 (– 2024-03-24)","text":"","category":"section"},{"location":"misc/NEWS/#Added-18","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"using DocumenterInterLinks for links to other Julia packages documentation.\nImplementation of sectional_curvature, sectional_curvature_min and sectional_curvature_max for several manifolds.\nsectional_curvature_matrix function and a tutorial on coordinate-free curvature.","category":"page"},{"location":"misc/NEWS/#Changed-19","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"default_vector_transport_method for GeneralUnitaryMatrices other than Rotations was changed to ProjectionTransport.","category":"page"},{"location":"misc/NEWS/#Fixed-13","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"typographical errors in tutorials/working-in-charts.jl.\nseveral typographical errors in the docs\nunifies to use two backticks `` for math instead of $ further in the docs","category":"page"},{"location":"misc/NEWS/#[0.9.14](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.14)-(–-2024-01-31)","page":"Changelog","title":"0.9.14 (– 2024-01-31)","text":"","category":"section"},{"location":"misc/NEWS/#Added-19","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"rand on UnitaryMatrices\nrand on arbitrary GroupManifolds and manifolds with IsGroupManifold trait generating points and elements from the Lie algebra, respectively","category":"page"},{"location":"misc/NEWS/#[0.9.13](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.13)-(–-2024-01-24)","page":"Changelog","title":"0.9.13 (– 2024-01-24)","text":"","category":"section"},{"location":"misc/NEWS/#Added-20","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"added the real symplectic Grassmann manifold SymplecticGrassmann\nIntroduce the manifold of HamiltonianMatrices and a wrapper for Hamiltonian matrices\nintroduce rand(:HamiltonianMatrices)\nextend rand to also rand! for HamiltonianMatrices, SymplecticMatrices and SymplecticStiefel\nimplement riemannian_gradient conversion for SymplecticMatrices and SymplecticGrassmann\nthe new manifold of MultinomialSymmetricPositiveDefinite matrices\nrand! for MultinomialDoublyStochastic and MultinomialSymmetric","category":"page"},{"location":"misc/NEWS/#Deprecated","page":"Changelog","title":"Deprecated","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Rename Symplectic to SimplecticMatrices in order to have a Symplectic wrapper for such matrices as well in the future for the next breaking change.\nRename SymplecticMatrix to SymplecticElement to clarify that it is the special matrix J_2n and not an arbitrary symplectic matrix.","category":"page"},{"location":"misc/NEWS/#Fixed-14","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"a bug that cause project for tangent vectors to return wrong results on MultinomialDoublyStochastic","category":"page"},{"location":"misc/NEWS/#[0.9.12](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.12)-(–-2024-01-21)","page":"Changelog","title":"0.9.12 (– 2024-01-21)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-15","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fixed var on TranslationGroup.","category":"page"},{"location":"misc/NEWS/#[0.9.11](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.11)-(–-2023-12-27)","page":"Changelog","title":"0.9.11 (– 2023-12-27)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-16","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fixed mixed array index number in-place parallel_transport_to! on zero-index Euclidean, on Julia 1.6.","category":"page"},{"location":"misc/NEWS/#[0.9.10](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.10)-(–-2023-12-27)","page":"Changelog","title":"0.9.10 (– 2023-12-27)","text":"","category":"section"},{"location":"misc/NEWS/#Added-21","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Compatibility with RecursiveArrayTools v3.","category":"page"},{"location":"misc/NEWS/#Fixed-17","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fixed mixed array index number in-place parallel_transport_to! on real Circle, on Julia 1.6.\nViolations of MD004 lint rule in this file.","category":"page"},{"location":"misc/NEWS/#[0.9.9](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.9)-(–-2023-12-25)","page":"Changelog","title":"0.9.9 (– 2023-12-25)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-18","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"introduced a nonzero atol for all point and vector checks that compre to zero. This makes those checks a bit more relaxed by default and resolves #630.\ndefault_estimation_method(M, f) is deprecated, use default_approximation_method(M, f) for your specific method f on the manifold M.\nAbstractEstimationMethod is deprecated, use AbstractApproximationMethod instead.","category":"page"},{"location":"misc/NEWS/#[0.9.8](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.8)-(-2023-11-17)","page":"Changelog","title":"0.9.8 (- 2023-11-17)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-19","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Improved distribution of random vector generation for rotation matrices and complex circle.","category":"page"},{"location":"misc/NEWS/#[0.9.7](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.7)-(–-2023-11-14)","page":"Changelog","title":"0.9.7 (– 2023-11-14)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-20","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fixed is_flat for CholeskySpace and SymmetricPositiveDefinite with LogCholeskyMetric https://github.com/JuliaManifolds/Manifolds.jl/issues/684.","category":"page"},{"location":"misc/NEWS/#[0.9.6](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.6)-(-2023-11-09)","page":"Changelog","title":"0.9.6 (- 2023-11-09)","text":"","category":"section"},{"location":"misc/NEWS/#Fixed-21","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fixed real coefficient basis for complex circle (an issue exposed by https://github.com/JuliaManifolds/ManifoldsBase.jl/pull/173).\nFixed VeeOrthogonalBasis test for non-real manifolds.","category":"page"},{"location":"misc/NEWS/#[0.9.5](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.5)-(-2023-11-08)","page":"Changelog","title":"0.9.5 (- 2023-11-08)","text":"","category":"section"},{"location":"misc/NEWS/#Changed-20","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"identity_element now returns a complex matrix for unitary group.\nnumber_of_coordinates is now exported.","category":"page"},{"location":"misc/NEWS/#[0.9.4](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.4)-(-2023-11-06)","page":"Changelog","title":"0.9.4 (- 2023-11-06)","text":"","category":"section"},{"location":"misc/NEWS/#Added-22","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Functions inv_diff, inv_diff!, adjoint_inv_diff and adjoint_inv_diff! that correspond to differentials and pullbacks of group inversion.\nJulia 1.10-rc CI workflow.","category":"page"},{"location":"misc/NEWS/#Changed-21","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Documentation project files are marked as compatible with BoundaryValueDiffEq v5.","category":"page"},{"location":"misc/NEWS/#Fixed-22","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Fixed issue with incorrect implementation of apply_diff_group in GroupOperationAction with left backward and right forward action #669.","category":"page"},{"location":"misc/NEWS/#[0.9.3](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.3)-(-2023-10-28)","page":"Changelog","title":"0.9.3 (- 2023-10-28)","text":"","category":"section"},{"location":"misc/NEWS/#Added-23","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Support for BoundaryValueDiffEq v5.","category":"page"},{"location":"misc/NEWS/#[0.9.2](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.2)-(-2023-10-27)","page":"Changelog","title":"0.9.2 (- 2023-10-27)","text":"","category":"section"},{"location":"misc/NEWS/#Added-24","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"rand(G; vector_at=Identity(G)) now works for translation, special orthogonal and special Euclidean groups G (issue #665).\nget_embedding now works for GeneralUnitaryMultiplicationGroup.\nGithub action that checks for NEWS.md changes.","category":"page"},{"location":"misc/NEWS/#[0.9.1](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.1)-(-2023-10-25)","page":"Changelog","title":"0.9.1 (- 2023-10-25)","text":"","category":"section"},{"location":"misc/NEWS/#Added-25","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"a new retraction and its inverse for the fixed Rank Manifolds, the orthographic retraction.","category":"page"},{"location":"misc/NEWS/#[0.9.0](https://github.com/JuliaManifolds/Manifolds.jl/releases/tag/v0.9.0)-(-2023-10-24)","page":"Changelog","title":"0.9.0 (- 2023-10-24)","text":"","category":"section"},{"location":"misc/NEWS/#Added-26","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Vector bundles are generalized to fiber bundles. Old BundleFibers functionality was reworked to better match mathematical abstractions. Fiber bundle functionality is experimental and minor changes may happen without a breaking release, with the exception of TangentBundle which is considered to be stable.\nRotationTranslationAction is introduced.","category":"page"},{"location":"misc/NEWS/#Changed-22","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"Sizes of all manifolds can now be either encoded in type or stored in a field to avoid over-specialization. The default is set to store the size in type parameter (except for PowerManifold and its variants), replicating the previous behavior. For field storage, pass the parameter=:field keyword argument to manifold constructor. For example statically sized CenteredMatrices{m,n} is now CenteredMatrices{TypeParameter{Tuple{m,n}}}, whereas the type of special Euclidean group with field-stored size is CenteredMatrices{Tuple{Int,Int}}. Similar change applies to:\nCenteredMatrices{m,n},\nCholeskySpace{N},\nElliptope{N,K},\nEuclidean,\nFixedRankMatrices{m,n,k},\nKendallsPreShapeSpace{n,k},\nKendallsShapeSpace{n,k},\nGeneralLinear{n},\nGeneralUnitaryMultiplicationGroup{n},\nGeneralizedGrassmann{n,k},\nGeneralizedStiefel{n,k},\nGrassmann{n,k},\nHeisenberg{n},\nHyperbolic{n},\nMultinomialMatrices{N,M},\nMultinomialDoublyStochastic{n},\nMultinomialSymmetric{n},\nOrthogonal{n},\nPowerManifold,\nPositiveArrays,\nPositiveMatrices,\nPositiveNumbers,\nProbabilitySimplex{n},\nSPDFixedDeterminant{n},\nSpecialLinear{n},\nSpecialOrthogonal{n},\nSpecialUnitary{n},\nSpecialEuclidean{n},\nSpecialEuclideanManifold{n},\nSpectrahedron{n,k},\nSphereSymmetricMatrices{N},\nStiefel{n,k},\nSymmetricMatrices{N},\nSymmetricPositiveDefinite{n},\nSymmetricPositiveSemidefiniteFixedRank{n,k},\nSymplectic{n},\nSymplecticStiefel{n,k},\nTranslationGroup,\nTucker.\nFor example\nfunction Base.show(io::IO, ::CenteredMatrices{m,n}) where {m,n}\n    return print(io, \"CenteredMatrices($m, $n)\")\nend\nneeds to be replaced with\nfunction Base.show(io::IO, ::CenteredMatrices{TypeParameter{Tuple{m,n}}}) where {m,n}\n    return print(io, \"CenteredMatrices($m, $n)\")\nend\nfor statically-sized groups and\nfunction Base.show(io::IO, M::CenteredMatrices{Tuple{Int,Int}})\n    m, n = get_parameter(M.size)\n    return print(io, \"CenteredMatrices($m, $n; parameter=:field)\")\nend\nfor groups with size stored in field. Alternatively, you can use a single generic method like this:\nfunction Base.show(io::IO, M::CenteredMatrices{T}) where {T}\n    m, n = get_parameter(M)\n    if T <: TypeParameter\n        return print(io, \"CenteredMatrices($m, $n)\")\n    else\n        return print(io, \"CenteredMatrices($m, $n; parameter=:field)\")\n    end\nend\nArgument order for type aliases RotationActionOnVector and RotationTranslationActionOnVector: most often dispatched on argument is now first.\nA more consistent handling of action direction was introduced. 4-valued ActionDirection was split into 2-valued ActionDirection (either left or right action) and GroupActionSide (action acting from the left or right side). See https://github.com/JuliaManifolds/Manifolds.jl/issues/637 for a design discussion.","category":"page"},{"location":"misc/NEWS/#Removed-3","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"misc/NEWS/","page":"Changelog","title":"Changelog","text":"ProductRepr is removed; please use ArrayPartition instead.\nDefault methods throwing \"not implemented\" ErrorException for some group-related operations. Standard MethodError is now thrown instead.\nLinearAffineMetric was deprecated in a previous release and the symbol is now removed. Please use AffineInvariantMetric instead.","category":"page"},{"location":"manifolds/multinomialdoublystochastic/#Multinomial-doubly-stochastic-matrices","page":"Multinomial doubly stochastic matrices","title":"Multinomial doubly stochastic matrices","text":"","category":"section"},{"location":"manifolds/multinomialdoublystochastic/#Manifolds.AbstractMultinomialDoublyStochastic","page":"Multinomial doubly stochastic matrices","title":"Manifolds.AbstractMultinomialDoublyStochastic","text":"AbstractMultinomialDoublyStochastic <: AbstractDecoratorManifold{ℝ}\n\nA common type for manifolds that are doubly stochastic, for example by direct constraint MultinomialDoubleStochastic or by symmetry MultinomialSymmetric, or additionally by symmetric positive definiteness MultinomialSymmetricPositiveDefinite as long as they are also modeled as IsometricallyEmbeddedManifoldType.\n\nThat way they share the inner product (just by restriction), and even the Riemannian gradient\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialdoublystochastic/#Manifolds.MultinomialDoubleStochastic","page":"Multinomial doubly stochastic matrices","title":"Manifolds.MultinomialDoubleStochastic","text":"MultinomialDoublyStochastic{T} <: AbstractMultinomialDoublyStochastic\n\nThe set of doubly stochastic multinomial matrices consists of all nn matrices with stochastic columns and rows, i.e.\n\nbeginaligned\nmathcalDP(n) coloneqq biglp  ℝ^nn big p_ij  0 text for all  i=1n j=1m\n pmathbf1_n = p^mathrmTmathbf1_n = mathbf1_n\nbigr\nendaligned\n\nwhere mathbf1_n is the vector of length n containing ones.\n\nThe tangent space can be written as\n\nT_pmathcalDP(n) coloneqq bigl\nX  ℝ^nn big X = X^mathrmT text and \nXmathbf1_n = X^mathrmTmathbf1_n = mathbf0_n\nbigr\n\nwhere mathbf0_n is the vector of length n containing zeros.\n\nMore details can be found in Section III [DH19].\n\nConstructor\n\nMultinomialDoubleStochastic(n::Int; parameter::Symbol=:type)\n\nGenerate the manifold of matrices ℝ^nn that are doubly stochastic and symmetric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialdoublystochastic/#Base.rand-Tuple{MultinomialDoubleStochastic}","page":"Multinomial doubly stochastic matrices","title":"Base.rand","text":"rand(::MultinomialDoubleStochastic; vector_at=nothing, σ::Real=1.0, kwargs...)\n\nGenerate random points on the MultinomialDoubleStochastic manifold or tangent vectors at the point vector_at if that is not nothing.\n\nLet nn denote the matrix dimension of the MultinomialDoubleStochastic.\n\nWhen vector_at is nothing, this is done by generating a random matrixrand(n,n) with positive entries and projecting it onto the manifold. The kwargs... are passed to this projection.\n\nWhen vector_at is not nothing, a random matrix in the ambient space is generated and projected onto the tangent space\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldDiff.riemannian_gradient-Tuple{Manifolds.AbstractMultinomialDoublyStochastic, Any, Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldDiff.riemannian_gradient","text":"riemannian_gradient(M::AbstractMultinomialDoublyStochastic, p, Y; kwargs...)\n\nLet Y denote the Euclidean gradient of a function tilde f defined in the embedding neighborhood of M, then the Riemannian gradient is given by Lemma 1 [DH19] as\n\n  operatornamegrad f(p) = proj_T_pmathcal M(Yp)\n\nwhere  denotes the Hadamard or elementwise product, and the projection is the projection onto the tangent space of the corresponding manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.check_point-Tuple{MultinomialDoubleStochastic, Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.check_point","text":"check_point(M::MultinomialDoubleStochastic, p)\n\nChecks whether p is a valid point on the MultinomialDoubleStochastic(n) M, i.e. is a  matrix with positive entries whose rows and columns sum to one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.check_vector-Tuple{MultinomialDoubleStochastic, Any, Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::MultinomialDoubleStochastic p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialDoubleStochastic M. This means, that p is valid, that X is of correct dimension and sums to zero along any column or row.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.is_flat-Tuple{MultinomialDoubleStochastic}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::MultinomialDoubleStochastic)\n\nReturn false. MultinomialDoubleStochastic is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.manifold_dimension-Tuple{MultinomialDoubleStochastic}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::MultinomialDoubleStochastic)\n\nreturns the dimension of the MultinomialDoubleStochastic manifold namely\n\noperatornamedim_mathcalDP(n) = (n-1)^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.project-Tuple{Manifolds.AbstractMultinomialDoublyStochastic, Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.project","text":"project(\n    M::AbstractMultinomialDoublyStochastic,\n    p;\n    maxiter = 100,\n    tolerance = eps(eltype(p))\n)\n\nproject a matrix p with positive entries applying Sinkhorn's algorithm. Note that this project method – different from the usual case, accepts keywords.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.project-Tuple{MultinomialDoubleStochastic, Any, Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.project","text":"project(M::MultinomialDoubleStochastic, p, Y)\n\nProject Y onto the tangent space at p on the MultinomialDoubleStochastic M, return the result in X. The formula reads\n\n    operatornameproj_p(Y) = Y - (αmathbf1_n^mathrmT + mathbf1_nβ^mathrmT)  p\n\nwhere  denotes the Hadamard or elementwise product and mathbb1_n is the vector of length n containing ones. The two vectors αβ  ℝ^nn are computed as a solution (typically using the left pseudo inverse) of\n\n    beginpmatrix I_n  pp^mathrmT  I_n endpmatrix\n    beginpmatrix α βendpmatrix\n    =\n    beginpmatrix Ymathbf1Y^mathrmTmathbf1endpmatrix\n\nwhere I_n is the nn unit matrix and mathbf1_n is the vector of length n containing ones.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.representation_size-Tuple{Manifolds.AbstractMultinomialDoublyStochastic}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractMultinomialDoublyStochastic)\n\nreturn the representation size of doubly stochastic matrices, which are embedded in the ℝ^nn matrices and hence the answer here is ``\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#ManifoldsBase.retract-Tuple{MultinomialDoubleStochastic, Any, Any, ProjectionRetraction}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.retract","text":"retract(M::MultinomialDoubleStochastic, p, X, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting podotexp(Xp) back onto the manifold, where  are elementwise multiplication and division, respectively. Similarly, exp refers to the elementwise exponentiation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic/#Literature","page":"Multinomial doubly stochastic matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/multinomialdoublystochastic/","page":"Multinomial doubly stochastic matrices","title":"Multinomial doubly stochastic matrices","text":"A. Douik and B. Hassibi. Manifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry. IEEE Transactions on Signal Processing 67, 5761–5774 (2019), arXiv:1802.02628.\n\n\n\n","category":"page"},{"location":"manifolds/product/#ProductManifoldSection","page":"Product manifold","title":"Product manifold","text":"","category":"section"},{"location":"manifolds/product/","page":"Product manifold","title":"Product manifold","text":"Product manifold mathcal M = mathcalM_1  mathcalM_2    mathcalM_n of manifolds mathcalM_1 mathcalM_2  mathcalM_n. Points on the product manifold can be constructed using ArrayPartition (from RecursiveArrayTools.jl) with canonical projections Π_i  mathcalM  mathcalM_i for i  1 2  n provided by submanifold_component.","category":"page"},{"location":"manifolds/product/#ManifoldDiff.riemannian_Hessian-Tuple{ProductManifold, Vararg{Any, 4}}","page":"Product manifold","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::ProductManifold, p, G, H, X)\nriemannian_Hessian!(M::ProductManifold, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nOn a product manifold, this decouples and can be computed elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product/#Manifolds.flat-Tuple{ProductManifold, Vararg{Any}}","page":"Product manifold","title":"Manifolds.flat","text":"flat(M::ProductManifold, p, X::FVector{TangentSpaceType})\n\nuse the musical isomorphism to transform the tangent vector X from the tangent space at p on the ProductManifold M to a cotangent vector. This can be done elementwise for every entry of X (with respect to the corresponding entry in p) separately.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product/#Manifolds.manifold_volume-Tuple{ProductManifold}","page":"Product manifold","title":"Manifolds.manifold_volume","text":"manifold_volume(M::ProductManifold)\n\nReturn the volume of ProductManifold M, i.e. product of volumes of the manifolds M is constructed from.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product/#Manifolds.sharp-Tuple{ProductManifold, Vararg{Any}}","page":"Product manifold","title":"Manifolds.sharp","text":"sharp(M::ProductManifold, p, ξ::FVector{CotangentSpaceType})\n\nUse the musical isomorphism to transform the cotangent vector ξ from the tangent space at p on the ProductManifold M to a tangent vector. This can be done elementwise for every entry of ξ (and p) separately\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product/#Manifolds.volume_density-Tuple{ProductManifold, Any, Any}","page":"Product manifold","title":"Manifolds.volume_density","text":"volume_density(M::ProductManifold, p, X)\n\nReturn volume density on the ProductManifold M, i.e. product of constituent volume densities.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spdfixeddeterminant/#SPDFixedDeterminantSection","page":"SPD, fixed determinant","title":"Symmetric positive definite matrices of fixed determinant","text":"","category":"section"},{"location":"manifolds/spdfixeddeterminant/#Manifolds.SPDFixedDeterminant","page":"SPD, fixed determinant","title":"Manifolds.SPDFixedDeterminant","text":"SPDFixedDeterminant{T,D} <: AbstractDecoratorManifold{ℝ}\n\nThe manifold of symmetric positive definite matrices of fixed determinant d  0, i.e.\n\nmathcal P_d(n) =\nbigl\np  ℝ^nn  big a^mathrmTpa  0 text for all  a  ℝ^nbackslash0\n  text and  det(p) = d\nbigr\n\nThis manifold is modelled as a submanifold of SymmetricPositiveDefinite(n), see EmbeddedSubmanifoldType for the implications, but for example retractions and inverse retractions are all available\n\nThese matrices are sometimes also called isochoric, which refers to the interpretation of the matrix representing an ellipsoid. All ellipsoids that represent points on this manifold have the same volume.\n\nThe tangent space is modelled the same as for SymmetricPositiveDefinite(n) and consists of all symmetric matrices with zero trace\n\n    T_pmathcal P_d(n) =\n    bigl\n        X in mathbb R^nn big X=X^mathrmT text and  operatornametr(X) = 0\n    bigr\n\nsince for a constant determinant we require that 0 = Ddet(p)Z = det(p)operatornametr(p^-1Z) for all tangent vectors Z. Additionally we store the tangent vectors as X=p^-1Z, i.e. symmetric matrices.\n\nConstructor\n\nSPDFixedDeterminant(n::Int, d::Real=1.0; parameter::Symbol=:type)\n\nGenerate the manifold mathcal P_d(n) subset mathcal P(n) of determinant d, which defaults to 1.0.\n\nparameter: whether a type parameter should be used to store n. By default size is stored in type. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spdfixeddeterminant/","page":"SPD, fixed determinant","title":"SPD, fixed determinant","text":"This manifold can is a submanifold of the symmetric positive definite matrices and hence inherits most properties therefrom.","category":"page"},{"location":"manifolds/spdfixeddeterminant/","page":"SPD, fixed determinant","title":"SPD, fixed determinant","text":"The differences are the functions","category":"page"},{"location":"manifolds/spdfixeddeterminant/#ManifoldsBase.check_point-Tuple{SPDFixedDeterminant, Any}","page":"SPD, fixed determinant","title":"ManifoldsBase.check_point","text":"check_point(M::SPDFixedDeterminant, p; kwargs...)\n\nCheck whether p is a valid manifold point on the SPDFixedDeterminant(n,d) M, i.e. whether p is a SymmetricPositiveDefinite matrix of size (n, n)\n\nwith determinant det(p) =M.d.\n\nThe tolerance for the determinant of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spdfixeddeterminant/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{SPDFixedDeterminant, Any, T}} where T","page":"SPD, fixed determinant","title":"ManifoldsBase.check_vector","text":"check_vector(M::SPDFixedDeterminant, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SPDFixedDeterminant M, i.e. X has to be a tangent vector on SymmetricPositiveDefinite, so a symmetric matrix, and additionally fulfill operatornametr(X) = 0.\n\nThe tolerance for the trace check of X can be set using kwargs..., which influences the isapprox-check.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spdfixeddeterminant/#ManifoldsBase.project-Tuple{SPDFixedDeterminant, Any, Any}","page":"SPD, fixed determinant","title":"ManifoldsBase.project","text":"Y = project(M::SPDFixedDeterminant, p, X)\nproject!(M::SPDFixedDeterminant, Y, p, X)\n\nProject the symmetric matrix X onto the tangent space at p of the (sub-)manifold of s.p.d. matrices of determinant M.d (in place of Y), by setting its diagonal (and hence its trace) to zero.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spdfixeddeterminant/#ManifoldsBase.project-Tuple{SPDFixedDeterminant, Any}","page":"SPD, fixed determinant","title":"ManifoldsBase.project","text":"q = project(M::SPDFixedDeterminant, p)\nproject!(M::SPDFixedDeterminant, q, p)\n\nProject the symmetric positive definite (s.p.d.) matrix p from the embedding onto the (sub-)manifold of s.p.d. matrices of determinant M.d (in place of q).\n\nThe formula reads\n\nq = Bigl(fracddet(p)Bigr)^frac1np\n\n\n\n\n\n","category":"method"},{"location":"features/distributions/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"features/distributions/","page":"Distributions","title":"Distributions","text":"The following functions and types provide support for manifold-valued and tangent space-valued distributions:","category":"page"},{"location":"manifolds/fixedrankmatrices/#FixedRankMatrices","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"","category":"section"},{"location":"manifolds/fixedrankmatrices/#Manifolds.FixedRankMatrices","page":"Fixed-rank matrices","title":"Manifolds.FixedRankMatrices","text":"FixedRankMatrices{𝔽, T} <: AbstractDecoratorManifold{𝔽}\n\nThe manifold of mn real-valued or complex-valued matrices of fixed rank k, i.e.\n\nbigl p  𝔽^mn big operatornamerank(p) = kbigr\n\nwhere 𝔽  ℝℂ and the rank is the number of linearly independent columns of a matrix.\n\nRepresentation with 3 matrix factors\n\nA point p  mathcal M can be stored using unitary matrices U  𝔽^mk, V  𝔽^nk as well as the k singular values of p = U_p S V_p^mathrmH, where ^mathrmH denotes the complex conjugate transpose or Hermitian. In other words, U and V are from the manifolds Stiefel(m,k,𝔽) and Stiefel(n,k,𝔽), respectively; see SVDMPoint for details.\n\nThe tangent space T_p mathcal M at a point p  mathcal M with p=U_p S V_p^mathrmH is given by\n\nT_pmathcal M = bigl U_p M V_p^mathrmH + U_X V_p^mathrmH + U_p V_X^mathrmH \n    M   𝔽^kk\n    U_X   𝔽^mk\n    V_X   𝔽^nk\n    text st \n    U_p^mathrmHU_X = 0_k\n    V_p^mathrmHV_X = 0_k\nbigr\n\nwhere 0_k is the kk zero matrix. See UMVTangentVector for details.\n\nThe (default) metric of this manifold is obtained by restricting the metric on ℝ^mn to the tangent bundle [Van13].\n\nConstructor\n\nFixedRankMatrices(m, n, k[, field=ℝ])\n\nGenerate the manifold of m-by-n (field-valued) matrices of rank k.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices/#Manifolds.OrthographicInverseRetraction","page":"Fixed-rank matrices","title":"Manifolds.OrthographicInverseRetraction","text":"OrthographicInverseRetraction <: AbstractInverseRetractionMethod\n\nRetractions that are related to orthographic projections, which was first used in [AM12].\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices/#Manifolds.OrthographicRetraction","page":"Fixed-rank matrices","title":"Manifolds.OrthographicRetraction","text":"OrthographicRetraction <: AbstractRetractionMethod\n\nRetractions that are related to orthographic projections, which was first used in [AM12].\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices/#Manifolds.SVDMPoint","page":"Fixed-rank matrices","title":"Manifolds.SVDMPoint","text":"SVDMPoint <: AbstractManifoldPoint\n\nA point on a certain manifold, where the data is stored in a svd like fashion, i.e. in the form USV^mathrmH, where this structure stores U, S and V^mathrmH. The storage might also be shortened to just k singular values and accordingly shortened U (columns) and V^mathrmH (rows).\n\nConstructors\n\nSVDMPoint(A) for a matrix A, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(S) for an SVD object, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(U,S,Vt) for the svd factors to initialize the SVDMPoint(i.e. implicitlyk=\\min\\{m,n\\}`)\nSVDMPoint(A,k) for a matrix A, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(S,k) for an SVD object, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(U,S,Vt,k) for the svd factors to initialize the SVDMPoint, stores its svd factors shortened to the best rank k approximation\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices/#Manifolds.UMVTangentVector","page":"Fixed-rank matrices","title":"Manifolds.UMVTangentVector","text":"UMVTangentVector <: AbstractTangentVector\n\nA tangent vector that can be described as a product U_p M V_p^mathrmH + U_X V_p^mathrmH + U_p V_X^mathrmH, where X = U_X S V_X^mathrmH is its base point, see for example FixedRankMatrices.\n\nThe base point p is required for example embedding this point, but it is not stored. The fields of thie tangent vector are U for U_X, M and Vt to store V_X^mathrmH\n\nConstructors\n\nUMVTangentVector(U,M,Vt) store umv factors to initialize the UMVTangentVector\nUMVTangentVector(U,M,Vt,k) store the umv factors after shortening them down to inner dimensions k.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices/#Base.rand-Tuple{FixedRankMatrices}","page":"Fixed-rank matrices","title":"Base.rand","text":"Random.rand(M::FixedRankMatrices; vector_at=nothing, kwargs...)\n\nIf vector_at is nothing, return a random point on the FixedRankMatrices manifold. The orthogonal matrices are sampled from the Stiefel manifold and the singular values are sampled uniformly at random.\n\nIf vector_at is not nothing, generate a random tangent vector in the tangent space of the point vector_at on the FixedRankMatrices manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldDiff.riemannian_Hessian-Tuple{FixedRankMatrices, Vararg{Any, 4}}","page":"Fixed-rank matrices","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::FixedRankMatrices, p, G, H, X)\nriemannian_Hessian!(M::FixedRankMatrices, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nThe Riemannian Hessian can be computed as stated in Remark 4.1 [Ngu23] or Section 2.3 [Van13], that B. Vandereycken adopted for Manopt (Matlab).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#Manifolds.inverse_retract_orthographic!-Tuple{AbstractManifold, Any, Any, Any}","page":"Fixed-rank matrices","title":"Manifolds.inverse_retract_orthographic!","text":"inverse_retract_orthographic!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the OrthographicInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#Manifolds.retract_orthographic!-Tuple{AbstractManifold, Any, Any, Any}","page":"Fixed-rank matrices","title":"Manifolds.retract_orthographic!","text":"retract_orthographic!(M::AbstractManifold, q, p, X)\n\nCompute the in-place variant of the OrthographicRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.check_point-Tuple{FixedRankMatrices, Any}","page":"Fixed-rank matrices","title":"ManifoldsBase.check_point","text":"check_point(M::FixedRankMatrices, p; kwargs...)\n\nCheck whether the matrix or SVDMPoint x ids a valid point on the FixedRankMatrices M, i.e. is an m-byn matrix of rank k. For the SVDMPoint the internal representation also has to have the right shape, i.e. p.U and p.Vt have to be unitary. The keyword arguments are passed to the rank function that verifies the rank of p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.check_vector-Tuple{FixedRankMatrices, SVDMPoint, UMVTangentVector}","page":"Fixed-rank matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M:FixedRankMatrices, p, X; kwargs...)\n\nCheck whether the tangent UMVTangentVector X is from the tangent space of the SVDMPoint p on the FixedRankMatrices M, i.e. that v.U and v.Vt are (columnwise) orthogonal to x.U and x.Vt, respectively, and its dimensions are consistent with p and X.M, i.e. correspond to m-by-n matrices of rank k.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.default_inverse_retraction_method-Tuple{FixedRankMatrices}","page":"Fixed-rank matrices","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::FixedRankMatrices)\n\nReturn PolarInverseRetraction as the default inverse retraction for the FixedRankMatrices manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.default_retraction_method-Tuple{FixedRankMatrices}","page":"Fixed-rank matrices","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::FixedRankMatrices)\n\nReturn PolarRetraction as the default retraction for the FixedRankMatrices manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.default_vector_transport_method-Tuple{FixedRankMatrices}","page":"Fixed-rank matrices","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::FixedRankMatrices)\n\nReturn the ProjectionTransport as the default vector transport method for the FixedRankMatrices manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.embed-Tuple{FixedRankMatrices, SVDMPoint, UMVTangentVector}","page":"Fixed-rank matrices","title":"ManifoldsBase.embed","text":"embed(M::FixedRankMatrices, p, X)\n\nEmbed the tangent vector X at point p in M from its UMVTangentVector representation  into the set of mn matrices.\n\nThe formula reads\n\nU_pMV_p^mathrmH + U_XV_p^mathrmH + U_pV_X^mathrmH\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.embed-Tuple{FixedRankMatrices, SVDMPoint}","page":"Fixed-rank matrices","title":"ManifoldsBase.embed","text":"embed(::FixedRankMatrices, p::SVDMPoint)\n\nEmbed the point p from its SVDMPoint representation into the set of mn matrices by computing USV^mathrmH.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.injectivity_radius-Tuple{FixedRankMatrices}","page":"Fixed-rank matrices","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(::FixedRankMatrices)\n\nReturn the incjectivity radius of the manifold of FixedRankMatrices, i.e. 0. See [HU17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.inner-Tuple{FixedRankMatrices, SVDMPoint, UMVTangentVector, UMVTangentVector}","page":"Fixed-rank matrices","title":"ManifoldsBase.inner","text":"inner(M::FixedRankMatrices, p::SVDMPoint, X::UMVTangentVector, Y::UMVTangentVector)\n\nCompute the inner product of X and Y in the tangent space of p on the FixedRankMatrices M, which is inherited from the embedding, i.e. can be computed using dot on the elements (U, Vt, M) of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.inverse_retract-Tuple{FixedRankMatrices, Any, Any, OrthographicInverseRetraction}","page":"Fixed-rank matrices","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, p, q, ::OrthographicInverseRetraction)\n\nCompute the orthographic inverse retraction FixedRankMatrices M by computing\n\n    X = P_T_pM(q - p) = qVV^mathrmT + UU^mathrmTq - UU^mathrmTqVV^mathrmT - p\n\nwhere p is a SVDMPoint(U,S,Vt) and P_T_pM is the projection onto the tangent space at p.\n\nFor more details, see [AO14].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.is_flat-Tuple{FixedRankMatrices}","page":"Fixed-rank matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::FixedRankMatrices)\n\nReturn false. FixedRankMatrices is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.manifold_dimension-Union{Tuple{FixedRankMatrices{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Fixed-rank matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::FixedRankMatrices)\n\nReturn the manifold dimension for the 𝔽-valued FixedRankMatrices M of dimension mxn of rank k, namely\n\ndim(mathcal M) = k(m + n - k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.project-Tuple{FixedRankMatrices, Any, Any}","page":"Fixed-rank matrices","title":"ManifoldsBase.project","text":"project(M, p, A)\n\nProject the matrix A  ℝ^mn or from the embedding the tangent space at p on the FixedRankMatrices M, further decomposing the result into X=UMV^mathrmH, i.e. a UMVTangentVector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.representation_size-Tuple{FixedRankMatrices}","page":"Fixed-rank matrices","title":"ManifoldsBase.representation_size","text":"representation_size(M::FixedRankMatrices)\n\nReturn the element size of a point on the FixedRankMatrices M, i.e. the size of matrices on this manifold (mn).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.retract-Tuple{FixedRankMatrices, Any, Any, OrthographicRetraction}","page":"Fixed-rank matrices","title":"ManifoldsBase.retract","text":"retract(M::FixedRankMatrices, p, X, ::OrthographicRetraction)\n\nCompute the OrthographicRetraction on the FixedRankMatrices M by finding the nearest point to p + X in\n\n    p + X + N_pmathcal M cap mathcal M\n\nwhere N_pmathcal M is the Normal Space of T_pmathcal M.\n\nIf X is sufficiently small, then the nearest such point is unique and can be expressed by\n\n    q = (U(S + M) + U_p)(S + M)^-1((S + M)V^mathrmT + V^mathrmT_p)\n\nwhere p is a SVDMPoint(U,S,Vt) and X is an UMVTangentVector(Up,M,Vtp).\n\nFor more details, see [AO14].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.retract-Tuple{FixedRankMatrices, Any, Any, PolarRetraction}","page":"Fixed-rank matrices","title":"ManifoldsBase.retract","text":"retract(M, p, X, ::PolarRetraction)\n\nCompute an SVD-based retraction on the FixedRankMatrices M by computing\n\n    q = U_kS_kV_k^mathrmH\n\nwhere U_k S_k V_k^mathrmH is the shortened singular value decomposition USV^mathrmH=p+X, in the sense that S_k is the diagonal matrix of size kk with the k largest singular values and U and V are shortened accordingly.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.vector_transport_to!-Tuple{FixedRankMatrices, Any, Any, Any, ProjectionTransport}","page":"Fixed-rank matrices","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to(M::FixedRankMatrices, p, X, q, ::ProjectionTransport)\n\nCompute the vector transport of the tangent vector X at p to q, using the project of X to q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#ManifoldsBase.zero_vector-Tuple{FixedRankMatrices, SVDMPoint}","page":"Fixed-rank matrices","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::FixedRankMatrices, p::SVDMPoint)\n\nReturn a UMVTangentVector representing the zero tangent vector in the tangent space of p on the FixedRankMatrices M, for example all three elements of the resulting structure are zero matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices/#Literature","page":"Fixed-rank matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/fixedrankmatrices/","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"P.-A. Absil and J. Malick. Projection-like Retractions on Matrix Manifolds. SIAM Journal on Optimization 22, 135–158 (2012).\n\n\n\nP.-A. Absil and I. V. Oseledets. Low-rank retractions: a survey and new results. Computational Optimization and Applications 62, 5–29 (2014).\n\n\n\nS. Hosseini and A. Uschmajew. A Riemannian Gradient Sampling Algorithm for Nonsmooth Optimization on Manifolds. SIAM J. Optim. 27, 173–189 (2017).\n\n\n\nD. Nguyen. Operator-Valued Formulas for Riemannian Gradient and Hessian and Families of Tractable Metrics in Riemannian Optimization. Journal of Optimization Theory and Applications 198, 135–164 (2023), arXiv:2009.10159.\n\n\n\nB. Vandereycken. Low-rank matrix completion by Riemannian optimization. SIAM Journal on Optimization 23, 1214–1236 (2013).\n\n\n\n","category":"page"},{"location":"manifolds/stiefel/#Stiefel","page":"Stiefel","title":"Stiefel","text":"","category":"section"},{"location":"manifolds/stiefel/#Common-and-metric-independent-functions","page":"Stiefel","title":"Common and metric independent functions","text":"","category":"section"},{"location":"manifolds/stiefel/#Manifolds.Stiefel","page":"Stiefel","title":"Manifolds.Stiefel","text":"Stiefel{𝔽, T} <: AbstractDecoratorManifold{𝔽}\n\nThe Stiefel manifold consists of all nk, n  k unitary matrices, i.e.\n\noperatornameSt(nk) = bigl p  𝔽^nk big p^mathrmHp = I_k bigr\n\nwhere 𝔽  ℝ ℂ, ^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k  ℝ^kk denotes the kk identity matrix.\n\nThe tangent space at a point p  mathcal M is given by\n\nT_p mathcal M =  X  𝔽^nk  p^mathrmHX + X^mathrmHp = 0_k\n\nwhere 0_k is the kk zero matrix.\n\nThis manifold is modelled as an embedded manifold to the Euclidean, i.e. several functions like the inner product and the zero_vector are inherited from the embedding.\n\nThe manifold is named after Eduard L. Stiefel (1909–1978).\n\nConstructor\n\nStiefel(n, k, field=ℝ; parameter::Symbol=:type)\n\nGenerate the (real-valued) Stiefel manifold of nk dimensional orthonormal matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Base.rand-Tuple{Stiefel}","page":"Stiefel","title":"Base.rand","text":"rand(::Stiefel; vector_at=nothing, σ::Real=1.0)\n\nWhen vector_at is nothing, return a random (Gaussian) point x on the Stiefel manifold M by generating a (Gaussian) matrix with standard deviation σ and return the orthogonalized version, i.e. return the Q component of the QR decomposition of the random matrix of size nk.\n\nWhen vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_vector_atmathrmSt(nk) with mean zero and standard deviation σ by projecting a random Matrix onto the tangent vector at vector_at.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.change_metric-Tuple{Stiefel, EuclideanMetric, Any, Any}","page":"Stiefel","title":"ManifoldsBase.change_metric","text":"change_metric(M::Stiefel, ::EuclideanMetric, p X)\n\nChange X to the corresponding vector with respect to the metric of the Stiefel M, which is just the identity, since the manifold is isometrically embedded.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.change_representer-Tuple{Stiefel, EuclideanMetric, Any, Any}","page":"Stiefel","title":"ManifoldsBase.change_representer","text":"change_representer(M::Stiefel, ::EuclideanMetric, p, X)\n\nChange X to the corresponding representer of a cotangent vector at p. Since the Stiefel manifold M, is isometrically embedded, this is the identity\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.check_point-Tuple{Stiefel, Any}","page":"Stiefel","title":"ManifoldsBase.check_point","text":"check_point(M::Stiefel, p; kwargs...)\n\nCheck whether p is a valid point on the Stiefel M=operatornameSt(nk), i.e. that it has the right AbstractNumbers type and p^mathrmHp is (approximately) the identity, where ^mathrmH is the complex conjugate transpose. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.check_vector-Tuple{Stiefel, Any, Any}","page":"Stiefel","title":"ManifoldsBase.check_vector","text":"check_vector(M::Stiefel, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector at p on the Stiefel M=operatornameSt(nk), i.e. the AbstractNumbers fits and it (approximately) holds that p^mathrmHX + X^mathrmHp = 0. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.default_inverse_retraction_method-Tuple{Stiefel}","page":"Stiefel","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::Stiefel)\n\nReturn PolarInverseRetraction as the default inverse retraction for the Stiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.default_retraction_method-Tuple{Stiefel}","page":"Stiefel","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::Stiefel)\n\nReturn PolarRetraction as the default retraction for the Stiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.default_vector_transport_method-Tuple{Stiefel}","page":"Stiefel","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::Stiefel)\n\nReturn the DifferentiatedRetractionVectorTransport of the [PolarRetraction](PolarRetraction as the default vector transport method for the Stiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.inverse_retract-Tuple{Stiefel, Any, Any, PolarInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, p, q, ::PolarInverseRetraction)\n\nCompute the inverse retraction based on a singular value decomposition for two points p, q on the Stiefel manifold M. This follows the following approach: From the Polar retraction we know that\n\noperatornameretr_p^-1q = qs - t\n\nif such a symmetric positive definite kk matrix exists. Since qs - t is also a tangent vector at p we obtain\n\np^mathrmHqs + s(p^mathrmHq)^mathrmH + 2I_k = 0\n\nwhich can either be solved by a Lyapunov approach or a continuous-time algebraic Riccati equation.\n\nThis implementation follows the Lyapunov approach.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.inverse_retract-Tuple{Stiefel, Any, Any, QRInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, p, q, ::QRInverseRetraction)\n\nCompute the inverse retraction based on a qr decomposition for two points p, q on the Stiefel manifold M and return the resulting tangent vector in X. The computation follows Algorithm 1 in [KFT13].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.is_flat-Tuple{Stiefel}","page":"Stiefel","title":"ManifoldsBase.is_flat","text":"is_flat(M::Stiefel)\n\nReturn true if Stiefel M is one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.manifold_dimension-Tuple{Stiefel{ℝ}}","page":"Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Stiefel)\n\nReturn the dimension of the Stiefel manifold M=operatornameSt(nk𝔽). The dimension is given by\n\nbeginaligned\ndim mathrmSt(n k ℝ) = nk - frac12k(k+1)\ndim mathrmSt(n k ℂ) = 2nk - k^2\ndim mathrmSt(n k ℍ) = 4nk - k(2k-1)\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.representation_size-Tuple{Stiefel}","page":"Stiefel","title":"ManifoldsBase.representation_size","text":"representation_size(M::Stiefel)\n\nReturns the representation size of the Stiefel M=operatornameSt(nk), i.e. (n,k), which is the matrix dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, CayleyRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(::Stiefel, p, X, ::CayleyRetraction)\n\nCompute the retraction on the Stiefel that is based on the Cayley transform[Zhu16]. Using\n\n  W_pX = operatornameP_pXp^mathrmH - pX^mathrmHoperatornameP_p\n  quadtextwhere\n  operatornameP_p = I - frac12pp^mathrmH\n\nthe formula reads\n\n    operatornameretr_pX = Bigl(I - frac12W_pXBigr)^-1Bigl(I + frac12W_pXBigr)p\n\nIt is implemented as the case m=1 of the PadeRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, PadeRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::PadeRetraction{m})\n\nCompute the retraction on the Stiefel manifold M based on the Padé approximation of order m [ZD18]. Let p_m and q_m be defined for any matrix A  ℝ^nx as\n\n  p_m(A) = sum_k=0^m frac(2m-k)m(2m)(m-k)fracA^kk\n\nand\n\n  q_m(A) = sum_k=0^m frac(2m-k)m(2m)(m-k)frac(-A)^kk\n\nrespectively. Then the Padé approximation (of the matrix exponential exp(A)) reads\n\n  r_m(A) = q_m(A)^-1p_m(A)\n\nDefining further\n\n  W_pX = operatornameP_pXp^mathrmH - pX^mathrmHoperatornameP_p\n  quadtextwhere \n  operatornameP_p = I - frac12pp^mathrmH\n\nthe retraction reads\n\n  operatornameretr_pX = r_m(W_pX)p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, PolarRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Stiefel manifold M. With USV = p + X the retraction reads\n\noperatornameretr_p X = UbarV^mathrmH\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, QRRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::QRRetraction)\n\nCompute the QR-based retraction QRRetraction on the Stiefel manifold M. With QR = p + X the retraction reads\n\noperatornameretr_p X = QD\n\nwhere D is a nk matrix with\n\nD = operatornamediagbigl(operatornamesgn(R_ii+05)_i=1^k bigr)\n\nwhere ``\\operatorname{sgn}(p) = \\begin{cases} 1 & \\text{ for } p > 0,\\\n0 & \\text{ for } p = 0,\\\n-1& \\text{ for } p < 0. \\end{cases}``\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.vector_transport_direction-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{CayleyRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(::Stiefel, p, X, d, ::DifferentiatedRetractionVectorTransport{CayleyRetraction})\n\nCompute the vector transport given by the differentiated retraction of the CayleyRetraction, cf. [Zhu16] Equation (17).\n\nThe formula reads\n\noperatornameT_pd(X) =\nBigl(I - frac12W_pdBigr)^-1W_pXBigl(I - frac12W_pdBigr)^-1p\n\nwith\n\n  W_pX = operatornameP_pXp^mathrmH - pX^mathrmHoperatornameP_p\n  quadtextwhere \n  operatornameP_p = I - frac12pp^mathrmH\n\nSince this is the differentiated retraction as a vector transport, the result will be in the tangent space at q=operatornameretr_p(d) using the CayleyRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.vector_transport_direction-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{PolarRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::Stiefel, p, X, d, DifferentiatedRetractionVectorTransport{PolarRetraction})\n\nCompute the vector transport by computing the push forward of retract(::Stiefel, ::Any, ::Any, ::PolarRetraction) Section 3.5 of [Zhu16]:\n\nT_pd^textPol(X) = q*Λ + (I-qq^mathrmT)X(1+d^mathrmTd)^-frac12\n\nwhere q = operatornameretr^mathrmPol_p(d), and Λ is the unique solution of the Sylvester equation\n\n    Λ(I+d^mathrmTd)^frac12 + (I + d^mathrmTd)^frac12 = q^mathrmTX - X^mathrmTq\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.vector_transport_direction-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{QRRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::Stiefel, p, X, d, DifferentiatedRetractionVectorTransport{QRRetraction})\n\nCompute the vector transport by computing the push forward of the retract(::Stiefel, ::Any, ::Any, ::QRRetraction), See  [AMS08], p. 173, or Section 3.5 of [Zhu16].\n\nT_pd^textQR(X) = q*rho_mathrms(q^mathrmTXR^-1) + (I-qq^mathrmT)XR^-1\n\nwhere q = operatornameretr^mathrmQR_p(d), R is the R factor of the QR decomposition of p + d, and\n\nbigl( rho_mathrms(A) bigr)_ij\n= begincases\nA_ijtext if  i  j\n0 text if  i = j\n-A_ji text if  i  j\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.vector_transport_to-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{PolarRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Stiefel, p, X, q, DifferentiatedRetractionVectorTransport{PolarRetraction})\n\nCompute the vector transport by computing the push forward of the retract(M::Stiefel, ::Any, ::Any, ::PolarRetraction), see Section 4 of [HGA15] or  Section 3.5 of [Zhu16]:\n\nT_qgets p^textPol(X) = q*Λ + (I-qq^mathrmT)X(1+d^mathrmTd)^-frac12\n\nwhere d = bigl( operatornameretr^mathrmPol_pbigr)^-1(q), and Λ is the unique solution of the Sylvester equation\n\n    Λ(I+d^mathrmTd)^frac12 + (I + d^mathrmTd)^frac12 = q^mathrmTX - X^mathrmTq\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.vector_transport_to-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{QRRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Stiefel, p, X, q, DifferentiatedRetractionVectorTransport{QRRetraction})\n\nCompute the vector transport by computing the push forward of the retract(M::Stiefel, ::Any, ::Any, ::QRRetraction), see  [AMS08], p. 173, or Section 3.5 of [Zhu16].\n\nT_q gets p^textQR(X) = q*rho_mathrms(q^mathrmTXR^-1) + (I-qq^mathrmT)XR^-1\n\nwhere d = bigl(operatornameretr^mathrmQRbigr)^-1_p(q), R is the R factor of the QR decomposition of p+X, and\n\nbigl( rho_mathrms(A) bigr)_ij\n= begincases\nA_ijtext if  i  j\n0 text if  i = j\n-A_ji text if  i  j\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.vector_transport_to-Tuple{Stiefel, Any, Any, Any, ProjectionTransport}","page":"Stiefel","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Stiefel, p, X, q, ::ProjectionTransport)\n\nCompute a vector transport by projection, i.e. project X from the tangent space at p by projection it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Default-metric:-the-Euclidean-metric","page":"Stiefel","title":"Default metric: the Euclidean metric","text":"","category":"section"},{"location":"manifolds/stiefel/","page":"Stiefel","title":"Stiefel","text":"The EuclideanMetric is obtained from the embedding of the Stiefel manifold in ℝ^nk.","category":"page"},{"location":"manifolds/stiefel/#Base.exp-Tuple{Stiefel, Vararg{Any}}","page":"Stiefel","title":"Base.exp","text":"exp(M::Stiefel, p, X)\n\nCompute the exponential map on the Stiefel{n,k,𝔽}() manifold M emanating from p in tangent direction X.\n\nexp_p X = beginpmatrix\n   pX\n endpmatrix\n operatornameExp\n left(\n beginpmatrix p^mathrmHX  - X^mathrmHX\n I_n  p^mathrmHXendpmatrix\n right)\nbeginpmatrix  exp( -p^mathrmHX)  0_nendpmatrix\n\nwhere operatornameExp denotes matrix exponential, ^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k and 0_k are the identity matrix and the zero matrix of dimension kk, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldDiff.riemannian_Hessian-Tuple{Stiefel, Vararg{Any, 4}}","page":"Stiefel","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::Stiefel, p, G, H, X)\nriemannian_Hessian!(M::Stiefel, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nHere, we adopt Eq. (5.6) [Ngu23], where we use for the EuclideanMetric α_0=α_1=1 in their formula. Then the formula reads\n\n    operatornameHessf(p)X\n    =\n    operatornameproj_T_pmathcal MBigl(\n        ^2f(p)X - frac12 X bigl((f(p))^mathrmHp + p^mathrmHf(p)bigr)\n    Bigr)\n\nCompared to Eq. (5.6) also the metric conversion simplifies to the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.Weingarten-Tuple{Stiefel, Any, Any, Any}","page":"Stiefel","title":"ManifoldsBase.Weingarten","text":"Weingarten(M::Stiefel, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the Stiefel M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nThe formula is due to [AMT13] given by\n\nmathcal W_p(XV) = -Xp^mathrmHV - frac12pbigl(X^mathrmHV + V^mathrmHXbigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.get_basis-Tuple{Stiefel{ℝ}, Any, DefaultOrthonormalBasis{ℝ, TangentSpaceType}}","page":"Stiefel","title":"ManifoldsBase.get_basis","text":"get_basis(M::Stiefel{ℝ}, p, B::DefaultOrthonormalBasis)\n\nCreate the default basis using the parametrization for any X  T_pmathcal M. Set p_bot in ℝ^n(n-k) the matrix such that the nn matrix of the common columns p p_bot is an ONB. For any skew symmetric matrix a  ℝ^kk and any b  ℝ^(n-k)k the matrix\n\nX = pa + p_bot b  T_pmathcal M\n\nand we can use the frac12k(k-1) + (n-k)k = nk-frac12k(k+1) entries of a and b to specify a basis for the tangent space. using unit vectors for constructing both the upper matrix of a to build a skew symmetric matrix and the matrix b, the default basis is constructed.\n\nSince p p_ is an automorphism on ℝ^np the elements of a and b are orthonormal coordinates for the tangent space. To be precise exactly one element in the upper triangular entries of a is set to 1 its symmetric entry to -1 and we normalize with the factor frac1sqrt2 and for b one can just use unit vectors reshaped to a matrix to obtain orthonormal set of parameters.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.injectivity_radius-Tuple{Stiefel}","page":"Stiefel","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Stiefel)\n\nReturn the injectivity radius for the Stiefel manifold M, which is globally π [ZS24].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.inverse_retract-Tuple{Stiefel, Any, Any, ProjectionInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, p, q, method::ProjectionInverseRetraction)\n\nCompute a projection-based inverse retraction.\n\nThe inverse retraction is computed by projecting the logarithm map in the embedding to the tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.project-Tuple{Stiefel, Any, Any}","page":"Stiefel","title":"ManifoldsBase.project","text":"project(M::Stiefel, p)\n\nProjects p from the embedding onto the Stiefel M, i.e. compute q as the polar decomposition of p such that q^mathrmHq is the identity, where ^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.project-Tuple{Stiefel, Vararg{Any}}","page":"Stiefel","title":"ManifoldsBase.project","text":"project(M::Stiefel, p, X)\n\nProject X onto the tangent space of p to the Stiefel manifold M. The formula reads\n\noperatornameproj_T_pmathcal M(X) = X - p operatornameSym(p^mathrmHX)\n\nwhere operatornameSym(q) is the symmetrization of q, e.g. by operatornameSym(q) = fracq^mathrmH+q2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, ProjectionRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, method::ProjectionRetraction)\n\nCompute a projection-based retraction.\n\nThe retraction is computed by projecting the exponential map in the embedding to M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#The-canonical-metric","page":"Stiefel","title":"The canonical metric","text":"","category":"section"},{"location":"manifolds/stiefel/","page":"Stiefel","title":"Stiefel","text":"Any XT_pmathcal M, pmathcal M, can be written as","category":"page"},{"location":"manifolds/stiefel/","page":"Stiefel","title":"Stiefel","text":"X = pA + (I_n-pp^mathrmT)B\nquad\nA  ℝ^pp text skew-symmetric\nquad\nB  ℝ^np text arbitrary","category":"page"},{"location":"manifolds/stiefel/","page":"Stiefel","title":"Stiefel","text":"In the EuclideanMetric, the elements from A are counted twice (i.e. weighted with a factor of 2). The canonical metric avoids this.","category":"page"},{"location":"manifolds/stiefel/#Manifolds.ApproximateLogarithmicMap","page":"Stiefel","title":"Manifolds.ApproximateLogarithmicMap","text":"ApproximateLogarithmicMap <: ApproximateInverseRetraction\n\nAn approximate implementation of the logarithmic map, which is an inverse_retraction. See inverse_retract(::MetricManifold{ℝ,<:Stiefel{ℝ},CanonicalMetric}, ::Any, ::Any, ::ApproximateLogarithmicMap) for a use case.\n\nFields\n\nmax_iterations – maximal number of iterations used in the approximation\ntolerance – a tolerance used as a stopping criterion\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Manifolds.CanonicalMetric","page":"Stiefel","title":"Manifolds.CanonicalMetric","text":"CanonicalMetric <: AbstractMetric\n\nThe Canonical Metric refers to a metric for the Stiefel manifold, see[EAS98].\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Base.exp-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, CanonicalMetric}, Vararg{Any}}","page":"Stiefel","title":"Base.exp","text":"q = exp(M::MetricManifold{ℝ,<:Stiefel{ℝ},CanonicalMetric}, p, X)\nexp!(M::MetricManifold{ℝ,<:Stiefel{ℝ},CanonicalMetric}, q, p, X)\n\nCompute the exponential map on the Stiefel(n, k) manifold with respect to the CanonicalMetric.\n\nFirst, decompose The tangent vector X into its horizontal and vertical component with respect to p, i.e.\n\nX = pp^mathrmTX + (I_n-pp^mathrmT)X\n\nwhere I_n is the nn identity matrix. We introduce A=p^mathrmTX and QR = (I_n-pp^mathrmT)X the qr decomposition of the vertical component. Then using the matrix exponential operatornameExp we introduce B and C as\n\nbeginpmatrix\nBC\nendpmatrix\ncoloneqq\noperatornameExpleft(\nbeginpmatrix\nA  -R^mathrmT R  0\nendpmatrix\nright)\nbeginpmatrixI_k0endpmatrix\n\nthe exponential map reads\n\nq = exp_p X = pC + QB\n\nFor more details, see [EAS98][Zim17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldDiff.riemannian_Hessian-Union{Tuple{𝔽}, Tuple{MetricManifold{𝔽, Stiefel, CanonicalMetric}, Vararg{Any, 4}}} where 𝔽","page":"Stiefel","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::MetricManifold{ℝ, Stiefel, CanonicalMetric}, p, G, H, X)\nriemannian_Hessian!(M::MetricManifold{ℝ, Stiefel, CanonicalMetric}, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nHere, we adopt Eq. (5.6) [Ngu23], for the CanonicalMetric α_0=1 α_1=frac12 in their formula. The formula reads\n\n    operatornameHessf(p)X\n    =\n    operatornameproj_T_pmathcal MBigl(\n        ^2f(p)X - frac12 X bigl( (f(p))^mathrmHp + p^mathrmHf(p)bigr)\n        - frac12 bigl( P f(p) p^mathrmH + p f(p))^mathrmH P)X\n    Bigr)\n\nwhere P = I-pp^mathrmH.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.inner-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, CanonicalMetric}, Any, Any, Any}","page":"Stiefel","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{ℝ, Stiefel{ℝ}, X, CanonicalMetric}, p, X, Y)\n\nCompute the inner product on the Stiefel manifold with respect to the CanonicalMetric. The formula reads\n\ng_p(XY) = operatornametrbigl( X^mathrmT(I_n - frac12pp^mathrmT)Y bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.inverse_retract-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, CanonicalMetric}, Any, Any, ApproximateLogarithmicMap}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"X = inverse_retract(M::MetricManifold{ℝ, Stiefel{ℝ}, CanonicalMetric}, p, q, a::ApproximateLogarithmicMap)\ninverse_retract!(M::MetricManifold{ℝ, Stiefel{ℝ}, X, CanonicalMetric}, p, q, a::ApproximateLogarithmicMap)\n\nCompute an approximation to the logarithmic map on the Stiefel(n, k) manifold with respect to the CanonicalMetric using a matrix-algebraic based approach to an iterative inversion of the formula of the exp.\n\nThe algorithm is derived in [Zim17] and it uses the max_iterations and the tolerance field from the ApproximateLogarithmicMap.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.is_flat-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, CanonicalMetric}}","page":"Stiefel","title":"ManifoldsBase.is_flat","text":"is_flat(MetricManifold{ℝ,<:Stiefel{ℝ},CanonicalMetric})\n\nReturn true if Stiefel M is one-dimensional, since only then, the manifold is flat.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#The-submersion-or-normal-metric","page":"Stiefel","title":"The submersion or normal metric","text":"","category":"section"},{"location":"manifolds/stiefel/#Manifolds.StiefelFactorization","page":"Stiefel","title":"Manifolds.StiefelFactorization","text":"StiefelFactorization{UT,XT} <: AbstractManifoldPoint\n\nRepresent points (and vectors) on Stiefel(n, k) with 2kk factors [ZH22].\n\nGiven a point p  mathrmSt(n k) and another matrix B  ℝ^nk for k  lfloorfracn2rfloor the factorization is\n\nbeginaligned\nB = UZ\nU = beginbmatrixp  Qendbmatrix  mathrmSt(n 2k)\nZ = beginbmatrixZ_1  Z_2endbmatrix quad Z_1Z_2  ℝ^kk\nendaligned\n\nIf B  mathrmSt(n k), then Z  mathrmSt(2k k). Note that not every matrix B can be factorized in this way.\n\nFor a fixed U, if r  mathrmSt(n k) has the factor Z_r  mathrmSt(2k k), then X_r  T_r mathrmSt(n k) has the factor Z_X_r  T_Z_r mathrmSt(2k k).\n\nQ is determined by choice of a second matrix A  ℝ^nk with the decomposition\n\nbeginaligned\nA = UZ\nZ_1 = p^mathrmT A \nQ Z_2 = (I - p p^mathrmT) A\nendaligned\n\nwhere here Q Z_2 is the any decomposition that produces Q  mathrmSt(n k), for which we choose the QR decomposition.\n\nThis factorization is useful because it is closed under addition, subtraction, scaling, projection, and the Riemannian exponential and logarithm under the StiefelSubmersionMetric. That is, if all matrices involved are factorized to have the same U, then all of these operations and any algorithm that depends only on them can be performed in terms of the 2kk matrices Z. For n  k, this can be much more efficient than working with the full matrices.\n\nwarning: Warning\nThis type is intended strictly for internal use and should not be directly used.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Manifolds.StiefelSubmersionMetric","page":"Stiefel","title":"Manifolds.StiefelSubmersionMetric","text":"StiefelSubmersionMetric{T<:Real} <: RiemannianMetric\n\nThe submersion (or normal) metric family on the Stiefel manifold.\n\nThe family, with a single real parameter α-1, has two special cases:\n\nα = -frac12: EuclideanMetric\nα = 0: CanonicalMetric\n\nThe family was described in [HML21]. This implementation follows the description in [ZH22].\n\nConstructor\n\nStiefelSubmersionMetric(α)\n\nConstruct the submersion metric on the Stiefel manifold with the parameter α.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Base.exp-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, <:StiefelSubmersionMetric}, Vararg{Any}}","page":"Stiefel","title":"Base.exp","text":"q = exp(M::MetricManifold{ℝ,<:Stiefel{ℝ},<:StiefelSubmersionMetric}, p, X)\nexp!(M::MetricManifold{ℝ,<:Stiefel{ℝ},<:StiefelSubmersionMetric}, q, p, X)\n\nCompute the exponential map on the Stiefel(n,k) manifold with respect to the StiefelSubmersionMetric.\n\nThe exponential map is given by\n\nexp_p X = operatornameExpbigl(\n    -frac2α+1α+1 p p^mathrmT X p^mathrmT +\n    X p^mathrmT - p X^mathrmT\nbigr) p operatornameExpbigl(fracalphaalpha+1 p^mathrmT Xbigr)\n\nThis implementation is based on [ZH22].\n\nFor k  fracn2 the exponential is computed more efficiently using StiefelFactorization.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Base.log-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, <:StiefelSubmersionMetric}, Any, Any}","page":"Stiefel","title":"Base.log","text":"log(M::MetricManifold{ℝ,<:Stiefel{ℝ},<:StiefelSubmersionMetric}, p, q; kwargs...)\n\nCompute the logarithmic map on the Stiefel(n,k) manifold with respect to the StiefelSubmersionMetric.\n\nThe logarithmic map is computed using ShootingInverseRetraction. For k  lfloorfracn2rfloor, this is sped up using the k-shooting method of [ZH22]. Keyword arguments are forwarded to ShootingInverseRetraction; see that documentation for details. Their defaults are:\n\nnum_transport_points=4\ntolerance=sqrt(eps())\nmax_iterations=1_000\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldDiff.riemannian_Hessian-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, <:StiefelSubmersionMetric}, Vararg{Any, 4}}","page":"Stiefel","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::MetricManifold{ℝ,<:Stiefel{ℝ},StiefelSubmersionMetric}, p, G, H, X)\nriemannian_Hessian!(MetricManifold{ℝ,<:Stiefel{ℝ},StiefelSubmersionMetric}, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nHere, we adopt Eq. (5.6) [Ngu23], for the CanonicalMetric α_0=1 α_1=frac12 in their formula. The formula reads\n\n    operatornameHessf(p)X\n    =\n    operatornameproj_T_pmathcal MBigl(\n        ^2f(p)X - frac12 X bigl( (f(p))^mathrmHp + p^mathrmHf(p)bigr)\n        - frac2α+12(α+1) bigl( P f(p) p^mathrmH + p f(p))^mathrmH P)X\n    Bigr)\n\nwhere P = I-pp^mathrmH.\n\nCompared to Eq. (5.6) we have that their α_0 = 1and alpha_1 =  frac2α+12(α+1) + 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.inner-Tuple{MetricManifold{ℝ, <:Stiefel{ℝ}, <:StiefelSubmersionMetric}, Any, Any, Any}","page":"Stiefel","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{ℝ,<:Stiefel{ℝ},<:StiefelSubmersionMetric}, p, X, Y)\n\nCompute the inner product on the Stiefel manifold with respect to the StiefelSubmersionMetric. The formula reads\n\ng_p(XY) = operatornametrbigl( X^mathrmT(I_n - frac2α+12(α+1)pp^mathrmT)Y bigr)\n\nwhere α is the parameter of the metric.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#ManifoldsBase.inverse_retract-Tuple{MetricManifold{ℝ, <:Stiefel, <:StiefelSubmersionMetric}, Any, Any, ShootingInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(\n    M::MetricManifold{ℝ,<:Stiefel{ℝ},<:StiefelSubmersionMetric}, p, q,\n    method::ShootingInverseRetraction,\n)\n\nCompute the inverse retraction using ShootingInverseRetraction.\n\nIn general the retraction is computed using the generic shooting method.\n\ninverse_retract(\n    M::MetricManifold{ℝ,<:Stiefel{ℝ},<:StiefelSubmersionMetric}, p, q,\n    method::ShootingInverseRetraction{\n        ExponentialRetraction,\n        ProjectionInverseRetraction,\n        <:Union{ProjectionTransport,ScaledVectorTransport{ProjectionTransport}},\n    },\n)\n\nCompute the inverse retraction using ShootingInverseRetraction more efficiently.\n\nFor k  fracn2 the retraction is computed more efficiently using StiefelFactorization.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Internal-types-and-functions","page":"Stiefel","title":"Internal types and functions","text":"","category":"section"},{"location":"manifolds/stiefel/#Manifolds.stiefel_factorization-Tuple{Any, Any}","page":"Stiefel","title":"Manifolds.stiefel_factorization","text":"stiefel_factorization(p, x) -> StiefelFactorization\n\nCompute the StiefelFactorization of x relative to the point p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Literature","page":"Stiefel","title":"Literature","text":"","category":"section"},{"location":"manifolds/stiefel/","page":"Stiefel","title":"Stiefel","text":"P. -.-A. Absil, R. Mahony and J. Trumpf. An Extrinsic Look at the Riemannian Hessian. In: Geometric Science of Information, edited by F. Nielsen and F. Barbaresco (Springer Berlin Heidelberg, 2013); pp. 361–368.\n\n\n\nP.-A. Absil, R. Mahony and R. Sepulchre. Optimization Algorithms on Matrix Manifolds (Princeton University Press, 2008), available online at press.princeton.edu/chapters/absil/.\n\n\n\nA. Edelman, T. A. Arias and S. T. Smith. The Geometry of Algorithms with Orthogonality Constraints. SIAM Journal on Matrix Analysis and Applications 20, 303–353 (1998), arXiv:806030.\n\n\n\nW. Huang, K. A. Gallivan and P.-A. Absil. A Broyden Class of Quasi-Newton Methods for Riemannian Optimization. SIAM Journal on Optimization 25, 1660–1685 (2015).\n\n\n\nK. Hüper, I. Markina and F. S. Leite. A Lagrangian approach to extremal curves on Stiefel manifolds. Journal of Geometric Mechanics 13, 55 (2021).\n\n\n\nT. Kaneko, S. Fiori and T. Tanaka. Empirical Arithmetic Averaging Over the Compact Stiefel Manifold. IEEE Transactions on Signal Processing 61, 883–894 (2013).\n\n\n\nD. Nguyen. Operator-Valued Formulas for Riemannian Gradient and Hessian and Families of Tractable Metrics in Riemannian Optimization. Journal of Optimization Theory and Applications 198, 135–164 (2023), arXiv:2009.10159.\n\n\n\nX. Zhu. A Riemannian conjugate gradient method for optimization on the Stiefel manifold. Computational Optimization and Applications 67, 73–110 (2016).\n\n\n\nX. Zhu and C. Duan. On matrix exponentials and their approximations related to optimization on the Stiefel manifold. Optimization Letters 13, 1069–1083 (2018).\n\n\n\nR. Zimmermann. A Matrix-Algebraic Algorithm for the Riemannian Logarithm on the Stiefel Manifold under the Canonical Metric. SIAM J. Matrix Anal. Appl. 38, 322–342 (2017), arXiv:1604.05054.\n\n\n\nR. Zimmermann and K. Hüper. Computing the Riemannian Logarithm on the Stiefel Manifold: Metrics, Methods, and Performance. SIAM Journal on Matrix Analysis and Applications 43, 953–980 (2022), arXiv:2103.12046.\n\n\n\nR. Zimmermann and J. Stoye. The injectivity radius of the compact Stiefel manifold under the Euclidean metric, arXiv Preprint (2024), arXiv:2405.02268.\n\n\n\n","category":"page"},{"location":"manifolds/circle/#Circle","page":"Circle","title":"Circle","text":"","category":"section"},{"location":"manifolds/circle/#Manifolds.Circle","page":"Circle","title":"Manifolds.Circle","text":"Circle{𝔽} <: AbstractManifold{𝔽}\n\nThe circle 𝕊^1 is a manifold here represented by real-valued points in -ππ) or complex-valued points z  ℂ of absolute value lvert zrvert = 1.\n\nConstructor\n\nCircle(𝔽=ℝ)\n\nGenerate the ℝ-valued Circle represented by angles, which alternatively can be set to use the AbstractNumbers 𝔽=ℂ to obtain the circle represented by ℂ-valued circle of unit numbers.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/circle/#Base.exp-Tuple{Circle, Vararg{Any}}","page":"Circle","title":"Base.exp","text":"exp(M::Circle, p, X)\n\nCompute the exponential map on the Circle.\n\nexp_p X = (p+X)_2π\n\nwhere ()_2π is the (symmetric) remainder with respect to division by 2π, i.e. in -ππ).\n\nFor the complex-valued case, the same formula as for the Sphere 𝕊^1 is applied to values in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Base.log-Tuple{Circle, Vararg{Any}}","page":"Circle","title":"Base.log","text":"log(M::Circle, p, q)\n\nCompute the logarithmic map on the Circle M.\n\nlog_p q = (q-p)_2π\n\nwhere ()_2π is the (symmetric) remainder with respect to division by 2π, i.e. in -ππ).\n\nFor the complex-valued case, the same formula as for the Sphere 𝕊^1 is applied to values in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Base.rand-Tuple{Circle}","page":"Circle","title":"Base.rand","text":"Random.rand(M::Circle{ℝ}; vector_at = nothing, σ::Real=1.0)\n\nIf vector_at is nothing, return a random point on the Circle mathbb S^1 by picking a random element from -pipi) uniformly.\n\nIf vector_at is not nothing, return a random tangent vector from the tangent space of the point vector_at on the Circle by using a normal distribution with mean 0 and standard deviation σ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manifolds.complex_dot-Tuple{Any, Any}","page":"Circle","title":"Manifolds.complex_dot","text":"complex_dot(a, b)\n\nCompute the inner product of two (complex) numbers with in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manifolds.manifold_volume-Tuple{Circle}","page":"Circle","title":"Manifolds.manifold_volume","text":"manifold_volume(M::Circle)\n\nReturn the volume of the Circle M, i.e. 2π.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manifolds.sym_rem-Union{Tuple{N}, Tuple{N, Any}} where N<:Number","page":"Circle","title":"Manifolds.sym_rem","text":"sym_rem(x,[T=π])\n\nCompute symmetric remainder of x with respect to the interall 2*T, i.e. (x+T)%2T, where the default for T is π\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manifolds.volume_density-Tuple{Circle, Any, Any}","page":"Circle","title":"Manifolds.volume_density","text":"volume_density(::Circle, p, X)\n\nReturn volume density of Circle, i.e. 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.check_point-Tuple{Circle, Vararg{Any}}","page":"Circle","title":"ManifoldsBase.check_point","text":"check_point(M::Circle, p)\n\nCheck whether p is a point on the Circle M. For the real-valued case, p is an angle and hence it checks that p  -ππ). for the complex-valued case, it is a unit number, p  ℂ with lvert p rvert = 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.check_vector-Tuple{Circle{ℝ}, Vararg{Any}}","page":"Circle","title":"ManifoldsBase.check_vector","text":"check_vector(M::Circle, p, X; kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the Circle M. For the real-valued case represented by angles, all X are valid, since the tangent space is the whole real line. For the complex-valued case X has to lie on the line parallel to the tangent line at p in the complex plane, i.e. their inner product has to be zero.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.distance-Tuple{Circle, Vararg{Any}}","page":"Circle","title":"ManifoldsBase.distance","text":"distance(M::Circle, p, q)\n\nCompute the distance on the Circle M, which is the absolute value of the symmetric remainder of p and q for the real-valued case and the angle between both complex numbers in the Gaussian plane for the complex-valued case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.embed-Tuple{Circle, Any, Any}","page":"Circle","title":"ManifoldsBase.embed","text":"embed(M::Circle, p, X)\n\nEmbed a tangent vector X at p on Circle M in the ambient space. It returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.embed-Tuple{Circle, Any}","page":"Circle","title":"ManifoldsBase.embed","text":"embed(M::Circle, p)\n\nEmbed a point p on Circle M in the ambient space. It returns p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.get_coordinates-Tuple{Circle{ℂ}, Any, Any, DefaultOrthonormalBasis{<:Any, TangentSpaceType}}","page":"Circle","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Circle{ℂ}, p, X, B::DefaultOrthonormalBasis)\n\nReturn tangent vector coordinates in the Lie algebra of the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.get_vector_orthonormal-Tuple{Circle{ℂ}, StaticArraysCore.StaticArray, Any, Union{ManifoldsBase.ComplexNumbers, ManifoldsBase.RealNumbers}}","page":"Circle","title":"ManifoldsBase.get_vector_orthonormal","text":"get_vector(M::Circle{ℂ}, p, X, B::DefaultOrthonormalBasis)\n\nReturn tangent vector from the coordinates in the Lie algebra of the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.injectivity_radius-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Circle[, p])\n\nReturn the injectivity radius on the Circle M, i.e. π.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.inner-Tuple{Circle, Vararg{Any}}","page":"Circle","title":"ManifoldsBase.inner","text":"inner(M::Circle, p, X, Y)\n\nCompute the inner product of the two tangent vectors X,Y from the tangent plane at p on the Circle M using the restriction of the metric from the embedding, i.e.\n\ng_p(XY) = X*Y\n\nfor the real case and\n\ng_p(XY) = Y^mathrmTX\n\nfor the complex case interpreting complex numbers in the Gaussian plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.is_flat-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.is_flat","text":"is_flat(::Circle)\n\nReturn true. Circle is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.manifold_dimension-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Circle)\n\nReturn the dimension of the Circle M, i.e. dim(𝕊^1) = 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.parallel_transport_to-Tuple{Circle, Any, Any, Any}","page":"Circle","title":"ManifoldsBase.parallel_transport_to","text":" parallel_transport_to(M::Circle, p, X, q)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the Circle M. For the real-valued case this results in the identity. For the complex-valued case, the formula is the same as for the Sphere(1) in the complex plane.\n\nmathcal P_qp X = X - fraclog_p qX_pd^2_ℂ(pq)\nbigl(log_p q + log_q p bigr)\n\nwhere log denotes the logarithmic map on M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.project-Tuple{Circle, Any, Any}","page":"Circle","title":"ManifoldsBase.project","text":"project(M::Circle, p, X)\n\nProject a value X onto the tangent space of the point p on the Circle M.\n\nFor the real-valued case this is just the identity. For the complex valued case X is projected onto the line in the complex plane that is parallel to the tangent to p on the unit circle and contains 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#ManifoldsBase.project-Tuple{Circle, Any}","page":"Circle","title":"ManifoldsBase.project","text":"project(M::Circle, p)\n\nProject a point p onto the Circle M. For the real-valued case this is the remainder with respect to modulus 2π. For the complex-valued case the result is the projection of p onto the unit circle in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Statistics.mean-Tuple{Circle{ℂ}, Any}","page":"Circle","title":"Statistics.mean","text":"mean(M::Circle{ℂ}, x::AbstractVector[, w::AbstractWeights])\n\nCompute the Riemannian mean of x of points on the Circle 𝕊^1, represented by complex numbers, i.e. embedded in the complex plane. Comuting the sum\n\ns = sum_i=1^n x_i\n\nthe mean is the angle of the complex number s, so represented in the complex plane as fracslvert s rvert, whenever s neq 0.\n\nIf the sum s=0, the mean is not unique. For example for opposite points or equally spaced angles.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Statistics.mean-Tuple{Circle{ℝ}, Any}","page":"Circle","title":"Statistics.mean","text":"mean(M::Circle{ℝ}, x::AbstractVector[, w::AbstractWeights])\n\nCompute the Riemannian mean of x of points on the Circle 𝕊^1, represented by real numbers, i.e. the angular mean\n\noperatornameatanBigl( sum_i=1^n w_isin(x_i)  sum_i=1^n w_isin(x_i) Bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#The-Segre-manifold","page":"Segre","title":"The Segre manifold","text":"","category":"section"},{"location":"manifolds/segre/#Manifolds.Segre","page":"Segre","title":"Manifolds.Segre","text":"Segre{𝔽,V} <: AbstractManifold{𝔽}\n\nThe Segre manifold\n\nmathcalS = operatornameSeg(𝔽^n_1 times dots times 𝔽^n_d)\n\nis the set of rank-one tensors in 𝔽^n_1 otimes dots otimes 𝔽^n_d.\n\nWhen 𝔽 = ℝ, the Segre manifold is a normal Riemannian covering of\n\nmathcalP = ℝ^+ times mathbbS^n_1 - 1 times dots times mathbbS^n_d - 1\n\nequipped with a warped product metric. The tuple (n_1 dots n_d) is called the valence of the manifold.\n\nThe geometry of the Segre manifold is summarized in [JSVV24]. It is named after Corrado Segre(1863–1924).\n\nConstructor\n\nSegre(n::Int...; field::AbstractNumbers=ℝ)\n\nGenerate a valence (n, ...) Segre manifold. Segre(n) is the same as mathbbR^n setminus  0 .\n\n\n\n\n\n","category":"type"},{"location":"manifolds/segre/#Base.exp-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any}} where V","page":"Segre","title":"Base.exp","text":"exp(M::Segre{ℝ, V}, p, X)\n\nExponential map on the Segre manifold.\n\nLet p  (λ x_1  x_d)  mathcalS and X = (ν u_1  u_d)  T_p mathcalS. The exponential map is given by\n\n    operatornameexp_p(X) \n    left(\n        sqrt(λ + ν)^2 + (λ m)^2\n        x_1 cosmathopenBig( fracf lVert u_1 rVert_x_1m mathcloseBig) + fracu_1lVert u_1 rVert_x_1 sinmathopenBig( fracf lVert u_1 rVert_x_1m mathcloseBig)\n        \n        x_d cosmathopenBig( fracf lVert u_d rVert_x_dm mathcloseBig) + fracu_dlVert u_d rVert_x_d sinmathopenBig( fracf lVert u_d rVert_x_dm mathcloseBig)\n    right)\n\nwhere\n\n    beginaligned\n        f = fracpi2 - tan^-1mathopenBig( fracλ + νλ m mathcloseBig)\n        m = sqrtlVert u_1 rVert_x_1^2 +  + lVert u_d rVert_x_d^2\n    endaligned\n\nIf m = 0 and -λ  ν, then operatornameexp_p(v) = p + X.\n\nThe formula is derived in proposition 3.1 in [JSVV24].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#Base.log-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any}} where V","page":"Segre","title":"Base.log","text":"log(M::Segre{ℝ, V}, p, q)\n\nLogarithmic map on the Segre manifold.\n\nLet p  (λ x_1  x_d), q  (μ y_1  y_d)  mathcalS. Assume p and q are connected by a geodesic.\n\nLet\n\n    m = sqrtsphericalangle(x_1 y_1)^2 +  + sphericalangle(x_d y_d)^2\n\nand assume (μ y_1  y_d) is the representative of q that minimizes m. Then\n\n    operatornamelog_p(q) =\n    left(\n        mu cosm - lambda\n        (y_1 - x_1 y_1 x_1) fracmu sphericalangle(x_1 y_1) sinmlambda m sinsphericalangle(x_1 y_1)\n        dots\n        (y_d - x_d y_d x_d) fracmu sphericalangle(x_d y_d) sinmlambda m sinsphericalangle(x_d y_d)\n    right)\n\nThe formula is derived in theorem 4.4 in [JSVV24].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#Base.rand-Union{Tuple{Segre{ℝ, V}}, Tuple{V}} where V","page":"Segre","title":"Base.rand","text":"rand(M::Segre{ℝ, V}; vector_at=nothing)\n\nIf vector_at is nothing, return a random point on\n\n    ℝ^+  mathbbS^n_1 - 1  mathbbS^n_d - 1\n\nfrom a log-normal distribution on ℝ^+ and a uniform distribution on mathbbS^n_1 - 1  mathbbS^n_d - 1.\n\nIf vector_at is not nothing, return a random tangent vector from a normal distribution on the tangent space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#Manifolds.closest_representative!-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any}} where V","page":"Segre","title":"Manifolds.closest_representative!","text":"closest_representative!(M::Segre{ℝ, V}, p, q)\n\nmathcalS is a 2^d-sheeted Riemannian covering of\n\nmathcalP = ℝ^+ times mathbbS^n_1 - 1 times dots times mathbbS^n_d - 1\n\nwith a warped product metric. Every equivalence class q in mathcalS has 2^d representatives in mathcalP. closest_representative!(M, q, p) changes representative of q to the one that is closest to p in mathcalP.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#Manifolds.connected_by_geodesic-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any}} where V","page":"Segre","title":"Manifolds.connected_by_geodesic","text":"connected_by_geodesic(M::Segre{ℝ, V}, p, q)\n\nmathcalS is not a complete manifold, i.e. not every pair p and q of points are connected by a geodesic in mathcalS. connected_by_geodesic(M, p, q) returns true if two points, p and q, are connected by a geodesic, and otherwise returns false.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#Manifolds.spherical_angle_sum-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any}} where V","page":"Segre","title":"Manifolds.spherical_angle_sum","text":"spherical_angle_sum(M::Segre{ℝ, V}, p, q)\n\nLet p  (λ x_1  x_d), q  (μ y_1  y_d)  mathcalS. Then this is\n\n    sqrtsphericalangle(x_1 y_1)^2 +  + sphericalangle(x_d y_d)^2\n\nwhere sphericalangle(x_i y_i) is the distance between x_i and y_i on the sphere mathbbS^n_i - 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.distance-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any}} where V","page":"Segre","title":"ManifoldsBase.distance","text":"distance(M::Segre{ℝ, V}, p, q)\n\nRiemannian distance between two points p and q on the Segre manifold.\n\nAssume p  (λ x_1  x_d), q  (μ y_1  y_d)  mathcalS are connected by a geodesic. Let\n\n    m = sqrtsphericalangle(x_1 y_1)^2 +  + sphericalangle(x_d y_d)^2\n\nand assume (μ y_1  y_d) is the representation of q that minimizes m. Then\n\n    operatornamedist_mathcalS(p q) = sqrtλ^2 - 2 λμcos(m) + μ^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.embed!-Union{Tuple{V}, Tuple{𝔽}, Tuple{Segre{𝔽, V}, Any, Any, Any}} where {𝔽, V}","page":"Segre","title":"ManifoldsBase.embed!","text":"embed!(M::Segre{𝔽, V}, p, X)\n\nEmbed tangent vector X = (ν u_1  u_d) at p  (λ x_1  x_d) in 𝔽^n_1  n_d using the Kronecker product\n\n    (ν u_1  u_d)  ν x_1  x_d + λ u_1  x_2  x_d +  + λ x_1  x_d - 1  u_d\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.embed-Tuple{Segre, Any}","page":"Segre","title":"ManifoldsBase.embed","text":"embed(M::Segre{𝔽, V}, p)\nembed!(M::Segre{𝔽, V}, q, p)\n\nEmbed p  (λ x_1  x_d) in 𝔽^n_1  n_d using the Kronecker product\n\n(λ x_1  x_d)  λ x_1  x_d\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.get_coordinates-Tuple{Segre, Any, Any, DefaultOrthonormalBasis}","page":"Segre","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Segre{𝔽, V}, p, X, ::DefaultOrthonormalBasis; kwargs...)\n\nGet coordinates of X in the tangent space T_(λ x_1  x_d) mathcalS = mathbbR  T_x_1 mathbbS^n_1 - 1  T_x_d mathbbS^n_d - 1 using a DefaultOrthonormalBasis on each factor.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.get_embedding-Union{Tuple{Segre{𝔽, V}}, Tuple{V}, Tuple{𝔽}} where {𝔽, V}","page":"Segre","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::Segre{𝔽,V})\n\nReturn the embedding of the Segre manifold mathcalS, which is 𝔽^n_1  n_d.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.get_vector-Tuple{Segre, Any, Any, DefaultOrthonormalBasis}","page":"Segre","title":"ManifoldsBase.get_vector","text":"get_vector( M::Segre{𝔽, V}, p, c, DefaultOrthonormalBasis; kwargs...)\n\nGet tangent vector X from coordinates in the tangent space T_(λ x_1  x_d) mathcalS = mathbbR  T_x_1 mathbbS^n_1 - 1  T_x_d mathbbS^n_d - 1 using a DefaultOrthonormalBasis on each factor.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.inner-Tuple{Segre{ℝ}, Any, Any, Any}","page":"Segre","title":"ManifoldsBase.inner","text":"inner(M::Segre{ℝ, V}, p, X, Y,)\n\nInner product between two tangent vectors X = (ν u_1  u_d) and Y = (ξ v_1  v_d) at p  (λ x_1 dots x_d). This inner product is obtained by embedding the Segre manifold in the space of tensors equipped with the Euclidean metric:\n\n    langle X Y rangle_p = nu xi + lambda^2 (langle u_1 v_1 rangle_x_1 + dots + langle u_d v_d rangle_x_d)\n\nwhere ν ξ  T_λ ℝ^+ = ℝ and u_i, v_i  T_x_i mathbbS^n_i - 1  ℝ^n_i.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.is_point-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any}} where V","page":"Segre","title":"ManifoldsBase.is_point","text":"is_point(M::Segre{ℝ, V}, p; kwargs...)\n\nCheck whether p is a valid point on M, i.e. p[1] is a singleton containing a positive number and p[i + 1] is a point on Sphere(V[i]). The tolerance can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.is_vector-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any}} where V","page":"Segre","title":"ManifoldsBase.is_vector","text":"is_vector(M::Segre{ℝ, V}, p, X, kwargs...)\n\nCheck whether X is a tangent vector to p on M, i.e. X has to be of same dimension as p and orthogonal to p. The tolerance can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.riemann_tensor-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Vararg{Any, 4}}} where V","page":"Segre","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::Segre{ℝ, V}, p, X, Y, Z)\n\nRiemann tensor of the Segre manifold at p.\n\nmathcalS is locally a warped product of ℝ^+ and mathbbS^n_1 - 1  mathbbS^n_d - 1. If p  (λ x_1  x_d)  mathcalS and X, Y, Z  T_p (mathbbS^n_1 - 1  mathbbS^n_d - 1)  T_p mathcalS, then\n\n    R_mathcalS(X Y) Z = R_mathbbS^n_1 - 1  mathbbS^n_d - 1(X Y) Z + λ^-2(X Z_p Y - Y Z_p X)\n\nR_mathcalS is zero in the remaining (orthogonal) directions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.sectional_curvature-Union{Tuple{V}, Tuple{Segre{ℝ, V}, Any, Any, Any}} where V","page":"Segre","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(M::Segre{ℝ, V}, p, u, v)\n\nSectional curvature of the Segre manifold at p.\n\nmathcalS is locally a warped product of ℝ^+ and mathbbS^n_1 - 1  mathbbS^n_d - 1 If p  (λ x_1  x_d)  mathcalS, u_i  T_x_i mathbbS^n_i - 1, and v_j  T_x_j mathbbS^n_j - 1, then\n\n    K_mathcalS(u_i v_j) = fracdelta_i j - 1lambda^2\n\nK_mathcalS is zero in the remaining (orthogonal) directions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#segre-warped-metric-sec","page":"Segre","title":"A warped metric","text":"","category":"section"},{"location":"manifolds/segre/#Manifolds.WarpedMetric","page":"Segre","title":"Manifolds.WarpedMetric","text":"WarpedMetric{A} <: AbstractMetric\n\nThe A-warped metric on the Segre manifold mathcalS is a generalization of the Euclidean metric on mathcalS. We denote this manifold by mathcalS_A.\n\nSimilarly to mathcalS, when 𝔽 = ℝ, mathcalS_A is a normal Riemannian covering of the product manifold\n\n    ℝ^+  mathbbS^n_1 - 1  mathbbS^n_d - 1\n\nwith a warped product metric, but the warping function now depends on the warping factor A. A = 1 corresponds to the usual Segre manifold. The Segre manifold is a cone in the sense that if p in mathcalS, then r p in mathcalS for all r neq 0. The tangent subspace at p defined mathrmd (r p)  mathrmd r is called the radial direction. A  1 puts less weight on the directions orthogonal to the radial direction compared to mathcalS, while A  1 puts more weight on those directions.\n\nThe geometry is summarized in [JSVV24].\n\nConstructor\n\nWarpedMetric(A::Real)\n\nGenerate a warped product metric with warping factor A.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/segre/#Base.exp-Union{Tuple{A}, Tuple{V}, Tuple{MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, Any, Any}} where {V, A}","page":"Segre","title":"Base.exp","text":"exp(M::MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, p, X)\n\nExponential map on the warped Segre manifold.\n\nLet p  (λ x_1 x_d)  mathcalS_A and X = (ν u_1 u_d)  T_p mathcalS_A. Then the exponential map is given by\n\n    operatornameexp_p(X) \n    left(\n        sqrt(λ + ν)^2 + (λ A m)^2\n        x_1 cosmathopenBig( fracf lVert u_1 rVert_x_1A m mathcloseBig) + fracu_1lVert u_1 rVert_x_1 sinmathopenBig( fracf lVert u_1 rVert_x_1A m mathcloseBig)\n        \n        x_d cosmathopenBig( fracf lVert u_d rVert_x_dA m mathcloseBig) + fracu_dlVert u_d rVert_x_d sinmathopenBig( fracf lVert u_d rVert_x_dA m mathcloseBig)\n    right)\n\nwhere\n\n    beginaligned\n        f = fracpi2 - tan^-1mathopenBig( fracλ + νλ A m mathcloseBig)\n        m = sqrtlVert u_1 rVert_x_1^2 +  + lVert u_d rVert_x_d^2\n    endaligned\n\nIf m = 0 and -λ  ν, then operatornameexp_p(v) = p + X.\n\nThe formula is derived in proposition 3.1 in [JSVV24].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#Base.log-Union{Tuple{A}, Tuple{V}, Tuple{MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, Any, Any}} where {V, A}","page":"Segre","title":"Base.log","text":"log(M::MetricManifold{ℝ, Segre{ℝ,V}, WarpedMetric{A}}, p, q)\n\nLogarithmic map on the warped Segre manifold.\n\nLet p  (λ x_1 x_d), q  (μ y_1 y_d)  mathcalS_A. Assume p and q are connected by a geodesic. Let\n\n    m = sqrtsphericalangle(x_1 y_1)^2 + + sphericalangle(x_d y_d)^2\n\nand assume (μ y_1 y_d) is the representative of q that minimizes m. Then\n\n    operatornamelog_p(q) =\n    left(\n        mu cosm - lambda\n        (y_1 - x_1 y_1 x_1) fracmu sphericalangle(x_1 y_1) sin(A m)lambda A m sinsphericalangle(x_1 y_1)\n        dots\n        (y_d - x_d y_d x_d) fracmu sphericalangle(x_d y_d) sin(A m)lambda A m sinsphericalangle(x_d y_d)\n    right)\n\nThe formula is derived in theorem 4.4 in [JSVV24].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.distance-Union{Tuple{A}, Tuple{V}, Tuple{MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, Any, Any}} where {V, A}","page":"Segre","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{ℝ, Segre{ℝ,V}, WarpedMetric{A}}, p, q)\n\nRiemannian distance between two points p and q on the warped Segre manifold.\n\nAssume p  (λ x_1 x_d), q  (μ y_1 y_d)  mathcalS_A are connected by a geodesic. Let\n\n    m = sqrtsphericalangle(x_1 y_1)^2 + + sphericalangle(x_d y_d)^2\n\nand assume (μ y_1 y_d) is the representation of q that minimizes m. Then\n\n    operatornamedist_mathcalS_A(p q) = sqrtλ^2 - 2 λ μ cos(A m) + μ^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.get_coordinates-Union{Tuple{A}, Tuple{V}, Tuple{𝔽}, Tuple{MetricManifold{𝔽, Segre{𝔽, V}, WarpedMetric{A}}, Any, Any, DefaultOrthonormalBasis}} where {𝔽, V, A}","page":"Segre","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Segre{𝔽, V}, p, v, ::DefaultOrthonormalBasis; kwargs...)\n\nGet coordinates of X in the tangent space T_(λ x_1 x_d) mathcalS_A = mathbbR  T_x_1 mathbbS^n_1 - 1  T_x_d mathbbS^n_d - 1 using a DefaultOrthonormalBasis on each factor.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.get_vector-Union{Tuple{𝔽}, Tuple{A}, Tuple{V}, Tuple{MetricManifold{𝔽, Segre{𝔽, V}, WarpedMetric{A}}, Any, Any, DefaultOrthonormalBasis}} where {V, A, 𝔽}","page":"Segre","title":"ManifoldsBase.get_vector","text":"get_vector(M::Segre{𝔽, V}, p, c, ::DefaultOrthonormalBasis; kwargs...)\n\nGet tangent vector X from coordinates in the tangent space T_(λ x_1 x_d) mathcalS_A = mathbbR  T_x_1 mathbbS^n_1 - 1  T_x_d mathbbS^n_d - 1 using a DefaultOrthonormalBasis on each factor.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.inner-Union{Tuple{A}, Tuple{V}, Tuple{MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, Any, Any, Any}} where {V, A}","page":"Segre","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, p, X, Y)\n\nInner product between two tangent vectors X = (ν u_1 u_d) and Y = (ξ v_1 v_d) at p doteq (λ x_1 x_d):\n\n    X Y_p = ν ξ + (A λ)^2 ( u_1 v_1 _x_1 + + u_d v_d_x_d)\n\nwhere ν, ξ  T_λ ℝ^+ = ℝ and u_i, v_i  T_x_i mathbbS^n_i - 1 subset ℝ^n_i.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.riemann_tensor-Union{Tuple{A}, Tuple{V}, Tuple{MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, Vararg{Any, 4}}} where {V, A}","page":"Segre","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::MetricManifold{ℝ, Segre{ℝ,V}, WarpedMetric{A}}, p, X, Y)\n\nRiemann tensor of the warped Segre manifold at p.\n\nmathcalS_A is locally a warped product of ℝ^+ and mathbbS^n_1 - 1  mathbbS^n_d - 1. If p  (λ x_1 x_d)  mathcalS_A and X, Y, Z  T_(x_1 x_d) (mathbbS^n_1 - 1  mathbbS^n_d - 1) subset T_p mathcalS_A then\n\n    R_mathcalS_A(X Y) Z = R_mathbbS^n_1 - 1  mathbbS^n_d - 1(X Y) Z + λ^-2( X Z _p Y -  Y Z _p X)\n\nR_mathcalS_A is zero in the remaining (orthogonal) directions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#ManifoldsBase.sectional_curvature-Union{Tuple{A}, Tuple{V}, Tuple{MetricManifold{ℝ, Segre{ℝ, V}, WarpedMetric{A}}, Any, Any, Any}} where {V, A}","page":"Segre","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(M::MetricManifold{ℝ, Segre{ℝ,V}, WarpedMetric{A}}, p, X, Y)\n\nSectional curvature of the warped Segre manifold at p.\n\nmathcalS_A is locally a warped product of ℝ^+ and mathbbS^n_1 - 1  mathbbS^n_d - 1 If p = (λ x_1 x_d)  mathcalS, u_i  T_x_i mathbbS^n_i - 1, and v_j  T_x_j mathbbS^n_j - 1, then\n\n    K_mathcalS_A(u_i v_j) = fracA^-2 delta_i j - 1λ^2\n\nK_mathcalS_A is zero in the remaining (orthogonal) directions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/segre/#Literature","page":"Segre","title":"Literature","text":"","category":"section"},{"location":"manifolds/segre/","page":"Segre","title":"Segre","text":"S. Jacobsson, L. Swijsen, J. V. Veken and N. Vannieuwenhoven. Warped geometries of Segre-Veronese manifolds (2024), arXiv:2410.00664 [math.NA].\n\n\n\n","category":"page"},{"location":"misc/about/#About-Manifolds.jl","page":"About","title":"About Manifolds.jl","text":"","category":"section"},{"location":"misc/about/","page":"About","title":"About","text":"Manifolds.jl was started by Seth Axen, Mateusz Baran, Ronny Bergmann, and Antoine Levitt in 2019, after a very fruitful discussion following the release of the first version of Manopt.jl. The goal of Manifolds.jl is to provide a library of manifolds in Julia. The manifolds are implemented using the ManifoldsBase.jl interface.","category":"page"},{"location":"misc/about/#Main-developers","page":"About","title":"Main developers","text":"","category":"section"},{"location":"misc/about/","page":"About","title":"About","text":"Mateusz Baran\nRonny Bergmann","category":"page"},{"location":"misc/about/#Former-Main-Developers","page":"About","title":"Former Main Developers","text":"","category":"section"},{"location":"misc/about/","page":"About","title":"About","text":"Seth Axen","category":"page"},{"location":"misc/about/#Contributors","page":"About","title":"Contributors","text":"","category":"section"},{"location":"misc/about/","page":"About","title":"About","text":"(in alphabetical order)","category":"page"},{"location":"misc/about/","page":"About","title":"About","text":"Nick Dewaele contributed the Tucker manifold\nRenée Dornig contributed the centered  matrices and the essential manifold\nDavid Hong contributed uniform distributions on the Stiefel and Grassmann manifolds.\nSimon Jacobsson contributed the Segre manifold including its warped metric thereon.\nJohannes Voll Kolstø contributed the symplectic manifold, the symplectic Stiefel manifold\nManuel Weiß contributed symmetric matrices","category":"page"},{"location":"misc/about/","page":"About","title":"About","text":"as well as everyone else reporting, investigating, and fixing bugs or fixing typographical errors in the documentation, see the GitHub contributors page.","category":"page"},{"location":"misc/about/","page":"About","title":"About","text":"Of course all further contributions are always welcome!","category":"page"},{"location":"misc/about/#Projects-using-Manifolds.jl","page":"About","title":"Projects using Manifolds.jl","text":"","category":"section"},{"location":"misc/about/","page":"About","title":"About","text":"Caesar.jl – Robust robotic localization and mapping\nFlowfusion.jl – training and sampling from diffusion and flow matching models\nManoptExamples.jl – collecting examples of optimization problems on manifolds implemented using Manifolds.jl and Manopt.jl.","category":"page"},{"location":"misc/about/","page":"About","title":"About","text":"Do you use Manifolds.jl in you package? Let us know and open an issue or pull request to add it to the list!","category":"page"},{"location":"misc/about/#License","page":"About","title":"License","text":"","category":"section"},{"location":"misc/about/","page":"About","title":"About","text":"MIT License","category":"page"},{"location":"features/testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"features/testing/","page":"Testing","title":"Testing","text":"Documentation for testing utilities for Manifolds.jl. The function test_manifold can be used to verify that your manifold correctly implements the Manifolds.jl interface.","category":"page"},{"location":"features/testing/#Manifolds.test_manifold","page":"Testing","title":"Manifolds.test_manifold","text":"test_manifold(M::AbstractManifold, pts::AbstractVector; kwargs...)\n\nTest general properties of manifold M, given at least three different points that lie on it (contained in pts).\n\nArguments\n\nbasis_has_specialized_diagonalizing_get = false: if true, assumes that   DiagonalizingOrthonormalBasis given in basis_types has   get_coordinates and get_vector that work without caching.\nbasis_types_to_from = (): basis types that will be tested based on   get_coordinates and get_vector.\nbasis_types_vecs = () : basis types that will be tested based on get_vectors\ndefault_inverse_retraction_method = ManifoldsBase.LogarithmicInverseRetraction():   default method for inverse retractions (log.\ndefault_retraction_method = ManifoldsBase.ExponentialRetraction(): default method for   retractions (exp).\nexp_log_atol_multiplier = 0: change absolute tolerance of exp/log tests   (0 use default, i.e. deactivate atol and use rtol).\nexp_log_rtol_multiplier = 1: change the relative tolerance of exp/log tests   (1 use default). This is deactivated if the exp_log_atol_multiplier is nonzero.\nexpected_dimension_type = Integer: expected type of value returned by   manifold_dimension.\ninverse_retraction_methods = []: inverse retraction methods that will be tested.\nis_mutating = true: whether mutating variants of functions should be tested.\nis_point_atol_multiplier = 0: determines atol of is_point checks.\nis_tangent_atol_multiplier = 0: determines atol of is_vector checks.\nhas_get_embedding = false: whether the manifold has a specialized   get_embedding(M, p) method (to test mutating embed!). This is experimental.\nmid_point12 = test_exp_log ? shortest_geodesic(M, pts[1], pts[2], 0.5) : nothing: if not nothing, then check   that mid_point(M, pts[1], pts[2]) is approximately equal to mid_point12. This is   by default set to nothing if text_exp_log is set to false.\npoint_distributions = [] : point distributions to test.\nrand_tvector_atol_multiplier = 0 : chage absolute tolerance in testing random vectors   (0 use default, i.e. deactivate atol and use rtol) random tangent vectors are tangent   vectors.\nretraction_atol_multiplier = 0: change absolute tolerance of (inverse) retraction tests   (0 use default, i.e. deactivate atol and use rtol).\nretraction_rtol_multiplier = 1: change the relative tolerance of (inverse) retraction   tests (1 use default). This is deactivated if the exp_log_atol_multiplier is nonzero.\nretraction_methods = []: retraction methods that will be tested.\ntest_atlases = []: Vector or tuple of atlases that should be tested.\ntest_exp_log = true: if true, check that exp is the inverse of log.\ntest_injectivity_radius = true: whether implementation of injectivity_radius   should be tested.\ntest_inplace = false : if true check if inplace variants work if they are activated,  e.g. check that exp!(M, p, p, X) work if test_exp_log = true.  This in general requires is_mutating to be true.\ntest_is_tangent: if true check that the default_inverse_retraction_method   actually returns valid tangent vectors.\ntest_musical_isomorphisms = false : test musical isomorphisms.\ntest_mutating_rand = false : test the mutating random function for points on manifolds.\ntest_project_point = false: test projections onto the manifold.\ntest_project_tangent = false : test projections on tangent spaces.\ntest_representation_size = true : test representation size of points/tvectprs.\ntest_tangent_vector_broadcasting = true : test boradcasting operators on TangentSpace.\ntest_vector_spaces = true : test Vector bundle of this manifold.\ntest_default_vector_transport = false : test the default vector transport (usually  parallel transport).\ntvector_distributions = [] : tangent vector distributions to test.\nvector_transport_methods = []: vector transport methods that should be tested.\nvector_transport_inverse_retractions = [default_inverse_retraction_method for _ in 1:length(vector_transport_methods)]` inverse retractions to use with the vector transport method (especially the differentiated ones)\nvector_transport_to = [ true for _ in 1:length(vector_transport_methods)]: whether  to check the to variant of vector transport\nvector_transport_direction = [ true for _ in 1:length(vector_transport_methods)]: whether  to check the direction variant of vector transport\n\n\n\n\n\n","category":"function"},{"location":"features/testing/#Manifolds.find_eps","page":"Testing","title":"Manifolds.find_eps","text":"find_eps(x...)\n\nFind an appropriate tolerance for given points or tangent vectors, or their types.\n\n\n\n\n\n","category":"function"},{"location":"features/testing/#Manifolds.test_parallel_transport","page":"Testing","title":"Manifolds.test_parallel_transport","text":"test_parallel_transport(M,P; to=true, direction=true)\n\nGeneric tests for parallel transport on Mgiven at least two pointsin P.\n\nThe single functions to transport to (a point) or (in a) direction are sub-tests that can be activated by the keywords arguments\n\n\n\n\n\n","category":"function"},{"location":"misc/notation/#Notation-overview","page":"Notation","title":"Notation overview","text":"","category":"section"},{"location":"misc/notation/","page":"Notation","title":"Notation","text":"Since manifolds include a reasonable amount of elements and functions, the following list tries to keep an overview of used notation throughout Manifolds.jl. The order is alphabetical by name. They might be used in a plain form within the code or when referring to that code. This is for example the case with the calligraphic symbols.","category":"page"},{"location":"misc/notation/","page":"Notation","title":"Notation","text":"Within the documented functions, the utf8 symbols are used whenever possible, as long as that renders correctly in TeX within this documentation.","category":"page"},{"location":"misc/notation/","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\ntau_p action map by group element p mathrmL_p, mathrmR_p either left or right\noperatornameAd_p(X) adjoint action of element p of a Lie group on the element X of the corresponding Lie algebra  \n Cartesian product of two manifolds  see ProductManifold\n^wedge (n-ary) Cartesian power of a manifold  see PowerManifold\n^mathrmH conjugate/Hermitian transpose  \na coordinates of a point in a chart  see get_parameters\nfracmathrmDmathrmdt covariant derivative of a vector field X(t)  \nT^*_p mathcal M the cotangent space at p  \nξ a cotangent vector from T^*_p mathcal M ξ_1 ξ_2 ηzeta sometimes written with base point ξ_p.\nmathrmdphi_p(q) Differential of a map phi mathcal M  mathcal N with respect to p at a point q. For functions of multiple variables, for example phi(p p_1) where p in mathcal M and p_1 in mathcal M_1, variable p is explicitly stated to specify with respect to which argument the differential is calculated. mathrmdphi_q, (mathrmdphi)_q, (phi_*)_q, D_pphi(q) pushes tangent vectors X in T_q mathcal M forward to mathrmdphi_p(q)X in T_phi(q) mathcal N\nn dimension (of a manifold) n_1n_2ldotsm dim(mathcal M) for the real dimension sometimes also dim_mathbb R(mathcal M)\nd() (Riemannian) distance d_mathcal M() \nexp_p X exponential map at p in mathcal M of a vector X in T_p mathcal M exp_p(X) \nF a fiber  see Fiber\nmathbb F a field, usually mathbb F in mathbb Rmathbb C mathbb H, i.e. the real, complex, and quaternion numbers, respectively.  field a manifold or a basis is based on\ngamma a geodesic gamma_pq, gamma_pX connecting two points pq or starting in p with velocity X.\noperatornamegrad f(p) (Riemannian) gradient of function f colon mathcalM  ℝ at p in mathcalM  \nnabla f(p) (Euclidean) gradient of function f colon mathcalM  ℝ at p in mathcalM but thought of as evaluated in the embedding G \ncirc a group operation  \n^mathrmH Hermitian or conjugate transposed for both complex or quaternion matrices  \noperatornameHess f(p) (Riemannian) Hessian of function f colon T_pmathcalM  T_pmathcal M (i.e. the 1-1-tensor form) at p in mathcalM  \nnabla^2 f(p) (Euclidean) Hessian of function f in the embedding H \ne identity element of a group  \nI_k identity matrix of size kk  \nk indices ij \nlanglerangle inner product (in T_p mathcal M) langlerangle_p g_p() \noperatornameretr^-1_pq an inverse retraction  \nmathfrak g a Lie algebra  \nmathcalG a (Lie) group  \nlog_p q logarithmic map at p in mathcal M of a point q in mathcal M log_p(q) \nmathcal M a manifold mathcal M_1 mathcal M_2ldotsmathcal N \nN_p mathcal M the normal space of the tangent space T_p mathcal M in some embedding mathcal E that should be clear from context  \nV a normal vector from N_p mathcal M W \noperatornameExp the matrix exponential  \noperatornameLog the matrix logarithm  \nmathcal P_qgets pX parallel transport  of the vector X from T_pmathcal M to T_qmathcal M\nmathcal P_pYX parallel transport in direction Y  of the vector X from T_pmathcal M to T_qmathcal M, q = exp_pY\nmathcal P_t_1gets t_0^cX parallel transport along the curve c mathcal P^cX=mathcal P_1gets 0^cX of the vector X from p=c(0) to c(1)\np a point on mathcal M p_1 p_2 ldotsq for 3 points one might use xyz\noperatornameretr_pX a retraction  \nkappa_p(X Y) sectional curvature  \nξ a set of tangent vectors X_1ldotsX_n \nJ_2n in ℝ^2n2n the SymplecticElement  \nT_p mathcal M the tangent space at p  \nX a tangent vector from T_p mathcal M X_1X_2ldotsYZ sometimes written with base point X_p\noperatornametr trace (of a matrix)  \n^mathrmT transposed  \ne_i in mathbb R^n the ith unit vector e_i^n the space dimension (n) is omitted, when clear from context\nB a vector bundle  \nmathcal T_qgets pX vector transport  of the vector X from T_pmathcal M to T_qmathcal M\nmathcal T_pYX vector transport in direction Y  of the vector X from T_pmathcal M to T_qmathcal M, where q is determined by Y, for example using the exponential map or some retraction.\noperatornameVol(mathcal M) volume of manifold mathcal M  \ntheta_p(X) volume density for vector X tangent at point p  \nmathcal W the Weingarten map mathcal W T_pmathcal M  N_pmathcal M  T_pmathcal M mathcal W_p the second notation to emphasize the dependency of the point pinmathcal M\n0_k the kk zero matrix.  ","category":"page"},{"location":"misc/notation/#Comparison-with-notation-commonly-used-in-robotics","page":"Notation","title":"Comparison with notation commonly used in robotics","text":"","category":"section"},{"location":"misc/notation/","page":"Notation","title":"Notation","text":"In robotics, a different notation is commonly used. The table below shows a quick guide how to translate between them for people coming from robotics background. We use [SDA21] as the primary robotics source.","category":"page"},{"location":"misc/notation/","page":"Notation","title":"Notation","text":"Robotics concept Manifolds.jl notation\np circ q compose(G, p, q)\np^-1 inv(G, p)\nmathcalE Identity(G) or identity_element(G)\ngroup action pcdot p_m apply(A, p, p_m)\nLie group exponential expcolon mathfrakg to mathcalG, exp(X)=p exp_lie(G, p)\nLie group logarithm logcolon mathcalG to mathfrakg, log(p)=X log_lie(G, X)\nn-D vector TranslationGroup(n);  its action is TranslationAction(Euclidean(n), TranslationGroup(n))\ncircle S^1 CircleGroup(); its action is ComplexPlanarRotation\nrotation mathrmSO(n) SpecialOrthogonal(n); its action is RotationAction(Euclidean(n), SpecialOrthogonal(n))\nrigid motion mathrmSE(n) SpecialEuclidean(n); its action is RotationTranslationAction(Euclidean(n), SpecialEuclidean(n))\nunit quaternions S^3 UnitaryMatrices(1, H); note that 3-sphere and the group of rotations (with its bi-invariant metric) are homeomorphic but not isomorphic\nsize (as in Table I) related to representation_size(G)\ndim (as in Table I) manifold_dimension(G)\nLie algebra element with coordinates tau^wedge hat(G, Identity(G), tau)\ncoordinates of an element of Lie algebra X^vee vee(G, Identity(G), X)\ncapital exponential map operatornameExp exp_lie(G, hat(G, Identity(G), tau))\ncapital logarithmic map operatornameLog vee(G, Identity(G), log_lie(G, p))\nright-oplus, p oplus tau compose(G, exp_lie(G, hat(G, Identity(G), tau)))\nright-ominus, p ominus q vee(G, Identity(G), log_lie(G, compose(G, inv(G, q), p)))\nleft-oplus, tau oplus p compose(G, exp_lie(G, hat(G, Identity(G), tau)), p)\nleft-ominus, p ominus q vee(G, Identity(G), log_lie(G, compose(G, p, inv(G, q))))\nadjoint mathrmAd_p(tau^wedge) adjoint_action(G, p, hat(G, Identity(G), tau))\nadjoint matrix mathrmAd_p adjoint_matrix(G, p)\nJacobian of group inversion and composition these can be easily constructed from the adjoint matrix\nleft and right Jacobians of a function In JuliaManifolds there is always one preferred way to store tangent vectors specified by each manifold, and so we follow the standard mathematical convention of having one Jacobian which follows the selected tangent vector storage convention. See for example jacobian_exp_argument, jacobian_exp_basepoint, jacobian_log_argument, jacobian_log_basepoint from ManifoldDiff.jl.\nleft and right Jacobians (of a group) mathbfJ_l mathbfJ_r jacobian_exp_argument for exponential coordinates. For other coordinate systems no replacement is available yet.\nJacobians of group actions not available yet","category":"page"},{"location":"misc/notation/","page":"Notation","title":"Notation","text":"Be also careful that the meaning of mathbfx is inconsistent in Table I from [SDA21]. It's a complex number for circle, quaternion for quaternion rotation and column vectors for other rows.","category":"page"},{"location":"manifolds/symmetricpsdfixedrank/#Symmetric-Positive-Semidefinite-Matrices-of-Fixed-Rank","page":"Symmetric positive semidefinite fixed rank","title":"Symmetric Positive Semidefinite Matrices of Fixed Rank","text":"","category":"section"},{"location":"manifolds/symmetricpsdfixedrank/#Manifolds.SymmetricPositiveSemidefiniteFixedRank","page":"Symmetric positive semidefinite fixed rank","title":"Manifolds.SymmetricPositiveSemidefiniteFixedRank","text":"SymmetricPositiveSemidefiniteFixedRank{T,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold  operatornameSPS_k(n) consisting of the real- or complex-valued symmetric positive semidefinite matrices of size nn and rank k, i.e. the set\n\noperatornameSPS_k(n) = bigl\np   𝔽^nn big p^mathrmH = p\napa^mathrmH geq 0 text for all  a  𝔽\ntext and  operatornamerank(p) = kbigr\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ. We sometimes operatornameSPS_k𝔽(n), when distinguishing the real- and complex-valued manifold is important.\n\nAn element is represented by q  𝔽^nk from the factorization p = qq^mathrmH. Note that since for any unitary (orthogonal) A  𝔽^nn we have (Aq)(Aq)^mathrmH = qq^mathrmH = p, the representation is not unique, or in other words, the manifold is a quotient manifold of 𝔽^nk.\n\nThe tangent space at p, T_poperatornameSPS_k(n), is also represented by matrices Y  𝔽^nk and reads as\n\nT_poperatornameSPS_k(n) = bigl\nX  𝔽^nnX = qY^mathrmH + Yq^mathrmH\ntext ie  X = X^mathrmH\nbigr\n\nNote that the metric used yields a non-complete manifold. The metric was used in [JBAS10][MA20].\n\nConstructor\n\nSymmetricPositiveSemidefiniteFixedRank(n::Int, k::Int, field::AbstractNumbers=ℝ; parameter::Symbol=:type)\n\nGenerate the manifold of nn symmetric positive semidefinite matrices of rank k over the field of real numbers ℝ or complex numbers ℂ.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpsdfixedrank/#Base.exp-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.exp","text":"exp(M::SymmetricPositiveSemidefiniteFixedRank, q, Y)\n\nCompute the exponential map on the SymmetricPositiveSemidefiniteFixedRank, which just reads\n\n    exp_q Y = q+Y\n\nnote: Note\nSince the manifold is represented in the embedding and is a quotient manifold, the exponential and logarithmic map are a bijection only with respect to the equivalence classes. Computing    q_2 = exp_p(log_pq)might yield a matrix q_2neq q, but they represent the same point on the quotient manifold, i.e. d_operatornameSPS_k(n)(q_2q) = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#Base.log-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.log","text":"log(M::SymmetricPositiveSemidefiniteFixedRank, q, p)\n\nCompute the logarithmic map on the SymmetricPositiveSemidefiniteFixedRank manifold by minimizing lVert p - qYrVert with respect to Y.\n\nnote: Note\nSince the manifold is represented in the embedding and is a quotient manifold, the exponential and logarithmic map are a bijection only with respect to the equivalence classes. Computing    q_2 = exp_p(log_pq)might yield a matrix q_2q, but they represent the same point on the quotient manifold, i.e. d_operatornameSPS_k(n)(q_2q) = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase._isapprox-Union{Tuple{T}, Tuple{SymmetricPositiveSemidefiniteFixedRank, T, Any}} where T","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase._isapprox","text":"isapprox(M::SymmetricPositiveSemidefiniteFixedRank, p, q; kwargs...)\n\ntest, whether two points p, q are (approximately) nearly the same. Since this is a quotient manifold in the embedding, the test is performed by checking their distance, if they are not the same, i.e. that d_mathcal M(pq) approx 0, where the comparison is performed with the classical isapprox. The kwargs... are passed on to this accordingly.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase.check_point-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.check_point","text":"check_point(M::SymmetricPositiveSemidefiniteFixedRank, q; kwargs...)\n\nCheck whether q is a valid manifold point on the SymmetricPositiveSemidefiniteFixedRank M, i.e. whether p=q*q' is a symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽. The symmetry of p is not explicitly checked since by using q p is symmetric by construction. The tolerance for the symmetry of p can and the rank of q*q' be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase.check_vector-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymmetricPositiveSemidefiniteFixedRank, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SymmetricPositiveSemidefiniteFixedRank M, i.e. X has to be a symmetric matrix of size (n,n) and its values have to be from the correct AbstractNumbers.\n\nDue to the reduced representation this is fulfilled as soon as the matrix is of correct size.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase.distance-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.distance","text":"distance(M::SymmetricPositiveSemidefiniteFixedRank, p, q)\n\nCompute the distance between two points p, q on the SymmetricPositiveSemidefiniteFixedRank, which is the Frobenius norm of Y which minimizes lVert p - qYrVert with respect to Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase.is_flat-Tuple{SymmetricPositiveSemidefiniteFixedRank}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.is_flat","text":"is_flat(::SymmetricPositiveSemidefiniteFixedRank)\n\nReturn false. SymmetricPositiveSemidefiniteFixedRank is not a flat manifold. See Theorem A.18 in [MA20].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase.manifold_dimension-Tuple{SymmetricPositiveSemidefiniteFixedRank}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricPositiveSemidefiniteFixedRank)\n\nReturn the dimension of the SymmetricPositiveSemidefiniteFixedRank matrix M over the number system 𝔽, i.e.\n\nbeginaligned\ndim operatornameSPS_kℝ(n) = kn - frack(k-1)2\ndim operatornameSPS_kℂ(n) = 2kn - k^2\nendaligned\n\nwhere the last k^2 is due to the zero imaginary part for Hermitian matrices diagonal\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase.vector_transport_to-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any, Any, ProjectionTransport}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::SymmetricPositiveSemidefiniteFixedRank, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank/#ManifoldsBase.zero_vector-Tuple{SymmetricPositiveSemidefiniteFixedRank, Vararg{Any}}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.zero_vector","text":" zero_vector(M::SymmetricPositiveSemidefiniteFixedRank, p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the SymmetricPositiveSemidefiniteFixedRank manifold M.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#atlases_and_charts","page":"Atlases and charts","title":"Atlases and charts","text":"","category":"section"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"Atlases on an n-dimensional manifold mathcal Mare collections of charts mathcal A = (U_i φ_i) colon i in I, where I is a (finite or infinite) index family, such that U_i subseteq mathcal M is an open set and each chart φ_i U_i  ℝ^n is a homeomorphism. This means, that φ_i is bijective – sometimes also called one-to-one and onto - and continuous, and its inverse φ_i^-1 is continuous as well. The inverse φ_i^-1 is called (local) parametrization. The resulting parameters a=φ(p) of p (with respect to the chart φ) are in the literature also called “(local) coordinates”. To distinguish the parameter a from  get_coordinates in a basis, we use the terminology parameter in this package.","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"For an atlas mathcal A we further require that","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"displaystylebigcup_iin I U_i = mathcal M","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"We say that φ_i is a chart about p, if pin U_i. An atlas provides a connection between a manifold and the Euclidean space ℝ^n, since locally, a chart about p can be used to identify its neighborhood (as long as you stay in U_i) with a subset of a Euclidean space. Most manifolds we consider are smooth, i.e. any change of charts φ_i circ φ_j^-1 ℝ^n  ℝ^n, where ijin I, is a smooth function. These changes of charts are also called transition maps.","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"Most operations on manifolds in Manifolds.jl avoid operating in a chart through appropriate embeddings and formulas derived for particular manifolds, though atlases provide the most general way of working with manifolds. Compared to these approaches, using an atlas is often more technical and time-consuming. They are extensively used in metric-related functions on MetricManifolds.","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"Atlases are represented by objects of subtypes of AbstractAtlas. There are no type restrictions for indices of charts in atlases.","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"Operations using atlases and charts are available through the following functions:","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"get_chart_index can be used to select an appropriate chart for the neighborhood of a given point p. This function should work deterministically, i.e. for a fixed p always return the same chart.\nget_parameters converts a point to its parameters with respect to the chart in a chart.\nget_point converts parameters (local coordinates) in a chart to the point that corresponds to them.\ninduced_basis returns a basis of a given vector space at a point induced by a chart φ.\ntransition_map converts coordinates of a point between two charts, e.g. computes φ_icirc φ_j^-1 ℝ^n  ℝ^n, ijin I.","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"While an atlas could store charts as explicit functions, it is favourable, that the [get_parameters] actually implements a chart φ, get_point its inverse, the prametrization φ^-1.","category":"page"},{"location":"features/atlases/#Manifolds.AbstractAtlas","page":"Atlases and charts","title":"Manifolds.AbstractAtlas","text":"AbstractAtlas{𝔽}\n\nAn abstract class for atlases whith charts that have values in the vector space 𝔽ⁿ for some value of n. 𝔽 is a number system determined by an AbstractNumbers object.\n\n\n\n\n\n","category":"type"},{"location":"features/atlases/#Manifolds.InducedBasis","page":"Atlases and charts","title":"Manifolds.InducedBasis","text":"InducedBasis(vs::VectorSpaceType, A::AbstractAtlas, i)\n\nThe basis induced by chart with index i from an AbstractAtlas A of vector space of type vs.\n\nFor the vs a TangentSpace this works as  follows:\n\nLet n denote the dimension of the manifold mathcal M.\n\nLet the parameter a=φ_i(p)  mathbb R^n and j1n. We can look at the jth parameter curve b_j(t) = a + te_j, where e_j denotes the jth unit vector. Using the parametrisation we obtain a curve c_j(t) = φ_i^-1(b_j(t)) which fulfills c(0) = p.\n\nNow taking the derivative(s) with respect to t (and evaluate at t=0), we obtain a tangent vector for each j corresponding to an equivalence class of curves (having the same derivative) as\n\nX_j = c_j = fracmathrmdmathrmdt c_i(t) Bigl_t=0\n\nand the set X_1ldotsX_n is the chart-induced basis of T_pmathcal M.\n\nSee also\n\nVectorSpaceType, AbstractBasis\n\n\n\n\n\n","category":"type"},{"location":"features/atlases/#Manifolds.RetractionAtlas","page":"Atlases and charts","title":"Manifolds.RetractionAtlas","text":"RetractionAtlas{\n    𝔽,\n    TRetr<:AbstractRetractionMethod,\n    TInvRetr<:AbstractInverseRetractionMethod,\n    TBasis<:AbstractBasis,\n} <: AbstractAtlas{𝔽}\n\nAn atlas indexed by points on a manifold, mathcal M = I and parameters (local coordinates) are given in T_pmathcal M. This means that a chart φ_p = mathrmcordcircmathrmretr_p^-1 is only locally defined (around p), where mathrmcord is the decomposition of the tangent vector into coordinates with respect to the given basis of the tangent space, cf. get_coordinates. The parametrization is given by φ_p^-1=mathrmretr_pcircmathrmvec, where mathrmvec turns the basis coordinates into a tangent vector, cf. get_vector.\n\nIn short: The coordinates with respect to a basis are used together with a retraction as a parametrization.\n\nSee also\n\nAbstractAtlas, AbstractInverseRetractionMethod, AbstractRetractionMethod, AbstractBasis\n\n\n\n\n\n","category":"type"},{"location":"features/atlases/#LinearAlgebra.norm-Tuple{AbstractManifold, AbstractAtlas, Any, Any, Any}","page":"Atlases and charts","title":"LinearAlgebra.norm","text":"norm(M::AbstractManifold, A::AbstractAtlas, i, a, Xc)\n\nCalculate norm on manifold M at point with parameters a in chart i of an AbstractAtlas A of vector with coefficients Xc in induced basis.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.affine_connection!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}","page":"Atlases and charts","title":"Manifolds.affine_connection!","text":"affine_connection!(M::AbstractManifold, Zc, A::AbstractAtlas, i, a, Xc, Yc)\n\nCalculate affine connection on manifold M at point with parameters a in chart i of an an AbstractAtlas A of vectors with coefficients Zc and Yc in induced basis and save the result in Zc.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.affine_connection-Tuple{AbstractManifold, Vararg{Any, 5}}","page":"Atlases and charts","title":"Manifolds.affine_connection","text":"affine_connection(M::AbstractManifold, A::AbstractAtlas, i, a, Xc, Yc)\n\nCalculate affine connection on manifold M at point with parameters a in chart i of AbstractAtlas A of vectors with coefficients Xc and Yc in induced basis.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.check_chart_switch-Tuple{AbstractManifold, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.check_chart_switch","text":"check_chart_switch(M::AbstractManifold, A::AbstractAtlas, i, a)\n\nDetermine whether chart should be switched when an operation in chart i from an AbstractAtlas A reaches parameters a in that chart.\n\nBy default false is returned.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.get_chart_index","text":"get_chart_index(M::AbstractManifold, A::AbstractAtlas, i, a)\n\nSelect a chart from an AbstractAtlas A for manifold M that is suitable for representing the neighborhood of point with parametrization a in chart i. This selection should be deterministic, although different charts may be selected for arbitrarily close but distinct points.\n\nSee also\n\nget_default_atlas\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any}","page":"Atlases and charts","title":"Manifolds.get_chart_index","text":"get_chart_index(M::AbstractManifold, A::AbstractAtlas, p)\n\nSelect a chart from an AbstractAtlas A for manifold M that is suitable for representing the neighborhood of point p. This selection should be deterministic, although different charts may be selected for arbitrarily close but distinct points.\n\nSee also\n\nget_default_atlas\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.get_default_atlas-Tuple{AbstractManifold}","page":"Atlases and charts","title":"Manifolds.get_default_atlas","text":"get_default_atlas(::AbstractManifold)\n\nDetermine the default real-valued atlas for the given manifold.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.get_parameters","text":"get_parameters(M::AbstractManifold, A::AbstractAtlas, i, p)\n\nCalculate parameters (local coordinates) of point p on manifold M in chart from an AbstractAtlas A at index i. This function is hence an implementation of the chart φ_i(p) iin I. The parameters are in the number system determined by A. If the point pnotin U_i is not in the domain of the chart, this method should throw an error.\n\nSee also\n\nget_point, get_chart_index\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.get_point","text":"get_point(M::AbstractManifold, A::AbstractAtlas, i, a)\n\nCalculate point at parameters (local coordinates) a on manifold M in chart from an AbstractAtlas A at index i. This function is hence an implementation of the inverse φ_i^-1(a) iin I of a chart, also called a parametrization.\n\nSee also\n\nget_parameters, get_chart_index\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.induced_basis-Tuple{AbstractManifold, AbstractAtlas, Any, VectorSpaceType}","page":"Atlases and charts","title":"Manifolds.induced_basis","text":"induced_basis(M::AbstractManifold, A::AbstractAtlas, i, p, VST::VectorSpaceType)\n\nBasis of vector space of type VST at point p from manifold M induced by chart (A, i).\n\nSee also\n\nVectorSpaceType, AbstractAtlas\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.induced_basis-Union{Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, AbstractAtlas, Any}, Tuple{AbstractManifold{𝔽}, AbstractAtlas, Any, VectorSpaceType}} where 𝔽","page":"Atlases and charts","title":"Manifolds.induced_basis","text":"induced_basis(::AbstractManifold, A::AbstractAtlas, i, VST::VectorSpaceType = TangentSpaceType())\n\nGet the basis induced by chart with index i from an AbstractAtlas A of vector space of type vs. Returns an object of type InducedBasis.\n\nSee also\n\nVectorSpaceType, AbstractBasis\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.inverse_chart_injectivity_radius-Tuple{AbstractManifold, AbstractAtlas, Any}","page":"Atlases and charts","title":"Manifolds.inverse_chart_injectivity_radius","text":"inverse_chart_injectivity_radius(M::AbstractManifold, A::AbstractAtlas, i)\n\nInjectivity radius of get_point for chart i from an AbstractAtlas A of a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.local_metric-Tuple{AbstractManifold, Any, InducedBasis}","page":"Atlases and charts","title":"Manifolds.local_metric","text":"local_metric(M::AbstractManifold, p, B::InducedBasis)\n\nCompute the local metric tensor for vectors expressed in terms of coordinates in basis B on manifold M. The point p is not checked.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.transition_map-Tuple{AbstractManifold, AbstractAtlas, Any, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.transition_map","text":"transition_map(M::AbstractManifold, A_from::AbstractAtlas, i_from, A_to::AbstractAtlas, i_to, a)\ntransition_map(M::AbstractManifold, A::AbstractAtlas, i_from, i_to, a)\n\nGiven coordinates a in chart (A_from, i_from) of a point on manifold M, returns coordinates of that point in chart (A_to, i_to). If A_from and A_to are equal, A_to can be omitted.\n\nMathematically this function is the transition map or change of charts, but it might even be between two atlases A_textfrom = (U_iφ_i)_iin I and A_textto = (V_jpsi_j)_jin J, and hence I J are their index sets. We have i_textfromin I, i_texttoin J.\n\nThis method then computes\n\nbigl(psi_i_texttocirc φ_i_textfrom^-1bigr)(a)\n\nNote that, similarly to get_parameters, this method should fail the same way if V_i_texttocap U_i_textfrom=emptyset.\n\nSee also\n\nAbstractAtlas, get_parameters, get_point\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.transition_map_diff!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}","page":"Atlases and charts","title":"Manifolds.transition_map_diff!","text":"transition_map_diff!(M::AbstractManifold, c_out, A::AbstractAtlas, i_from, a, c, i_to)\n\nCompute transition_map_diff on given arguments and save the result in c_out.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.transition_map_diff-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}","page":"Atlases and charts","title":"Manifolds.transition_map_diff","text":"transition_map_diff(M::AbstractManifold, A::AbstractAtlas, i_from, a, c, i_to)\n\nCompute differential of transition map from chart i_from to chart i_to from an AbstractAtlas A on manifold M at point with parameters a on tangent vector with coordinates c in the induced basis.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#ManifoldsBase.inner-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}","page":"Atlases and charts","title":"ManifoldsBase.inner","text":"inner(M::AbstractManifold, A::AbstractAtlas, i, a, Xc, Yc)\n\nCalculate inner product on manifold M at point with parameters a in chart i of an atlas A of vectors with coefficients Xc and Yc in induced basis.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Cotangent-space-and-musical-isomorphisms","page":"Atlases and charts","title":"Cotangent space and musical isomorphisms","text":"","category":"section"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"Related to atlases, there is also support for the cotangent space and coefficients of cotangent vectors in bases of the cotangent space.","category":"page"},{"location":"features/atlases/","page":"Atlases and charts","title":"Atlases and charts","text":"Functions sharp and flat implement musical isomorphisms for arbitrary vector bundles.","category":"page"},{"location":"features/atlases/#Manifolds.RieszRepresenterCotangentVector","page":"Atlases and charts","title":"Manifolds.RieszRepresenterCotangentVector","text":"RieszRepresenterCotangentVector(M::AbstractManifold, p, X)\n\nCotangent vector in Riesz representer form on manifold M at point p with Riesz representer X.\n\n\n\n\n\n","category":"type"},{"location":"features/atlases/#Manifolds.flat-Tuple{AbstractManifold, Any, Any}","page":"Atlases and charts","title":"Manifolds.flat","text":"flat(M::AbstractManifold, p, X)\n\nCompute the flat isomorphism (one of the musical isomorphisms) of tangent vector X from the vector space of type M at point p from the underlying AbstractManifold.\n\nThe function can be used for example to transform vectors from the tangent bundle to vectors from the cotangent bundle   Tmathcal M  T^*mathcal M\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Manifolds.sharp-Tuple{AbstractManifold, Any, Any}","page":"Atlases and charts","title":"Manifolds.sharp","text":"sharp(M::AbstractManifold, p, ξ)\n\nCompute the sharp isomorphism (one of the musical isomorphisms) of vector ξ from the vector space M at point p from the underlying AbstractManifold.\n\nThe function can be used for example to transform vectors from the cotangent bundle to vectors from the tangent bundle   T^*mathcal M  Tmathcal M\n\n\n\n\n\n","category":"method"},{"location":"features/atlases/#Computations-in-charts","page":"Atlases and charts","title":"Computations in charts","text":"","category":"section"},{"location":"features/atlases/#Manifolds.IntegratorTerminatorNearChartBoundary","page":"Atlases and charts","title":"Manifolds.IntegratorTerminatorNearChartBoundary","text":"IntegratorTerminatorNearChartBoundary{TKwargs}\n\nAn object for determining the point at which integration of a differential equation in a chart on a manifold should be terminated for the purpose of switching a chart.\n\nThe value stored in check_chart_switch_kwargs will be passed as keyword arguments to  check_chart_switch. By default an empty tuple is stored.\n\n\n\n\n\n","category":"type"},{"location":"features/atlases/#Manifolds.estimate_distance_from_bvp","page":"Atlases and charts","title":"Manifolds.estimate_distance_from_bvp","text":"estimate_distance_from_bvp(\n    M::AbstractManifold, a1, a2, A::AbstractAtlas, i;\n    solver=MIRK4(), dt=0.05, kwargs...\n)\n\nEstimate distance between points on AbstractManifold M with parameters a1 and a2 in chart i of AbstractAtlas A using solver solver, employing solve_chart_log_bvp to solve the geodesic BVP.\n\n\n\n\n\n","category":"function"},{"location":"features/atlases/#Manifolds.solve_chart_exp_ode","page":"Atlases and charts","title":"Manifolds.solve_chart_exp_ode","text":"solve_chart_exp_ode(\n    M::AbstractManifold, a, Xc, A::AbstractAtlas, i0;\n    solver=AutoVern9(Rodas5()),\n    final_time::Real=1.0,\n    check_chart_switch_kwargs=NamedTuple(),\n    kwargs...,\n)\n\nSolve geodesic ODE on a manifold M from point of coordinates a in chart i0 from an AbstractAtlas A in direction of coordinates Xc in the induced basis. The geodesic is solved up to time final_time (by default equal to 1).\n\nChart switching\n\nIf the solution exceeds the domain of chart i0 (which is detected using the check_chart_switch function with additional keyword arguments check_chart_switch_kwargs), a new chart is selected using get_chart_index on the final point in the old chart.\n\nReturned value\n\nThe function returns an object of type StitchedChartSolution{:Exp} to represent the geodesic.\n\n\n\n\n\n","category":"function"},{"location":"features/atlases/#Manifolds.solve_chart_log_bvp","page":"Atlases and charts","title":"Manifolds.solve_chart_log_bvp","text":"solve_chart_log_bvp(\n    M::AbstractManifold, a1, a2, A::AbstractAtlas, i;\n    solver=MIRK4(), dt::Real=0.05, kwargs...\n)\n\nSolve the BVP corresponding to geodesic calculation on AbstractManifold M, between points with parameters a1 and a2 in a chart i of an AbstractAtlas A using solver solver. Geodesic γ is sampled at time interval dt, with γ(0) = a1 and γ(1) = a2.\n\n\n\n\n\n","category":"function"},{"location":"features/atlases/#Manifolds.solve_chart_parallel_transport_ode","page":"Atlases and charts","title":"Manifolds.solve_chart_parallel_transport_ode","text":"solve_chart_parallel_transport_ode(\n    M::AbstractManifold, a, Xc, A::AbstractAtlas, i0, Yc;\n    solver=AutoVern9(Rodas5()), check_chart_switch_kwargs=NamedTuple(), final_time=1.0,\n    kwargs...\n)\n\nParallel transport vector with coordinates Yc along geodesic on a manifold M from point of coordinates a in a chart i0 from an AbstractAtlas A in direction of coordinates Xc in the induced basis.\n\n\n\n\n\n","category":"function"},{"location":"features/differentiation/#Differentiation","page":"Differentiation","title":"Differentiation","text":"","category":"section"},{"location":"features/differentiation/","page":"Differentiation","title":"Differentiation","text":"Documentation for Manifolds.jl's methods and types for finite differences and automatic differentiation.","category":"page"},{"location":"features/differentiation/#Differentiation-backends","page":"Differentiation","title":"Differentiation backends","text":"","category":"section"},{"location":"features/differentiation/","page":"Differentiation","title":"Differentiation","text":"Further differentiation backends and features are available in ManifoldDiff.jl.","category":"page"},{"location":"features/differentiation/#FiniteDifferenes.jl","page":"Differentiation","title":"FiniteDifferenes.jl","text":"","category":"section"},{"location":"features/differentiation/#Riemannian-differentiation-backends","page":"Differentiation","title":"Riemannian differentiation backends","text":"","category":"section"},{"location":"manifolds/flag/#Flag-manifold","page":"Flag","title":"Flag manifold","text":"","category":"section"},{"location":"manifolds/flag/#Manifolds.Flag","page":"Flag","title":"Manifolds.Flag","text":"Flag{T,d} <: AbstractDecoratorManifold{ℝ}\n\nFlag manifold of d subspaces of ℝ^N [YWL21]. By default the manifold uses the Stiefel coordinates representation, embedding it in the Stiefel manifold. The other available representation is an embedding in OrthogonalMatrices. It can be utilized using OrthogonalPoint and OrthogonalTangentVector wrappers.\n\nTangent space is represented in the block-skew-symmetric form.\n\nConstructor\n\nFlag(N, n1, n2, ..., nd; parameter::Symbol=:type)\n\nGenerate the manifold operatornameFlag(n_1 n_2  n_d N) of subspaces\n\n𝕍_1  𝕍_2    V_d quad operatornamedim(𝕍_i) = n_i\n\nwhere 𝕍_i for i  1 2  d are subspaces of ℝ^N of dimension operatornamedim 𝕍_i = n_i.\n\nparameter: whether a type parameter should be used to store n. By default size is stored in type. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/flag/#Manifolds.OrthogonalPoint","page":"Flag","title":"Manifolds.OrthogonalPoint","text":"OrthogonalPoint <: AbstractManifoldPoint\n\nA type to represent points on a manifold Flag in the orthogonal coordinates representation, i.e. a rotation matrix.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/flag/#Manifolds.OrthogonalTangentVector","page":"Flag","title":"Manifolds.OrthogonalTangentVector","text":"OrthogonalTangentVector <: AbstractTangentVector\n\nA type to represent tangent vectors to points on a Flag manifold  in the orthogonal coordinates representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/flag/#Manifolds.ZeroTuple","page":"Flag","title":"Manifolds.ZeroTuple","text":"ZeroTuple\n\nInternal structure for representing shape of a Flag manifold. Behaves like a normal tuple, except at index zero returns value 0.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/flag/#Base.convert-Tuple{Type{AbstractMatrix}, Flag, OrthogonalPoint, OrthogonalTangentVector}","page":"Flag","title":"Base.convert","text":"convert(::Type{AbstractMatrix}, M::Flag, p::OrthogonalPoint, X::OrthogonalTangentVector)\n\nConvert tangent vector from Flag manifold M from orthogonal representation to Stiefel representation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#Base.convert-Tuple{Type{AbstractMatrix}, Flag, OrthogonalPoint}","page":"Flag","title":"Base.convert","text":"convert(::Type{AbstractMatrix}, M::Flag, p::OrthogonalPoint)\n\nConvert point p from Flag manifold M from orthogonal representation to Stiefel representation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#Base.convert-Tuple{Type{OrthogonalPoint}, Flag, AbstractMatrix}","page":"Flag","title":"Base.convert","text":"convert(::Type{OrthogonalPoint}, M::Flag, p::AbstractMatrix)\n\nConvert point p from Flag manifold M from Stiefel representation to orthogonal representation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#Base.convert-Tuple{Type{OrthogonalTangentVector}, Flag, AbstractMatrix, AbstractMatrix}","page":"Flag","title":"Base.convert","text":"convert(::Type{OrthogonalTangentVector}, M::Flag, p::AbstractMatrix, X::AbstractMatrix)\n\nConvert tangent vector from Flag manifold M from Stiefel representation to orthogonal representation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.get_embedding-Union{Tuple{Flag{Tuple{Int64}, dp1}}, Tuple{dp1}} where dp1","page":"Flag","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::Flag)\n\nGet the embedding of the Flag manifold M, i.e. the Stiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.injectivity_radius-Tuple{Flag}","page":"Flag","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Flag)\ninjectivity_radius(M::Flag, p)\n\nReturn the injectivity radius on the Flag M, which is fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.manifold_dimension-Union{Tuple{Flag{<:Any, dp1}}, Tuple{dp1}} where dp1","page":"Flag","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Flag)\n\nReturn dimension of flag manifold operatornameFlag(n_1 n_2  n_d N). The formula reads sum_i=1^d (n_i-n_i-1)(N-n_i).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#The-flag-manifold-represented-as-points-on-the-[Stiefel](@ref)-manifold","page":"Flag","title":"The flag manifold represented as points on the Stiefel manifold","text":"","category":"section"},{"location":"manifolds/flag/#ManifoldsBase.check_vector-Union{Tuple{dp1}, Tuple{Flag{<:Any, dp1}, AbstractMatrix, AbstractMatrix}} where dp1","page":"Flag","title":"ManifoldsBase.check_vector","text":"check_vector(M::Flag, p::AbstractMatrix, X::AbstractMatrix; kwargs... )\n\nCheck whether X is a tangent vector to point p on the Flag manifold M operatornameFlag(n_1 n_2  n_d N) in the Stiefel representation, i.e. that X is a matrix of the form\n\nX = beginbmatrix\n0                      B_12                  B_1d \n-B_12^mathrmT    0                        B_2d \nvdots                 vdots                   vdots  \n-B_1d^mathrmT    -B_2d^mathrmT      0       \n-B_1d+1^mathrmT  -B_2d+1^mathrmT    -B_dd+1^mathrmT\nendbmatrix\n\nwhere B_ij  ℝ^(n_i - n_i-1)  (n_j - n_j-1), for  1  i  j  d+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.default_inverse_retraction_method-Tuple{Flag}","page":"Flag","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::Flag)\n\nReturn PolarInverseRetraction as the default inverse retraction for the Flag manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.default_retraction_method-Tuple{Flag}","page":"Flag","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::Flag)\n\nReturn PolarRetraction as the default retraction for the Flag manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.default_vector_transport_method-Tuple{Flag}","page":"Flag","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::Flag)\n\nReturn the ProjectionTransport as the default vector transport method for the Flag manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.inverse_retract-Tuple{Flag, Any, Any, PolarInverseRetraction}","page":"Flag","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Flag, p, q, ::PolarInverseRetraction)\n\nCompute the inverse retraction for the PolarRetraction, on the Flag manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.project-Tuple{Flag, Any, Any}","page":"Flag","title":"ManifoldsBase.project","text":"project(::Flag, p, X)\n\nProject vector X in the Euclidean embedding to the tangent space at point p on Flag manifold. The formula reads [YWL21]:\n\nY_i = X_i - (p_i p_i^mathrmT) X_i + sum_j neq i p_j X_j^mathrmT p_i\n\nfor i from 1 to d where the resulting vector is Y = Y_1 Y_2  Y_d and X = X_1 X_2  X_d, p = p_1 p_2  p_d are decompositions into basis vector matrices for consecutive subspaces of the flag.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.retract-Tuple{Flag, Any, Any, PolarRetraction}","page":"Flag","title":"ManifoldsBase.retract","text":"retract(M::Flag, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Flag M. With USV = p + X the retraction reads\n\noperatornameretr_p X = UV^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#The-flag-manifold-represented-as-orthogonal-matrices","page":"Flag","title":"The flag manifold represented as orthogonal matrices","text":"","category":"section"},{"location":"manifolds/flag/#ManifoldsBase.check_vector-Union{Tuple{dp1}, Tuple{Flag{<:Any, dp1}, OrthogonalPoint, OrthogonalTangentVector}} where dp1","page":"Flag","title":"ManifoldsBase.check_vector","text":"check_vector(M::Flag, p::OrthogonalPoint, X::OrthogonalTangentVector; kwargs... )\n\nCheck whether X is a tangent vector to point p on the Flag manifold M operatornameFlag(n_1 n_2  n_d N) in the orthogonal matrix representation, i.e. that X is block-skew-symmetric with zero diagonal:\n\nX = beginbmatrix\n0                      B_12                  B_1d+1 \n-B_12^mathrmT    0                        B_2d+1 \nvdots                 vdots                   vdots    \n-B_1d+1^mathrmT  -B_2d+1^mathrmT    0\nendbmatrix\n\nwhere B_ij  ℝ^(n_i - n_i-1)  (n_j - n_j-1), for  1  i  j  d+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.get_embedding-Union{Tuple{N}, Tuple{Flag{ManifoldsBase.TypeParameter{Tuple{N}}}, Type{<:OrthogonalPoint}}} where N","page":"Flag","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::Flag, p::OrthogonalPoint)\n\nGet embedding of Flag manifold M, i.e. the manifold OrthogonalMatrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.project-Union{Tuple{dp1}, Tuple{Flag{<:Any, dp1}, OrthogonalPoint, OrthogonalTangentVector}} where dp1","page":"Flag","title":"ManifoldsBase.project","text":"project(M::Flag, p::OrthogonalPoint, X::OrthogonalTangentVector)\n\nProject vector X to tangent space at point p from Flag manifold M operatornameFlag(n_1 n_2  n_d N), in the orthogonal matrix representation. It works by first projecting X to the space of SkewHermitianMatrices and then setting diagonal blocks to 0:\n\nX = beginbmatrix\n0                      B_12                  B_1d+1 \n-B_12^mathrmT    0                        B_2d+1 \nvdots                 vdots                   vdots    \n-B_1d+1^mathrmT  -B_2d+1^mathrmT    0\nendbmatrix\n\nwhere B_ij  ℝ^(n_i - n_i-1)  (n_j - n_j-1), for  1  i  j  d+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/flag/#ManifoldsBase.retract-Tuple{Flag, OrthogonalPoint, OrthogonalTangentVector, QRRetraction}","page":"Flag","title":"ManifoldsBase.retract","text":"retract(M::Flag, p::OrthogonalPoint, X::OrthogonalTangentVector, ::QRRetraction)\n\nCompute the QR retraction on the Flag in the orthogonal matrix representation as the first order approximation to the exponential map. Similar to QR retraction for [GeneralUnitaryMatrices].\n\n\n\n\n\n","category":"method"},{"location":"tutorials/working-in-charts/#Working-in-charts","page":"work in charts","title":"Working in charts","text":"","category":"section"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"In this tutorial we will learn how to use charts for basic geometric operations like exponential map, logarithmic map and parallel transport.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"There are two conceptually different approaches to working on a manifold: working in charts and chart-free representations.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"The first one, widespread in differential geometry textbooks, is based on defining an atlas on the manifold and performing computations in selected charts. This approach, while generic, is not ideally suitable in all circumstances. For example, working in charts that do not cover the entire manifold causes issues with having to switch charts when operating on a manifold.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"The second one is beneficial if there exists a representation of points and tangent vectors for a manifold which allows for efficient closed-form formulas for standard functions like the exponential map or Riemannian distance in this representation. These computations are then chart-free. Manifolds.jl supports both approaches, although the chart-free approach is the main focus of the library.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"In this tutorial we focus on chart-based computation.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"using Manifolds, RecursiveArrayTools, OrdinaryDiffEq, DiffEqCallbacks, BoundaryValueDiffEq","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"The manifold we consider is the M is the torus in form of the EmbeddedTorus, that is the representation defined as a surface of revolution of a circle of radius 2 around a circle of radius 3. The atlas we will perform computations in is its DefaultTorusAtlas A, consisting of a family of charts indexed by two angles, that specify the base point of the chart.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"We will draw geodesics time between 0 and t_end, and then sample the solution at multiples of dt and draw a line connecting sampled points.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"M = Manifolds.EmbeddedTorus(3, 2)\nA = Manifolds.DefaultTorusAtlas()","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"Manifolds.DefaultTorusAtlas()","category":"page"},{"location":"tutorials/working-in-charts/#Setup","page":"work in charts","title":"Setup","text":"","category":"section"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"We will first set up our plot with an empty torus. param_points are points on the surface of the torus that will be used for basic surface shape in Makie.jl. The torus will be colored according to its Gaussian curvature stored in gcs. We later want to have a color scale that has negative curvature blue, zero curvature white and positive curvature red so gcs_mm is the largest absolute value of the curvature that will be needed to properly set range of curvature values.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"In the documentation this tutorial represents a static situation (without interactivity). Makie.jl rendering is turned off.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"# using GLMakie, Makie\n# GLMakie.activate!()\n\n\"\"\"\n    torus_figure()\n\nThis function generates a simple plot of a torus and returns the new figure containing the plot.\n\"\"\"\nfunction torus_figure()\n    fig = Figure(resolution=(1400, 1000), fontsize=16)\n    ax = LScene(fig[1, 1], show_axis=true)\n    ϴs, φs = LinRange(-π, π, 50), LinRange(-π, π, 50)\n    param_points = [Manifolds._torus_param(M, θ, φ) for θ in ϴs, φ in φs]\n    X1, Y1, Z1 = [[p[i] for p in param_points] for i in 1:3]\n    gcs = [gaussian_curvature(M, p) for p in param_points]\n    gcs_mm = max(abs(minimum(gcs)), abs(maximum(gcs)))\n    pltobj = surface!(\n        ax,\n        X1,\n        Y1,\n        Z1;\n        shading=true,\n        ambient=Vec3f(0.65, 0.65, 0.65),\n        backlight=1.0f0,\n        color=gcs,\n        colormap=Reverse(:RdBu),\n        colorrange=(-gcs_mm, gcs_mm),\n        transparency=true,\n    )\n    wireframe!(ax, X1, Y1, Z1; transparency=true, color=:gray, linewidth=0.5)\n    zoom!(ax.scene, cameracontrols(ax.scene), 0.98)\n    Colorbar(fig[1, 2], pltobj, height=Relative(0.5), label=\"Gaussian curvature\")\n    return ax, fig\nend","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"Main.Notebook.torus_figure","category":"page"},{"location":"tutorials/working-in-charts/#Values-for-the-geodesic","page":"work in charts","title":"Values for the geodesic","text":"","category":"section"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"solve_for is a helper function that solves a parallel transport along geodesic problem on the torus M. p0x is the (theta varphi) parametrization of the point from which we will transport the vector. We first calculate the coordinates in the embedding of p0x and store it as p, and then get the initial chart from atlas A appropriate for starting working at point p. The vector we transport has coordinates Y_transp in the induced tangent space basis of chart i_p0x. The function returns the full solution to the parallel transport problem, containing the sequence of charts that was used and solutions of differential equations computed using OrdinaryDiffEq.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"bvp_i is needed later for a different purpose, it is the chart index we will use for solving the logarithmic map boundary value problem in.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"Next we solve the vector transport problem solve_for([θₚ, φₚ], [θₓ, φₓ], [θy, φy]), sample the result at the selected time steps and store the result in geo. The solution includes the geodesic which we extract and convert to a sequence of points digestible by Makie.jl, geo_ps. [θₚ, φₚ] is the parametrization in chart (0, 0) of the starting point of the geodesic. The direction of the geodesic is determined by [θₓ, φₓ], coordinates of the tangent vector at the starting point expressed in the induced basis of chart i_p0x (which depends on the initial point). Finally, [θy, φy] are the coordinates of the tangent vector that will be transported along the geodesic, which are also expressed in same basis as [θₓ, φₓ].","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"We won’t draw the transported vector at every point as there would be too many arrows, which is why we select every 100th point only for that purpose with pt_indices. Then, geo_ps_pt contains points at which the transported vector is tangent to and geo_Ys the transported vector at that point, represented in the embedding.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"The logarithmic map will be solved between points with parametrization bvp_a1 and bvp_a2 in chart bvp_i. The result is assigned to variable bvp_sol and then sampled with time step 0.05. The result of this sampling is converted from parameters in chart bvp_i to point in the embedding and stored in geo_r.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"function solve_for(p0x, X_p0x, Y_transp, T)\n    p = [Manifolds._torus_param(M, p0x...)...]\n    i_p0x = Manifolds.get_chart_index(M, A, p)\n    p_exp = Manifolds.solve_chart_parallel_transport_ode(\n        M,\n        [0.0, 0.0],\n        X_p0x,\n        A,\n        i_p0x,\n        Y_transp;\n        final_time=T,\n    )\n    return p_exp\nend;","category":"page"},{"location":"tutorials/working-in-charts/#Solving-parallel-Transport-ODE","page":"work in charts","title":"Solving parallel Transport ODE","text":"","category":"section"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"We set the end time t_end and time step dt.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"t_end = 2.0\ndt = 1e-1","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"0.1","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"We also parametrise the start point and direction.","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"θₚ = π/10\nφₚ = -π/4\nθₓ = π/2\nφₓ = 0.7\nθy = 0.2\nφy = -0.1\n\ngeo = solve_for([θₚ, φₚ], [θₓ, φₓ], [θy, φy], t_end)(0.0:dt:t_end);\n# geo_ps = [Point3f(s[1]) for s in geo]\n# pt_indices = 1:div(length(geo), 10):length(geo)\n# geo_ps_pt = [Point3f(s[1]) for s in geo[pt_indices]]\n# geo_Ys = [Point3f(s[3]) for s in geo[pt_indices]]\n\n# ax1, fig1 = torus_figure()\n# arrows!(ax1, geo_ps_pt, geo_Ys, linewidth=0.05, color=:blue)\n# lines!(geo_ps; linewidth=4.0, color=:green)\n# fig1","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"(Image: fig-pt)","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"fig-pt","category":"page"},{"location":"tutorials/working-in-charts/#Solving-the-logarithmic-map-ODE","page":"work in charts","title":"Solving the logarithmic map ODE","text":"","category":"section"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"θ₁=π/2\nφ₁=-1.0\nθ₂=-π/8\nφ₂=π/2\n\nbvp_i = (0, 0)\nbvp_a1 = [θ₁, φ₁]\nbvp_a2 = [θ₂, φ₂]\nbvp_sol = Manifolds.solve_chart_log_bvp(M, bvp_a1, bvp_a2, A, bvp_i);\n# geo_r = [Point3f(get_point(M, A, bvp_i, p[1:2])) for p in bvp_sol(0.0:0.05:1.0)]\n\n# ax2, fig2 = torus_figure()\n# lines!(geo_r; linewidth=4.0, color=:green)\n# fig2","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"(Image: fig-geodesic)","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"fig-geodesic","category":"page"},{"location":"tutorials/working-in-charts/","page":"work in charts","title":"work in charts","text":"An interactive Pluto version of this tutorial is available in file tutorials/working-in-charts.jl.","category":"page"},{"location":"tutorials/getstarted/#Get-Started-with-Manifolds.jl","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"This is a short overview of Manifolds.jl and how to get started working with your first Manifold. we first need to install the package, using for example","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"using Pkg; Pkg.add(\"Manifolds\")","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Then you can load the package with","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"using Manifolds","category":"page"},{"location":"tutorials/getstarted/#Using-the-Library-of-Manifolds","page":"🚀 Get Started with Manifolds.jl","title":"Using the Library of Manifolds","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Manifolds.jl is first of all a library of manifolds, see the list in the menu here under “basic manifolds”.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Let’s look at three examples together with the first few functions on manifolds.","category":"page"},{"location":"tutorials/getstarted/#1.-[The-Euclidean-space](https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html)","page":"🚀 Get Started with Manifolds.jl","title":"1. The Euclidean space","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The Euclidean Space Euclidean brings us (back) into linear case of vectors, so in terms of manifolds, this is a very simple one. It is often useful to compare to classical algorithms, or implementations.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₁ = Euclidean(3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Euclidean(3; field=ℝ)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Since a manifold is a type in Julia, we write it in CamelCase. Its parameters are first a dimension or size parameter of the manifold, sometimes optional is a field the manifold is defined over.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"For example the above definition is the same as the real-valued case","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₁ === Euclidean(3, field=ℝ)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"But we even introduced a short hand notation, since ℝ is also just a symbol/variable to use”","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₁ === ℝ^3","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"And similarly here are two ways to create the manifold of vectors of length two with complex entries – or mathematically the space mathbb C^2","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Euclidean(2, field=ℂ) === ℂ^2","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The easiest to check is the dimension of a manifold. Here we have three “directions to walk into” at every point pin mathbb R ^3 so manifold_dimension is","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"manifold_dimension(M₁)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"3","category":"page"},{"location":"tutorials/getstarted/#2.-[The-hyperbolic-space](@ref-HyperbolicSpace)","page":"🚀 Get Started with Manifolds.jl","title":"2. The hyperbolic space","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The d-dimensional hyperbolic space is usually represented in mathbb R^d+1 as the set of points pinmathbb R^3 fulfilling","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"p_1^2+p_2^2+s+p_d^2-p_d+1^2 = -1","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"We define the manifold using","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₂ = Hyperbolic(2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Hyperbolic(2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"And we can again just start with looking at the manifold dimension of M₂","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"manifold_dimension(M₂)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"2","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"A next useful function is to check, whether some pmathbb R^3 is a point on the manifold M₂. We can check","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_point(M₂, [0, 0, 1])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"or","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_point(M₂, [1, 0, 1])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"false","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Keyword arguments are passed on to any numerical checks, for example an absolute tolerance when checking the above equality.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"But in an interactive session an error message might be helpful. A positional (third) argument is present to activate this. Setting this parameter to true, we obtain an error message that gives insight into why the point is not a point on M₂. Note that the LoadError: is due to quarto, on REPL you would just get the DomainError.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_point(M₂, [0, 0, 1.001]; error=:error)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"DomainError: DomainError(-1.0020009999999997, \"The point [0.0, 0.0, 1.001] does not lie on Hyperbolic(2) since its Minkowski inner product is not -1.\")\nDomainError with -1.0020009999999997:\nThe point [0.0, 0.0, 1.001] does not lie on Hyperbolic(2) since its Minkowski inner product is not -1.\nStacktrace:\n [1] \u001b[0m\u001b[1m_is_point_forwarding\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mT\u001b[39m::\u001b[0mManifoldsBase.EmbeddedForwardingType\u001b[90m{ManifoldsBase.DirectEmbedding}\u001b[39m, \u001b[90mM\u001b[39m::\u001b[0mHyperbolic\u001b[90m{ManifoldsBase.TypeParameter{Tuple{2}}}\u001b[39m, \u001b[90mp\u001b[39m::\u001b[0mVector\u001b[90m{Float64}\u001b[39m; \u001b[90merror\u001b[39m::\u001b[0mSymbol, \u001b[90mkwargs\u001b[39m::\u001b[0m@Kwargs\u001b[90m{}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m   @\u001b[39m \u001b[35mManifoldsBase\u001b[39m \u001b[90m~/.julia/packages/ManifoldsBase/EGiHK/src/\u001b[39m\u001b[90m\u001b[4mdecorator_trait.jl:538\u001b[24m\u001b[39m\n [2] \u001b[0m\u001b[1m_is_point_forwarding\u001b[22m\n\u001b[90m   @\u001b[39m \u001b[90m~/.julia/packages/ManifoldsBase/EGiHK/src/\u001b[39m\u001b[90m\u001b[4mdecorator_trait.jl:501\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n [3] \u001b[0m\u001b[1m#is_point#131\u001b[22m\n\u001b[90m   @\u001b[39m \u001b[90m~/.julia/packages/ManifoldsBase/EGiHK/src/\u001b[39m\u001b[90m\u001b[4mnested_trait.jl:148\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n [4] top-level scope\n\u001b[90m   @\u001b[39m \u001b[90m~/work/Manifolds.jl/Manifolds.jl/tutorials/\u001b[39m\u001b[90m\u001b[4mgetstarted.qmd:111\u001b[24m\u001b[39m","category":"page"},{"location":"tutorials/getstarted/#3.-[The-sphere](@ref-SphereSection)","page":"🚀 Get Started with Manifolds.jl","title":"3. The sphere","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The sphere mathbb S^d is the d-dimensional sphere represented in its embedded form, that is unit vectors p in mathbb R^d+1 with unit norm lVert p rVert_2 = 1.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₃ = Sphere(2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Sphere(2, ℝ)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"If we only have a point that is approximately on the manifold, we can allow for a tolerance. Usually these are the same values of atol and rtol allowed in isapprox, i.e. we get","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_point(M₃, [0, 0, 1.001]; atol=1e-3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Here we can show a last nice check: is_vector to check whether a tangent vector X is a representation of a tangent vector XT_pmathcal M to a point p on the manifold.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"This function has two positional arguments, the first to again indicate whether to throw an error, the second to disable the check that p is a valid point on the manifold. Usually this validity is essential for the tangent check, but if it was for example performed before, it can be turned off to spare time.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"For example in our first example the point is not of unit norm","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_vector(M₃, [2, 0, 0], [0, 1, 1])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"false","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"But the orthogonality of p and X is still valid, we can disable the point check, but even setting the error to true we get here","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_vector(M₃, [2, 0, 0], [0, 1, 1], true, false)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"false","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"But of course it is better to use a valid point in the first place","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_vector(M₃, [1, 0, 0], [0, 1, 1])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"and for these we again get informative error messages","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"@expect_error is_vector(M₃, [1, 0, 0], [0.1, 1, 1]; error=:error) DomainError","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"LoadError: LoadError(\"/home/runner/work/Manifolds.jl/Manifolds.jl/tutorials/getstarted.qmd\", 156, UndefVarError(Symbol(\"@expect_error\"), 0x000000000000978f, Main.Notebook))\nLoadError: UndefVarError: `@expect_error` not defined in `Main.Notebook`\nSuggestion: check for spelling errors or missing imports.\nin expression starting at /home/runner/work/Manifolds.jl/Manifolds.jl/tutorials/getstarted.qmd:156\nStacktrace:\n  [1] \u001b[0m\u001b[1meval\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mm\u001b[39m::\u001b[0mModule, \u001b[90me\u001b[39m::\u001b[0mAny\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90mCore\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mboot.jl:489\u001b[24m\u001b[39m\n  [2] \u001b[0m\u001b[1m(::QuartoNotebookWorker.var\"#21#22\"{Module, Expr})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:222\u001b[24m\u001b[39m\n  [3] \u001b[0m\u001b[1m(::QuartoNotebookWorker.Packages.IOCapture.var\"#12#13\"{Type{InterruptException}, QuartoNotebookWorker.var\"#21#22\"{Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker.Packages.IOCapture\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/vendor/IOCapture/src/\u001b[39m\u001b[90m\u001b[4mIOCapture.jl:170\u001b[24m\u001b[39m\n  [4] \u001b[0m\u001b[1mwith_logstate\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.Packages.IOCapture.var\"#12#13\"\u001b[90m{Type{InterruptException}, QuartoNotebookWorker.var\"#21#22\"{Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}}\u001b[39m, \u001b[90mlogstate\u001b[39m::\u001b[0mBase.CoreLogging.LogState\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90mBase.CoreLogging\u001b[39m \u001b[90m./logging/\u001b[39m\u001b[90m\u001b[4mlogging.jl:540\u001b[24m\u001b[39m\n  [5] \u001b[0m\u001b[1mwith_logger\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mFunction, \u001b[90mlogger\u001b[39m::\u001b[0mBase.CoreLogging.ConsoleLogger\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90mBase.CoreLogging\u001b[39m \u001b[90m./logging/\u001b[39m\u001b[90m\u001b[4mlogging.jl:651\u001b[24m\u001b[39m\n  [6] \u001b[0m\u001b[1mcapture\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.var\"#21#22\"\u001b[90m{Module, Expr}\u001b[39m; \u001b[90mrethrow\u001b[39m::\u001b[0mType, \u001b[90mcolor\u001b[39m::\u001b[0mBool, \u001b[90mpassthrough\u001b[39m::\u001b[0mBool, \u001b[90mcapture_buffer\u001b[39m::\u001b[0mIOBuffer, \u001b[90mio_context\u001b[39m::\u001b[0mVector\u001b[90m{Pair{Symbol, Any}}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker.Packages.IOCapture\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/vendor/IOCapture/src/\u001b[39m\u001b[90m\u001b[4mIOCapture.jl:167\u001b[24m\u001b[39m\n  [7] \u001b[0m\u001b[1mcapture\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:248\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n  [8] \u001b[0m\u001b[1mio_capture\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mFunction; \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m, \u001b[90mkws\u001b[39m::\u001b[0m@Kwargs\u001b[90m{rethrow::DataType, color::Bool, io_context::Vector{Pair{Symbol, Any}}}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:250\u001b[24m\u001b[39m\n  [9] \u001b[0m\u001b[1mio_capture\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:246\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n [10] \u001b[0m\u001b[1minclude_str\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mmod\u001b[39m::\u001b[0mModule, \u001b[90mcode\u001b[39m::\u001b[0mString; \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:201\u001b[24m\u001b[39m\n [11] \u001b[0m\u001b[1m#invokelatest_gr#232\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mreflection.jl:1282\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n [12] \u001b[0m\u001b[1minvokelatest_gr\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mreflection.jl:1274\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n [13] \u001b[0m\u001b[1m#7\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:18\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n [14] \u001b[0m\u001b[1mwith_inline_display\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.var\"#7#8\"\u001b[90m{String, String, Int64, Dict{Any, Any}}\u001b[39m, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mInlineDisplay.jl:31\u001b[24m\u001b[39m\n [15] \u001b[0m\u001b[1m_render_thunk\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mthunk\u001b[39m::\u001b[0mFunction, \u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m, \u001b[90mis_expansion_ref\u001b[39m::\u001b[0mBase.RefValue\u001b[90m{Bool}\u001b[39m; \u001b[90minline\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:43\u001b[24m\u001b[39m\n [16] \u001b[0m\u001b[1m_render_thunk\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:35\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n [17] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m; \u001b[90minline\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:15\u001b[24m\u001b[39m\n [18] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:1\u001b[24m\u001b[39m\n [19] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m::\u001b[0mString, ::\u001b[0mVararg\u001b[90m{Any}\u001b[39m; \u001b[90mkwargs\u001b[39m::\u001b[0m@Kwargs\u001b[90m{}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[90m    @\u001b[39m \u001b[32mMain\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/\u001b[39m\u001b[90m\u001b[4mstartup.jl:145\u001b[24m\u001b[39m\n [20] top-level scope\n\u001b[90m    @\u001b[39m \u001b[90m\u001b[4mnone:1\u001b[24m\u001b[39m","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"To learn about how to define a manifold yourself check out the How to define your own manifold tutorial of ManifoldsBase.jl.”","category":"page"},{"location":"tutorials/getstarted/#Building-more-advanced-manifolds","page":"🚀 Get Started with Manifolds.jl","title":"Building more advanced manifolds","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Based on these basic manifolds we can directly build more advanced manifolds.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The first one concerns vectors or matrices of data on a manifold, the PowerManifold.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₄ = M₂^2","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"PowerManifold(Hyperbolic(2), 2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Then points are represented by arrays, where the power manifold dimension is added in the end. In other words – for the hyperbolic manifold here, we have a matrix with 2 columns, where each column is a valid point on hyperbolic space.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"p = [0 0; 0 1; 1 sqrt(2)]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"3×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  1.0\n 1.0  1.41421","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"[is_point(M₂, p[:, 1]), is_point(M₂, p[:, 2])]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"2-element Vector{Bool}:\n 1\n 1","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"But of course the method we used previously also works for power manifolds:","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_point(M₄, p)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Note that nested power manifolds are combined into one as in","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₄₂ = M₄^4","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"PowerManifold(Hyperbolic(2), 2, 4)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"which represents 24 – matrices of hyperbolic points represented in 324 arrays.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"We can – alternatively – use a power manifold with nested arrays","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₅ = PowerManifold(M₃, NestedPowerRepresentation(), 2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"PowerManifold(Sphere(2, ℝ), ManifoldsBase.NestedPowerRepresentation(), 2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"which emphasizes that we have vectors of length 2 that contain points, so we store them that way.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"p₂ = [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"2-element Vector{Vector{Float64}}:\n [0.0, 0.0, 1.0]\n [0.0, 1.0, 0.0]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"To unify both representations, elements of the power manifold can also be accessed in the classical indexing fashion, if we start with the corresponding manifold first. This way one can implement algorithms also independent of which representation is used.”","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"p[M₄, 1]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"3-element Vector{Float64}:\n 0.0\n 0.0\n 1.0","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"p₂[M₅, 2]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"3-element Vector{Float64}:\n 0.0\n 1.0\n 0.0","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Another constructor is the ProductManifold to combine different manifolds. Here of course the order matters. First we construct these using ","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₆ = M₂ × M₃","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"ProductManifold with 2 submanifolds:\n Hyperbolic(2)\n Sphere(2, ℝ)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Since now the representations might differ from element to element, we have to encapsulate these in their own type.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"using RecursiveArrayTools: ArrayPartition\np₃ = ArrayPartition([0, 0, 1], [0, 1, 0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"([0, 0, 1], [0, 1, 0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Here ArrayPartition taken from RecursiveArrayTools.jl to store the point on the product manifold efficiently in one array, still allowing efficient access to the product elements.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"is_point(M₆, p₃; error=:error)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"But accessing single components still works the same.”","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"p₃[M₆, 1]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"3-element Vector{Int64}:\n 0\n 0\n 1","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Finally, also the TangentBundle, the manifold collecting all tangent spaces on a manifold is available as”","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₇ = TangentBundle(M₃)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"TangentBundle(Sphere(2, ℝ))","category":"page"},{"location":"tutorials/getstarted/#Implementing-generic-Functions","page":"🚀 Get Started with Manifolds.jl","title":"Implementing generic Functions","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"In this section we take a look how to implement generic functions on manifolds.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"For our example here, we want to implement the so-called Bézier curve using the so-called de-Casteljau algorithm. The linked algorithm can easily be generalised to manifolds by replacing lines with geodesics. This was for example used in [BG18] and the following example is an extended version of an example from [ABBR23].","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The algorithm works recursively. For the case that we have a Bézier curve with just two points, the algorithm just evaluates the geodesic connecting both at some time point t01. The function to evaluate a shortest geodesic (it might not be unique, but then a deterministic choice is taken) between two points p and q on a manifold M shortest_geodesic(M, p, q, t).","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"function de_Casteljau(M::AbstractManifold, t, pts::NTuple{2})\n    return shortest_geodesic(M, pts[1], pts[2], t)\nend","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"de_Casteljau (generic function with 1 method)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"function de_Casteljau(M::AbstractManifold, t, pts::NTuple)\n    p = de_Casteljau(M, t, pts[1:(end - 1)])\n    q = de_Casteljau(M, t, pts[2:end])\n    return shortest_geodesic(M, p, q, t)\nend","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"de_Casteljau (generic function with 2 methods)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Which can now be used on any manifold where the shortest geodesic is implemented","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Now on several manifolds the exponential map and its (locally defined) inverse, the logarithmic map might not be available in an implementation. So one way to generalise this, is the use of a retraction (see [AMS08], Def. 4.1.1 for details) and its (local) inverse.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The function itself is quite similar to the exponential map, just that retract(M, p, X, m) has one further parameter, the type of retraction to take, so m is a subtype of m, the same for the inverse_retract(M, p, q, n) with an AbstractInverseRetractionMethod n.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Thinking of a generic implementation, we would like to have a way to specify one, that is available. This can be done by using default_retraction_method and default_inverse_retraction_method, respectively. We implement","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"function generic_de_Casteljau(\n    M::AbstractManifold,\n    t,\n    pts::NTuple{2};\n    m::AbstractRetractionMethod=default_retraction_method(M),\n    n::AbstractInverseRetractionMethod=default_inverse_retraction_method(M),\n)\n    X = inverse_retract(M, pts[1], pts[2], n)\n    return retract(M, pts[1], X, t, m)\nend","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"generic_de_Casteljau (generic function with 1 method)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"and for the recursion","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"function generic_de_Casteljau(\n    M::AbstractManifold,\n    t,\n    pts::NTuple;\n    m::AbstractRetractionMethod=default_retraction_method(M),\n    n::AbstractInverseRetractionMethod=default_inverse_retraction_method(M),\n)\n    p = generic_de_Casteljau(M, t, pts[1:(end - 1)]; m=m, n=n)\n    q = generic_de_Casteljau(M, t, pts[2:end]; m=m, n=n)\n    X = inverse_retract(M, p, q, n)\n    return retract(M, p, X, t, m)\nend","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"generic_de_Casteljau (generic function with 2 methods)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Note that on a manifold M where the exponential map is implemented, the default_retraction_method(M) returns ExponentialRetraction, which yields that the retract function falls back to calling exp.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The same mechanism exists for parallel_transport_to(M, p, X, q) and the more general vector_transport_to(M, p, X, q, m) whose AbstractVectorTransportMethod m has a default defined by default_vector_transport_method(M).","category":"page"},{"location":"tutorials/getstarted/#Allocating-and-in-place-computations","page":"🚀 Get Started with Manifolds.jl","title":"Allocating and in-place computations","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Memory allocation is a critical performance issue when programming in Julia. To take this into account, Manifolds.jl provides special functions to reduce the amount of allocations.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"We again look at the exponential map. On a manifold M the exponential map needs a point p (to start from) and a tangent vector X, which can be seen as direction to “walk into” as well as the length to walk into this direction. In Manifolds.jl the function can then be called with q = exp(M, p, X) (see exp(M, p, X)). This function returns the resulting point q, which requires to allocate new memory.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"To avoid this allocation, the function exp!(M, q, p, X) can be called. Here q is allocated beforehand and is passed as the memory, where the result is returned in. It might be used even for interims computations, as long as it does not introduce side effects. Thas means that even with exp!(M, p, p, X) the result is correct.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Let’s look at an example.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"We take another look at the Sphere, but now a high-dimensional one. We can also illustrate how to generate radnom points and tangent vectors.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M = Sphere(10000)\np₄ = rand(M)\nX = rand(M; vector_at=p₄)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Looking at the allocations required we get","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"@allocated exp(M, p₄, X)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"80136","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"While if we have already allocated memory for the resulting point on the manifold, for example","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"q₂ = zero(p₄);","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"There are no new memory allocations necessary if we use the in-place function.”","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"@allocated exp!(M, q₂, p₄, X)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"0","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"This methodology is used for all functions that compute a new point or tangent vector. By default all allocating functions allocate memory and call the in-place function. This also means that if you implement a new manifold, you just have to implement the in-place version.","category":"page"},{"location":"tutorials/getstarted/#Decorating-a-manifold","page":"🚀 Get Started with Manifolds.jl","title":"Decorating a manifold","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"As you saw until now, an [AbstractManifold]@extref ManifoldsBase.AbstractManifold) describes a Riemannian manifold. For completeness, this also includes the chosen Riemannian metric tensor or inner product on the tangent spaces.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"In Manifolds.jl these are assumed to be a “reasonable default”. For example on the Sphere(n) we used above, the default metric is the one inherited from restricting the inner product from the embedding space onto each tangent space.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Consider a manifold like","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₈ = SymmetricPositiveDefinite(3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"SymmetricPositiveDefinite(3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"which is the manifold of 33 matrices that are symmetric and positive definite. which has a default as well, the affine invariant AffineInvariantMetric, but also has several different metrics.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"To switch the metric, we use the idea of a decorator pattern approach. Defining","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"M₈₂ = MetricManifold(M₈, BuresWassersteinMetric())","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"MetricManifold(SymmetricPositiveDefinite(3), Manifolds.BuresWassersteinMetric())","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"changes the manifold to use the BuresWassersteinMetric.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"This changes all functions that depend on the metric, most prominently the Riemannian matric, but also the exponential and logarithmic map and hence also geodesics.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"All functions that are not dependent on a metric – for example the manifold dimension, the tests of points and vectors we already looked at, but also all retractions – stay unchanged. This means that for example","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"[manifold_dimension(M₈₂), manifold_dimension(M₈)]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"2-element Vector{Int64}:\n 6\n 6","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"both calls the same underlying function. On the other hand with","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"p₅, X₅ = one(zeros(3, 3)), [1.0 0.0 1.0; 0.0 1.0 0.0; 1.0 0.0 1.0]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [1.0 0.0 1.0; 0.0 1.0 0.0; 1.0 0.0 1.0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"but for example the exponential map and the norm yield different results","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"[exp(M₈, p₅, X₅), exp(M₈₂, p₅, X₅)]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"2-element Vector{Matrix{Float64}}:\n [4.194528049465325 0.0 3.194528049465325; 0.0 2.718281828459045 0.0; 3.194528049465325 0.0 4.194528049465328]\n [2.5 0.0 1.5; 0.0 2.25 0.0; 1.5 0.0 2.5]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"[norm(M₈, p₅, X₅), norm(M₈₂, p₅, X₅)]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"2-element Vector{Float64}:\n 2.23606797749979\n 1.118033988749895","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Technically this done using the MetricManifold.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"The same approach is used for","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"specifying a different connection\nspecifying a certain embeddings","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"Again, for all of these, the concrete types only have to be used if you want to do a second, different from the details, property, for example a second way to embed a manifold. If a manifold is (in its usual representation) an embedded manifold, this works with the default manifold type already, since then it is again set as the reasonable default.","category":"page"},{"location":"tutorials/getstarted/#Literature","page":"🚀 Get Started with Manifolds.jl","title":"Literature","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with Manifolds.jl","title":"🚀 Get Started with Manifolds.jl","text":"P.-A. Absil, R. Mahony and R. Sepulchre. Optimization Algorithms on Matrix Manifolds (Princeton University Press, 2008), available online at press.princeton.edu/chapters/absil/.\n\n\n\nS. D. Axen, M. Baran, R. Bergmann and K. Rzecki. Manifolds.Jl: An Extensible Julia Framework for Data Analysis on Manifolds. ACM Transactions on Mathematical Software 49 (2023).\n\n\n\nR. Bergmann and P.-Y. Gousenbourger. A variational model for data fitting on manifolds by minimizing the acceleration of a Bézier curve. Frontiers in Applied Mathematics and Statistics 4 (2018), arXiv:1807.10090.\n\n\n\n","category":"page"},{"location":"tutorials/exploring-curvature/#Exploring-curvature-without-coordinates","page":"explore curvature without coordinates","title":"Exploring curvature without coordinates","text":"","category":"section"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"This part of documentation covers exploration of curvature of manifolds mathcalM. There are multiple ways to describe curvature: Christoffel symbols, Riemann tensor, Ricci tensor, sectional curvature, and many other. They are usually considered only in coordinates but there is a way to demonstrate curvature in coordinate-free way.","category":"page"},{"location":"tutorials/exploring-curvature/#Sectional-curvature-matrix","page":"explore curvature without coordinates","title":"Sectional curvature matrix","text":"","category":"section"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"Curvature of a manifold can be explored using the sectional_curvature_matrix function. Note that Riemann tensor and sectional curvature are equivalently full specifications of curvature in a manifold, see [CE08], Eq. (1.12).","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"Let’s take the SymmetricPositiveDefinite manifold as our first example. It has nonpositive sectional curvature:","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"using Manifolds\nusing LinearAlgebra\nM = SymmetricPositiveDefinite(3)\np = rand(M)\ncm = sectional_curvature_matrix(M, p, DefaultOrthonormalBasis())","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"6×6 Matrix{Float64}:\n  0.0          -0.25         -0.25         …   6.3207e-22  -4.92629e-22\n -0.25          0.0          -0.125           -0.125       -6.90015e-22\n -0.25         -0.125         0.0             -0.125       -0.25\n  9.03815e-22  -0.25          1.66199e-24     -0.25        -1.56788e-23\n  6.3207e-22   -0.125        -0.125            0.0         -0.25\n -4.92629e-22  -6.90015e-22  -0.25         …  -0.25         0.0","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"We can verify that the curvature is consistent with an approximation based on the Bertrand–Diguet–Puiseux theorem, which relies only on an ONB, exponential map and distance calculation:","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"cm_bdp = Manifolds.estimated_sectional_curvature_matrix(M, p, DefaultOrthonormalBasis(); r=1e-3, N_pts=100000)\nprintln(norm(cm - cm_bdp))","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"0.004388716521414799","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"This approximation converges quite slowly with N_pts and is prone to numerical errors at low values of r and large values of N_pts.","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"You can also take the vectors from the basis and see what kind of planes they correspond to. It may be easier to see for the identity matrix as the base point.","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"p = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\nV = get_vectors(M, p, get_basis(M, p, DefaultOrthonormalBasis()))\ncm = sectional_curvature_matrix(M, p, DefaultOrthonormalBasis())\nfor X in V\n    println(exp(M, p, X))\nend","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"[2.718281828459045 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\n[1.260591836521356 0.7675231451261162 0.0; 0.7675231451261162 1.2605918365213566 0.0; 0.0 0.0 1.0]\n[1.260591836521356 0.0 0.7675231451261162; 0.0 1.0 0.0; 0.7675231451261162 0.0 1.2605918365213566]\n[1.0 0.0 0.0; 0.0 2.718281828459045 0.0; 0.0 0.0 1.0]\n[1.0 0.0 0.0; 0.0 1.260591836521356 0.7675231451261162; 0.0 0.7675231451261162 1.2605918365213566]\n[1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 2.718281828459045]","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"The flat planes correspond to directions where the matrix changes independently. In other cases sectional curvature indicates hyperbolic characteristic of a submanifold.","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"Sectional curvature can be either larger or smaller than entries in the matrix on other planes. Consider for example the manifold of rotation matrices in four dimensions, and a function that computes plane of maximum curvature using random search.","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"function max_curvature(M::AbstractManifold, p)\n    mc = -Inf\n    X = zero_vector(M, p)\n    Y = zero_vector(M, p)\n    for _ in 1:10000\n        X_c = rand(M; vector_at=p)\n        Y_c = rand(M; vector_at=p)\n        sc = sectional_curvature(M, p, X_c, Y_c)\n        if sc > mc\n            mc = sc\n            X .= X_c\n            Y .= Y_c\n        end\n    end\n    return mc, X, Y\nend\n\nM = Rotations(4)\np = Matrix(I(4) * 1.0)\nprintln(sectional_curvature_matrix(M, p, DefaultOrthonormalBasis()))\nmc, X, Y = max_curvature(M, p)\nprintln(mc)\nprintln(X)\nprintln(Y)","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"[0.0 0.12500000000000003 … 0.12500000000000003 0.12500000000000003; 0.12500000000000003 0.0 … 0.0 0.12500000000000003; … ; 0.12500000000000003 0.0 … 0.0 0.12500000000000003; 0.12500000000000003 0.12500000000000003 … 0.12500000000000003 0.0]\n0.24258881817077757\n[0.0 0.11969784615824122 -0.9193863912207128 -1.2883591183330676; -0.11969784615824122 0.0 1.3762285967438759 -0.5625963753515246; 0.9193863912207128 -1.3762285967438759 0.0 0.14297778350329035; 1.2883591183330676 0.5625963753515246 -0.14297778350329035 0.0]\n[0.0 -0.16922820320017437 0.7241681185660996 -0.7845677872344756; 0.16922820320017437 0.0 0.893382497602577 0.8657773787164379; -0.7241681185660996 -0.893382497602577 0.0 0.05372305966724548; 0.7845677872344756 -0.8657773787164379 -0.05372305966724548 0.0]","category":"page"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"In the planes corresponding to orthonormal basis, the maximum sectional curvature is 0.125 but the true upper bound is 0.25.","category":"page"},{"location":"tutorials/exploring-curvature/#Literature","page":"explore curvature without coordinates","title":"Literature","text":"","category":"section"},{"location":"tutorials/exploring-curvature/","page":"explore curvature without coordinates","title":"explore curvature without coordinates","text":"J. Cheeger and D. G. Ebin. Comparison Theorems in Riemannian Geometry (American Mathematical Society, Providence, R.I, 2008).\n\n\n\n","category":"page"},{"location":"manifolds/hyperbolic/#HyperbolicSpace","page":"Hyperbolic space","title":"Hyperbolic space","text":"","category":"section"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"The hyperbolic space can be represented in three different models.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"Hyperboloid which is the default model, i.e. is used when using arbitrary array types for points and tangent vectors\nPoincaré ball with separate types for points and tangent vectors and a visualization for the two-dimensional case\nPoincaré half space with separate types for points and tangent vectors and a visualization for the two-dimensional cae.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"In the following the common functions are collected.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"A function in this general section uses vectors interpreted as if in the hyperboloid model, and other representations usually just convert to this representation to use these general functions.","category":"page"},{"location":"manifolds/hyperbolic/#Manifolds.Hyperbolic","page":"Hyperbolic space","title":"Manifolds.Hyperbolic","text":"Hyperbolic{T} <: AbstractDecoratorManifold{ℝ}\n\nThe hyperbolic space mathcal H^n represented by n+1-Tuples, i.e. embedded in the Lorentzian manifold equipped with the MinkowskiMetric _mathrmM. The space is defined as\n\nmathcal H^n = Biglp  ℝ^n+1 Big pp_mathrmM= -p_n+1^2\n  + displaystylesum_k=1^n p_k^2 = -1 p_n+1  0Bigr\n\nThe tangent space T_p mathcal H^n is given by\n\nT_p mathcal H^n = bigl\nX  ℝ^n+1  pX_mathrmM = 0\nbigr\n\nNote that while the MinkowskiMetric renders the Lorentz manifold (only) pseudo-Riemannian, on the tangent bundle of the Hyperbolic space it induces a Riemannian metric. The corresponding sectional curvature is -1.\n\nIf p and X are Vectors of length n+1 they are assumed to be a HyperboloidPoint and a HyperboloidTangentVector, respectively\n\nOther models are the Poincaré ball model, see PoincareBallPoint and PoincareBallTangentVector, respectively and the Poincaré half space model, see PoincareHalfSpacePoint and PoincareHalfSpaceTangentVector, respectively.\n\nConstructor\n\nHyperbolic(n::Int; parameter::Symbol=:type)\n\nGenerate the Hyperbolic manifold of dimension n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manifolds.HyperboloidPoint","page":"Hyperbolic space","title":"Manifolds.HyperboloidPoint","text":"HyperboloidPoint <: AbstractManifoldPoint\n\nIn the Hyperboloid model of the Hyperbolic mathcal H^n points are represented as vectors in ℝ^n+1 with MinkowskiMetric equal to -1.\n\nThis representation is the default, i.e. AbstractVectors are assumed to have this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manifolds.HyperboloidTangentVector","page":"Hyperbolic space","title":"Manifolds.HyperboloidTangentVector","text":"HyperboloidTangentVector <: AbstractTangentVector\n\nIn the Hyperboloid model of the Hyperbolic mathcal H^n tangent vctors are represented as vectors in ℝ^n+1 with MinkowskiMetric pX_mathrmM=0 to their base point p.\n\nThis representation is the default, i.e. vectors are assumed to have this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manifolds.PoincareBallPoint","page":"Hyperbolic space","title":"Manifolds.PoincareBallPoint","text":"PoincareBallPoint <: AbstractManifoldPoint\n\nA point on the Hyperbolic manifold mathcal H^n can be represented as a vector of norm less than one in mathbb R^n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manifolds.PoincareBallTangentVector","page":"Hyperbolic space","title":"Manifolds.PoincareBallTangentVector","text":"PoincareBallTangentVector <: AbstractTangentVector\n\nIn the Poincaré ball model of the Hyperbolic mathcal H^n tangent vectors are represented as vectors in ℝ^n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manifolds.PoincareHalfSpacePoint","page":"Hyperbolic space","title":"Manifolds.PoincareHalfSpacePoint","text":"PoincareHalfSpacePoint <: AbstractManifoldPoint\n\nA point on the Hyperbolic manifold mathcal H^n can be represented as a vector in the half plane, i.e. x  ℝ^n with x_d  0.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manifolds.PoincareHalfSpaceTangentVector","page":"Hyperbolic space","title":"Manifolds.PoincareHalfSpaceTangentVector","text":"PoincareHalfPlaneTangentVector <: AbstractTangentVector\n\nIn the Poincaré half plane model of the Hyperbolic mathcal H^n tangent vectors are represented as vectors in ℝ^n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Base.exp-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"Base.exp","text":"exp(M::Hyperbolic, p, X)\n\nCompute the exponential map on the Hyperbolic space mathcal H^n emanating from p towards X. The formula reads\n\nexp_p X = cosh(sqrtXX_mathrmM)p\n+ sinh(sqrtXX_mathrmM)fracXsqrtXX_mathrmM\n\nwhere _mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold, see for example the extended version [BPS15] of the paper [BPS16].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.log-Tuple{Hyperbolic, Vararg{Any}}","page":"Hyperbolic space","title":"Base.log","text":"log(M::Hyperbolic, p, q)\n\nCompute the logarithmic map on the Hyperbolic space mathcal H^n, the tangent vector representing the geodesic starting from p reaches q after time 1. The formula reads for p  q\n\nlog_p q = d_mathcal H^n(pq)\nfracq-pq_mathrmM plVert q-pq_mathrmM p rVert_2\n\nwhere _mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold. For p=q the logarithmic map is equal to the zero vector For more details, see for example the extended version [BPS15] of the paper [BPS16].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manifolds.manifold_volume-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"Manifolds.manifold_volume","text":"manifold_dimension(M::Hyperbolic)\n\nReturn the volume of the hyperbolic space manifold mathcal H^n, i.e. infinity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.check_point-Tuple{Hyperbolic, Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_point","text":"check_point(M::Hyperbolic, p; kwargs...)\n\nCheck whether p is a valid point on the Hyperbolic M.\n\nFor the HyperboloidPoint or plain vectors this means that, p is a vector of length n+1 with inner product in the embedding of -1, see MinkowskiMetric. The tolerance for the last test can be set using the kwargs....\n\nFor the PoincareBallPoint a valid point is a vector p  ℝ^n with a norm strictly less than 1.\n\nFor the PoincareHalfSpacePoint a valid point is a vector from p  ℝ^n with a positive last entry, i.e. p_n0\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.check_vector-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_vector","text":"check_vector(M::Hyperbolic, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the Hyperbolic M, i.e. after check_point(M,p), X has to be of the same dimension as p. The tolerance for the last test can be set using the kwargs....\n\nFor a the hyperboloid model or vectors, X has to be  orthogonal to p with respect to the inner product from the embedding, see MinkowskiMetric.\n\nFor a the Poincaré ball as well as the Poincaré half plane model, X has to be a vector from ℝ^n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.injectivity_radius-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Hyperbolic)\ninjectivity_radius(M::Hyperbolic, p)\n\nReturn the injectivity radius on the Hyperbolic, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.is_flat-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"ManifoldsBase.is_flat","text":"is_flat(::Hyperbolic)\n\nReturn false. Hyperbolic is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.manifold_dimension-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Hyperbolic)\n\nReturn the dimension of the hyperbolic space manifold mathcal H^n, i.e. dim(mathcal H^n) = n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.parallel_transport_to-Tuple{Hyperbolic, Any, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Hyperbolic, p, X, q)\n\nCompute the parallel transport of the X from the tangent space at p on the Hyperbolic space mathcal H^n to the tangent at q along the geodesic connecting p and q. The formula reads\n\nmathcal P_qpX = X - fraclog_p qX_pd^2_mathcal H^n(pq)\nbigl(log_p q + log_qp bigr)\n\nwhere _p denotes the inner product in the tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.project-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.project","text":"project(M::Hyperbolic, p, X)\n\nPerform an orthogonal projection with respect to the Minkowski inner product of X onto the tangent space at p of the Hyperbolic space M.\n\nThe formula reads\n\nY = X + pX_mathrmM p\n\nwhere  _mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold.\n\nnote: Note\nProjection is only available for the (default) HyperboloidTangentVector representation, the others don't have such an embedding\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.riemann_tensor-Tuple{Hyperbolic, Vararg{Any, 4}}","page":"Hyperbolic space","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::Hyperbolic{n}, p, X, Y, Z)\n\nCompute the Riemann tensor R(XY)Z at point p on Hyperbolic M. The formula reads (see e.g., [Lee19] Proposition 8.36)\n\nR(XY)Z = - (langle Z Y rangle X - langle Z X rangle Y)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.sectional_curvature-Tuple{Hyperbolic, Any, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(::Hyperbolic, p, X, Y)\n\nSectional curvature of Hyperbolic M is -1 if dimension is > 1 and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.sectional_curvature_max-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(::Hyperbolic)\n\nSectional curvature of Hyperbolic M is -1 if dimension is > 1 and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.sectional_curvature_min-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::Hyperbolic)\n\nSectional curvature of Hyperbolic M is -1 if dimension is > 1 and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Statistics.mean-Tuple{Hyperbolic, Vararg{Any}}","page":"Hyperbolic space","title":"Statistics.mean","text":"mean(\n    M::Hyperbolic,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = CyclicProximalPointEstimation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x on the Hyperbolic space using CyclicProximalPointEstimation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#hyperboloid_model","page":"Hyperbolic space","title":"hyperboloid model","text":"","category":"section"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{HyperboloidPoint}, PoincareBallPoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidPoint}, p::PoincareBallPoint)\nconvert(::Type{AbstractVector}, p::PoincareBallPoint)\n\nconvert a point PoincareBallPoint x (from ℝ^n) from the Poincaré ball model of the Hyperbolic manifold mathcal H^n to a HyperboloidPoint π(p)  ℝ^n+1. The isometry is defined by\n\nπ(p) = frac11-lVert p rVert^2\nbeginpmatrix2p_12p_n1+lVert p rVert^2endpmatrix\n\nNote that this is also used, when the type to convert to is a vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{HyperboloidPoint}, PoincareHalfSpacePoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidPoint}, p::PoincareHalfSpacePoint)\nconvert(::Type{AbstractVector}, p::PoincareHalfSpacePoint)\n\nconvert a point PoincareHalfSpacePoint p (from ℝ^n) from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a HyperboloidPoint π(p)  ℝ^n+1.\n\nThis is done in two steps, namely transforming it to a Poincare ball point and from there further on to a Hyperboloid point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{HyperboloidTangentVector}, PoincareBallPoint, PoincareBallTangentVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidTangentVector}, p::PoincareBallPoint, X::PoincareBallTangentVector)\nconvert(::Type{AbstractVector}, p::PoincareBallPoint, X::PoincareBallTangentVector)\n\nConvert the PoincareBallTangentVector X from the tangent space at p to a HyperboloidTangentVector by computing the push forward of the isometric map, cf. convert(::Type{HyperboloidPoint}, p::PoincareBallPoint).\n\nThe push forward π_*(p) maps from ℝ^n to a subspace of ℝ^n+1, the formula reads\n\nπ_*(p)X = beginpmatrix\n    frac2X_11-lVert p rVert^2 + frac4(1-lVert p rVert^2)^2Xpp_1\n    \n    frac2X_n1-lVert p rVert^2 + frac4(1-lVert p rVert^2)^2Xpp_n\n    frac4(1-lVert p rVert^2)^2Xp\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{HyperboloidTangentVector}, PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidTangentVector}, p::PoincareHalfSpacePoint, X::PoincareHalfSpaceTangentVector)\nconvert(::Type{AbstractVector}, p::PoincareHalfSpacePoint, X::PoincareHalfSpaceTangentVector)\n\nconvert a point PoincareHalfSpaceTangentVector X (from ℝ^n) at p from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a HyperboloidTangentVector π(p)  ℝ^n+1.\n\nThis is done in two steps, namely transforming it to a Poincare ball point and from there further on to a Hyperboloid point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{Tuple{HyperboloidPoint, HyperboloidTangentVector}}, Tuple{PoincareBallPoint, PoincareBallTangentVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{HyperboloidPoint,HyperboloidTangentVector}}.\n    (p,X)::Tuple{PoincareBallPoint,PoincareBallTangentVector}\n)\nconvert(\n    ::Type{Tuple{P,T}},\n    (p, X)::Tuple{PoincareBallPoint,PoincareBallTangentVector},\n) where {P<:AbstractVector, T <: AbstractVector}\n\nConvert a PoincareBallPoint p and a PoincareBallTangentVector X to a HyperboloidPoint and a HyperboloidTangentVector simultaneously, see convert(::Type{HyperboloidPoint}, ::PoincareBallPoint) and convert(::Type{HyperboloidTangentVector}, ::PoincareBallPoint, ::PoincareBallTangentVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{Tuple{HyperboloidPoint, HyperboloidTangentVector}}, Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{HyperboloidPoint,HyperboloidTangentVector},\n    (p,X)::Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}\n)\nconvert(\n    ::Type{Tuple{T,T},\n    (p,X)::Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}\n) where {T<:AbstractVector}\n\nconvert a point PoincareHalfSpaceTangentVector X (from ℝ^n) at p from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a tuple of a HyperboloidPoint and a HyperboloidTangentVector π(p)  ℝ^n+1 simultaneously.\n\nThis is done in two steps, namely transforming it to the Poincare ball model and from there further on to a Hyperboloid.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldDiff.riemannian_Hessian-Tuple{Hyperbolic, Vararg{Any, 4}}","page":"Hyperbolic space","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::Hyperbolic, p, G, H, X)\nriemannian_Hessian!(M::Hyperbolic, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nLet mathbfg = mathbfg^-1 = operatornamediag(11-1). Then using Remark 4.1 [Ngu23] the formula reads\n\noperatornameHessf(p)X\n=\noperatornameproj_T_pmathcal Mbigl(\n    mathbfg^-1nabla^2f(p)X + Xpmathbfg^-1f(p)_p\nbigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manifolds.volume_density-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"Manifolds.volume_density","text":"volume_density(M::Hyperbolic, p, X)\n\nCompute volume density function of the hyperbolic manifold. The formula reads (sinh(lVert XrVert)lVert XrVert)^(n-1) where n is the dimension of M. It is derived from Eq. (4.1) in[CLLD22].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.change_representer-Tuple{Hyperbolic, EuclideanMetric, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.change_representer","text":"change_representer(M::Hyperbolic, ::EuclideanMetric, p, X)\n\nChange the Eucliden representer X of a cotangent vector at point p. We only have to correct for the metric, which means that the sign of the last entry changes, since for the result Y  we are looking for a tangent vector such that\n\n    g_p(YZ) = -y_n+1z_n+1 + sum_i=1^n y_iz_i = sum_i=1^n+1 z_ix_i\n\nholds, which directly yields y_i=x_i for i=1ldotsn and y_n+1=-x_n+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.distance-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(M::Hyperbolic, p, q)\ndistance(M::Hyperbolic, p::HyperboloidPoint, q::HyperboloidPoint)\n\nCompute the distance on the Hyperbolic M, which reads\n\nd_mathcal H^n(pq) = operatornameacosh( - p q_mathrmM)\n\nwhere _mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold, see for example the extended version [BPS15] of the paper [BPS16].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.get_coordinates-Tuple{Hyperbolic, Any, Any, DefaultOrthonormalBasis}","page":"Hyperbolic space","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Hyperbolic, p, X, ::DefaultOrthonormalBasis)\n\nCompute the coordinates of the vector X with respect to the orthogonalized version of the unit vectors from ℝ^n, where n is the manifold dimension of the Hyperbolic  M, putting them into the tangent space at p and orthonormalizing them.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.get_vector-Tuple{Hyperbolic, Any, Any, DefaultOrthonormalBasis}","page":"Hyperbolic space","title":"ManifoldsBase.get_vector","text":"get_vector(M::Hyperbolic, p, c, ::DefaultOrthonormalBasis)\n\nCompute the vector from the coordinates with respect to the orthogonalized version of the unit vectors from ℝ^n, where n is the manifold dimension of the Hyperbolic  M, putting them into the tangent space at p and orthonormalizing them.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.inner-Tuple{Hyperbolic, Any, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.inner","text":"inner(M::Hyperbolic, p, X, Y)\ninner(M::Hyperbolic, p::HyperboloidPoint, X::HyperboloidTangentVector, Y::HyperboloidTangentVector)\n\nCmpute the inner product in the Hyperboloid model, i.e. the minkowski_metric in the embedding. The formula reads\n\ng_p(XY) = XY_mathrmM = -X_nY_n + displaystylesum_k=1^n-1 X_kY_k\n\nThis employs the metric of the embedding, see Lorentz space, see for example the extended version [BPS15] of the paper [BPS16].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Random.rand!-Tuple{Random.AbstractRNG, Hyperbolic, Any}","page":"Hyperbolic space","title":"Random.rand!","text":"Random.rand!(rng, M::Hyperbolic, pX; vector_at = nothing, σ = one(eltype(pX)) / sqrt(manifold_dimension(M)))\n\nFill pX in-place with a random object on the Hyperbolic manifold M (hyperboloid model).\n\nBehavior\n\nIf vector_at === nothing (default) then pX is filled as a random point on the hyperboloid (an element of H^n in the hyperboloid embedding in ℝ^{n+1}). The routine samples a direction a  N(0I_n) in the first n coordinates and an offset f = 1 + σ * |N(0,1)| for the last coordinate, then sets the first n components to the vector a  sqrt(f^2 - 1)  a) and the last component to f. The resulting vector satisfies the Minkowski normalization ⟨p,p⟩_M = -1.\nIf vector_at is provided (a point on the manifold) then pX is filled with a random tangent vector at vector_at. A Euclidean Gaussian Y = σ * randn(...) is sampled and then projected to the tangent space at vector_at.\n\nArguments\n\nrng::AbstractRNG : random number generator used for sampling.\nM::Hyperbolic : the hyperbolic manifold instance (hyperboloid model).\npX : the array or wrapped type to be written in-place (point or tangent vector).\nvector_at : optional point on M indicating the base point for tangent vector sampling.\nσ::Real : scale parameter (default = 1) controlling dispersion of the samples.\n\nReturns\n\npX (mutated) : the sampled point or tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#hyperboloid_plot","page":"Hyperbolic space","title":"Visualization of the Hyperboloid","text":"","category":"section"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"For the case of Hyperbolic(2) there is plotting available based on a PlottingRecipe. You can easily plot points, connecting geodesics as well as tangent vectors.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"note: Note\nThe recipes are only loaded if Plots.jl or RecipesBase.jl is loaded.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"If we consider a set of points, we can first plot these and their connecting geodesics using the geodesic_interpolation for the points. This variable specifies with how many points a geodesic between two successive points is sampled (per default it's -1, which deactivates geodesics) and the line style is set to be a path.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"In general you can plot the surface of the hyperboloid either as wireframe (wireframe=true) additionally specifying wires (or wires_x and wires_y) to change the density of wires and a wireframe_color. The same holds for the plot as a surface (which is false by default) and its surface_resolution (or surface_resolution_x or surface_resolution_y) and a surface_color.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"using Manifolds, Plots\nM = Hyperbolic(2)\npts =  [ [0.85*cos(φ), 0.85*sin(φ), sqrt(0.85^2+1)] for φ ∈ range(0,2π,length=11) ]\nscene = plot(M, pts; geodesic_interpolation=100)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"To just plot the points atop, we can just omit the geodesic_interpolation parameter to obtain a scatter plot. Note that we avoid redrawing the wireframe in the following plot! calls.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, pts; wireframe=false)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"We can further generate tangent vectors in these spaces and use a plot for there. Keep in mind that a tangent vector in plotting always requires its base point.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"pts2 = [ [0.45 .*cos(φ + 6π/11), 0.45 .*sin(φ + 6π/11), sqrt(0.45^2+1) ] for φ ∈ range(0,2π,length=11)]\nvecs = log.(Ref(M),pts,pts2)\nplot!(scene, M, pts, vecs; wireframe=false)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"Just to illustrate, for the first point the tangent vector is pointing along the following geodesic","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, [pts[1], pts2[1]]; geodesic_interpolation=100, wireframe=false)","category":"page"},{"location":"manifolds/hyperbolic/#Internal-functions","page":"Hyperbolic space","title":"Internal functions","text":"","category":"section"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"The following functions are available for internal use to construct points in the hyperboloid model","category":"page"},{"location":"manifolds/hyperbolic/#Manifolds._hyperbolize-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"Manifolds._hyperbolize","text":"_hyperbolize(M, p, Y)\n\nGiven the Hyperbolic(n) manifold using the hyperboloid model and a point p thereon, we can put a vector Yin ℝ^n  into the tangent space by computing its last component such that for the resulting p we have that its minkowski_metric is pX_mathrmM = 0, i.e. X_n+1 = fractilde p Yp_n+1, where tilde p = (p_1ldotsp_n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manifolds._hyperbolize-Tuple{Hyperbolic, Any}","page":"Hyperbolic space","title":"Manifolds._hyperbolize","text":"_hyperbolize(M, q)\n\nGiven the Hyperbolic(n) manifold using the hyperboloid model, a point from the qin ℝ^n can be set onto the manifold by computing its last component such that for the resulting p we have that its minkowski_metric is pp_mathrmM = - 1, i.e. p_n+1 = sqrtlVert q rVert^2 - 1\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#poincare_ball","page":"Hyperbolic space","title":"Poincaré ball model","text":"","category":"section"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareBallPoint}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareBallPoint}, p::HyperboloidPoint)\nconvert(::Type{PoincareBallPoint}, p::T) where {T<:AbstractVector}\n\nconvert a HyperboloidPoint pℝ^n+1 from the hyperboloid model of the Hyperbolic manifold mathcal H^n to a PoincareBallPoint π(p)ℝ^n in the Poincaré ball model. The isometry is defined by\n\nπ(p) = frac11+p_n+1 beginpmatrixp_1p_nendpmatrix\n\nNote that this is also used, when x is a vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareBallPoint}, PoincareHalfSpacePoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareBallPoint}, p::PoincareHalfSpacePoint)\n\nconvert a point PoincareHalfSpacePoint p (from ℝ^n) from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a PoincareBallPoint π(p)  ℝ^n. Denote by tilde p = (p_1ldotsp_d-1)^mathrmT. Then the isometry is defined by\n\nπ(p) = frac1lVert tilde p rVert^2 + (p_n+1)^2\nbeginpmatrix2p_12p_n-1lVert prVert^2 - 1endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareBallTangentVector}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareBallTangentVector}, p::HyperboloidPoint, X::HyperboloidTangentVector)\nconvert(::Type{PoincareBallTangentVector}, p::P, X::T) where {P<:AbstractVector, T<:AbstractVector}\n\nconvert a HyperboloidTangentVector X at p to a PoincareBallTangentVector on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Hyperboloid to the Poincaré ball, cf. convert(::Type{PoincareBallPoint}, ::HyperboloidPoint).\n\nThe formula reads\n\nπ_*(p)X = frac1p_n+1+1Bigl(tilde X - fracX_n+1p_n+1+1tilde p Bigl)\n\nwhere tilde X = beginpmatrixX_1X_nendpmatrix and tilde p = beginpmatrixp_1p_nendpmatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareBallTangentVector}, PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{PoincareBallTangentVector},\n    p::PoincareHalfSpacePoint,\n    X::PoincareHalfSpaceTangentVector\n)\n\nconvert a PoincareHalfSpaceTangentVector X at p to a PoincareBallTangentVector on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Poincaré half space to the Poincaré ball, cf. convert(::Type{PoincareBallPoint}, ::PoincareHalfSpacePoint).\n\nThe formula reads\n\nπ_*(p)X =\nfrac1lVert tilde prVert^2 + (1+p_n)^2\nbeginpmatrix\n2X_1\n\n2X_n-1\n2Xp\nendpmatrix\n-\nfrac2(lVert tilde prVert^2 + (1+p_n)^2)^2\nbeginpmatrix\n2p_1(Xp+X_n)\n\n2p_n-1(Xp+X_n)\n(lVert p rVert^2-1)(Xp+X_n)\nendpmatrix\n\nwhere tilde p = beginpmatrixp_1p_n-1endpmatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{Tuple{PoincareBallPoint, PoincareBallTangentVector}}, Tuple{HyperboloidPoint, HyperboloidTangentVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTangentVector}},\n    (p,X)::Tuple{HyperboloidPoint,HyperboloidTangentVector}\n)\nconvert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTangentVector}},\n    (p, X)::Tuple{P,T},\n) where {P<:AbstractVector, T <: AbstractVector}\n\nConvert a HyperboloidPoint p and a HyperboloidTangentVector X to a PoincareBallPoint and a PoincareBallTangentVector simultaneously, see convert(::Type{PoincareBallPoint}, ::HyperboloidPoint) and convert(::Type{PoincareBallTangentVector}, ::HyperboloidPoint, ::HyperboloidTangentVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{Tuple{PoincareBallPoint, PoincareBallTangentVector}}, Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTangentVector}},\n    (p,X)::Tuple{HyperboloidPoint,HyperboloidTangentVector}\n)\nconvert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTangentVector}},\n    (p, X)::Tuple{T,T},\n) where {T <: AbstractVector}\n\nConvert a PoincareHalfSpacePoint p and a PoincareHalfSpaceTangentVector X to a PoincareBallPoint and a PoincareBallTangentVector simultaneously, see convert(::Type{PoincareBallPoint}, ::PoincareHalfSpacePoint) and convert(::Type{PoincareBallTangentVector}, ::PoincareHalfSpacePoint, ::PoincareHalfSpaceTangentVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.change_metric-Tuple{Hyperbolic, EuclideanMetric, PoincareBallPoint, PoincareBallTangentVector}","page":"Hyperbolic space","title":"ManifoldsBase.change_metric","text":"change_metric(M::Hyperbolic, ::EuclideanMetric, p::PoincareBallPoint, X::PoincareBallTangentVector)\n\nSince in the metric we always have the term α = frac21-sum_i=1^n p_i^2 per element, the correction for the metric reads Z = frac1αX.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.change_representer-Tuple{Hyperbolic, EuclideanMetric, PoincareBallPoint, PoincareBallTangentVector}","page":"Hyperbolic space","title":"ManifoldsBase.change_representer","text":"change_representer(M::Hyperbolic, ::EuclideanMetric, p::PoincareBallPoint, X::PoincareBallTangentVector)\n\nSince in the metric we have the term α = frac21-sum_i=1^n p_i^2 per element, the correction for the gradient reads Y = frac1α^2X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.distance-Tuple{Hyperbolic, PoincareBallPoint, PoincareBallPoint}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(::Hyperbolic, p::PoincareBallPoint, q::PoincareBallPoint)\n\nCompute the distance on the Hyperbolic manifold mathcal H^n represented in the Poincaré ball model. The formula reads\n\nd_mathcal H^n(pq) =\noperatornameacoshBigl(\n  1 + frac2lVert p - q rVert^2(1-lVert prVert^2)(1-lVert qrVert^2)\nBigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.inner-Tuple{Hyperbolic, PoincareBallPoint, PoincareBallTangentVector, PoincareBallTangentVector}","page":"Hyperbolic space","title":"ManifoldsBase.inner","text":"inner(::Hyperbolic, p::PoincareBallPoint, X::PoincareBallTangentVector, Y::PoincareBallTangentVector)\n\nCompute the inner product in the Poincaré ball model. The formula reads\n\ng_p(XY) = frac4(1-lVert p rVert^2)^2  X Y \n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.project-Tuple{Hyperbolic, PoincareBallPoint, PoincareBallTangentVector}","page":"Hyperbolic space","title":"ManifoldsBase.project","text":"project(::Hyperbolic, ::PoincareBallPoint, ::PoincareBallTangentVector)\n\nprojection of tangent vectors in the Poincaré ball model is just the identity, since the tangent space consists of all ℝ^n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#poincare_ball_plot","page":"Hyperbolic space","title":"Visualization of the Poincaré ball","text":"","category":"section"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"For the case of Hyperbolic(2) there is a plotting available based on a PlottingRecipe you can easily plot points, connecting geodesics as well as tangent vectors.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"note: Note\nThe recipes are only loaded if Plots.jl or RecipesBase.jl is loaded.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"If we consider a set of points, we can first plot these and their connecting geodesics using the geodesic_interpolation For the points. This variable specifies with how many points a geodesic between two successive points is sampled (per default it's -1, which deactivates geodesics) and the line style is set to be a path. Another keyword argument added is the border of the Poincaré disc, namely circle_points = 720 resolution of the drawn boundary (every hlaf angle) as well as its color, hyperbolic_border_color = RGBA(0.0, 0.0, 0.0, 1.0).","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"using Manifolds, Plots\nM = Hyperbolic(2)\npts = PoincareBallPoint.( [0.85 .* [cos(φ), sin(φ)] for φ ∈ range(0,2π,length=11)])\nscene = plot(M, pts, geodesic_interpolation = 100)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"To just plot the points atop, we can just omit the geodesic_interpolation parameter to obtain a scatter plot","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, pts)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"We can further generate tangent vectors in these spaces and use a plot for there. Keep in mind, that a tangent vector in plotting always requires its base point","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"pts2 = PoincareBallPoint.( [0.45 .* [cos(φ + 6π/11), sin(φ + 6π/11)] for φ ∈ range(0,2π,length=11)])\nvecs = log.(Ref(M),pts,pts2)\nplot!(scene, M, pts,vecs)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"Just to illustrate, for the first point the tangent vector is pointing along the following geodesic","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, [pts[1], pts2[1]], geodesic_interpolation=100)","category":"page"},{"location":"manifolds/hyperbolic/#poincare_halfspace","page":"Hyperbolic space","title":"Poincaré half space model","text":"","category":"section"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareHalfSpacePoint}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpacePoint}, p::Hyperboloid)\nconvert(::Type{PoincareHalfSpacePoint}, p)\n\nconvert a HyperboloidPoint or Vectorp (from ℝ^n+1) from the Hyperboloid model of the Hyperbolic manifold mathcal H^n to a PoincareHalfSpacePoint π(x)  ℝ^n.\n\nThis is done in two steps, namely transforming it to a Poincare ball point and from there further on to a PoincareHalfSpacePoint point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareHalfSpacePoint}, PoincareBallPoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpacePoint}, p::PoincareBallPoint)\n\nconvert a point PoincareBallPoint p (from ℝ^n) from the Poincaré ball model of the Hyperbolic manifold mathcal H^n to a PoincareHalfSpacePoint π(p)  ℝ^n. Denote by tilde p = (p_1ldotsp_n-1). Then the isometry is defined by\n\nπ(p) = frac1lVert tilde p rVert^2 - (p_n-1)^2\nbeginpmatrix2p_12p_n-11-lVert prVert^2endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareHalfSpaceTangentVector}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpaceTangentVector}, p::HyperboloidPoint, ::HyperboloidTangentVector)\nconvert(::Type{PoincareHalfSpaceTangentVector}, p::P, X::T) where {P<:AbstractVector, T<:AbstractVector}\n\nconvert a HyperboloidTangentVector X at p to a PoincareHalfSpaceTangentVector on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Hyperboloid to the Poincaré half space, cf. convert(::Type{PoincareHalfSpacePoint}, ::HyperboloidPoint).\n\nThis is done similarly to the approach there, i.e. by using the Poincaré ball model as an intermediate step.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{PoincareHalfSpaceTangentVector}, PoincareBallPoint, PoincareBallTangentVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpaceTangentVector}, p::PoincareBallPoint, X::PoincareBallTangentVector)\n\nconvert a PoincareBallTangentVector X at p to a PoincareHalfSpacePoint on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Poincaré ball to the Poincaré half space, cf. convert(::Type{PoincareHalfSpacePoint}, ::PoincareBallPoint).\n\nThe formula reads\n\nπ_*(p)X =\nfrac1lVert tilde prVert^2 + (1-p_n)^2\nbeginpmatrix\n2X_1\n\n2X_n-1\n-2Xp\nendpmatrix\n-\nfrac2(lVert tilde prVert^2 + (1-p_n)^2)^2\nbeginpmatrix\n2p_1(Xp-X_n)\n\n2p_n-1(Xp-X_n)\n(lVert p rVert^2-1)(Xp-X_n)\nendpmatrix\n\nwhere tilde p = beginpmatrixp_1p_n-1endpmatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}}, Tuple{HyperboloidPoint, HyperboloidTangentVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareHalfSpacePoint,PoincareHalfSpaceTangentVector}},\n    (p,X)::Tuple{HyperboloidPoint,HyperboloidTangentVector}\n)\nconvert(\n    ::Type{Tuple{PoincareHalfSpacePoint,PoincareHalfSpaceTangentVector}},\n    (p, X)::Tuple{P,T},\n) where {P<:AbstractVector, T <: AbstractVector}\n\nConvert a HyperboloidPoint p and a HyperboloidTangentVector X to a PoincareHalfSpacePoint and a PoincareHalfSpaceTangentVector simultaneously, see convert(::Type{PoincareHalfSpacePoint}, ::HyperboloidPoint) and convert(::Type{PoincareHalfSpaceTangentVector}, ::Tuple{HyperboloidPoint,HyperboloidTangentVector}) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.convert-Tuple{Type{Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector}}, Tuple{PoincareBallPoint, PoincareBallTangentVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareHalfSpacePoint,PoincareHalfSpaceTangentVector}},\n    (p,X)::Tuple{PoincareBallPoint,PoincareBallTangentVector}\n)\n\nConvert a PoincareBallPoint p and a PoincareBallTangentVector X to a PoincareHalfSpacePoint and a PoincareHalfSpaceTangentVector simultaneously, see convert(::Type{PoincareHalfSpacePoint}, ::PoincareBallPoint) and convert(::Type{PoincareHalfSpaceTangentVector}, ::PoincareBallPoint,::PoincareBallTangentVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.distance-Tuple{Hyperbolic, PoincareHalfSpacePoint, PoincareHalfSpacePoint}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(::Hyperbolic, p::PoincareHalfSpacePoint, q::PoincareHalfSpacePoint)\n\nCompute the distance on the Hyperbolic manifold mathcal H^n represented in the Poincaré half space model. The formula reads\n\nd_mathcal H^n(pq) = operatornameacoshBigl( 1 + fraclVert p - q rVert^22 p_n q_n Bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.inner-Tuple{Hyperbolic, PoincareHalfSpacePoint, PoincareHalfSpaceTangentVector, PoincareHalfSpaceTangentVector}","page":"Hyperbolic space","title":"ManifoldsBase.inner","text":"inner(\n    ::Hyperbolic,\n    p::PoincareHalfSpacePoint,\n    X::PoincareHalfSpaceTangentVector,\n    Y::PoincareHalfSpaceTangentVector\n)\n\nCompute the inner product in the Poincaré half space model. The formula reads\n\ng_p(XY) = fracXYp_n^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#ManifoldsBase.project-Tuple{Hyperbolic, PoincareHalfSpaceTangentVector}","page":"Hyperbolic space","title":"ManifoldsBase.project","text":"project(::Hyperbolic, ::PoincareHalfSpacePoint ::PoincareHalfSpaceTangentVector)\n\nprojection of tangent vectors in the Poincaré half space model is just the identity, since the tangent space consists of all ℝ^n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#poincare_half_plane_plot","page":"Hyperbolic space","title":"Visualization on the Poincaré half plane","text":"","category":"section"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"For the case of Hyperbolic(2) there is a plotting available based on a PlottingRecipe you can easily plot points, connecting geodesics as well as tangent vectors.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"note: Note\nThe recipes are only loaded if Plots.jl or RecipesBase.jl is loaded.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"We again have two different recipes, one for points, one for tangent vectors, where the first one again can be equipped with geodesics between the points. In the following example we generate 7 points on an ellipse in the Hyperboloid model.","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"using Manifolds, Plots\nM = Hyperbolic(2)\npre_pts = [2.0 .* [5.0*cos(φ), sin(φ)] for φ ∈ range(0,2π,length=7)]\npts = convert.(\n    Ref(PoincareHalfSpacePoint),\n    Manifolds._hyperbolize.(Ref(M), pre_pts)\n)\nscene = plot(M, pts, geodesic_interpolation = 100)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"To just plot the points atop, we can just omit the geodesic_interpolation parameter to obtain a scatter plot","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, pts)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"We can further generate tangent vectors in these spaces and use a plot for there. Keep in mind, that a tangent vector in plotting always requires its base point. Here we would like to look at the tangent vectors pointing to the origin","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"origin = PoincareHalfSpacePoint([0.0,1.0])\nvecs = [log(M,p,origin) for p ∈ pts]\nscene = plot!(scene, M, pts, vecs)","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"And we can again look at the corresponding geodesics, for example","category":"page"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, [pts[1], origin], geodesic_interpolation=100)\nplot!(scene, M, [pts[2], origin], geodesic_interpolation=100)","category":"page"},{"location":"manifolds/hyperbolic/#Literature","page":"Hyperbolic space","title":"Literature","text":"","category":"section"},{"location":"manifolds/hyperbolic/","page":"Hyperbolic space","title":"Hyperbolic space","text":"R. Bergmann, J. Persch and G. Steidl. A parallel Douglas Rachford algorithm for minimizing ROF-like functionals on images with values in symmetric Hadamard manifolds, arXiv Preprint (2015), arXiv:1512.02814.\n\n\n\nR. Bergmann, J. Persch and G. Steidl. A parallel Douglas Rachford algorithm for minimizing ROF-like functionals on images with values in symmetric Hadamard manifolds. SIAM Journal on Imaging Sciences 9, 901–937 (2016).\n\n\n\nE. Chevallier, D. Li, Y. Lu and D. B. Dunson. Exponential-wrapped distributions on symmetric spaces. ArXiv Preprint (2022).\n\n\n\nJ. M. Lee. Introduction to Riemannian Manifolds (Springer Cham, 2019).\n\n\n\nD. Nguyen. Operator-Valued Formulas for Riemannian Gradient and Hessian and Families of Tractable Metrics in Riemannian Optimization. Journal of Optimization Theory and Applications 198, 135–164 (2023), arXiv:2009.10159.\n\n\n\n","category":"page"},{"location":"manifolds/projectivespace/#Projective-space","page":"Projective space","title":"Projective space","text":"","category":"section"},{"location":"manifolds/projectivespace/#Manifolds.AbstractProjectiveSpace","page":"Projective space","title":"Manifolds.AbstractProjectiveSpace","text":"AbstractProjectiveSpace{𝔽} <: AbstractDecoratorManifold{𝔽}\n\nAn abstract type to represent a projective space over 𝔽 that is represented isometrically in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/projectivespace/#Manifolds.ArrayProjectiveSpace","page":"Projective space","title":"Manifolds.ArrayProjectiveSpace","text":"ArrayProjectiveSpace{𝔽, T<:Tuple} <: AbstractProjectiveSpace{𝔽}\n\nThe projective space 𝔽ℙ^n₁n₂nᵢ is the manifold of all lines in 𝔽^n₁n₂nᵢ. The default representation is in the embedding, i.e. as unit (Frobenius) norm matrices in 𝔽^n₁n₂nᵢ:\n\n𝔽ℙ^n_1 n_2  n_i = bigl p  𝔽^n_1 n_2  n_i  big lVert p rVert_mathrmF = 1 λ  𝔽 λ = 1 p  p λ bigr\n\nwhere p is an equivalence class of points p,  indicates equivalence, and lVert  rVert_mathrmF is the Frobenius norm. Note that unlike ProjectiveSpace, the argument for ArrayProjectiveSpace is given by the size of the embedding. This means that ProjectiveSpace(2) and ArrayProjectiveSpace(3) are the same manifold. Additionally, ArrayProjectiveSpace(n,1;field=𝔽) and Grassmann(n,1;field=𝔽) are the same.\n\nThe tangent space at point p is given by\n\nT_p 𝔽ℙ^n_1 n_2  n_i = bigl X  𝔽^n_1 n_2  n_i  pX_mathrmF = 0 bigr \n\nwhere _mathrmF denotes the (Frobenius) inner product in the embedding 𝔽^n_1 n_2  n_i.\n\nConstructor\n\nArrayProjectiveSpace(n₁,n₂,...,nᵢ; field=ℝ)\n\nGenerate the projective space 𝔽ℙ^n_1 n_2  n_i, defaulting to the real projective space, where field can also be used to generate the complex- and right-quaternionic projective spaces.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/projectivespace/#Manifolds.ProjectiveSpace","page":"Projective space","title":"Manifolds.ProjectiveSpace","text":"ProjectiveSpace{𝔽, n} <: AbstractProjectiveSpace{𝔽}\n\nThe projective space 𝔽ℙ^n is the manifold of all lines in 𝔽^n+1. The default representation is in the embedding, i.e. as unit norm vectors in 𝔽^n+1:\n\n𝔽ℙ^n = bigl p  𝔽^n+1  big lVert p rVert = 1 λ  𝔽 λ = 1 p  p λ bigr\n\nwhere p is an equivalence class of points p, and  indicates equivalence. For example, the real projective space ℝℙ^n is represented as the unit sphere 𝕊^n, where antipodal points are considered equivalent.\n\nThe tangent space at point p is given by\n\nT_p 𝔽ℙ^n = bigl X  𝔽^n+1 big pX = 0 bigr \n\nwhere  denotes the inner product in the embedding 𝔽^n+1.\n\nWhen 𝔽 = ℍ, this implementation of ℍℙ^n is the right-quaternionic projective space.\n\nConstructor\n\nProjectiveSpace(n[, field=ℝ])\n\nGenerate the projective space 𝔽ℙ^n  𝔽^n+1, defaulting to the real projective space ℝℙ^n, where field can also be used to generate the complex- and right-quaternionic projective spaces.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/projectivespace/#Base.log-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"Base.log","text":"log(M::AbstractProjectiveSpace, p, q)\n\nCompute the logarithmic map on AbstractProjectiveSpace M= 𝔽ℙ^n, i.e. the tangent vector whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = (q λ - cos θ p) fracθsin θ\n\nwhere θ = arccosq p_mathrmF is the distance between p and q,  _mathrmF is the Frobenius inner product, and λ = fracq p_mathrmFq p_mathrmF  𝔽 is the unit scalar that minimizes d_𝔽^n+1(p - q λ). That is, q λ is the member of the equivalence class q that is closest to p in the embedding. As a result, exp_p circ log_p colon q  q λ.\n\nThe logarithmic maps for the real AbstractSphere 𝕊^n and the real projective space ℝℙ^n are identical when p and q are in the same hemisphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#Manifolds.manifold_volume-Tuple{AbstractProjectiveSpace{ℝ}}","page":"Projective space","title":"Manifolds.manifold_volume","text":"manifold_volume(M::AbstractProjectiveSpace{ℝ})\n\nVolume of the n-dimensional AbstractProjectiveSpace M. The formula reads:\n\nfracpi^(n+1)2Γ((n+1)2)\n\nwhere Γ denotes the Gamma function. For details see [BST03].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase._isapprox-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"ManifoldsBase._isapprox","text":"isapprox(M::AbstractProjectiveSpace, p, q; kwargs...)\n\nCheck that points p and q on the AbstractProjectiveSpace M=𝔽ℙ^n are members of the same equivalence class, i.e. that p = q λ for some element λ  𝔽 with unit absolute value, that is, λ = 1. This is equivalent to the Riemannian distance being 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.check_point-Tuple{AbstractProjectiveSpace, Any}","page":"Projective space","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractProjectiveSpace, p; kwargs...)\n\nCheck whether p is a valid point on the AbstractProjectiveSpace M, i.e. that it has the same size as elements of the embedding and has unit Frobenius norm. The tolerance for the norm check can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{AbstractProjectiveSpace, Any, T}} where T","page":"Projective space","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractProjectiveSpace, p, X; kwargs... )\n\nCheck whether X is a tangent vector in the tangent space of p on the AbstractProjectiveSpace M, i.e. that X has the same size as elements of the tangent space of the embedding and that the Frobenius inner product p X_mathrmF = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.distance-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"ManifoldsBase.distance","text":"distance(M::AbstractProjectiveSpace, p, q)\n\nCompute the Riemannian distance on AbstractProjectiveSpace M=𝔽ℙ^n between points p and q, i.e.\n\nd_𝔽ℙ^n(p q) = arccosbigl p q_mathrmF bigr\n\nNote that this definition is similar to that of the AbstractSphere. However, the absolute value ensures that all equivalent p and q have the same pairwise distance.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.get_coordinates-Tuple{AbstractProjectiveSpace{ℝ}, Any, Any, DefaultOrthonormalBasis}","page":"Projective space","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractProjectiveSpace, p, X, B::DefaultOrthonormalBasis{ℝ})\n\nRepresent the tangent vector X at point p from the AbstractProjectiveSpace M = 𝔽ℙ^n in an orthonormal basis by unitarily transforming the hyperplane containing X, whose normal is p, to the hyperplane whose normal is the x-axis.\n\nGiven q = p overlineλ + x, where λ = fracx p_mathrmFx p_mathrmF,  _mathrmF denotes the Frobenius inner product, and overline denotes complex or quaternionic conjugation, the formula for Y is\n\nbeginpmatrix0  Yendpmatrix = left(X - qfrac2 q X_mathrmFq q_mathrmFright)overlineλ\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.get_vector-Tuple{AbstractProjectiveSpace, Any, Any, DefaultOrthonormalBasis{ℝ}}","page":"Projective space","title":"ManifoldsBase.get_vector","text":"get_vector(M::AbstractProjectiveSpace, p, X, B::DefaultOrthonormalBasis{ℝ})\n\nConvert a one-dimensional vector of coefficients X in the basis B of the tangent space at p on the AbstractProjectiveSpace M=𝔽ℙ^n to a tangent vector Y at p by unitarily transforming the hyperplane containing X, whose normal is the x-axis, to the hyperplane whose normal is p.\n\nGiven q = p overlineλ + x, where λ = fracx p_mathrmFx p_mathrmF,  _mathrmF denotes the Frobenius inner product, and overline denotes complex or quaternionic conjugation, the formula for Y is\n\nY = left(X - qfrac2 leftlangle q beginpmatrix0  Xendpmatrixrightrangle_mathrmFq q_mathrmFright) λ\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.inverse_retract-Tuple{AbstractProjectiveSpace, Any, Any, Union{PolarInverseRetraction, ProjectionInverseRetraction, QRInverseRetraction}}","page":"Projective space","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractProjectiveSpace, p, q, method::ProjectionInverseRetraction)\ninverse_retract(M::AbstractProjectiveSpace, p, q, method::PolarInverseRetraction)\ninverse_retract(M::AbstractProjectiveSpace, p, q, method::QRInverseRetraction)\n\nCompute the equivalent inverse retraction ProjectionInverseRetraction, PolarInverseRetraction on the AbstractProjectiveSpace manifold M=𝔽ℙ^n, i.e.\n\noperatornameretr_p^-1 q = q frac1p q_mathrmF - p\n\nwhere  _mathrmF is the Frobenius inner product.\n\nNote that this inverse retraction is equivalent to the three corresponding inverse retractions on Grassmann(n+1,1,𝔽), where the three inverse retractions in this case coincide. For ℝℙ^n, it is the same as the ProjectionInverseRetraction on the real Sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.is_flat-Tuple{AbstractProjectiveSpace}","page":"Projective space","title":"ManifoldsBase.is_flat","text":"is_flat(M::AbstractProjectiveSpace)\n\nReturn true if AbstractProjectiveSpace is of dimension 1 and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.manifold_dimension-Union{Tuple{AbstractProjectiveSpace{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Projective space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractProjectiveSpace{𝔽}) where {𝔽}\n\nReturn the real dimension of the AbstractProjectiveSpace M, respectively i.e. the real dimension of the embedding minus the real dimension of the field 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.parallel_transport_direction-Tuple{AbstractProjectiveSpace, Any, Any, Any}","page":"Projective space","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::AbstractProjectiveSpace, p, X, d)\n\nParallel transport a vector X from the tangent space at a point p on the AbstractProjectiveSpace M along the geodesic in the direction indicated by the tangent vector d, i.e.\n\nmathcalP_exp_p (d)  p(X) = X - left(p fracsin θθ + d frac1 - cos θθ^2right) d X_p\n\nwhere θ = lVert d rVert, and  _p is the inner product at the point p. For the real projective space, this is equivalent to the same vector transport on the real AbstractSphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.parallel_transport_to-Tuple{AbstractProjectiveSpace, Any, Any, Any}","page":"Projective space","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::AbstractProjectiveSpace, p, X, q)\n\nParallel transport a vector X from the tangent space at a point p on the AbstractProjectiveSpace M=𝔽ℙ^n to the tangent space at another point q.\n\nThis implementation proceeds by transporting X to T_q λ M using the same approach as parallel_transport_direction, where λ = fracq p_mathrmFq p_mathrmF  𝔽 is the unit scalar that takes q to the member q λ of its equivalence class q closest to p in the embedding. It then maps the transported vector from T_q λ M to T_q M. The resulting transport to T_q M is\n\nmathcalP_q  p(X) = left(X - left(p fracsin θθ + d frac1 - cos θθ^2right) d X_pright) overlineλ\n\nwhere d = log_p q is the direction of the transport, θ = lVert d rVert_p is the distance between p and q, and overline denotes complex or quaternionic conjugation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.project-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"ManifoldsBase.project","text":"project(M::AbstractProjectiveSpace, p, X)\n\nOrthogonally project the point X onto the tangent space at p on the AbstractProjectiveSpace M:\n\noperatornameproj_p (X) = X - pp X_mathrmF\n\nwhere  _mathrmF denotes the Frobenius inner product. For the real AbstractSphere and AbstractProjectiveSpace, this projection is the same.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.project-Tuple{AbstractProjectiveSpace, Any}","page":"Projective space","title":"ManifoldsBase.project","text":"project(M::AbstractProjectiveSpace, p)\n\nOrthogonally project the point p from the embedding onto the AbstractProjectiveSpace M:\n\noperatornameproj(p) = fracplVert p rVert_mathrmF\n\nwhere lVert  rVert_mathrmF denotes the Frobenius norm. This is identical to projection onto the AbstractSphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.representation_size-Tuple{ArrayProjectiveSpace}","page":"Projective space","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractProjectiveSpace)\n\nReturn the size points on the AbstractProjectiveSpace M are represented as, i.e., the representation size of the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#ManifoldsBase.retract-Tuple{AbstractProjectiveSpace, Any, Any, Union{PolarRetraction, ProjectionRetraction, QRRetraction}}","page":"Projective space","title":"ManifoldsBase.retract","text":"retract(M::AbstractProjectiveSpace, p, X, method::ProjectionRetraction)\nretract(M::AbstractProjectiveSpace, p, X, method::PolarRetraction)\nretract(M::AbstractProjectiveSpace, p, X, method::QRRetraction)\n\nCompute the equivalent retraction ProjectionRetraction, and QRRetraction on the AbstractProjectiveSpace manifold M=𝔽ℙ^n, i.e.\n\noperatornameretr_p X = operatornameproj_p(p + X)\n\nNote that this retraction is equivalent to the three corresponding retractions on Grassmann(n+1,1,𝔽), where in this case they coincide. For ℝℙ^n, it is the same as the ProjectionRetraction on the real Sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace/#Statistics.mean-Tuple{AbstractProjectiveSpace, Vararg{Any}}","page":"Projective space","title":"Statistics.mean","text":"mean(\n    M::AbstractProjectiveSpace,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of points in vector x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#VectorBundleSection","page":"Vector bundle","title":"Vector bundles","text":"","category":"section"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"Vector bundle E is a special case of a fiber bundle where each fiber is a vector space.","category":"page"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"Tangent bundle is a simple example of a vector bundle, where each fiber is the tangent space at the specified point p. An object representing a tangent bundle can be obtained using the constructor called TangentBundle.","category":"page"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"There is also another type, VectorSpaceFiber, that represents a specific fiber at a given point. This is also considered a manifold.","category":"page"},{"location":"manifolds/vector_bundle/#FVector","page":"Vector bundle","title":"FVector","text":"","category":"section"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"For cases where confusion between different types of vectors is possible, the type FVector can be used to express which type of vector space the vector belongs to. It is used for example in musical isomorphisms (the flat and sharp functions) that are used to go from a tangent space to cotangent space and vice versa.","category":"page"},{"location":"manifolds/vector_bundle/#Documentation","page":"Vector bundle","title":"Documentation","text":"","category":"section"},{"location":"manifolds/vector_bundle/#Manifolds.TensorProductType","page":"Vector bundle","title":"Manifolds.TensorProductType","text":"TensorProductType(spaces::VectorSpaceType...)\n\nVector space type corresponding to the tensor product of given vector space types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle/#Manifolds.TangentBundle","page":"Vector bundle","title":"Manifolds.TangentBundle","text":"TangentBundle{𝔽,M} = VectorBundle{𝔽,TangentSpaceType,M} where {𝔽,M<:AbstractManifold{𝔽}}\n\nTangent bundle for manifold of type M, as a manifold with the Sasaki metric [Sas58].\n\nExact retraction and inverse retraction can be approximated using FiberBundleProductRetraction, FiberBundleInverseProductRetraction and SasakiRetraction. FiberBundleProductVectorTransport can be used as a vector transport.\n\nConstructors\n\nTangentBundle(M::AbstractManifold)\nTangentBundle(M::AbstractManifold, vtm::FiberBundleProductVectorTransport)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle/#Manifolds.VectorBundle","page":"Vector bundle","title":"Manifolds.VectorBundle","text":"VectorBundle{𝔽,TVS,TM,VTV} = FiberBundle{𝔽,TVS,TM,TVT} where {TVS<:VectorSpaceType}\n\nAlias for FiberBundle when fiber type is a TVS of type VectorSpaceType.\n\nVectorSpaceFiberType is used to encode vector spaces as fiber types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle/#Manifolds.fiber_bundle_transport-Tuple{AbstractManifold, ManifoldsBase.FiberType}","page":"Vector bundle","title":"Manifolds.fiber_bundle_transport","text":"fiber_bundle_transport(M::AbstractManifold, fiber::FiberType)\n\nDetermine the vector transport used for exp and log maps on a vector bundle with fiber type fiber and manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.injectivity_radius-Tuple{FiberBundle{𝔽, TangentSpaceType, M} where {𝔽, M<:AbstractManifold{𝔽}}}","page":"Vector bundle","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::TangentBundle)\n\nInjectivity radius of TangentBundle manifold is infinite if the base manifold is flat and 0 otherwise. See https://mathoverflow.net/questions/94322/injectivity-radius-of-the-sasaki-metric.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.inner-Tuple{FiberBundle, Any, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundle, p, X, Y)\n\nInner product of tangent vectors X and Y at point p from the vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe tangent vector v = (V_XM V_XF)  T_xB where V_XM is a tangent vector from the tangent space T_x_pmathcal M and V_XF is a tangent vector from the tangent space T_V_pF (isomorphic to F). Similarly for the other tangent vector w = (V_YM V_YF)  T_xB.\n\nThe inner product is calculated as\n\nX Y_p = V_XM V_YM_x_p + V_XF V_YF_V_p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.inverse_retract-Tuple{VectorBundle{𝔽} where 𝔽, Any, Any, Manifolds.FiberBundleInverseProductRetraction}","page":"Vector bundle","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::VectorBundle, p, q, ::FiberBundleInverseProductRetraction)\n\nCompute the allocating variant of the FiberBundleInverseProductRetraction, which by default allocates and calls inverse_retract_product!.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.is_flat-Tuple{VectorBundle{𝔽} where 𝔽}","page":"Vector bundle","title":"ManifoldsBase.is_flat","text":"is_flat(::VectorBundle)\n\nReturn true if the underlying manifold of VectorBundle M is flat.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.project-Tuple{VectorBundle{𝔽} where 𝔽, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundle, p, X)\n\nProject the element X of the ambient space of the tangent space T_p B to the tangent space T_p B.\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe vector x = (V_XM V_XF) where x_p belongs to the ambient space of T_x_pmathcal M and V_XF belongs to the ambient space of the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting V_XM to tangent space T_x_pmathcal M and then projecting the vector V_XF to the fiber F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.project-Tuple{VectorBundle{𝔽} where 𝔽, Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundle, p)\n\nProject the point p from the ambient space of the vector bundle B over manifold B.fiber (denoted mathcal M) to the vector bundle.\n\nNotation:\n\nThe point p = (x_p V_p) where x_p belongs to the ambient space of mathcal M and V_p belongs to the ambient space of the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting the point x_p to the manifold mathcal M and then projecting the vector V_p to the tangent space T_x_pmathcal M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.retract-Tuple{VectorBundle{𝔽} where 𝔽, Any, Any, Manifolds.FiberBundleProductRetraction}","page":"Vector bundle","title":"ManifoldsBase.retract","text":"retract(M::VectorBundle, p, q, ::FiberBundleProductRetraction)\n\nCompute the allocating variant of the FiberBundleProductRetraction, which by default allocates and calls retract_product!.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#ManifoldsBase.vector_transport_to-Tuple{VectorBundle{𝔽} where 𝔽, Any, Any, Any, Manifolds.FiberBundleProductVectorTransport}","page":"Vector bundle","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::VectorBundle, p, X, q, m::FiberBundleProductVectorTransport)\n\nCompute the vector transport the tangent vector Xat p to q on the VectorBundle M using the FiberBundleProductVectorTransport m.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle/#Example","page":"Vector bundle","title":"Example","text":"","category":"section"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"The following code defines a point on the tangent bundle of the sphere S^2 and a tangent vector to that point.","category":"page"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"using Manifolds, RecursiveArrayTools\nM = Sphere(2)\nTB = TangentBundle(M)\np = ArrayPartition([1.0, 0.0, 0.0], [0.0, 1.0, 3.0])\nX = ArrayPartition([0.0, 1.0, 0.0], [0.0, 0.0, -2.0])","category":"page"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"An approximation of the exponential in the Sasaki metric using 1000 steps can be calculated as follows.","category":"page"},{"location":"manifolds/vector_bundle/","page":"Vector bundle","title":"Vector bundle","text":"q = retract(TB, p, X, SasakiRetraction(1000))\nprintln(\"Approximation of the exponential map: \", q)","category":"page"},{"location":"manifolds/spheresymmetricmatrices/#Unit-norm-symmetric-matrices","page":"Unit-norm symmetric matrices","title":"Unit-norm symmetric matrices","text":"","category":"section"},{"location":"manifolds/spheresymmetricmatrices/#Manifolds.SphereSymmetricMatrices","page":"Unit-norm symmetric matrices","title":"Manifolds.SphereSymmetricMatrices","text":"SphereSymmetricMatrices{𝔽, T} <: AbstractEmbeddedManifold{ℝ,TransparentIsometricEmbedding}\n\nThe AbstractManifold  consisting of the nn symmetric matrices of unit Frobenius norm, i.e.\n\nmathcalS_textsym =biglp   𝔽^nn big p^mathrmH = p lVert p rVert = 1 bigr\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ.\n\nConstructor\n\nSphereSymmetricMatrices(n[, field=ℝ])\n\nGenerate the manifold of n-by-n symmetric matrices of unit Frobenius norm.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spheresymmetricmatrices/#ManifoldsBase.check_point-Union{Tuple{T}, Tuple{SphereSymmetricMatrices, T}} where T","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.check_point","text":"check_point(M::SphereSymmetricMatrices, p; kwargs...)\n\nCheck whether the matrix is a valid point on the SphereSymmetricMatrices M, i.e. is an n-by-n symmetric matrix of unit Frobenius norm.\n\nThe tolerance for the symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{SphereSymmetricMatrices, Any, T}} where T","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::SphereSymmetricMatrices, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SphereSymmetricMatrices M, i.e. X has to be a symmetric matrix of size (n,n) of unit Frobenius norm.\n\nThe tolerance for the symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices/#ManifoldsBase.is_flat-Tuple{SphereSymmetricMatrices}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::SphereSymmetricMatrices)\n\nReturn false. SphereSymmetricMatrices is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices/#ManifoldsBase.manifold_dimension-Union{Tuple{SphereSymmetricMatrices{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SphereSymmetricMatrices{<:Any,𝔽})\n\nReturn the manifold dimension of the SphereSymmetricMatrices n-by-n symmetric matrix M of unit Frobenius norm over the number system 𝔽, i.e.\n\nbeginaligned\ndim(mathcalS_textsym)(nℝ) = fracn(n+1)2 - 1\ndim(mathcalS_textsym)(nℂ) = 2fracn(n+1)2 - n -1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices/#ManifoldsBase.project-Tuple{SphereSymmetricMatrices, Any, Any}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SphereSymmetricMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SphereSymmetricMatrices M, i.e.\n\noperatornameproj_p(X) = fracX + X^mathrmH2 - p fracX + X^mathrmH2p\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices/#ManifoldsBase.project-Tuple{SphereSymmetricMatrices, Any}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SphereSymmetricMatrices, p)\n\nProjects p from the embedding onto the SphereSymmetricMatrices M, i.e.\n\noperatornameproj_mathcalS_textsym(p) = frac12 bigl( p + p^mathrmH bigr)\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#Positive-Numbers","page":"Positive numbers","title":"Positive Numbers","text":"","category":"section"},{"location":"manifolds/positivenumbers/","page":"Positive numbers","title":"Positive numbers","text":"The manifold PositiveNumbers represents positive numbers with hyperbolic geometry. Additionally, there are also short forms for its corresponding PowerManifolds, i.e. PositiveVectors, PositiveMatrices, and PositiveArrays.","category":"page"},{"location":"manifolds/positivenumbers/#Manifolds.PositiveNumbers","page":"Positive numbers","title":"Manifolds.PositiveNumbers","text":"PositiveNumbers <: AbstractManifold{ℝ}\n\nThe hyperbolic manifold of positive numbers H^1 is a the hyperbolic manifold represented by just positive numbers.\n\nConstructor\n\nPositiveNumbers()\n\nGenerate the ℝ-valued hyperbolic model represented by positive positive numbers. To use this with arrays (1-element arrays), please use SymmetricPositiveDefinite(1).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/positivenumbers/#Base.exp-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"Base.exp","text":"exp(M::PositiveNumbers, p, X)\n\nCompute the exponential map on the PositiveNumbers M.\n\nexp_p X = poperatornameexp(Xp)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#Base.log-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"Base.log","text":"log(M::PositiveNumbers, p, q)\n\nCompute the logarithmic map on the PositiveNumbers M.\n\nlog_p q = plogfracqp\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldDiff.riemannian_Hessian-Tuple{PositiveNumbers, Vararg{Any, 4}}","page":"Positive numbers","title":"ManifoldDiff.riemannian_Hessian","text":"riemannian_Hessian(M::SymmetricPositiveDefinite, p, G, H, X)\n\nThe Riemannian Hessian can be computed as stated in Eq. (7.3) [Ngu23]. Let nabla f(p) denote the Euclidean gradient G, nabla^2 f(p)X the Euclidean Hessian H. Then the formula reads\n\n    operatornameHessf(p)X = pbigl(^2 f(p)Xbigr)p + Xbigl(f(p)bigr)p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#Manifolds.PositiveArrays-Union{NTuple{I, Int64}, Tuple{I}} where I","page":"Positive numbers","title":"Manifolds.PositiveArrays","text":"PositiveArrays(n₁, n₂, ..., nᵢ; parameter::Symbol=:type)\n\nGenerate the manifold of i-dimensional arrays with positive entries. This manifold is modeled as a PowerManifold of PositiveNumbers.\n\nparameter: whether a type parameter should be used to store n. By default size is stored in a type parameter. Value can either be :field or :type.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#Manifolds.PositiveMatrices-Tuple{Integer, Integer}","page":"Positive numbers","title":"Manifolds.PositiveMatrices","text":"PositiveMatrices(m::Integer, n::Integer; parameter::Symbol=:type)\n\nGenerate the manifold of matrices with positive entries. This manifold is modeled as a PowerManifold of PositiveNumbers.\n\nparameter: whether a type parameter should be used to store n. By default size is stored in a type parameter. Value can either be :field or :type.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#Manifolds.PositiveVectors-Tuple{Integer}","page":"Positive numbers","title":"Manifolds.PositiveVectors","text":"PositiveVectors(n::Integer; parameter::Symbol=:type)\n\nGenerate the manifold of vectors with positive entries. This manifold is modeled as a PowerManifold of PositiveNumbers.\n\nparameter: whether a type parameter should be used to store n. By default size is stored in a type parameter. Value can either be :field or :type.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#Manifolds.manifold_volume-Tuple{PositiveNumbers}","page":"Positive numbers","title":"Manifolds.manifold_volume","text":"manifold_volume(M::PositiveNumbers)\n\nReturn volume of PositiveNumbers M, i.e. Inf.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#Manifolds.volume_density-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"Manifolds.volume_density","text":"volume_density(M::PositiveNumbers, p, X)\n\nCompute volume density function of PositiveNumbers. The formula reads\n\ntheta_p(X) = exp(X  p)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.change_metric-Tuple{PositiveNumbers, EuclideanMetric, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.change_metric","text":"change_metric(M::PositiveNumbers, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function with respect to the EuclideanMetric g_E, this function changes the representer into the one with respect to the positivity metric of PositiveNumbers M.\n\nFor all ZY we are looking for the function c on the tangent space at p such that\n\n    ZY = XY = fracc(Z)c(Y)p^2 = g_p(c(Y)c(Z))\n\nand hence C(X) = pX.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.change_representer-Tuple{PositiveNumbers, EuclideanMetric, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.change_representer","text":"change_representer(M::PositiveNumbers, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function with respect to the EuclideanMetric g_E, this function changes the representer into the one with respect to the positivity metric representation of PositiveNumbers M.\n\nFor all tangent vectors Y the result Z has to fulfill\n\n    XY = XY = fracZYp^2 = g_p(YZ)\n\nand hence Z = p^2X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.check_point-Tuple{PositiveNumbers, Any}","page":"Positive numbers","title":"ManifoldsBase.check_point","text":"check_point(M::PositiveNumbers, p)\n\nCheck whether p is a point on the PositiveNumbers M, i.e. p0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.check_vector-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.check_vector","text":"check_vector(M::PositiveNumbers, p, X; kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the PositiveNumbers M. For the real-valued case represented by positive numbers, all X are valid, since the tangent space is the whole real line. For the complex-valued case X [...]\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.distance-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.distance","text":"distance(M::PositiveNumbers, p, q)\n\nCompute the distance on the PositiveNumbers M, which is\n\nd(pq) = Bigllvert log fracpq Bigrrvert = lvert log p - log qrvert\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.get_coordinates-Tuple{PositiveNumbers, Any, Any, DefaultOrthonormalBasis{ℝ}}","page":"Positive numbers","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(::PositiveNumbers, p, X, ::DefaultOrthonormalBasis{ℝ})\n\nCompute the coordinate of vector X which is tangent to p on the PositiveNumbers manifold. The formula is X  p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.get_vector-Tuple{PositiveNumbers, Any, Any, DefaultOrthonormalBasis{ℝ}}","page":"Positive numbers","title":"ManifoldsBase.get_vector","text":"get_vector(::PositiveNumbers, p, c, ::DefaultOrthonormalBasis{ℝ})\n\nCompute the vector with coordinate c which is tangent to p on the PositiveNumbers manifold. The formula is p * c.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.injectivity_radius-Tuple{PositiveNumbers}","page":"Positive numbers","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::PositiveNumbers[, p])\n\nReturn the injectivity radius on the PositiveNumbers M, i.e. infty.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.inner-Tuple{PositiveNumbers, Vararg{Any}}","page":"Positive numbers","title":"ManifoldsBase.inner","text":"inner(M::PositiveNumbers, p, X, Y)\n\nCompute the inner product of the two tangent vectors X,Y from the tangent plane at p on the PositiveNumbers M, i.e.\n\ng_p(XY) = fracXYp^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.is_flat-Tuple{PositiveNumbers}","page":"Positive numbers","title":"ManifoldsBase.is_flat","text":"is_flat(::PositiveNumbers)\n\nReturn false. PositiveNumbers is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.manifold_dimension-Tuple{PositiveNumbers}","page":"Positive numbers","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PositiveNumbers)\n\nReturn the dimension of the PositiveNumbers M, i.e. of the 1-dimensional hyperbolic space,\n\ndim(H^1) = 1\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.parallel_transport_to-Tuple{PositiveNumbers, Any, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::PositiveNumbers, p, X, q)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the PositiveNumbers M.\n\nmathcal P_qgets p(X) = Xfracqp\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers/#ManifoldsBase.project-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.project","text":"project(M::PositiveNumbers, p, X)\n\nProject a value X onto the tangent space of the point p on the PositiveNumbers M, which is just the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#Torus","page":"Torus","title":"Torus","text":"","category":"section"},{"location":"manifolds/torus/","page":"Torus","title":"Torus","text":"The torus 𝕋^d  -ππ)^d is modeled as an AbstractPowerManifold  of the (real-valued) Circle and uses ArrayPowerRepresentation. Points on the torus are hence row vectors, x  ℝ^d.","category":"page"},{"location":"manifolds/torus/#Example","page":"Torus","title":"Example","text":"","category":"section"},{"location":"manifolds/torus/","page":"Torus","title":"Torus","text":"The following code can be used to make a three-dimensional torus 𝕋^3 and compute a tangent vector:","category":"page"},{"location":"manifolds/torus/","page":"Torus","title":"Torus","text":"using Manifolds\nM = Torus(3)\np = [0.5, 0.0, 0.0]\nq = [0.0, 0.5, 1.0]\nX = log(M, p, q)","category":"page"},{"location":"manifolds/torus/#Types-and-functions","page":"Torus","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/torus/","page":"Torus","title":"Torus","text":"Most functions are directly implemented for an AbstractPowerManifold  with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/torus/#Manifolds.Torus","page":"Torus","title":"Manifolds.Torus","text":"Torus{N} <: AbstractPowerManifold\n\nThe n-dimensional torus is the n-dimensional product of the Circle.\n\nThe Circle is stored internally within M.manifold, such that all functions of AbstractPowerManifold  can be used directly.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/torus/#ManifoldsBase.check_point-Tuple{Torus, Any}","page":"Torus","title":"ManifoldsBase.check_point","text":"check_point(M::Torus{n},p)\n\nChecks whether p is a valid point on the Torus M, i.e. each of its entries is a valid point on the Circle and the length of x is n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#ManifoldsBase.check_vector-Union{Tuple{N}, Tuple{Torus{N}, Any, Any}} where N","page":"Torus","title":"ManifoldsBase.check_vector","text":"check_vector(M::Torus{n}, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the Torus M. This means, that p is valid, that X is of correct dimension and elementwise a tangent vector to the elements of p on the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#Embedded-Torus","page":"Torus","title":"Embedded Torus","text":"","category":"section"},{"location":"manifolds/torus/","page":"Torus","title":"Torus","text":"Two-dimensional torus embedded in ℝ^3.","category":"page"},{"location":"manifolds/torus/#Manifolds.DefaultTorusAtlas","page":"Torus","title":"Manifolds.DefaultTorusAtlas","text":"DefaultTorusAtlas()\n\nAtlas for torus with charts indexed by two angles numbers θ₀ φ₀  -π π). Inverse of a chart (θ₀ φ₀) is given by\n\nx(θ φ) = (R + rcos(θ + θ₀))cos(φ + φ₀) \ny(θ φ) = (R + rcos(θ + θ₀))sin(φ + φ₀) \nz(θ φ) = rsin(θ + θ₀)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/torus/#Manifolds.EmbeddedTorus","page":"Torus","title":"Manifolds.EmbeddedTorus","text":"EmbeddedTorus{TR<:Real} <: AbstractDecoratorManifold{ℝ}\n\nSurface in ℝ³ described by parametric equations:\n\nx(θ φ) = (R + rcos θ)cos φ \ny(θ φ) = (R + rcos θ)sin φ \nz(θ φ) = rsin θ\n\nfor θ, φ in -π π). It is assumed that R  r  0.\n\nAlternative names include anchor ring, donut and doughnut.\n\nConstructor\n\nEmbeddedTorus(R, r)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/torus/#Manifolds.affine_connection-Tuple{Manifolds.EmbeddedTorus, Manifolds.DefaultTorusAtlas, Vararg{Any, 4}}","page":"Torus","title":"Manifolds.affine_connection","text":"affine_connection(M::EmbeddedTorus, A::DefaultTorusAtlas, i, a, Xc, Yc)\n\nAffine connection on EmbeddedTorus M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#Manifolds.check_chart_switch-Tuple{Manifolds.EmbeddedTorus, Manifolds.DefaultTorusAtlas, Any, Any}","page":"Torus","title":"Manifolds.check_chart_switch","text":"check_chart_switch(::EmbeddedTorus, A::DefaultTorusAtlas, i, a; ϵ = pi/3)\n\nReturn true if parameters a lie closer than ϵ to chart boundary.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#Manifolds.gaussian_curvature-Tuple{Manifolds.EmbeddedTorus, Any}","page":"Torus","title":"Manifolds.gaussian_curvature","text":"gaussian_curvature(M::EmbeddedTorus, p)\n\nGaussian curvature at point p from EmbeddedTorus M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#Manifolds.inverse_chart_injectivity_radius-Tuple{Manifolds.EmbeddedTorus, Manifolds.DefaultTorusAtlas, Any}","page":"Torus","title":"Manifolds.inverse_chart_injectivity_radius","text":"inverse_chart_injectivity_radius(M::AbstractManifold, A::AbstractAtlas, i)\n\nInjectivity radius of get_point for chart i from the DefaultTorusAtlas A of the EmbeddedTorus.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#Manifolds.normal_vector-Tuple{Manifolds.EmbeddedTorus, Any}","page":"Torus","title":"Manifolds.normal_vector","text":"normal_vector(M::EmbeddedTorus, p)\n\nOutward-pointing normal vector on the EmbeddedTorus at the point p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#ManifoldsBase.check_point-Tuple{Manifolds.EmbeddedTorus, Any}","page":"Torus","title":"ManifoldsBase.check_point","text":"check_point(M::EmbeddedTorus, p; kwargs...)\n\nCheck whether p is a valid point on the EmbeddedTorus M. The tolerance for the last test can be set using the kwargs....\n\nThe method checks if (p_1^2 + p_2^2 + p_3^2 + R^2 - r^2)^2 is approximately equal to 4R^2(p_1^2 + p_2^2).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#ManifoldsBase.check_vector-Tuple{Manifolds.EmbeddedTorus, Any, Any}","page":"Torus","title":"ManifoldsBase.check_vector","text":"check_vector(M::EmbeddedTorus, p, X; atol=eps(eltype(p)), kwargs...)\n\nCheck whether X is a valid vector tangent to p on the EmbeddedTorus M. The method checks if the vector X is orthogonal to the vector normal to the torus, see normal_vector. Absolute tolerance can be set using atol.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#ManifoldsBase.inner-Tuple{Manifolds.EmbeddedTorus, Manifolds.DefaultTorusAtlas, Vararg{Any, 4}}","page":"Torus","title":"ManifoldsBase.inner","text":"inner(M::EmbeddedTorus, ::DefaultTorusAtlas, i, a, Xc, Yc)\n\nInner product on EmbeddedTorus in chart i in the DefaultTorusAtlas. between vectors with coordinates Xc and Yc tangent at point with parameters a. Vector coordinates must be given in the induced basis.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#ManifoldsBase.is_flat-Tuple{Manifolds.EmbeddedTorus}","page":"Torus","title":"ManifoldsBase.is_flat","text":"is_flat(::EmbeddedTorus)\n\nReturn false. EmbeddedTorus is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus/#ManifoldsBase.manifold_dimension-Tuple{Manifolds.EmbeddedTorus}","page":"Torus","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::EmbeddedTorus)\n\nReturn the dimension of the EmbeddedTorus M that is 2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#The-probability-simplex","page":"Probability simplex","title":"The probability simplex","text":"","category":"section"},{"location":"manifolds/probabilitysimplex/#Manifolds.FisherRaoMetric","page":"Probability simplex","title":"Manifolds.FisherRaoMetric","text":"FisherRaoMetric <: AbstractMetric\n\nThe Fisher-Rao metric or Fisher information metric is a particular Riemannian metric which can be defined on a smooth statistical manifold, i.e., a smooth manifold whose points are probability measures defined on a common probability space.\n\nSee for example the ProbabilitySimplex.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex/#Manifolds.ProbabilitySimplex","page":"Probability simplex","title":"Manifolds.ProbabilitySimplex","text":"ProbabilitySimplex{T,boundary} <: AbstractDecoratorManifold{𝔽}\n\nThe (relative interior of) the probability simplex is the set\n\nΔ^n = biggl p  ℝ^n+1 big p_i  0 text for all  i=1n+1\ntext and  mathbb1p = sum_i=1^n+1 p_i = 1biggr\n\nwhere mathbb1=(11)^mathrmT ℝ^n+1 denotes the vector containing only ones.\n\nIf boundary is set to :open, then the object represents an open simplex. Otherwise, that is when boundary is set to :closed, the boundary is also included:\n\nhatΔ^n = biggl p  ℝ^n+1 big p_i geq 0 text for all  i=1n+1\ntext and  mathbb1p = sum_i=1^n+1 p_i = 1biggr\n\nThis set is also called the unit simplex or standard simplex.\n\nThe tangent space is given by\n\nT_pΔ^n = biggl X  ℝ^n+1 big mathbb1X = sum_i=1^n+1 X_i = 0 biggr\n\nThe manifold is implemented assuming the Fisher-Rao metric for the multinomial distribution, which is equivalent to the induced metric from isometrically embedding the probability simplex in the n-sphere of radius 2. The corresponding diffeomorphism varphi mathbb Δ^n  mathcal N, where mathcal N subset 2𝕊^n is given by varphi(p) = 2sqrtp.\n\nThis implementation follows the notation in [APSS17].\n\nConstructor\n\nProbabilitySimplex(n::Int; boundary::Symbol=:open)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex/#Base.exp-Tuple{ProbabilitySimplex, Vararg{Any}}","page":"Probability simplex","title":"Base.exp","text":"exp(M::ProbabilitySimplex, p, X)\n\nCompute the exponential map on the probability simplex.\n\nexp_pX = frac12Bigl(p+fracX_p^2lVert X_p rVert^2Bigr)\n+ frac12Bigl(p - fracX_p^2lVert X_p rVert^2Bigr)cos(lVert X_prVert)\n+ frac1lVert X_p rVertsqrtpsin(lVert X_prVert)\n\nwhere X_p = fracXsqrtp, with its division meant elementwise, as well as for the operations X_p^2 and sqrtp.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Base.log-Tuple{ProbabilitySimplex, Vararg{Any}}","page":"Probability simplex","title":"Base.log","text":"log(M::ProbabilitySimplex, p, q)\n\nCompute the logarithmic map of p and q on the ProbabilitySimplex M.\n\nlog_pq = fracd_Δ^n(pq)sqrt1-sqrtpsqrtq(sqrtpq - sqrtpsqrtqp)\n\nwhere pq and sqrtp is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Base.rand-Tuple{ProbabilitySimplex}","page":"Probability simplex","title":"Base.rand","text":"rand(::ProbabilitySimplex; vector_at=nothing, σ::Real=1.0)\n\nWhen vector_at is nothing, return a random (uniform over the Fisher-Rao metric; that is, uniform with respect to the n-sphere whose positive orthant is mapped to the simplex). point x on the ProbabilitySimplex manifold M according to the isometric embedding into the n-sphere by normalizing the vector length of a sample from a multivariate Gaussian. See [Mar72].\n\nWhen vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_pmathrmDelta^nby shifting a multivariate Gaussian with standard deviation σ to have a zero component sum.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldDiff.riemannian_gradient-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"ManifoldDiff.riemannian_gradient","text":"X = riemannian_gradient(M::ProbabilitySimplex, p, Y)\nriemannian_gradient!(M::ProbabilitySimplex, X, p, Y)\n\nGiven a gradient Y = operatornamegrad tilde f(p) in the embedding ℝ^n+1 of the ProbabilitySimplex Δ^n, this function computes the Riemannian gradient X = operatornamegrad f(p) where f is the function tilde f restricted to the manifold.\n\nThe formula reads\n\n    X = p  Y - p Yp\n\nwhere  denotes the emelementwise product.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Manifolds.manifold_volume-Tuple{ProbabilitySimplex}","page":"Probability simplex","title":"Manifolds.manifold_volume","text":"manifold_volume(::ProbabilitySimplex)\n\nReturn the volume of the ProbabilitySimplex, i.e. volume of the n-dimensional Sphere divided by 2^n+1, corresponding to the volume of its positive orthant.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Manifolds.volume_density-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"Manifolds.volume_density","text":"volume_density(M::ProbabilitySimplex, p, X)\n\nCompute the volume density at point p on ProbabilitySimplex M for tangent vector X. It is computed using isometry with positive orthant of a sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.change_metric-Tuple{ProbabilitySimplex, EuclideanMetric, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.change_metric","text":"change_metric(M::ProbabilitySimplex, ::EuclideanMetric, p, X)\n\nTo change the metric, we are looking for a function ccolon T_pΔ^n  T_pΔ^n such that for all XY  T_pΔ^n This can be achieved by rewriting representer change in matrix form as (Diagonal(p) - p * p') * X and taking square root of the matrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.change_representer-Tuple{ProbabilitySimplex, EuclideanMetric, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.change_representer","text":"change_representer(M::ProbabilitySimplex, ::EuclideanMetric, p, X)\n\nGiven a tangent vector with respect to the metric from the embedding, the EuclideanMetric, the representer of a linear functional on the tangent space is adapted as Z = p * X - p * dot(p X). The first part “compensates” for the division by p in the Riemannian metric on the ProbabilitySimplex and the second part performs appropriate projection to keep the vector tangent.\n\nFor details see Proposition 2.3 in [APSS17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.check_point-Union{Tuple{boundary}, Tuple{ProbabilitySimplex{<:Any, boundary}, Any}} where boundary","page":"Probability simplex","title":"ManifoldsBase.check_point","text":"check_point(M::ProbabilitySimplex, p; kwargs...)\n\nCheck whether p is a valid point on the ProbabilitySimplex M, i.e. is a point in the embedding with positive entries that sum to one The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{ProbabilitySimplex, Any, T}} where T","page":"Probability simplex","title":"ManifoldsBase.check_vector","text":"check_vector(M::ProbabilitySimplex, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the ProbabilitySimplex M, i.e. after check_point(M,p), X has to be of same dimension as p and its elements have to sum to one. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.distance-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.distance","text":"distance(M, p, q)\n\nCompute the distance between two points on the ProbabilitySimplex M. The formula reads\n\nd_Δ^n(pq) = 2arccos biggl( sum_i=1^n+1 sqrtp_i q_i biggr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.injectivity_radius-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::ProbabilitySimplex, p)\n\nCompute the injectivity radius on the ProbabilitySimplex M at the point p, i.e. the distanceradius to a point near/on the boundary, that could be reached by following the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.inner-Union{Tuple{boundary}, Tuple{ProbabilitySimplex{<:Any, boundary}, Any, Any, Any}} where boundary","page":"Probability simplex","title":"ManifoldsBase.inner","text":"inner(M::ProbabilitySimplex, p, X, Y)\n\nCompute the inner product of two tangent vectors X, Y from the tangent space T_pΔ^n at p. The formula reads\n\ng_p(XY) = sum_i=1^n+1fracX_iY_ip_i\n\nWhen M includes boundary, we can just skip coordinates where p_i is equal to 0, see Proposition 2.1 in [AJLS17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.inverse_retract-Tuple{ProbabilitySimplex, Any, Any, SoftmaxInverseRetraction}","page":"Probability simplex","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProbabilitySimplex, p, q, ::SoftmaxInverseRetraction)\n\nCompute a first order approximation by projection. The formula reads\n\noperatornameretr^-1_p q = bigl( I_n+1 - frac1nmathbb1^n+1n+1 bigr)(log(q)-log(p))\n\nwhere mathbb1^mn is the size (m,n) matrix containing ones, and log is applied elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.is_flat-Tuple{ProbabilitySimplex}","page":"Probability simplex","title":"ManifoldsBase.is_flat","text":"is_flat(::ProbabilitySimplex)\n\nReturn false. ProbabilitySimplex is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.manifold_dimension-Tuple{ProbabilitySimplex}","page":"Probability simplex","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::ProbabilitySimplex)\n\nReturns the manifold dimension of the probability simplex in ℝ^n+1, i.e.\n\n    dim_Δ^n = n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.project-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.project","text":"project(M::ProbabilitySimplex, p, Y)\n\nProject Y from the embedding onto the tangent space at p on the ProbabilitySimplex M. The formula reads\n\n`math \\operatorname{proj}_{Δ^n}(p,Y) = Y - \\bar{Y} where barY denotes mean of Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.project-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"ManifoldsBase.project","text":"project(M::ProbabilitySimplex, p)\n\nproject p from the embedding onto the ProbabilitySimplex M. The formula reads\n\noperatornameproj_Δ^n(p) = frac1mathbb 1pp\n\nwhere mathbb 1  ℝ denotes the vector of ones. Not that this projection is only well-defined if p has positive entries.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.representation_size-Tuple{ProbabilitySimplex}","page":"Probability simplex","title":"ManifoldsBase.representation_size","text":"representation_size(::ProbabilitySimplex)\n\nReturn the representation size of points in the n-dimensional probability simplex, i.e. an array size of (n+1,).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.retract-Tuple{ProbabilitySimplex, Any, Any, SoftmaxRetraction}","page":"Probability simplex","title":"ManifoldsBase.retract","text":"retract(M::ProbabilitySimplex, p, X, ::SoftmaxRetraction)\n\nCompute a first order approximation by applying the softmax function. The formula reads\n\noperatornameretr_p X = fracpmathrme^Xpmathrme^X\n\nwhere multiplication, exponentiation and division are meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.riemann_tensor-Tuple{ProbabilitySimplex, Vararg{Any, 4}}","page":"Probability simplex","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(::ProbabilitySimplex, p, X, Y, Z)\n\nCompute the Riemann tensor R(XY)Z at point p on ProbabilitySimplex M. It is computed using isometry with positive orthant of a sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#ManifoldsBase.zero_vector-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::ProbabilitySimplex, p)\n\nReturn the zero tangent vector in the tangent space of the point p  from the ProbabilitySimplex M, i.e. its representation by the zero vector in the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Statistics.mean-Tuple{ProbabilitySimplex, Vararg{Any}}","page":"Probability simplex","title":"Statistics.mean","text":"mean(\n    M::ProbabilitySimplex,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Euclidean-metric","page":"Probability simplex","title":"Euclidean metric","text":"","category":"section"},{"location":"manifolds/probabilitysimplex/#Base.rand-Tuple{MetricManifold{ℝ, <:ProbabilitySimplex, <:EuclideanMetric}}","page":"Probability simplex","title":"Base.rand","text":"rand(::MetricManifold{ℝ,<:ProbabilitySimplex,<:EuclideanMetric}; vector_at=nothing, σ::Real=1.0)\n\nWhen vector_at is nothing, return a random (uniform) point x on the ProbabilitySimplex with the Euclidean metric manifold M by normalizing independent exponential draws to unit sum, see [Dev86], Theorems 2.1 and 2.2 on p. 207 and 208, respectively. When vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_pmathrmDelta^nby shifting a multivariate Gaussian with standard deviation σ to have a zero component sum.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Manifolds.manifold_volume-Tuple{MetricManifold{ℝ, <:ProbabilitySimplex, <:EuclideanMetric}}","page":"Probability simplex","title":"Manifolds.manifold_volume","text":"manifold_volume(::MetricManifold{ℝ,<:ProbabilitySimplex{n},<:EuclideanMetric})) where {n}\n\nReturn the volume of the ProbabilitySimplex with the Euclidean metric. The formula reads fracsqrtn+1n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Manifolds.volume_density-Tuple{MetricManifold{ℝ, <:ProbabilitySimplex, <:EuclideanMetric}, Any, Any}","page":"Probability simplex","title":"Manifolds.volume_density","text":"volume_density(::MetricManifold{ℝ,<:ProbabilitySimplex,<:EuclideanMetric}, p, X)\n\nCompute the volume density at point p on ProbabilitySimplex M for tangent vector X. It is equal to 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Real-probability-amplitudes","page":"Probability simplex","title":"Real probability amplitudes","text":"","category":"section"},{"location":"manifolds/probabilitysimplex/","page":"Probability simplex","title":"Probability simplex","text":"An isometric embedding of interior of ProbabilitySimplex in positive orthant of the Sphere is established through functions simplex_to_amplitude and amplitude_to_simplex. Some properties extend to the boundary but not all.","category":"page"},{"location":"manifolds/probabilitysimplex/","page":"Probability simplex","title":"Probability simplex","text":"This embedding isometrically maps the Fisher-Rao metric on the open probability simplex to the sphere of radius 1 with Euclidean metric. More details can be found in Section 2.2 of [AJLS17].","category":"page"},{"location":"manifolds/probabilitysimplex/","page":"Probability simplex","title":"Probability simplex","text":"The name derives from the notion of probability amplitudes in quantum mechanics. They are complex-valued and their squared norm corresponds to probability. This construction restricted to real valued amplitudes results in this embedding.","category":"page"},{"location":"manifolds/probabilitysimplex/#Manifolds.amplitude_to_simplex-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"Manifolds.amplitude_to_simplex","text":"amplitude_to_simplex(M::ProbabilitySimplex, p)\n\nConvert point (real) probability amplitude p on to a point on ProbabilitySimplex. The formula reads (p_1^2 p_2^2  p_N+1^2). This is an isometry from the interior of the positive orthant of a sphere to interior of the probability simplex.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Manifolds.amplitude_to_simplex_diff-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"Manifolds.amplitude_to_simplex_diff","text":"amplitude_to_simplex_diff(M::ProbabilitySimplex, p, X)\n\nCompute differential of amplitude_to_simplex of a point p on ProbabilitySimplex at tangent vector X from the tangent space at p from a sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Manifolds.simplex_to_amplitude-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"Manifolds.simplex_to_amplitude","text":"simplex_to_amplitude(M::ProbabilitySimplex, p)\n\nConvert point p on ProbabilitySimplex to (real) probability amplitude. The formula reads (sqrtp_1 sqrtp_2  sqrtp_N+1). This is an isometry from the interior of the probability simplex to the interior of the positive orthant of a sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Manifolds.simplex_to_amplitude_diff-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"Manifolds.simplex_to_amplitude_diff","text":"simplex_to_amplitude_diff(M::ProbabilitySimplex, p, X)\n\nCompute differential of simplex_to_amplitude of a point on p one ProbabilitySimplex at tangent vector X from the tangent space at p from a sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex/#Literature","page":"Probability simplex","title":"Literature","text":"","category":"section"},{"location":"manifolds/probabilitysimplex/","page":"Probability simplex","title":"Probability simplex","text":"N. Ay, J. Jost, H. V. Lê and L. Schwachhöfer. Information Geometry (Springer Cham, 2017).\n\n\n\nL. Devroye. Non-Uniform Random Variate Generation (Springer New York, NY, 1986).\n\n\n\nG. Marsaglia. Choosing a Point from the Surface of a Sphere. Annals of Mathematical Statistics 43, 645–646 (1972).\n\n\n\nF. Åström, S. Petra, B. Schmitzer and C. Schnörr. Image Labeling by Assignment. Journal of Mathematical Imaging and Vision 58, 211–238 (2017), arXiv:1603.05285.\n\n\n\n","category":"page"},{"location":"manifolds/generalizedstiefel/#Generalized-Stiefel","page":"Generalized Stiefel","title":"Generalized Stiefel","text":"","category":"section"},{"location":"manifolds/generalizedstiefel/#Manifolds.GeneralizedStiefel","page":"Generalized Stiefel","title":"Manifolds.GeneralizedStiefel","text":"GeneralizedStiefel{𝔽,T,B} <: AbstractDecoratorManifold{𝔽}\n\nThe Generalized Stiefel manifold consists of all nk, ngeq k orthonormal matrices w.r.t. an arbitrary scalar product with symmetric positive definite matrix Bin R^nn, i.e.\n\noperatornameSt(nkB) = bigl p in mathbb F^nk big p^mathrmH B p = I_k bigr\n\nwhere 𝔽  ℝ ℂ, ^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k in mathbb R^kk denotes the kk identity matrix.\n\nIn the case B=I_k one gets the usual Stiefel manifold.\n\nThe tangent space at a point pinmathcal M=operatornameSt(nkB) is given by\n\nT_pmathcal M =  X in 𝔽^nk  p^mathrmHBX + X^mathrmHBp=0_n\n\nwhere 0_k is the kk zero matrix.\n\nThis manifold is modeled as an embedded manifold to the Euclidean, i.e. several functions like the zero_vector are inherited from the embedding.\n\nThe manifold is named after Eduard L. Stiefel (1909–1978).\n\nConstructor\n\nGeneralizedStiefel(n, k, B=I_n, F=ℝ)\n\nGenerate the (real-valued) Generalized Stiefel manifold of nk dimensional orthonormal matrices with scalar product B.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalizedstiefel/#Base.rand-Tuple{GeneralizedStiefel}","page":"Generalized Stiefel","title":"Base.rand","text":"rand(::GeneralizedStiefel; vector_at=nothing, σ::Real=1.0)\n\nWhen vector_at is nothing, return a random (Gaussian) point p on the GeneralizedStiefel manifold M by generating a (Gaussian) matrix with standard deviation σ and return the (generalized) orthogonalized version, i.e. return the projection onto the manifold of the Q component of the QR decomposition of the random matrix of size nk.\n\nWhen vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_vector_atmathrmSt(nk) with mean zero and standard deviation σ by projecting a random Matrix onto the tangent vector at vector_at.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.check_point-Tuple{GeneralizedStiefel, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.check_point","text":"check_point(M::GeneralizedStiefel, p; kwargs...)\n\nCheck whether p is a valid point on the GeneralizedStiefel M=operatornameSt(nkB), i.e. that it has the right AbstractNumbers type and x^mathrmHBx is (approximately) the identity, where ^mathrmH is the complex conjugate transpose. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.check_vector-Tuple{GeneralizedStiefel, Any, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.check_vector","text":"check_vector(M::GeneralizedStiefel, p, X; kwargs...)\n\nCheck whether X is a valid tangent vector at p on the GeneralizedStiefel M=operatornameSt(nkB), i.e. the AbstractNumbers fits, p is a valid point on M and it (approximately) holds that p^mathrmHBX + overlineX^mathrmHBp = 0, where kwargs... is passed to the isapprox.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.inner-Tuple{GeneralizedStiefel, Any, Any, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.inner","text":"inner(M::GeneralizedStiefel, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the GeneralizedStiefel manifold M. The formula reads\n\n(X Y)_p = operatornametrace(v^mathrmHBw)\n\ni.e. the metric induced by the scalar product B from the embedding, restricted to the tangent space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.is_flat-Tuple{GeneralizedStiefel}","page":"Generalized Stiefel","title":"ManifoldsBase.is_flat","text":"is_flat(M::GeneralizedStiefel)\n\nReturn true if GeneralizedStiefel M is one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.manifold_dimension-Tuple{GeneralizedStiefel{ℝ}}","page":"Generalized Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::GeneralizedStiefel)\n\nReturn the dimension of the GeneralizedStiefel manifold M=operatornameSt(nkB𝔽). The dimension is given by\n\nbeginaligned\ndim mathrmSt(n k B ℝ) = nk - frac12k(k+1) \ndim mathrmSt(n k B ℂ) = 2nk - k^2\ndim mathrmSt(n k B ℍ) = 4nk - k(2k-1)\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.project-Tuple{GeneralizedStiefel, Any, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.project","text":"project(M:GeneralizedStiefel, p, X)\n\nProject X onto the tangent space of p to the GeneralizedStiefel manifold M. The formula reads\n\noperatornameproj_operatornameSt(nk)(pX) = X - poperatornameSym(p^mathrmHBX)\n\nwhere operatornameSym(y) is the symmetrization of y, e.g. by operatornameSym(y) = fracy^mathrmH+y2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.project-Tuple{GeneralizedStiefel, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.project","text":"project(M::GeneralizedStiefel, p)\n\nProject p from the embedding onto the GeneralizedStiefel M, i.e. compute q as the polar decomposition of p such that q^mathrmHBq is the identity, where ^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel/#ManifoldsBase.retract-Tuple{GeneralizedStiefel, Vararg{Any}}","page":"Generalized Stiefel","title":"ManifoldsBase.retract","text":"retract(M::GeneralizedStiefel, p, X)\nretract(M::GeneralizedStiefel, p, X, ::PolarRetraction)\nretract(M::GeneralizedStiefel, p, X, ::ProjectionRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the GeneralizedStiefel manifold M, which in this case is the same as the projection based retraction employing the exponential map in the embedding and projecting the result back to the manifold.\n\nThe default retraction for this manifold is the ProjectionRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetricpositivedefinite/#Multinomial-symmetric-positive-definite-matrices","page":"Multinomial symmetric positive definite matrices","title":"Multinomial symmetric positive definite matrices","text":"","category":"section"},{"location":"manifolds/multinomialsymmetricpositivedefinite/#Manifolds.MultinomialSymmetricPositiveDefinite","page":"Multinomial symmetric positive definite matrices","title":"Manifolds.MultinomialSymmetricPositiveDefinite","text":"MultinomialSymmetricPositiveDefinite <: AbstractMultinomialDoublyStochastic\n\nThe symmetric positive definite multinomial matrices manifold consists of all symmetric nn matrices with positive eigenvalues, and positive entries such that each column sums to one, i.e.\n\nbeginaligned\nmathcalSP^+(n) coloneqq bigl\n    p  ℝ^nn big p_ij  0 text for all  i=1n j=1m\n p^mathrmT = p\n pmathbf1_n = mathbf1_n\na^mathrmTpa  0 text for all  a  ℝ^nbackslashmathbf0_n\nbigr\nendaligned\n\nwhere mathbf1_n and mathbr0_n are the vectors of length n containing ones and zeros, respectively. More details about this manifold can be found in [DH19].\n\nConstructor\n\nMultinomialSymmetricPositiveDefinite(n)\n\nGenerate the manifold of matrices mathbb R^nn that are symmetric, positive definite, and doubly stochastic.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialsymmetricpositivedefinite/#Random.rand!-Tuple{Random.AbstractRNG, MultinomialSymmetricPositiveDefinite, AbstractMatrix}","page":"Multinomial symmetric positive definite matrices","title":"Random.rand!","text":"Random.rand!(\n    rng::AbstractRNG,\n    M::MultinomialSymmetricPositiveDefinite,\n    p::AbstractMatrix,\n)\n\nGenerate a random point on MultinomialSymmetricPositiveDefinite manifold. The steps are as follows:\n\nGenerate a random totally positive matrix  a. Construct a vector L of n random positive increasing real numbers.  b. Construct the Vandermonde matrix     V based on the sequence L.  c. Perform LU factorization of V in such way that both L and U components have     positive elements.  d. Convert the LU factorization into LDU factorization by taking the diagonal of U     and dividing U by it, V=LDU.  e. Construct a new matrix R = UDL which is totally positive.\nProject the totally positive matrix R onto the manifold of MultinomialDoubleStochastic matrices.\nSymmetrize the projected matrix and return the result.\n\nThis method roughly follows the procedure described in https://math.stackexchange.com/questions/2773460/how-to-generate-a-totally-positive-matrix-randomly-using-software-like-maple\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetricpositivedefinite/#Literature","page":"Multinomial symmetric positive definite matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/multinomialsymmetricpositivedefinite/","page":"Multinomial symmetric positive definite matrices","title":"Multinomial symmetric positive definite matrices","text":"A. Douik and B. Hassibi. Manifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry. IEEE Transactions on Signal Processing 67, 5761–5774 (2019), arXiv:1802.02628.\n\n\n\n","category":"page"},{"location":"manifolds/symplecticstiefel/#(Real)-Symplectic-Stiefel","page":"Symplectic Stiefel","title":"(Real) Symplectic Stiefel","text":"","category":"section"},{"location":"manifolds/symplecticstiefel/","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"The SymplecticStiefel manifold, denoted operatornameSpSt(2n 2k), represents canonical symplectic bases of 2k dimensonal symplectic subspaces of ℝ^2n2n. This means that the columns of each element p in operatornameSpSt(2n 2k) subset ℝ^2n2k constitute a canonical symplectic basis of operatornamespan(p). The canonical symplectic form is a non-degenerate, bilinear, and skew symmetric map omega_2kcolon 𝔽^2k𝔽^2k  𝔽, given by omega_2k(x y) = x^T Q_2k y for elements x y in 𝔽^2k, with","category":"page"},{"location":"manifolds/symplecticstiefel/","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"    Q_2k =\n    beginbmatrix\n     0_k    I_k \n    -I_k    0_k\n    endbmatrix","category":"page"},{"location":"manifolds/symplecticstiefel/","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"Specifically given an element p in operatornameSpSt(2n 2k) we require that","category":"page"},{"location":"manifolds/symplecticstiefel/","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"    omega_2n (p x p y) = x^T(p^TQ_2np)y = x^TQ_2ky = omega_2k(x y) forall x y in 𝔽^2k","category":"page"},{"location":"manifolds/symplecticstiefel/","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"leading to the requirement on p that p^TQ_2np = Q_2k. In the case that k = n, this manifold reduces to the SymplecticMatrices manifold, which is also known as the symplectic group.","category":"page"},{"location":"manifolds/symplecticstiefel/#Manifolds.SymplecticStiefel","page":"Symplectic Stiefel","title":"Manifolds.SymplecticStiefel","text":"SymplecticStiefel{𝔽, T} <: AbstractEmbeddedManifold{𝔽, DefaultIsometricEmbeddingType}\n\nThe symplectic Stiefel manifold consists of all 2n2k n  k matrices satisfying the requirement\n\nmathrmSpSt(2n 2k ℝ)\n    = bigl p  ℝ^2n2k  big  p^mathrmTJ_2np = J_2k bigr\n\nwhere J_2n denotes the SymplecticElement\n\nJ_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix\n\nThe symplectic Stiefel tangent space at p can be parametrized as [BZ21]\n\nbeginalign*\n    T_pmathrmSpSt(2n 2k)\n    = X  ℝ^2n2k  p^TJ_2nX + X^TJ_2np = 0  \n    = X = pΩ + p^sB mid\n        Ω  ℝ^2k2k Ω^+ = -Ω \n        quadqquad p^s  mathrmSpSt(2n 2(n- k)) B  ℝ^2(n-k)2k \nendalign*\n\nwhere Ω  mathfraksp(2nF) is Hamiltonian and p^s means the symplectic complement of p s.t. p^+p^s = 0. Here p^+ denotes the symplectic_inverse.\n\nYou can also use StiefelPoint and StiefelTangentVector with this manifold, they are equivalent to using arrays.\n\nConstructor\n\nSymplecticStiefel(2n::Int, 2k::Int, field::AbstractNumbers=ℝ; parameter::Symbol=:type)\n\nGenerate the (real-valued) symplectic Stiefel manifold of 2n2k matrices which span a 2k dimensional symplectic subspace of ℝ^2n2k. The constructor for the SymplecticStiefel manifold accepts the even column dimension 2n and an even number of columns 2k for the real symplectic Stiefel manifold with elements p  ℝ^2n2k.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplecticstiefel/#Base.exp-Tuple{SymplecticStiefel, Any, Any}","page":"Symplectic Stiefel","title":"Base.exp","text":"exp(::SymplecticStiefel, p, X)\nexp!(M::SymplecticStiefel, q, p, X)\n\nCompute the exponential mapping\n\n  expcolon TmathrmSpSt(2n 2k)  mathrmSpSt(2n 2k)\n\nat a point p  mathrmSpSt(2n 2k) in the direction of X  T_pmathrmSpSt(2n 2k).\n\nThe tangent vector X can be written in the form X = barOmegap [BZ21], with\n\n  barOmega = X (p^mathrmTp)^-1p^mathrmT\n    + J_2np(p^mathrmTp)^-1X^mathrmT(I_2n\n    - J_2n^mathrmTp(p^mathrmTp)^-1p^mathrmTJ_2n)J_2n\n     ℝ^2n2n\n\nwhere J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\nUsing this expression for X, the exponential mapping can be computed as\n\n  exp_p(X) = operatornameExp(barOmega - barOmega^mathrmT)\n                             operatornameExp(barOmega^mathrmT)p\n\nwhere operatornameExp() denotes the matrix exponential.\n\nComputing the above mapping directly however, requires taking matrix exponentials of two 2n2n matrices, which is computationally expensive when n increases. Therefore we instead follow [BZ21] who express the above exponential mapping in a way which only requires taking matrix exponentials of an 8k8k matrix and a 4k4k matrix.\n\nTo this end, first define\n\nbarA = J_2kp^mathrmTX(p^mathrmTp)^-1J_2k +\n            (p^mathrmTp)^-1X^mathrmT(p - J_2n^mathrmTp(p^mathrmTp)^-1J_2k)  ℝ^2k2k\n\nand\n\nbarH = (I_2n - pp^+)J_2nX(p^mathrmTp)^-1J_2k  ℝ^2n2k\n\nWe then let barDelta = pbarA + barH, and define the matrices\n\n    γ = leftleft(I_2n - frac12pp^+right)barDelta quad\n              -p right  ℝ^2n4k\n\nand\n\n    λ = leftJ_2n^mathrmTpJ_2k quad\n        left(barDelta^+left(I_2n\n              - frac12pp^+right)right)^mathrmTright  ℝ^2n4k\n\nWith the above defined matrices it holds that barOmega = λγ^mathrmT.  As a last preliminary step, concatenate γ and λ to define the matrices Γ = λ quad -γ  ℝ^2n8k and Λ = γ quad λ  ℝ^2n8k.\n\nWith these matrix constructions done, we can compute the exponential mapping as\n\n  exp_p(X) = Γ operatornameExp(ΛΓ^mathrmT)\n    beginbmatrix 0_4k  I_4k endbmatrix\n    operatornameExp(λγ^mathrmT)\n    beginbmatrix 0_2k  I_2k endbmatrix\n\nwhich only requires computing the matrix exponentials of ΛΓ^mathrmT  ℝ^8k8k and λγ^mathrmT  ℝ^4k4k.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#Base.inv-Tuple{SymplecticStiefel, Any}","page":"Symplectic Stiefel","title":"Base.inv","text":"inv(::SymplecticStiefel, A)\ninv!(::SymplecticStiefel, q, p)\n\nCompute the symplectic inverse A^+ of matrix A  ℝ^2n2k. Given a matrix\n\nA  ℝ^2n2kquad\nA =\nbeginbmatrix\nA_1 1  A_1 2 \nA_2 1  A_2 2\nendbmatrix quad A_i j  ℝ^2n2k\n\nthe symplectic inverse is defined as:\n\nA^+ = J_2k^mathrmT A^mathrmT J_2n\n\nwhere J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\nThe symplectic inverse of a matrix A can be expressed explicitly as:\n\nA^+ =\n  beginbmatrix\n    A_2 2^mathrmT  -A_1 2^mathrmT 12mm\n   -A_2 1^mathrmT   A_1 1^mathrmT\n  endbmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#Base.rand-Tuple{SymplecticStiefel}","page":"Symplectic Stiefel","title":"Base.rand","text":"rand(M::SymplecticStiefel; vector_at=nothing, σ = 1.0)\n\nGenerate a random point p  mathrmSpSt(2n 2k) or a random tangent vector X  T_pmathrmSpSt(2n 2k) if vector_at is set to a point p  mathrmSp(2n).\n\nA random point on mathrmSpSt(2n 2k) is found by first generating a random point on the symplectic manifold mathrmSp(2n), and then projecting onto the Symplectic Stiefel manifold using the canonical_project π_mathrmSpSt(2n 2k). That is, p = π_mathrmSpSt(2n 2k)(p_mathrmSp).\n\nTo generate a random tangent vector in T_pmathrmSpSt(2n 2k) this code exploits the second tangent vector space parametrization of SymplecticStiefel, that any X  T_pmathrmSpSt(2n 2k) can be written as X = pΩ_X + p^sB_X. To generate random tangent vectors at p then, this function sets B_X = 0 and generates a random Hamiltonian matrix Ω_X  mathfraksp(2nF) with Frobenius norm of σ before returning X = pΩ_X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldDiff.riemannian_gradient-Tuple{SymplecticStiefel, Any, Any}","page":"Symplectic Stiefel","title":"ManifoldDiff.riemannian_gradient","text":"X = riemannian_gradient(::SymplecticStiefel, f, p, Y; embedding_metric::EuclideanMetric=EuclideanMetric())\nriemannian_gradient!(::SymplecticStiefel, f, X, p, Y; embedding_metric::EuclideanMetric=EuclideanMetric())\n\nCompute the riemannian gradient X of f on SymplecticStiefel  at a point p, provided that the gradient of the function tilde f, which is f continued into the embedding is given by Y. The metric in the embedding is the Euclidean metric.\n\nThe manifold gradient X is computed from Y as\n\n    X = Yp^mathrmTp + J_2npY^mathrmTJ_2np\n\nwhere J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#Manifolds.symplectic_inverse_times-Tuple{SymplecticStiefel, Any, Any}","page":"Symplectic Stiefel","title":"Manifolds.symplectic_inverse_times","text":"symplectic_inverse_times(::SymplecticStiefel, p, q)\nsymplectic_inverse_times!(::SymplecticStiefel, A, p, q)\n\nDirectly compute the symplectic inverse of p  mathrmSpSt(2n 2k), multiplied with q  mathrmSpSt(2n 2k). That is, this function efficiently computes p^+q = (J_2kp^mathrmTJ_2n)q  ℝ^2k2k, where J_2n J_2k are the SymplecticElement of sizes 2n2n and 2k2k respectively.\n\nThis function performs this common operation without allocating more than a 2k2k matrix to store the result in, or in the case of the in-place function, without allocating memory at all.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.canonical_project-Tuple{SymplecticStiefel, Any}","page":"Symplectic Stiefel","title":"ManifoldsBase.canonical_project","text":"canonical_project(::SymplecticStiefel, p_Sp)\ncanonical_project!(::SymplecticStiefel, p, p_Sp)\n\nDefine the canonical projection from mathrmSp(2n 2n) onto mathrmSpSt(2n 2k), by projecting onto the first k columns and the n + 1'th onto the n + k'th columns [BZ21].\n\nIt is assumed that the point p is on mathrmSp(2n 2n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.check_point-Tuple{SymplecticStiefel{ℝ}, Any}","page":"Symplectic Stiefel","title":"ManifoldsBase.check_point","text":"check_point(M::SymplecticStiefel, p; kwargs...)\n\nCheck whether p is a valid point on the SymplecticStiefel, mathrmSpSt(2n 2k) manifold, that is p^+p is the identity, ()^+ denotes the symplectic_inverse.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.check_vector-Tuple{SymplecticStiefel, Vararg{Any}}","page":"Symplectic Stiefel","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymplecticMatrices, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector at p on the SymplecticStiefel, mathrmSpSt(2n 2k) manifold.\n\nThe check consists of verifying that H = p^+X  𝔤_2k, where 𝔤 is the Lie Algebra of the symplectic group mathrmSp(2k), that is the set of [HamiltonianMatrices])(@ref), where ()^+ denotes the symplectic_inverse.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.get_total_space-Union{Tuple{SymplecticStiefel{ℝ, ManifoldsBase.TypeParameter{Tuple{n, k}}}}, Tuple{k}, Tuple{n}} where {n, k}","page":"Symplectic Stiefel","title":"ManifoldsBase.get_total_space","text":"get_total_space(::SymplecticStiefel)\n\nReturn the total space of the SymplecticStiefel manifold, which is the corresponding SymplecticMatrices manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.inner-Tuple{SymplecticStiefel, Any, Any, Any}","page":"Symplectic Stiefel","title":"ManifoldsBase.inner","text":"inner(M::SymplecticStiefel, p, X. Y)\n\nCompute the Riemannian inner product g^mathrmSpSt at p  mathrmSpSt of tangent vectors Y X  T_pmathrmSpSt. Given by Proposition 3.10 in [BZ21].\n\ng^mathrmSpSt_p(X Y)\n  = operatornametrBigl(\n    X^mathrmTbigl(\n      I_2n - frac12J_2n^mathrmT p(p^mathrmTp)^-1p^mathrmTJ_2n\n    bigr) Y (p^mathrmTp)^-1Bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.inverse_retract-Tuple{SymplecticStiefel, Any, Any, CayleyInverseRetraction}","page":"Symplectic Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(::SymplecticStiefel, p, q, ::CayleyInverseRetraction)\ninverse_retract!(::SymplecticStiefel, X, p, q, ::CayleyInverseRetraction)\n\nCompute the Cayley Inverse Retraction X = mathcalL_p^mathrmSpSt(q) such that the Cayley Retraction from p along X lands at q, i.e. mathcalR_p(X) = q [BZ21].\n\nFor p q  mathrmSpSt(2n 2k ℝ) we can define the inverse cayley retraction as long as the following matrices exist.\n\n    U = (I + p^+ q)^-1  ℝ^2k2k\n    quad\n    V = (I + q^+ p)^-1  ℝ^2k2k\n\nwhere ()^+ denotes the symplectic_inverse.\n\nTHen the inverse retraction reads\n\nmathcalL_p^mathrmSp(q) = 2pbigl(V - Ubigr) + 2bigl((p + q)U - pbigr)  T_pmathrmSp(2n)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.is_flat-Tuple{SymplecticStiefel}","page":"Symplectic Stiefel","title":"ManifoldsBase.is_flat","text":"is_flat(::SymplecticStiefel)\n\nReturn false. SymplecticStiefel is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.manifold_dimension-Tuple{SymplecticStiefel}","page":"Symplectic Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(::SymplecticStiefel)\n\nReturns the dimension of the symplectic Stiefel manifold embedded in ℝ^2n2k, i.e. [BZ21]\n\n    operatornamedim(mathrmSpSt(2n 2k)) = (4n - 2k + 1)k\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.project-Tuple{SymplecticStiefel, Any, Any}","page":"Symplectic Stiefel","title":"ManifoldsBase.project","text":"project(::SymplecticStiefel, p, A)\nproject!(::SymplecticStiefel, Y, p, A)\n\nGiven a point p  mathrmSpSt(2n 2k), project an element A  ℝ^2n2k onto the tangent space T_pmathrmSpSt(2n 2k) relative to the euclidean metric of the embedding ℝ^2n2k.\n\nThat is, we find the element X  T_pmathrmSpSt(2n 2k) which solves the constrained optimization problem\n\n    displaystyleoperatornamemin_X  ℝ^2n2k frac12X - A^2 quad\n    textst\n    h(X) = X^mathrmT J p + p^mathrmT J X = 0\n\nwhere h  ℝ^2n2k  operatornameskew(2k) defines the restriction of X onto the tangent space T_pmathrmSpSt(2n 2k).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#ManifoldsBase.retract-Tuple{SymplecticStiefel, Any, Any, CayleyRetraction}","page":"Symplectic Stiefel","title":"ManifoldsBase.retract","text":"retract(::SymplecticStiefel, p, X, ::CayleyRetraction)\nretract!(::SymplecticStiefel, q, p, X, ::CayleyRetraction)\n\nCompute the Cayley retraction on the Symplectic Stiefel manifold, from p along X (computed inplace of q).\n\nGiven a point p  mathrmSpSt(2n 2k), every tangent vector X  T_pmathrmSpSt(2n 2k) is of the form X = tildeOmegap, with\n\n    tildeOmega = left(I_2n - frac12pp^+right)Xp^+ -\n                     pX^+left(I_2n - frac12pp^+right)  ℝ^2n2n\n\nas shown in Proposition 3.5 of [BZ21]. Using this representation of X, the Cayley retraction on mathrmSpSt(2n 2k) is defined pointwise as\n\n    mathcalR_p(X) = operatornamecayleft(frac12tildeOmegaright)p\n\nThe operator operatornamecay(A) = (I - A)^-1(I + A) is the Cayley transform.\n\nHowever, the computation of an 2n2n matrix inverse in the expression above can be reduced down to inverting a 2k2k matrix due to Proposition 5.2 of [BZ21].\n\nLet A = p^+X and H = X - pA. Then an equivalent expression for the Cayley retraction defined pointwise above is\n\n  mathcalR_p(X) = -p + (H + 2p)(H^+H4 - A2 + I_2k)^-1\n\nThis expression can be computed in place of q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel/#Literature","page":"Symplectic Stiefel","title":"Literature","text":"","category":"section"},{"location":"manifolds/symplecticstiefel/","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"T. Bendokat and R. Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv Preprint, 2108.12447 (2021), arXiv:2108.12447.\n\n\n\n","category":"page"},{"location":"manifolds/connection/#ConnectionSection","page":"Connection manifold","title":"Connection manifold","text":"","category":"section"},{"location":"manifolds/connection/","page":"Connection manifold","title":"Connection manifold","text":"A connection manifold always consists of a topological manifold together with a connection Γ.","category":"page"},{"location":"manifolds/connection/","page":"Connection manifold","title":"Connection manifold","text":"However, often there is an implicitly assumed (default) connection, like the LeviCivitaConnection connection on a Riemannian manifold. It is not necessary to use this decorator if you implement just one (or the first) connection. If you later introduce a second, the old (first) connection can be used without an explicitly stated connection.","category":"page"},{"location":"manifolds/connection/","page":"Connection manifold","title":"Connection manifold","text":"This manifold decorator serves two purposes:","category":"page"},{"location":"manifolds/connection/","page":"Connection manifold","title":"Connection manifold","text":"to implement different connections (e.g. in closed form) for one AbstractManifold\nto provide a way to compute geodesics on manifolds, where this AbstractAffineConnection does not yield a closed formula.","category":"page"},{"location":"manifolds/connection/","page":"Connection manifold","title":"Connection manifold","text":"Pages = [\"connection.md\"]\nDepth = 2","category":"page"},{"location":"manifolds/connection/#Types","page":"Connection manifold","title":"Types","text":"","category":"section"},{"location":"manifolds/connection/#Manifolds.AbstractAffineConnection","page":"Connection manifold","title":"Manifolds.AbstractAffineConnection","text":"AbstractAffineConnection\n\nAbstract type for affine connections on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection/#Manifolds.ConnectionManifold","page":"Connection manifold","title":"Manifolds.ConnectionManifold","text":"ConnectionManifold{𝔽,,M<:AbstractManifold{𝔽},G<:AbstractAffineConnection} <: AbstractDecoratorManifold{𝔽}\n\nConstructor\n\nConnectionManifold(M, C)\n\nDecorate the AbstractManifold  M with AbstractAffineConnection C.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection/#Manifolds.LeviCivitaConnection","page":"Connection manifold","title":"Manifolds.LeviCivitaConnection","text":"LeviCivitaConnection\n\nThe Levi-Civita connection of a Riemannian manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection/#Functions","page":"Connection manifold","title":"Functions","text":"","category":"section"},{"location":"manifolds/connection/#Manifolds.christoffel_symbols_first-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.christoffel_symbols_first","text":"christoffel_symbols_first(\n    M::AbstractManifold,\n    p,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend = default_differential_backend(),\n)\n\nCompute the Christoffel symbols of the first kind in local coordinates of basis B. The Christoffel symbols are (in Einstein summation convention)\n\nΓ_ijk = frac12 Biglg_kji + g_ikj - g_ijkBigr\n\nwhere g_ijk=frac p^k g_ij is the coordinate derivative of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.christoffel_symbols_second-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.christoffel_symbols_second","text":"christoffel_symbols_second(\n    M::AbstractManifold,\n    p,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend = default_differential_backend(),\n)\n\nCompute the Christoffel symbols of the second kind in local coordinates of basis B. For affine connection manifold the Christoffel symbols need to be explicitly implemented while, for a MetricManifold they are computed as (in Einstein summation convention)\n\nΓ^l_ij = g^kl Γ_ijk\n\nwhere Γ_ijk are the Christoffel symbols of the first kind (see christoffel_symbols_first), and g^kl is the inverse of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (lij).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.christoffel_symbols_second_jacobian-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.christoffel_symbols_second_jacobian","text":"christoffel_symbols_second_jacobian(\n    M::AbstractManifold,\n    p,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend = default_differential_backend(),\n)\n\nGet partial derivatives of the Christoffel symbols of the second kind for manifold M at p with respect to the coordinates of B, i.e.\n\nfrac p^l Γ^k_ij = Γ^k_ijl\n\nThe dimensions of the resulting multi-dimensional array are ordered (ijkl).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.connection-Tuple{AbstractManifold}","page":"Connection manifold","title":"Manifolds.connection","text":"connection(M::AbstractManifold)\n\nGet the connection (an object of a subtype of AbstractAffineConnection) of AbstractManifold M.\n\nThe global default connection is the LeviCivitaConnection.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.connection-Tuple{ConnectionManifold}","page":"Connection manifold","title":"Manifolds.connection","text":"connection(M::ConnectionManifold)\n\nReturn the connection associated with ConnectionManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.gaussian_curvature-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.gaussian_curvature","text":"gaussian_curvature(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = default_differential_backend())\n\nCompute the Gaussian curvature of the manifold M at the point p using basis B. This is equal to half of the scalar Ricci curvature, see ricci_curvature.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.is_default_connection-Tuple{AbstractManifold, AbstractAffineConnection}","page":"Connection manifold","title":"Manifolds.is_default_connection","text":"is_default_connection(M::AbstractManifold, c::AbstractAffineConnection)\n\nreturns whether an AbstractAffineConnection is the default metric on the manifold M or not.\n\nThis function falls back to check whether connection(M) == c.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.ricci_tensor-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.ricci_tensor","text":"ricci_tensor(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = default_differential_backend())\n\nCompute the Ricci tensor, also known as the Ricci curvature tensor, of the manifold M at the point p using basis B, see https://en.wikipedia.org/wiki/Ricci_curvature#Introduction_and_local_definition.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#Manifolds.solve_exp_ode-Tuple{AbstractManifold, Any, Any, Number}","page":"Connection manifold","title":"Manifolds.solve_exp_ode","text":"solve_exp_ode(\n    M::AbstractManifold,\n    p,\n    X,\n    t::Number;\n    B::AbstractBasis = DefaultOrthonormalBasis(),\n    backend::AbstractDiffBackend = default_differential_backend(),\n    solver = AutoVern9(Rodas5()),\n    kwargs...,\n)\n\nApproximate the exponential map on the manifold by evaluating the ODE descripting the geodesic at 1, assuming the default connection of the given manifold by solving the ordinary differential equation\n\nfracd^2dt^2 p^k + Γ^k_ij fracddt p_i fracddt p_j = 0\n\nwhere Γ^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed. The argument solver follows the OrdinaryDiffEq conventions. kwargs... specify keyword arguments that will be passed to OrdinaryDiffEq.solve.\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\nnote: Note\nThis function only works when OrdinaryDiffEq.jl is loaded withusing OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend=default_differential_backend())\n\nCompute the Riemann tensor R^l_ijk, also known as the Riemann curvature tensor, at the point p in local coordinates defined by B. The dimensions of the resulting multi-dimensional array are ordered (lijk).\n\nThe function uses the coordinate expression involving the second Christoffel symbol, see https://en.wikipedia.org/wiki/Riemann_curvature_tensor#Coordinate_expression for details.\n\nSee also\n\nchristoffel_symbols_second, christoffel_symbols_second_jacobian\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection/#connections_charts","page":"Connection manifold","title":"Charts and bases of vector spaces","text":"","category":"section"},{"location":"manifolds/connection/","page":"Connection manifold","title":"Connection manifold","text":"All connection-related functions take a basis of a vector space as one of the arguments. This is needed because generally there is no way to define these functions without referencing a basis. In some cases there is no need to be explicit about this basis, and then for example a DefaultOrthonormalBasis object can be used. In cases where being explicit about these bases is needed, for example when using multiple charts, a basis can be specified, for example using induced_basis.","category":"page"},{"location":"#Manifolds","page":"Home","title":"Manifolds","text":"","category":"section"},{"location":"#Manifolds.Manifolds","page":"Home","title":"Manifolds.Manifolds","text":"Manifolds.jl provides a library of manifolds aiming for an easy-to-use and fast implementation.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"The implemented manifolds are accompanied by their mathematical formulae.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The manifolds are implemented using the interface for manifolds given in ManifoldsBase.jl. You can use that interface to implement your own software on manifolds, such that all manifolds based on that interface can be used within your code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information, see the About section.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package just type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"Manifolds\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then you can directly start, for example to stop half way from the north pole on the Sphere to a point on the the equator, you can generate the shortest_geodesic. It internally employs log and exp.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Manifolds\nM = Sphere(2)\nγ = shortest_geodesic(M, [0., 0., 1.], [0., 1., 0.])\nγ(0.5)","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Manifolds.jl in your work, please cite the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"@online{2106.08777,\n    Author = {Seth D. Axen and Mateusz Baran and Ronny Bergmann and Krzysztof Rzecki},\n    Title = {Manifolds.jl: An Extensible Julia Framework for Data Analysis on Manifolds},\n    Year = {2021},\n    Eprint = {2106.08777},\n    Eprinttype = {arXiv},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"To refer to a specific version, it is recommended to cite, for example,","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{manifoldsjl-zenodo-mostrecent,\n  Author = {Seth D. Axen and Mateusz Baran and Ronny Bergmann},\n  Title = {Manifolds.jl},\n  Doi = {10.5281/ZENODO.4292129},\n  Url = {https://zenodo.org/record/4292129},\n  Publisher = {Zenodo},\n  Year = {2021},\n  Copyright = {MIT License}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"for the most recent version or a corresponding version specific DOI, see the list of all versions. Note that both citations are in BibLaTeX format.","category":"page"},{"location":"manifolds/lorentz/#Lorentzian-Manifold","page":"Lorentzian manifold","title":"Lorentzian Manifold","text":"","category":"section"},{"location":"manifolds/lorentz/","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"The Lorentz manifold is a pseudo-Riemannian manifold. It is named after the Dutch physicist Hendrik Lorentz (1853–1928). The default LorentzMetric is the MinkowskiMetric named after the German mathematician Hermann Minkowski (1864–1909).","category":"page"},{"location":"manifolds/lorentz/","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"Within Manifolds.jl it is used as the embedding of the Hyperbolic space.","category":"page"},{"location":"manifolds/lorentz/#Manifolds.Lorentz","page":"Lorentzian manifold","title":"Manifolds.Lorentz","text":"Lorentz{T} = MetricManifold{Euclidean{T,ℝ},LorentzMetric}\n\nThe Lorentz manifold (or Lorentzian) is a pseudo-Riemannian manifold.\n\nConstructor\n\nLorentz(n[, metric=MinkowskiMetric()])\n\nGenerate the Lorentz manifold of dimension n with the LorentzMetric m, which is by default set to the MinkowskiMetric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz/#Manifolds.LorentzMetric","page":"Lorentzian manifold","title":"Manifolds.LorentzMetric","text":"LorentzMetric <: AbstractMetric\n\nAbstract type for Lorentz metrics, which have a single time dimension. These metrics assume the spacelike convention with the time dimension being last, giving the signature (+++-).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz/#Manifolds.MinkowskiMetric","page":"Lorentzian manifold","title":"Manifolds.MinkowskiMetric","text":"MinkowskiMetric <: LorentzMetric\n\nAs a special metric of signature  (+++-), i.e. a LorentzMetric, see minkowski_metric for the formula.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz/#Manifolds.minkowski_metric-Tuple{Any, Any}","page":"Lorentzian manifold","title":"Manifolds.minkowski_metric","text":"minkowski_metric(a, b)\n\nCompute the minkowski metric on mathbb R^n is given by\n\nab_mathrmM = -a_nb_n +\ndisplaystylesum_k=1^n-1 a_kb_k\n\n\n\n\n\n","category":"method"},{"location":"misc/CONTRIBUTING/#Contributing-to-Manifolds.jl","page":"Contributing","title":"Contributing to Manifolds.jl","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"First, thanks for taking the time to contribute. Any contribution is appreciated and welcome.","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"The following is a set of guidelines to Manifolds.jl.","category":"page"},{"location":"misc/CONTRIBUTING/#Table-of-contents","page":"Contributing","title":"Table of contents","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Contributing to Manifolds.jl\nTable of Contents\nHow to ask a question\nHow to file an issue\nHow to contribute\nAdd a missing method\nProvide a new manifold\nCode style","category":"page"},{"location":"misc/CONTRIBUTING/#How-to-ask-a-question","page":"Contributing","title":"How to ask a question","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You can most easily reach the developers in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"misc/CONTRIBUTING/#How-to-file-an-issue","page":"Contributing","title":"How to file an issue","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you found a bug or want to propose a feature, issues are tracked within the GitHub repository.","category":"page"},{"location":"misc/CONTRIBUTING/#How-to-contribute","page":"Contributing","title":"How to contribute","text":"","category":"section"},{"location":"misc/CONTRIBUTING/#Overview-of-resources","page":"Contributing","title":"Overview of resources","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"ManifoldsBase.jl documents the main design principles for Riemannian manifolds in the JuliaManifolds ecosystem\nThe main set of functions serves as a guide, showing which functions the Library of manifolds in Manifolds.jl provides.\nA tutorial on how to define a manifold serves as a starting point on how to introduce a new manifold\nThe changelog documents all additions and changes. The corresponding file to edit is the NEWS.md\nThis file CONTRIBUTING.md  provides a technical introduction to contributing to Manifolds.jl","category":"page"},{"location":"misc/CONTRIBUTING/#Add-a-missing-method","page":"Contributing","title":"Add a missing method","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Within Manifolds.jl, there might be manifolds, that are only partially define the list of methods from the interface given in ManifoldsBase.jl. If you notice a missing method but are aware of an algorithm or theory about it, contributing the method is welcome. Even just the smallest function is a good contribution.","category":"page"},{"location":"misc/CONTRIBUTING/#Provide-a-new-manifold","page":"Contributing","title":"Provide a new manifold","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"A main contribution you can provide is another manifold that is not yet included in the package. A manifold is a concrete subtype of AbstractManifold from ManifoldsBase.jl. A tutorial on how to define a manifold helps to get started on a new manifold. Every new manifold is welcome, even if you only add a few functions, for example when your use case for now does not require more features.","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"One important detail is that the interface provides an in-place as well as a non-mutating variant See for example exp! and exp. The non-mutating one, exp, always falls back to allocating the according memory, here a point on the manifold, to then call the in-place variant. This way it suffices to provide the in-place variant, exp!. The allocating variant only needs to defined if a more efficient version than the default is available.","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Note that since the first argument is always the AbstractManifold, the mutated argument is always the second one in the signature. In the example there are exp(M, p, X) for the exponential map that allocates its result q, and exp!(M, q, p, X) for the in-place one, which computes and returns the q.","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Since a user probably looks for the documentation on the allocating variant, we recommend to attach the documentation string to this variant, mentioning all possible function signatures including the mutating one. You can best achieve this by adding a documentation string to the method with a general signature with the first argument being your manifold:","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"struct MyManifold <: AbstractManifold end\n\n@doc \"\"\"\n    exp(M::MyManifold, p, X)\n    exp!(M::MyManifold, q, p, X)\n\nDescribe the function, its input and output as well as a mathematical formula.\n\"\"\"\nexp(::MyManifold, ::Any, ::Any)","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You can also save the string to a variable, for example _doc_myM_exp and attach it to both functions","category":"page"},{"location":"misc/CONTRIBUTING/#Code-style","page":"Contributing","title":"Code style","text":"","category":"section"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Please follow the documentation guidelines from the Julia documentation and use Runic.jl for code formatting.","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Please consider a few internal conventions:","category":"page"},{"location":"misc/CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Please include a description of the manifold and a reference to the general theory in the struct of your manifold that inherits from AbstractManifold'.\nInclude the mathematical formulae for any implemented function if a closed form exists.\nWithin the source code of one manifold, the struct the manifold should be the first element of the file.\nan alphabetical order of functions in every file is preferable.\nThe preceding implies that the mutating variant of a function follows the non-mutating variant.\nThere should be no dangling = signs.\nAlways add a newline between things of different types (struct/method/const).\nAlways add a newline between methods for different functions (including allocating and in-place variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the documentation string.\nAlways document all input variables and keyword arguments\nif possible provide both mathematical formulae and literature references using DocumenterCitations.jl and BibTeX where possible\nAll import/using/include should be in the main module file.","category":"page"},{"location":"misc/internals/#Internal-documentation","page":"Internals","title":"Internal documentation","text":"","category":"section"},{"location":"misc/internals/","page":"Internals","title":"Internals","text":"This page documents the internal types and methods of Manifolds.jl's that might be of use for writing your own manifold.","category":"page"},{"location":"misc/internals/#Functions","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"misc/internals/#Manifolds.eigen_safe","page":"Internals","title":"Manifolds.eigen_safe","text":"eigen_safe(x)\n\nCompute the eigendecomposition of x. If x is a StaticMatrix, it is converted to a Matrix before the decomposition.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.estimated_sectional_curvature","page":"Internals","title":"Manifolds.estimated_sectional_curvature","text":"estimated_sectional_curvature(M::AbstractManifold, p, X, Y; r::Real=1e-3, N::Int=10000)\n\nApproximate sectional curvature of manifold M in the plane spanned by vectors X and Y from tangent space at p using a circle on M of radius r divided into N segments.\n\nThe approximation is derived from the Bertrand–Diguet–Puiseux theorem which states that\n\nkappa_p(X Y) = lim_r to 0^+ 3frac2pi r-C(r)pi r^3\n\nwhere C(r) is the circumference of the circle of radius r around p in submanifold of M spanned by X and Y. The circumference calculation method has a tendency to return curvature values larger than the exact ones.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.estimated_sectional_curvature_matrix","page":"Internals","title":"Manifolds.estimated_sectional_curvature_matrix","text":"estimated_sectional_curvature_matrix(M::AbstractManifold, p, B::AbstractBasis; r::Real=1e-3, N::Int=10000)\n\nEstimate the matrix of sectional curvatures of manifold M at point p using estimated_sectional_curvature. Entry (i, j)corresponds to sectional curvature of the surface spanned by vectorsiandjfrom basisB`.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.get_parameter_type","page":"Internals","title":"Manifolds.get_parameter_type","text":"get_parameter_type(M::AbstractManifold)\n\nGet parameter argument of the constructor of manifold M. Returns either :field or :type.\n\nSee also\n\nget_parameter, TypeParameter\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.isnormal","page":"Internals","title":"Manifolds.isnormal","text":"isnormal(x; kwargs...) -> Bool\n\nCheck if the matrix or number x is normal, that is, if it commutes with its adjoint:\n\nx x^mathrmH = x^mathrmH x\n\nBy default, this is an equality check. Provide kwargs for isapprox to perform an approximate check.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.log_safe","page":"Internals","title":"Manifolds.log_safe","text":"log_safe(x)\n\nCompute the matrix logarithm of x. If x is a StaticMatrix, it is converted to a Matrix before computing the log.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.log_safe!","page":"Internals","title":"Manifolds.log_safe!","text":"log_safe!(y, x)\n\nCompute the matrix logarithm of x. If the eltype of y is real, then the imaginary part of x is ignored, and a DomainError is raised if real(x) has no real logarithm.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.mul!_safe","page":"Internals","title":"Manifolds.mul!_safe","text":"mul!_safe(Y, A, B) -> Y\n\nCall mul! safely, that is, A and/or B are permitted to alias with Y.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.normal_tvector_distribution","page":"Internals","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::AbstractManifold, p, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at p.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.nzsign","page":"Internals","title":"Manifolds.nzsign","text":"nzsign(z[, absz])\n\nCompute a modified sign(z) that is always nonzero, i.e. where\n\noperatorname(nzsign)(z) = begincases\n    1  textif  z = 0\n    fraczz  textotherwise\nendcases\n\nNote that the condition absz == 0 would be incorrectly handled by ForwardDiff.jl.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.projected_distribution","page":"Internals","title":"Manifolds.projected_distribution","text":"projected_distribution(M::AbstractManifold, d, [p=rand(d)])\n\nWrap the standard distribution d into a manifold-valued distribution. Generated points will be of similar type to p. By default, the type is not changed.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.realify","page":"Internals","title":"Manifolds.realify","text":"realify(X::AbstractMatrix{T𝔽}, 𝔽::AbstractNumbers) -> Y::AbstractMatrix{<:Real}\n\nGiven a matrix X  𝔽^nn, compute Y  ℝ^mm, where m = n operatornamedim_𝔽, and operatornamedim_𝔽 is the real_dimension of the number field 𝔽, using the map ϕ colon X  Y, that preserves the matrix product, so that for all CD  𝔽^nn,\n\nϕ(C) ϕ(D) = ϕ(CD)\n\nSee realify! for an in-place version, and unrealify! to compute the inverse of ϕ.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.realify!","page":"Internals","title":"Manifolds.realify!","text":"realify!(Y::AbstractMatrix{<:Real}, X::AbstractMatrix{T𝔽}, 𝔽::AbstractNumbers)\n\nIn-place version of realify.\n\n\n\n\n\nrealify!(Y::AbstractMatrix{<:Real}, X::AbstractMatrix{<:Complex}, ::typeof(ℂ))\n\nGiven a complex matrix X = A + iB  ℂ^nn, compute its realified matrix Y  ℝ^2n2n, written where\n\nY = beginpmatrixA  -B  B  A endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.symmetrize","page":"Internals","title":"Manifolds.symmetrize","text":"symmetrize(X)\n\nGiven a square matrix X compute 1/2 .* (X' + X).\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.symmetrize!","page":"Internals","title":"Manifolds.symmetrize!","text":"symmetrize!(Y, X)\n\nGiven a square matrix X compute 1/2 .* (X' + X) in place of Y.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.unrealify!","page":"Internals","title":"Manifolds.unrealify!","text":"unrealify!(X::AbstractMatrix{T𝔽}, Y::AbstractMatrix{<:Real}, 𝔽::AbstractNumbers[, n])\n\nGiven a real matrix Y  ℝ^mm, where m = n operatornamedim_𝔽, and operatornamedim_𝔽 is the real_dimension of the number field 𝔽, compute in-place its equivalent matrix X  𝔽^nn. Note that this function does not check that Y has a valid structure to be un-realified.\n\nSee realify! for the inverse of this function.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.usinc","page":"Internals","title":"Manifolds.usinc","text":"usinc(θ::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(θ) = fracsin(θ)θ. This is equivalent to sinc(θ/π).\n\nNote that ForwardDiff.jl would return wrong answer at θ=0 if a simple equality was used.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.usinc_from_cos","page":"Internals","title":"Manifolds.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(θ) = fracsin(θ)θ, computed from x = cos(θ).\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Manifolds.vec2skew!","page":"Internals","title":"Manifolds.vec2skew!","text":"vec2skew!(X, v, k)\n\nCreate a skew symmetric matrix in-place in X of size kk from a vector v, for example for v=[1,2,3] and k=3 this yields\n\n[  0  1  2;\n  -1  0  3;\n  -2 -3  0\n]\n\n\n\n\n\n","category":"function"},{"location":"misc/internals/#Types-in-Extensions","page":"Internals","title":"Types in Extensions","text":"","category":"section"},{"location":"misc/internals/#Manifolds.IntegratorTerminatorNearChartBoundary-Tuple{Any, Any, Any}","page":"Internals","title":"Manifolds.IntegratorTerminatorNearChartBoundary","text":"(int_term::IntegratorTerminatorNearChartBoundary)(u, t, integrator)\n\nTerminate integration when integrator goes too closely to chart boundary. Closeness is determined by ϵ value of IntegratorTerminatorNearChartBoundary int_term.\n\nArguments:\n\nint_term: object containing keyword arguments for check_chart_switch, such as the desired maximum distance to boundary,\nu: parameters of a point at which the integrator is solving a differential equation.\nt: time parameter of the integrator\nintegrator: state of the integrator. Internal parameters are expected to contained the manifold on which the equation is solved, the atlas and the current chart index.\n\n\n\n\n\n","category":"method"},{"location":"misc/internals/#ManifoldsOrdinaryDiffEqDiffEqCallbacksExt.StitchedChartSolution","page":"Internals","title":"ManifoldsOrdinaryDiffEqDiffEqCallbacksExt.StitchedChartSolution","text":"StitchedChartSolution{Prob,TM<:AbstractManifold,TA<:AbstractAtlas,TChart}\n\nSolution of an ODE on a manifold M in charts of an AbstractAtlas A.\n\nWhen StitchedChartSolution{:Exp} is used as a function with a number t as an argument, a pair (p, X) is returned such that pin mathcalM is the point at time t of the geodesic and X in T_p mathcalM is the velocity of the geodesic at that point. Similarly, StitchedChartSolution{:PT} called with number t returns a triple (p, X, Y) where (p, X) corresponds to the geodesic along which the vector is transported and Yin T_pmathcalM is the vector transported to p.\n\n\n\n\n\n","category":"type"},{"location":"misc/internals/#Manifolds.solve_chart_exp_ode-Tuple{AbstractManifold, Any, Any, AbstractAtlas, Any}","page":"Internals","title":"Manifolds.solve_chart_exp_ode","text":"solve_chart_exp_ode(\n    M::AbstractManifold, a, Xc, A::AbstractAtlas, i0;\n    solver=AutoVern9(Rodas5()),\n    final_time::Real=1.0,\n    check_chart_switch_kwargs=NamedTuple(),\n    kwargs...,\n)\n\nSolve geodesic ODE on a manifold M from point of coordinates a in chart i0 from an AbstractAtlas A in direction of coordinates Xc in the induced basis. The geodesic is solved up to time final_time (by default equal to 1).\n\nChart switching\n\nIf the solution exceeds the domain of chart i0 (which is detected using the check_chart_switch function with additional keyword arguments check_chart_switch_kwargs), a new chart is selected using get_chart_index on the final point in the old chart.\n\nReturned value\n\nThe function returns an object of type StitchedChartSolution{:Exp} to represent the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"misc/internals/#Manifolds.solve_chart_parallel_transport_ode-Tuple{AbstractManifold, Any, Any, AbstractAtlas, Any, Any}","page":"Internals","title":"Manifolds.solve_chart_parallel_transport_ode","text":"solve_chart_parallel_transport_ode(\n    M::AbstractManifold, a, Xc, A::AbstractAtlas, i0, Yc;\n    solver=AutoVern9(Rodas5()), check_chart_switch_kwargs=NamedTuple(), final_time=1.0,\n    kwargs...\n)\n\nParallel transport vector with coordinates Yc along geodesic on a manifold M from point of coordinates a in a chart i0 from an AbstractAtlas A in direction of coordinates Xc in the induced basis.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#SphereSection","page":"Sphere","title":"Sphere and unit norm arrays","text":"","category":"section"},{"location":"manifolds/sphere/#Manifolds.AbstractSphere","page":"Sphere","title":"Manifolds.AbstractSphere","text":"AbstractSphere{𝔽} <: AbstractDecoratorManifold{𝔽}\n\nAn abstract type to represent a unit sphere that is represented isometrically in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"The classical sphere, i.e. unit norm (real- or complex-valued) vectors can be generated as usual: to create the 2-dimensional sphere (in ℝ^3), use Sphere(2) and Sphere(2,ℂ), respectively.","category":"page"},{"location":"manifolds/sphere/#Manifolds.Sphere","page":"Sphere","title":"Manifolds.Sphere","text":"Sphere{𝔽, T} <: AbstractSphere{𝔽}\n\nThe (unit) sphere manifold 𝕊^n is the set of all unit norm vectors in 𝔽^n+1. The sphere is represented in the embedding, i.e.\n\n𝕊^n = bigl p in 𝔽^n+1 big lVert p rVert = 1 bigr\n\nwhere 𝔽inℝℂℍ. Note that compared to the ArraySphere, here the argument n of the manifold is the dimension of the manifold, i.e. 𝕊^n  𝔽^n+1, nin ℕ.\n\nThe tangent space at point p is given by\n\nT_p𝕊^n = bigl X  𝔽^n+1  Re(pX) = 0 bigr \n\nwhere 𝔽inℝℂℍ and  denotes the inner product in the embedding 𝔽^n+1.\n\nFor 𝔽=ℂ, the manifold is the complex sphere, written ℂ𝕊^n, embedded in ℂ^n+1. ℂ𝕊^n is the complexification of the real sphere 𝕊^2n+1. Likewise, the quaternionic sphere ℍ𝕊^n is the quaternionification of the real sphere 𝕊^4n+3. Consequently, ℂ𝕊^0 is equivalent to 𝕊^1 and Circle, while ℂ𝕊^1 and ℍ𝕊^0 are equivalent to 𝕊^3, though with different default representations.\n\nThis manifold is modeled as a special case of the more general case, i.e. as an embedded manifold to the Euclidean, and several functions like the inner product and the zero_vector are inherited from the embedding.\n\nConstructor\n\nSphere(n[, field=ℝ])\n\nGenerate the (real-valued) sphere 𝕊^n  ℝ^n+1, where field can also be used to generate the complex- and quaternionic-valued sphere.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"For the higher-dimensional arrays, for example unit (Frobenius) norm matrices, the manifold is generated using the size of the matrix. To create the unit sphere of 32 real-valued matrices, write ArraySphere(3,2) and the complex case is done – as for the Euclidean case – with an keyword argument ArraySphere(3,2; field=ℂ). This case also covers the classical sphere as a special case, but you specify the size of the vectors/embedding instead: The 2-sphere can here be generated ArraySphere(3).","category":"page"},{"location":"manifolds/sphere/#Manifolds.ArraySphere","page":"Sphere","title":"Manifolds.ArraySphere","text":"ArraySphere{𝔽, T} <: AbstractSphere{𝔽}\n\nThe (unit) sphere manifold 𝕊^n₁n₂nᵢ is the set of all unit (Frobenius) norm elements of 𝔽^n₁n₂nᵢ, where ``𝔽\\in{ℝ,ℂ,ℍ}. The generalized sphere is represented in the embedding, and supports arbitrary sized arrays or in other words arbitrary tensors of unit norm. The set formally reads\n\n𝕊^n_1 n_2  n_i = bigl p in 𝔽^n_1 n_2  n_i big lVert p rVert = 1 bigr\n\nwhere 𝔽ℝℂℍ. Setting i=1 and 𝔽=ℝ  this  simplifies to unit vectors in ℝ^n, see Sphere for this special case. Note that compared to this classical case, the argument for the generalized case here is given by the dimension of the embedding. This means that Sphere(2) and ArraySphere(3) are the same manifold.\n\nThe tangent space at point p is given by\n\nT_p 𝕊^n_1 n_2  n_i = bigl X  𝔽^n_1 n_2  n_i  Re(pX) = 0 bigr \n\nwhere 𝔽ℝℂℍ and  denotes the (Frobenius) inner product in the embedding 𝔽^n_1 n_2  n_i.\n\nThis manifold is modelled as an embedded manifold to the Euclidean, i.e. several functions like the inner product and the zero_vector are inherited from the embedding.\n\nConstructor\n\nArraySphere(n₁,n₂,...,nᵢ; field=ℝ, parameter::Symbol=:type)\n\nGenerate sphere in 𝔽^n_1 n_2  n_i, where 𝔽 defaults to the real-valued case ℝ.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"There is also one atlas available on the sphere.","category":"page"},{"location":"manifolds/sphere/#Manifolds.StereographicAtlas","page":"Sphere","title":"Manifolds.StereographicAtlas","text":"StereographicAtlas()\n\nThe stereographic atlas of S^n with two charts: one with the singular point (-1, 0, ..., 0) (called :north) and one with the singular point (1, 0, ..., 0) (called :south).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere/#Functions-on-unit-spheres","page":"Sphere","title":"Functions on unit spheres","text":"","category":"section"},{"location":"manifolds/sphere/#Base.exp-Tuple{AbstractSphere, Vararg{Any}}","page":"Sphere","title":"Base.exp","text":"exp(M::AbstractSphere, p, X)\n\nCompute the exponential map from p in the tangent direction X on the AbstractSphere M by following the great arc emanating from p in direction X.\n\nexp_p X = cos(lVert X rVert_p)p + sin(lVert X rVert_p)fracXlVert X rVert_p\n\nwhere lVert X rVert_p is the norm on the tangent space at p of the AbstractSphere M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Base.log-Tuple{AbstractSphere, Vararg{Any}}","page":"Sphere","title":"Base.log","text":"log(M::AbstractSphere, p, q)\n\nCompute the logarithmic map on the AbstractSphere M, i.e. the tangent vector, whose geodesic starting from p reaches q after time 1. The formula reads for x  -y\n\nlog_p q = d_𝕊(pq) fracq-Re(pq) plVert q-Re(pq) p rVert_2\n\nand a deterministic choice from the set of tangent vectors is returned if x=-y, i.e. for opposite points.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manifolds.local_metric-Tuple{Sphere{ℝ, Tuple{Int64}}, Any, DefaultOrthonormalBasis}","page":"Sphere","title":"Manifolds.local_metric","text":"local_metric(M::Sphere{n}, p, ::DefaultOrthonormalBasis)\n\nreturn the local representation of the metric in a DefaultOrthonormalBasis, namely the diagonal matrix of size nn with ones on the diagonal, since the metric is obtained from the embedding by restriction to the tangent space T_pmathcal M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manifolds.manifold_volume-Tuple{AbstractSphere{ℝ}}","page":"Sphere","title":"Manifolds.manifold_volume","text":"manifold_volume(M::AbstractSphere{ℝ})\n\nVolume of the n-dimensional Sphere M. The formula reads\n\noperatornameVol(𝕊^n) = frac2pi^(n+1)2Γ((n+1)2)\n\nwhere Γ denotes the Gamma function.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manifolds.volume_density-Tuple{AbstractSphere{ℝ}, Any, Any}","page":"Sphere","title":"Manifolds.volume_density","text":"volume_density(M::AbstractSphere{ℝ}, p, X)\n\nCompute volume density function of a sphere, i.e. determinant of the differential of exponential map exp(M, p, X). The formula reads (sin(lVert XrVert)lVert XrVert)^(n-1) where n is the dimension of M. It is derived from Eq. (4.1) in [CLLD22].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.Weingarten-Tuple{Sphere, Any, Any, Any}","page":"Sphere","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::Sphere, p, X, V)\nWeingarten!(M::Sphere, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the Sphere M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nThe formula is due to [AMT13] given by\n\nmathcal W_p(XV) = -Xp^mathrmTV\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.check_point-Tuple{AbstractSphere, Any}","page":"Sphere","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractSphere, p; kwargs...)\n\nCheck whether p is a valid point on the AbstractSphere M, i.e. is a point in the embedding of unit length. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{AbstractSphere, Any, T}} where T","page":"Sphere","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractSphere, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the AbstractSphere M, i.e. after check_point(M,p), X has to be of same dimension as p and orthogonal to p. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.default_retraction_method-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::AbstractSphere)\n\nThe default retraction on the sphere is usually the exponential map. Howeverm since that map tends to be very sensitive to also only slight errors in tangent vectors (not being tangent), we use a stabilized version as default that projects onto the sphere afterwards, see StabilizedRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.distance-Tuple{AbstractSphere, Any, Any}","page":"Sphere","title":"ManifoldsBase.distance","text":"distance(M::AbstractSphere, p, q)\n\nCompute the geodesic distance between p and q on the AbstractSphere M. The formula is given by the (shorter) great arc length on the (or a) great circle both p and q lie on.\n\nd_𝕊(pq) = arccos(Re(pq))\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.get_coordinates-Tuple{AbstractSphere{ℝ}, Any, Any, DefaultOrthonormalBasis}","page":"Sphere","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractSphere{ℝ}, p, X, B::DefaultOrthonormalBasis)\n\nRepresent the tangent vector X at point p from the AbstractSphere M in an orthonormal basis by rotating the hyperplane containing X to a hyperplane whose normal is the x-axis.\n\nGiven q = p λ + x, where λ = operatornamesgn(x p), and  _mathrmF denotes the Frobenius inner product, the formula for Y is\n\nbeginpmatrix0  Yendpmatrix = X - qfrac2 q X_mathrmFq q_mathrmF\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.get_vector-Tuple{AbstractSphere{ℝ}, Any, Any, DefaultOrthonormalBasis}","page":"Sphere","title":"ManifoldsBase.get_vector","text":"get_vector(M::AbstractSphere{ℝ}, p, X, B::DefaultOrthonormalBasis)\n\nConvert a one-dimensional vector of coefficients X in the basis B of the tangent space at p on the AbstractSphere M to a tangent vector Y at p by rotating the hyperplane containing X, whose normal is the x-axis, to the hyperplane whose normal is p.\n\nGiven q = p λ + x, where λ = operatornamesgn(x p), and  _mathrmF denotes the Frobenius inner product, the formula for Y is\n\nY = X - qfrac2 leftlangle q beginpmatrix0  Xendpmatrixrightrangle_mathrmFq q_mathrmF\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.injectivity_radius-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractSphere[, p])\n\nReturn the injectivity radius for the AbstractSphere M, which is globally π.\n\ninjectivity_radius(M::Sphere, x, ::ProjectionRetraction)\n\nReturn the injectivity radius for the ProjectionRetraction on the AbstractSphere, which is globally fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.inverse_retract-Tuple{AbstractSphere, Any, Any, ProjectionInverseRetraction}","page":"Sphere","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractSphere, p, q, ::ProjectionInverseRetraction)\n\nCompute the inverse of the projection based retraction on the AbstractSphere M, i.e. rearranging p+X = qlVert p+XrVert_2 yields since Re(pX) = 0 and when d_𝕊^2(pq)  fracπ2 that\n\noperatornameretr_p^-1(q) = fracqRe(p q) - p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.is_flat-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.is_flat","text":"is_flat(M::AbstractSphere)\n\nReturn true if AbstractSphere is of dimension 1 and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.manifold_dimension-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractSphere)\n\nReturn the dimension of the AbstractSphere M, respectively i.e. the dimension of the embedding -1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.parallel_transport_to-Tuple{AbstractSphere, Vararg{Any, 4}}","page":"Sphere","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::AbstractSphere, p, X, q)\n\nCompute the parallel transport on the Sphere of the tangent vector X at p to q, provided, the geodesic between p and q is unique. The formula reads\n\nP_pq(X) = X - fracRe(log_p qX_p)d^2_𝕊(pq)\nbigl(log_p q + log_q p bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.project-Tuple{AbstractSphere, Any, Any}","page":"Sphere","title":"ManifoldsBase.project","text":"project(M::AbstractSphere, p, X)\n\nProject the point X onto the tangent space at p on the Sphere M.\n\noperatornameproj_p(X) = X - Re(p X)p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.project-Tuple{AbstractSphere, Any}","page":"Sphere","title":"ManifoldsBase.project","text":"project(M::AbstractSphere, p)\n\nProject the point p from the embedding onto the Sphere M.\n\noperatornameproj(p) = fracplVert p rVert\n\nwhere lVertrVert denotes the usual 2-norm for vectors if m=1 and the Frobenius norm for the case m1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.representation_size-Tuple{ArraySphere}","page":"Sphere","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractSphere)\n\nReturn the size points on the AbstractSphere M are represented as, i.e., the representation size of the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.retract-Tuple{AbstractSphere, Any, Any, ProjectionRetraction}","page":"Sphere","title":"ManifoldsBase.retract","text":"retract(M::AbstractSphere, p, X, ::ProjectionRetraction)\n\nCompute the retraction that is based on projection, i.e.\n\noperatornameretr_p(X) = fracp+XlVert p+X rVert_2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.riemann_tensor-Tuple{AbstractSphere{ℝ}, Vararg{Any, 4}}","page":"Sphere","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::AbstractSphere{ℝ}, p, X, Y, Z)\n\nCompute the Riemann tensor R(XY)Z at point p on AbstractSphere M. The formula reads [MF12] (though note that a different convention is used in that paper than in Manifolds.jl):\n\nR(XY)Z = langle Z Y rangle X - langle Z X rangle Y\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.sectional_curvature-Tuple{AbstractSphere, Any, Any, Any}","page":"Sphere","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(::AbstractSphere, p, X, Y)\n\nSectional curvature of AbstractSphere M is 1 if dimension is greater than 1 and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.sectional_curvature_max-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(::AbstractSphere)\n\nSectional curvature of AbstractSphere M is 1 if dimension is greater than 1 and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#ManifoldsBase.sectional_curvature_min-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::AbstractSphere)\n\nSectional curvature of AbstractSphere M is 1 if dimension is greater than 1 and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Statistics.mean-Tuple{AbstractSphere, Vararg{Any}}","page":"Sphere","title":"Statistics.mean","text":"mean(\n    S::AbstractSphere,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Visualization-on-Sphere{2,ℝ}","page":"Sphere","title":"Visualization on Sphere{2,ℝ}","text":"","category":"section"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"You can visualize both points and tangent vectors on the sphere.","category":"page"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"note: Note\nThere seems to be no unified way to draw spheres in the backends of Plots.jl. This recipe currently uses the seriestype wireframe and surface, which does not yet work with the default backend GR.","category":"page"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"In general you can plot the surface of the hyperboloid either as wireframe (wireframe=true) additionally specifying wires (or wires_x and wires_y) to change the density of the wires and a wireframe_color for their color. The same holds for the plot as a surface (which is false by default) and its surface_resolution (or surface_resolution_lat or surface_resolution_lon) and a surface_color.","category":"page"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"using Manifolds, Plots\npythonplot()\nM = Sphere(2)\npts = [ [1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0] ]\nscene = plot(M, pts; wireframe_color=colorant\"#CCCCCC\", markersize=10)","category":"page"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"which scatters our points. We can also draw connecting geodesics, which here is a geodesic triangle. Here we discretize each geodesic with 100 points along the geodesic. The default value is geodesic_interpolation=-1 which switches to scatter plot of the data.","category":"page"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"plot!(scene, M, pts; wireframe=false, geodesic_interpolation=100, linewidth=2)","category":"page"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"And we can also add tangent vectors, for example tangents pointing towards the geometric center of given points.","category":"page"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"pts2 =  [ [1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0] ]\np3 = 1/sqrt(3) .* [1.0, -1.0, 1.0]\nvecs = log.(Ref(M), pts2, Ref(p3))\nplot!(scene, M, pts2, vecs; wireframe = false, linewidth=1.5)","category":"page"},{"location":"manifolds/sphere/#Literature","page":"Sphere","title":"Literature","text":"","category":"section"},{"location":"manifolds/sphere/","page":"Sphere","title":"Sphere","text":"P. -.-A. Absil, R. Mahony and J. Trumpf. An Extrinsic Look at the Riemannian Hessian. In: Geometric Science of Information, edited by F. Nielsen and F. Barbaresco (Springer Berlin Heidelberg, 2013); pp. 361–368.\n\n\n\nE. Chevallier, D. Li, Y. Lu and D. B. Dunson. Exponential-wrapped distributions on symmetric spaces. ArXiv Preprint (2022).\n\n\n\nP. Muralidharan and P. T. Fletcher. Sasaki metrics for analysis of longitudinal data on manifolds. In: 2012 IEEE Conference on Computer Vision and Pattern Recognition (2012).\n\n\n\n","category":"page"},{"location":"manifolds/shapespace/#Shape-spaces","page":"Shape spaces","title":"Shape spaces","text":"","category":"section"},{"location":"manifolds/shapespace/","page":"Shape spaces","title":"Shape spaces","text":"Shape spaces are spaces of k points in ℝ^n up to simultaneous action of a group on all points. The most commonly encountered are Kendall's pre-shape and shape spaces. In the case of the Kendall's pre-shape spaces the action is translation and scaling. In the case of the Kendall's shape spaces the action is translation, scaling and rotation.","category":"page"},{"location":"manifolds/shapespace/","page":"Shape spaces","title":"Shape spaces","text":"using Manifolds, Plots\n\nM = KendallsShapeSpace(2, 3)\n# two random point on the shape space\np = [\n    0.4385117672460505 -0.6877826444042382 0.24927087715818771\n    -0.3830259932279294 0.35347460720654283 0.029551386021386548\n]\nq = [\n    -0.42693314765896473 -0.3268567431952937 0.7537898908542584\n    0.3054740561061169 -0.18962848284149897 -0.11584557326461796\n]\n# let's plot them as triples of points on a plane\nfig = scatter(p[1,:], p[2,:], label=\"p\", aspect_ratio=:equal)\nscatter!(fig, q[1,:], q[2,:], label=\"q\")","category":"page"},{"location":"manifolds/shapespace/","page":"Shape spaces","title":"Shape spaces","text":"A more extensive usage example is available in the hand_gestures.jl tutorial.","category":"page"},{"location":"manifolds/shapespace/#Manifolds.KendallsPreShapeSpace","page":"Shape spaces","title":"Manifolds.KendallsPreShapeSpace","text":"KendallsPreShapeSpace{T} <: AbstractSphere{ℝ}\n\nKendall's pre-shape space of k landmarks in ℝ^n represented by n×k matrices. In each row the sum of elements of a matrix is equal to 0. The Frobenius norm of the matrix is equal to 1 [Ken84][Ken89].\n\nThe space can be interpreted as tuples of k points in ℝ^n up to simultaneous translation and scaling of all points, so this can be thought of as a quotient manifold.\n\nConstructor\n\nKendallsPreShapeSpace(n::Int, k::Int; parameter::Symbol=:type)\n\nSee also\n\nKendallsShapeSpace, esp. for the references\n\n\n\n\n\n","category":"type"},{"location":"manifolds/shapespace/#Manifolds.KendallsShapeSpace","page":"Shape spaces","title":"Manifolds.KendallsShapeSpace","text":"KendallsShapeSpace{T} <: AbstractDecoratorManifold{ℝ}\n\nKendall's shape space, defined as quotient of a KendallsPreShapeSpace (represented by n×k matrices) modulo column wise application of a single rotation.\n\nThe space can be interpreted as tuples of k points in ℝ^n up to simultaneous translation and scaling and rotation of all points [Ken84][Ken89].\n\nConstructor\n\nKendallsShapeSpace(n::Int, k::Int; parameter::Symbol=:type)\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"manifolds/shapespace/#Provided-functions","page":"Shape spaces","title":"Provided functions","text":"","category":"section"},{"location":"manifolds/shapespace/#ManifoldsBase.check_point-Tuple{KendallsPreShapeSpace, Any}","page":"Shape spaces","title":"ManifoldsBase.check_point","text":"check_point(M::KendallsPreShapeSpace, p; atol=sqrt(max_eps(X, Y)), kwargs...)\n\nCheck whether p is a valid point on KendallsPreShapeSpace, i.e. whether each row has zero mean. Other conditions are checked via embedding in ArraySphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.check_vector-Tuple{KendallsPreShapeSpace, Any, Any}","page":"Shape spaces","title":"ManifoldsBase.check_vector","text":"check_vector(M::KendallsPreShapeSpace, p, X; kwargs... )\n\nCheck whether X is a valid tangent vector on KendallsPreShapeSpace, i.e. whether each row has zero mean. Other conditions are checked via embedding in ArraySphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.get_embedding-Tuple{KendallsPreShapeSpace}","page":"Shape spaces","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::KendallsPreShapeSpace)\n\nReturn the space KendallsPreShapeSpace M is embedded in, i.e. ArraySphere of matrices of the same shape.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.manifold_dimension-Tuple{KendallsPreShapeSpace}","page":"Shape spaces","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::KendallsPreShapeSpace)\n\nReturn the dimension of the KendallsPreShapeSpace manifold M. The dimension is given by n(k - 1) - 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.project-Tuple{KendallsPreShapeSpace, Any, Any}","page":"Shape spaces","title":"ManifoldsBase.project","text":"project(M::KendallsPreShapeSpace, p, X)\n\nProject tangent vector X at point p from the embedding to KendallsPreShapeSpace by selecting the right element from the tangent space to orthogonal section representing the quotient manifold M. See Section 3.7 of [SK16] for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.project-Tuple{KendallsPreShapeSpace, Any}","page":"Shape spaces","title":"ManifoldsBase.project","text":"project(M::KendallsPreShapeSpace, p)\n\nProject point p from the embedding to KendallsPreShapeSpace by selecting the right element from the orthogonal section representing the quotient manifold M. See Section 3.7 of [SK16] for details.\n\nThe method computes the mean of the landmarks and moves them to make their mean zero; afterwards the Frobenius norm of the landmarks (as a matrix) is normalised to fix the scaling.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#Base.exp-Tuple{KendallsShapeSpace, Any, Any}","page":"Shape spaces","title":"Base.exp","text":"exp(M::KendallsShapeSpace, p, X)\n\nCompute the exponential map on KendallsShapeSpace M. See [GMTP21] for discussion about its computation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#Base.log-Tuple{KendallsShapeSpace, Any, Any}","page":"Shape spaces","title":"Base.log","text":"log(M::KendallsShapeSpace, p, q)\n\nCompute the logarithmic map on KendallsShapeSpace M. See the [exp](@ref exp(::KendallsShapeSpace, ::Any, ::Any)onential map for more details\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#Base.rand-Tuple{KendallsShapeSpace}","page":"Shape spaces","title":"Base.rand","text":"rand(::KendallsShapeSpace; vector_at=nothing)\n\nWhen vector_at is nothing, return a random point x on the KendallsShapeSpace manifold M by generating a random point in the embedding.\n\nWhen vector_at is not nothing, return a random vector from the tangent space with mean zero and standard deviation σ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.get_embedding-Tuple{KendallsShapeSpace}","page":"Shape spaces","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::KendallsShapeSpace)\n\nGet the manifold in which KendallsShapeSpace M is embedded, i.e. KendallsPreShapeSpace of matrices of the same shape.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.get_total_space-Tuple{KendallsShapeSpace}","page":"Shape spaces","title":"ManifoldsBase.get_total_space","text":"get_total_space(::KendallsShapeSpace)\n\nReturn the total space of the KendallsShapeSpace manifold, which is the KendallsPreShapeSpace manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.horizontal_component-Tuple{KendallsShapeSpace, Any, Any}","page":"Shape spaces","title":"ManifoldsBase.horizontal_component","text":"horizontal_component(::KendallsShapeSpace, p, X)\n\nCompute the horizontal component of tangent vector X at p on KendallsShapeSpace M. See [GMTP21], Section 2.3 for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.is_flat-Tuple{KendallsShapeSpace}","page":"Shape spaces","title":"ManifoldsBase.is_flat","text":"is_flat(::KendallsShapeSpace)\n\nReturn false. KendallsShapeSpace is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#ManifoldsBase.manifold_dimension-Tuple{KendallsShapeSpace}","page":"Shape spaces","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::KendallsShapeSpace)\n\nReturn the dimension of the KendallsShapeSpace manifold M. The dimension is given by n(k - 1) - 1 - n(n - 1)2 in the typical case where k geq n+1, and (k + 1)(k - 2)  2 otherwise, unless k is equal to 1, in which case the dimension is 0. See [Ken84] for a discussion of the over-dimensioned case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/shapespace/#Literature","page":"Shape spaces","title":"Literature","text":"","category":"section"},{"location":"manifolds/shapespace/","page":"Shape spaces","title":"Shape spaces","text":"N. Guigui, E. Maignant, A. Trouvé and X. Pennec. Parallel Transport on Kendall Shape Spaces. In: Geometric Science of Information (SPringer Cham, 2021); pp. 103–110.\n\n\n\nD. G. Kendall. Shape Manifolds, Procrustean Metrics, and Complex Projective Spaces. Bulletin of the London Mathematical Society 16, 81–121 (1984).\n\n\n\nD. G. Kendall. A Survey of the Statistical Theory of Shape. Statistical Sciences 4, 87–99 (1989).\n\n\n\nA. Srivastava and E. P. Klassen. Functional and Shape Data Analysis (Springer New York, 2016).\n\n\n\n","category":"page"},{"location":"manifolds/determinantone/#Matrices-of-determinant-one","page":"Determinant one matrices","title":"Matrices of determinant one","text":"","category":"section"},{"location":"manifolds/determinantone/#Manifolds.DeterminantOneMatrices","page":"Determinant one matrices","title":"Manifolds.DeterminantOneMatrices","text":"DeterminantOneMatrices{𝔽,T} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold consisting of the real- or complex-valued (invertible) matrices od determinant one, that is the set\n\nbiglp   𝔽^nn big det(p) = 1 bigr\n\nwhere the field 𝔽   ℝ ℂ.\n\nNote that this is a subset of InvertibleMatrices, and a superset of any of the GeneralUnitaryMatrices\n\nThe tangent space at any point p is the set of matrices with trace 0.\n\nConstructor\n\nDeterminantOneMatrices(n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of nn matrices of determinant one.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/determinantone/#Base.rand-Tuple{DeterminantOneMatrices}","page":"Determinant one matrices","title":"Base.rand","text":"Random.rand(M::DeterminantOneMatrices; vector_at=nothing, kwargs...)\n\nIf vector_at is nothing, return a random point on the DeterminantOneMatrices manifold M by using rand in the embedding.\n\nIf vector_at is not nothing, return a random tangent vector from the tangent space of the point vector_at on the DeterminantOneMatrices by using by using rand in the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/determinantone/#ManifoldsBase.check_point-Tuple{DeterminantOneMatrices, Any}","page":"Determinant one matrices","title":"ManifoldsBase.check_point","text":"check_point(M::DeterminantOneMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether p is a valid manifold point on the DeterminantOneMatrices M, i.e. whether p has a determinant of 1.\n\nThe check is performed with isapprox and all keyword arguments are passed to this\n\n\n\n\n\n","category":"method"},{"location":"manifolds/determinantone/#ManifoldsBase.check_vector-Tuple{DeterminantOneMatrices, Any, Any}","page":"Determinant one matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::DeterminantOneMatrices{n,𝔽}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the DeterminantOneMatrices M, which are all matrices of size nn with trace 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/determinantone/#ManifoldsBase.manifold_dimension-Union{Tuple{DeterminantOneMatrices{<:Any, 𝔽}}, Tuple{𝔽}} where 𝔽","page":"Determinant one matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::DeterminantOneMatrices{n,𝔽})\n\nReturn the dimension of the DeterminantOneMatrices matrix M over the number system 𝔽, which is one dimension less than its embedding, the Euclidean(n, n; field=𝔽).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/determinantone/#ManifoldsBase.project-Tuple{DeterminantOneMatrices, Any, Any}","page":"Determinant one matrices","title":"ManifoldsBase.project","text":"project(G::DeterminantOneMatrices, p, X)\nproject!(G::DeterminantOneMatrices, Y, p, X)\n\nOrthogonally project X  𝔽^nn onto the tangent space of p to the DeterminantOneMatrices.\n\nThis first changes the representation from X to the trace-zero component, i.e. computes Y = p \\ X and then subtracts c = tr(Y) / n from all diagonal entries.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/determinantone/#ManifoldsBase.project-Tuple{DeterminantOneMatrices, Any}","page":"Determinant one matrices","title":"ManifoldsBase.project","text":"project(G::DeterminantOneMatrices, p)\nproject!(G::DeterminantOneMatrices, q, p)\n\nProject p  mathrmGL(n 𝔽) to the DeterminantOneMatrices using the singular value decomposition of p = U S V^mathrmH.\n\nThe formula for the projection is\n\noperatornameproj(p) = U S D V^mathrmH\n\nwhere\n\nD_ij = δ_ij begincases\n    1             text if  i  n \n    det(p)^-1  text if  i = n\nendcases\n\nThe operation can be done in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/heisenberg/#Heisenberg-matrices","page":"Heisenberg matrices","title":"Heisenberg matrices","text":"","category":"section"},{"location":"manifolds/heisenberg/#Manifolds.HeisenbergMatrices","page":"Heisenberg matrices","title":"Manifolds.HeisenbergMatrices","text":"HeisenbergMatrices{T} <: AbstractDecoratorManifold{𝔽}\n\nHeisenberg matrices HeisenbergMatrices(n) is the manifold of (n+2)(n+2) matrices [BP08]\n\nbeginbmatrix 1  mathbfa  c \nmathbf0_n  I_n  mathbfb \n0  mathbf0_n^mathrmT  1 endbmatrix\n\nwhere I_n is the nn unit matrix, mathbfa is a row vector of length n, mathbfb is a column vector of length n, mathbf0_n is the column zero vector of length n, and c is a real number.\n\nIt is a submanifold of Euclidean(n+2, n+2).\n\nConstructor\n\nHeisenbergMatrices(n::Int; parameter::Symbol=:type)\n\nGenerate the manifold of (n+2)(n+2) Heisenberg matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/heisenberg/#Base.rand-Tuple{HeisenbergMatrices}","page":"Heisenberg matrices","title":"Base.rand","text":"Random.rand(M::HeisenbergMatrices; vector_at = nothing, σ::Real=1.0)\n\nIf vector_at is nothing, return a random point on the HeisenbergMatrices M by sampling elements of the first row and the last column from the normal distribution with mean 0 and standard deviation σ.\n\nIf vector_at is not nothing, return a random tangent vector from the tangent space of the point vector_at on the HeisenbergMatrices by using a normal distribution with mean 0 and standard deviation σ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/heisenberg/#ManifoldsBase.Weingarten-Tuple{HeisenbergMatrices, Any, Any, Any}","page":"Heisenberg matrices","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::HeisenbergMatrices, p, X, V)\nWeingarten!(M::HeisenbergMatrices, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the HeisenbergMatrices M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/heisenberg/#ManifoldsBase.get_coordinates-Tuple{HeisenbergMatrices, Any, Any, DefaultOrthonormalBasis{ℝ, TangentSpaceType}}","page":"Heisenberg matrices","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::HeisenbergMatrices, p, X, ::DefaultOrthonormalBasis{ℝ,TangentSpaceType})\n\nGet coordinates of tangent vector X at point p from the HeisenbergMatrices M. Given a matrix\n\nbeginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\nthe coordinates are concatenated vectors mathbfa, mathbfb, and number c.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/heisenberg/#ManifoldsBase.get_vector-Tuple{HeisenbergMatrices, Any, Any, DefaultOrthonormalBasis{ℝ, TangentSpaceType}}","page":"Heisenberg matrices","title":"ManifoldsBase.get_vector","text":"get_vector(M::HeisenbergMatrices, p, Xⁱ, ::DefaultOrthonormalBasis{ℝ,TangentSpaceType})\n\nGet tangent vector with coordinates Xⁱ at point p from the HeisenbergMatrices M. Given a vector of coordinates beginbmatrixmathbba  mathbbb  cendbmatrix the tangent vector is equal to\n\nbeginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/heisenberg/#ManifoldsBase.is_flat-Tuple{HeisenbergMatrices}","page":"Heisenberg matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::HeisenbergMatrices)\n\nReturn true. HeisenbergMatrices is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/heisenberg/#ManifoldsBase.manifold_dimension-Tuple{HeisenbergMatrices}","page":"Heisenberg matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::HeisenbergMatrices)\n\nReturn the dimension of HeisenbergMatrices(n), which is equal to 2n+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#(Real)-Symplectic-Grassmann","page":"Symplectic Grassmann","title":"(Real) Symplectic Grassmann","text":"","category":"section"},{"location":"manifolds/symplecticgrassmann/#Manifolds.SymplecticGrassmann","page":"Symplectic Grassmann","title":"Manifolds.SymplecticGrassmann","text":"SymplecticGrassmann{𝔽, T} <: AbstractEmbeddedManifold{𝔽, DefaultIsometricEmbeddingType}\n\nThe symplectic Grassmann manifold consists of all symplectic subspaces of ℝ^2n of dimension 2k, n  k.\n\nPoints on this manifold can be represented as corresponding representers on the SymplecticStiefel\n\noperatornameSpGr(2n2k) = bigl operatornamespan(p) big  p  operatornameSpSt(2n 2k ℝ)\n\nor as projectors\n\noperatornameSpGr(2n 2k ℝ) = bigl p  ℝ^2n2n  big  p^2 = p operatornamerank(p) = 2k p^+=p bigr\n\nwhere ^+ is the symplectic_inverse. See also ProjectorPoint and StiefelPoint for these two representations, where arrays are interpreted as those on the Stiefel manifold.\n\nWith respect to the quotient structure, the canonical projection π = π_mathrmSpStmathrmSpGr is given by\n\nπ mathrmSpSt(2n2k)  mathrmSpGr(2n2k) p  π(p) = pp^+\n\nThe tangent space is either the tangent space from the symplectic Stiefel manifold, where tangent vectors are representers of their corresponding congruence classes, or for the representation as projectors, using a ProjectorTangentVector as\n\n  T_poperatornameSpGr(2n 2k ℝ) =\n  bigl Xp  mid X  mathfraksp(2nℝ) Xp+pX = X bigr\n\nwhere Xp = Xp-pX denotes the matrix commutator and mathfraksp(2nℝ) is the Lie algebra of the symplectic group consisting of HamiltonianMatrices.\n\nThe first representation is in StiefelPoints and StiefelTangentVectors, which both represent their symplectic Grassmann equivalence class. Arrays are interpreted in this representation as well\n\nFor the representation in ProjectorPoint and ProjectorTangentVectors, we use the representation from the surjective submersion\n\nρ mathrmSpSt(2n2k)  mathrmSpGr(2n2k)\nqquad\nρ(p) = pp^+\n\nand its differential\n\nmathrmdρ(pX) = Xp^+ + pX^+\n\nrespectively. The manifold was first introduced in [BZ21]\n\nConstructor\n\nSymplecticGrassmann(2n::Int, 2k::Int, field::AbstractNumbers=ℝ; parameter::Symbol=:type)\n\nGenerate the (real-valued) symplectic Grassmann manifold. of  2k dimensional symplectic subspace of ℝ^2n. Note that both dimensions passed to this constructor have to be even.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.manifold_dimension-Tuple{SymplecticGrassmann{ℝ}}","page":"Symplectic Grassmann","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(::SymplecticGrassmann)\n\nReturn the dimension of the SymplecticGrassmann(2n,2k), which is\n\noperatornamedimoperatornameSpGr(2n 2k) = 4(n-k)k\n\nsee [BZ21], Section 4.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#The-(default)-symplectic-Stiefel-representation","page":"Symplectic Grassmann","title":"The (default) symplectic Stiefel representation","text":"","category":"section"},{"location":"manifolds/symplecticgrassmann/#Base.exp-Tuple{SymplecticGrassmann, Any, Any}","page":"Symplectic Grassmann","title":"Base.exp","text":"exp(::SymplecticGrassmann, p, X)\nexp!(M::SymplecticGrassmann, q, p, X)\n\nCompute the exponential mapping\n\n  expcolon TmathrmSpGr(2n 2k)  mathrmSpGr(2n 2k)\n\nwhen representing points and tangent vectors as symplectic bases and their tangents, i.e. on the SymplecticStiefel manifold. Then we can just pass this on to exp(::SymplecticStiefel, p, X).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#ManifoldDiff.riemannian_gradient-Tuple{SymplecticGrassmann, Any, Any}","page":"Symplectic Grassmann","title":"ManifoldDiff.riemannian_gradient","text":"riemannian_gradient(M::SymplecticGrassmann, p, Y)\n\nGiven a gradient Y = operatornamegrad tilde f(p) in the embedding ℝ^2n2k or at least around the SymplecticGrassmann M where p (the embedding of) a point on M, and the restriction tilde f to the SymplecticStiefel be invariant for the equivalence classes. In other words f(p) = f(qp) for q in mathrmSp(2k ℝ), where mathrmSp(2k ℝ) denotes the SymplecticMatrices manifold. Then the Riemannian gradient X = operatornamegrad f(p) is given by\n\n  X = J_2n^THJ_2kp^mathrmTp - J_2n^TpJ_2kH^mathrmTp\n\nwhere J_2n denotes the SymplecticElement, and H = (I_2n - pp^+)J_2n^mathrmTYJ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.check_point-Tuple{SymplecticGrassmann, Any}","page":"Symplectic Grassmann","title":"ManifoldsBase.check_point","text":"check_point(M::SymplecticGrassmann, p; kwargs...)\n\nCheck whether p is a valid point on the SymplecticGrassmann, operatornameSpGr(2n 2k) manifold by verifying that it is a valid representer of an equivalence class of the corersponding SymplecticStiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.check_vector-Tuple{SymplecticGrassmann, Any, Any}","page":"Symplectic Grassmann","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymplecticGrassmann, p, X; kwargs...)\n\nCheck whether X is a valid tangent vector at p on the SymplecticGrassmann, operatornameSpGr(2n 2k) manifold by verifying that it is a valid representer of an equivalence class of the corersponding SymplecticStiefel manifolds tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.inner-Tuple{SymplecticGrassmann, Any, Any, Any}","page":"Symplectic Grassmann","title":"ManifoldsBase.inner","text":"inner(::SymplecticGrassmann, p, X, Y)\n\nCompute the Riemannian inner product g^mathrmSpGr_p(XY) on the SymplecticGrassmann manifold \\mathrm{SpGr}`.\n\nFor the case where p is represented by a point on the SymplecticStiefel manifold acting as a representant of its equivalence class p in mathrmSpGr and the tangent vectors XY in mathrmHor_p^πoperatornameSpSt(2n2k) are horizontal tangent vectors.\n\nThen the inner product reads according to Proposition Lemma 4.8 [BZ21].\n\ng^mathrmSpGr_p(XY) = operatornametrbigl(\n        (p^mathrmTp)^-1X^mathrmT(I_2n - pp^+)Y\n    bigr)\n\nwhere I_2n denotes the identity matrix and ()^+ the symplectic_inverse.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.inverse_retract-Tuple{SymplecticGrassmann, Any, Any, CayleyInverseRetraction}","page":"Symplectic Grassmann","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(::SymplecticGrassmann, p, q, ::CayleyInverseRetraction)\ninverse_retract!(::SymplecticGrassmann, X, p, q, ::CayleyInverseRetraction)\n\nCompute the Cayley Inverse Retraction on the Symplectic Grassmann manifold, when the points are represented as symplectic bases, i.e. on the SymplecticStiefel.\n\nHere we can directly employ the CaleyInverseRetraction on the symplectic Stiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.retract-Tuple{SymplecticGrassmann, Any, Any, CayleyRetraction}","page":"Symplectic Grassmann","title":"ManifoldsBase.retract","text":"retract(::SymplecticGrassmann, p, X, ::CayleyRetraction)\nretract!(::SymplecticGrassmann, q, p, X, ::CayleyRetraction)\n\nCompute the Cayley retraction on the Symplectic Grassmann manifold, when the points are represented as symplectic bases, i.e. on the SymplecticStiefel.\n\nHere we can directly employ the CaleyRetraction on the symplectic Stiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#The-symplectic-projector-representation","page":"Symplectic Grassmann","title":"The symplectic projector representation","text":"","category":"section"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.check_point-Tuple{SymplecticGrassmann, ProjectorPoint}","page":"Symplectic Grassmann","title":"ManifoldsBase.check_point","text":"check_point(M::SymplecticGrassmann, p::ProjectorPoint; kwargs...)\n\nCheck whether p is a valid point on the SymplecticGrassmann, operatornameSpGr(2n 2k), that is a proper symplectic projection:\n\np^2 = p, that is p is a projection\noperatornamerank(p) = 2k, that is, the supspace projected onto is of right dimension\np^+ = p the projection is symplectic.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#ManifoldsBase.check_vector-Tuple{SymplecticGrassmann, ProjectorPoint, ProjectorTangentVector}","page":"Symplectic Grassmann","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymplecticGrassmann, p::ProjectorPoint, X::ProjectorTangentVector; kwargs...)\n\nCheck whether X is a valid tangent vector at p on the SymplecticGrassmann, operatornameSpGr(2n 2k) manifold by verifying that it\n\nX^+ = X\nX = Xp + pX\n\nFor details see Proposition 4.2 in [BZ21] and the definition of mathfraksp_P(2n) before, especially the barΩ, which is the representation for X used here.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticgrassmann/#Literature","page":"Symplectic Grassmann","title":"Literature","text":"","category":"section"},{"location":"manifolds/symplecticgrassmann/","page":"Symplectic Grassmann","title":"Symplectic Grassmann","text":"T. Bendokat and R. Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv Preprint, 2108.12447 (2021), arXiv:2108.12447.\n\n\n\n","category":"page"},{"location":"manifolds/graph/#Graph-manifold","page":"Graph manifold","title":"Graph manifold","text":"","category":"section"},{"location":"manifolds/graph/","page":"Graph manifold","title":"Graph manifold","text":"For a given graph G(VE) implemented using Graphs.jl, the GraphManifold models a PowerManifold either on the nodes or edges of the graph, depending on the GraphManifoldType. i.e., it's either a mathcal M^lvert V rvert for the case of a vertex manifold or a mathcal M^lvert E rvert for the case of a edge manifold.","category":"page"},{"location":"manifolds/graph/#Example","page":"Graph manifold","title":"Example","text":"","category":"section"},{"location":"manifolds/graph/","page":"Graph manifold","title":"Graph manifold","text":"To make a graph manifold over ℝ^2 with three vertices and two edges, one can use","category":"page"},{"location":"manifolds/graph/","page":"Graph manifold","title":"Graph manifold","text":"using Manifolds\nusing Graphs\nM = Euclidean(2)\np = [[1., 4.], [2., 5.], [3., 6.]]\nq = [[4., 5.], [6., 7.], [8., 9.]]\nx = [[6., 5.], [4., 3.], [2., 8.]]\nG = SimpleGraph(3)\nadd_edge!(G, 1, 2)\nadd_edge!(G, 2, 3)\nN = GraphManifold(G, M, VertexManifold())","category":"page"},{"location":"manifolds/graph/","page":"Graph manifold","title":"Graph manifold","text":"It supports all AbstractPowerManifold  operations (it is based on NestedPowerRepresentation) and furthermore it is possible to compute a graph logarithm:","category":"page"},{"location":"manifolds/graph/","page":"Graph manifold","title":"Graph manifold","text":"incident_log(N, p)","category":"page"},{"location":"manifolds/graph/#Types-and-functions","page":"Graph manifold","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/graph/#Manifolds.EdgeManifold","page":"Graph manifold","title":"Manifolds.EdgeManifold","text":"EdgeManifoldManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the edges.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph/#Manifolds.GraphManifold","page":"Graph manifold","title":"Manifolds.GraphManifold","text":"GraphManifold{𝔽, G, M, T} <: AbstractPowerManifold{𝔽,M,NestedPowerRepresentation}\n\nBuild a manifold, that is a PowerManifold of the AbstractManifold  M either on the edges or vertices of a graph G depending on the GraphManifoldType T.\n\nFields\n\nG is an AbstractSimpleGraph\nM is a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph/#Manifolds.GraphManifoldType","page":"Graph manifold","title":"Manifolds.GraphManifoldType","text":"GraphManifoldType\n\nThis type represents the type of data on the graph that the GraphManifold represents.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph/#Manifolds.VertexManifold","page":"Graph manifold","title":"Manifolds.VertexManifold","text":"VectexGraphManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the vertices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph/#Manifolds.incident_log-Tuple{GraphManifold{𝔽, <:Graphs.AbstractGraph, <:AbstractManifold{𝔽}, VertexManifold} where 𝔽, Any}","page":"Graph manifold","title":"Manifolds.incident_log","text":"incident_log(M::GraphManifold, x)\n\nReturn the tangent vector on the (vertex) GraphManifold, where at each node the sum of the logs to incident nodes is computed. For a SimpleGraph, an egde is interpreted as double edge in the corresponding SimpleDiGraph\n\nIf the internal graph is a SimpleWeightedGraph the weighted sum of the tangent vectors is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph/#ManifoldsBase.check_point-Tuple{GraphManifold, Vararg{Any}}","page":"Graph manifold","title":"ManifoldsBase.check_point","text":"check_point(M::GraphManifold, p)\n\nCheck whether p is a valid point on the GraphManifold, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of p passes the check_point test for the base manifold M.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph/#ManifoldsBase.check_vector-Tuple{GraphManifold, Vararg{Any}}","page":"Graph manifold","title":"ManifoldsBase.check_vector","text":"check_vector(M::GraphManifold, p, X; kwargs...)\n\nCheck whether p is a valid point on the GraphManifold, and X it from its tangent space, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of X together with its corresponding entry of p passes the check_vector test for the base manifold M.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph/#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{𝔽, <:Graphs.AbstractGraph, <:AbstractManifold{𝔽}, EdgeManifold} where 𝔽}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,𝔽,M,EdgeManifold})\n\nreturns the manifold dimension of the GraphManifold N on the edges of a graph G=(VE), i.e.\n\ndim(mathcal N) = lvert E rvert dim(mathcal M)\n\nwhere mathcal M is the manifold of the data on the edges.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph/#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{𝔽, <:Graphs.AbstractGraph, <:AbstractManifold{𝔽}, VertexManifold} where 𝔽}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,𝔽,M,VertexManifold})\n\nreturns the manifold dimension of the GraphManifold N on the vertices of a graph G=(VE), i.e.\n\ndim(mathcal N) = lvert V rvert dim(mathcal M)\n\nwhere mathcal M is the manifold of the data on the nodes.\n\n\n\n\n\n","category":"method"},{"location":"features/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"features/integration/#Manifolds.manifold_volume-Tuple{AbstractManifold}","page":"Integration","title":"Manifolds.manifold_volume","text":"manifold_volume(M::AbstractManifold)\n\nVolume of manifold M defined through integration of Riemannian volume element in a chart. Note that for many manifolds there is no universal agreement over the exact ranges over which the integration should happen. For details see [BST03].\n\n\n\n\n\n","category":"method"},{"location":"features/integration/#Manifolds.volume_density-Tuple{AbstractManifold, Any, Any}","page":"Integration","title":"Manifolds.volume_density","text":"volume_density(M::AbstractManifold, p, X)\n\nVolume density function of manifold M, i.e. determinant of the differential of exponential map exp(M, p, X). Determinant can be understood as computed in a basis, from the matrix of the linear operator said differential corresponds to. Details are available in Section 4.1 of [CLLD22].\n\nNote that volume density is well-defined only for X for which exp(M, p, X) is injective.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#EuclideanSection","page":"Euclidean","title":"Euclidean space","text":"","category":"section"},{"location":"manifolds/euclidean/","page":"Euclidean","title":"Euclidean","text":"The Euclidean space ℝ^n is a simple model space, since it has curvature constantly zero everywhere; hence, nearly all operations simplify. The easiest way to generate an Euclidean space is to use a field, i.e. AbstractNumbers, e.g. to create the ℝ^n or ℝ^nn you can simply type M = ℝ^n or ℝ^(n,n), respectively.","category":"page"},{"location":"manifolds/euclidean/#Manifolds.Euclidean","page":"Euclidean","title":"Manifolds.Euclidean","text":"Euclidean{T,𝔽} <: AbstractManifold{𝔽}\n\nEuclidean vector space.\n\nConstructor\n\nEuclidean(n)\n\nGenerate the n-dimensional vector space ℝ^n.\n\nEuclidean(n₁,n₂,...,nᵢ; field=ℝ, parameter::Symbol = :field)\n𝔽^(n₁,n₂,...,nᵢ) = Euclidean(n₁,n₂,...,nᵢ; field=𝔽)\n\nGenerate the vector space of k = n_1  n_2    n_i values, i.e. the manifold 𝔽^n_1 n_2  n_i, 𝔽inℝℂ, whose elements are interpreted as n_1  n_2    n_i arrays. For i=2 we obtain a matrix space. The default field=ℝ can also be set to field=ℂ. The dimension of this space is k dim_ℝ 𝔽, where dim_ℝ 𝔽 is the real_dimension of the field 𝔽.\n\nparameter: whether a type parameter should be used to store n. By default size is stored in type. Value can either be :field or :type.\n\nEuclidean(; field=ℝ)\n\nGenerate the 1D Euclidean manifold for an ℝ-, ℂ-valued  real- or complex-valued immutable values (in contrast to 1-element arrays from the constructor above).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/euclidean/#Base.exp-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"Base.exp","text":"exp(M::Euclidean, p, X)\n\nCompute the exponential map on the Euclidean manifold M from p in direction X, which in this case is just\n\nexp_p X = p + X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Base.log-Tuple{Euclidean, Vararg{Any}}","page":"Euclidean","title":"Base.log","text":"log(M::Euclidean, p, q)\n\nCompute the logarithmic map on the Euclidean M from p to q, which in this case is just\n\nlog_p q = q-p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#LinearAlgebra.norm","page":"Euclidean","title":"LinearAlgebra.norm","text":"norm(M::Euclidean, p, X, r::Real=2)\n\nCompute the norm of a tangent vector X at p on the Euclidean M, i.e. since every tangent space can be identified with M itself in this case, just the (Frobenius) norm of X. Specifying r, other norms are available as well\n\n\n\n\n\n","category":"function"},{"location":"manifolds/euclidean/#Manifolds.manifold_volume-Tuple{Euclidean}","page":"Euclidean","title":"Manifolds.manifold_volume","text":"manifold_volume(::Euclidean)\n\nReturn volume of the Euclidean manifold, i.e. infinity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manifolds.volume_density-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"Manifolds.volume_density","text":"volume_density(M::Euclidean, p, X)\n\nReturn volume density function of Euclidean manifold M, i.e. 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.Weingarten-Tuple{Euclidean, Any, Any, Any}","page":"Euclidean","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::Euclidean, p, X, V)\nWeingarten!(M::Euclidean, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the Euclidean M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.distance-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"ManifoldsBase.distance","text":"distance(M::Euclidean, p, q, r::Real=2)\n\nCompute the Euclidean distance between two points on the Euclidean manifold M, i.e. for vectors it's just the norm of the difference, for matrices and higher order arrays, the matrix and tensor Frobenius norm, respectively. Specifying further an r≠2, other norms, like the 1-norm or the ∞-norm can also be computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.embed-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"ManifoldsBase.embed","text":"embed(M::Euclidean, p, X)\n\nEmbed the tangent vector X at point p in M. Equivalent to an identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.embed-Tuple{Euclidean, Any}","page":"Euclidean","title":"ManifoldsBase.embed","text":"embed(M::Euclidean, p)\n\nEmbed the point p in M. Equivalent to an identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.injectivity_radius-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Euclidean)\n\nReturn the injectivity radius on the Euclidean M, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.inner-Tuple{Euclidean, Vararg{Any}}","page":"Euclidean","title":"ManifoldsBase.inner","text":"inner(M::Euclidean, p, X, Y)\n\nCompute the inner product on the Euclidean M, which is just the inner product on the real-valued or complex valued vector space of arrays (or tensors) of size n_1  n_2       n_i, i.e.\n\ng_p(XY) = sum_k  I overlineX_k Y_k\n\nwhere I is the set of vectors k  ℕ^i, such that for all\n\ni  j  i it holds 1  k_j  n_j and overline denotes the complex conjugate.\n\nFor the special case of i  2, i.e. matrices and vectors, this simplifies to\n\ng_p(XY) = operatornametr(X^mathrmHY)\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.is_flat-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.is_flat","text":"is_flat(::Euclidean)\n\nReturn true. Euclidean is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.manifold_dimension-Union{Tuple{Euclidean{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Euclidean","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Euclidean)\n\nReturn the manifold dimension of the Euclidean M, i.e. the product of all array dimensions and the real_dimension of the underlying number system.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.parallel_transport_direction-Tuple{Euclidean, Any, Any, Any}","page":"Euclidean","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::Euclidean, p, X, d)\n\nthe parallel transport on Euclidean is the identity, i.e. returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.parallel_transport_to-Tuple{Euclidean, Any, Any, Any}","page":"Euclidean","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Euclidean, p, X, q)\n\nthe parallel transport on Euclidean is the identity, i.e. returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.project-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"ManifoldsBase.project","text":"project(M::Euclidean, p, X)\n\nProject an arbitrary vector X into the tangent space of a point p on the Euclidean M, which is just the identity, since any tangent space of M can be identified with all of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.project-Tuple{Euclidean, Any}","page":"Euclidean","title":"ManifoldsBase.project","text":"project(M::Euclidean, p)\n\nProject an arbitrary point p onto the Euclidean manifold M, which is of course just the identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.representation_size-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.representation_size","text":"representation_size(M::Euclidean)\n\nReturn the array dimensions required to represent an element on the Euclidean M, i.e. the vector of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.riemann_tensor-Tuple{Euclidean, Vararg{Any, 4}}","page":"Euclidean","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::Euclidean, p, X, Y, Z)\n\nCompute the Riemann tensor R(XY)Z at point p on Euclidean manifold M. Its value is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.sectional_curvature-Tuple{Euclidean, Any, Any, Any}","page":"Euclidean","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(::Euclidean, p, X, Y)\n\nSectional curvature of Euclidean manifold M is 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.sectional_curvature_max-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(::Euclidean)\n\nSectional curvature of Euclidean manifold M is 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.sectional_curvature_min-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::Euclidean)\n\nSectional curvature of Euclidean manifold M is 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.vector_transport_to-Tuple{Euclidean, Any, Any, Any, AbstractVectorTransportMethod}","page":"Euclidean","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Euclidean, p, X, q, ::AbstractVectorTransportMethod)\n\nTransport the vector X from the tangent space at p to the tangent space at q on the Euclidean M, which simplifies to the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#ManifoldsBase.zero_vector-Tuple{Euclidean, Vararg{Any}}","page":"Euclidean","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Euclidean, p)\n\nReturn the zero vector in the tangent space of p on the Euclidean M, which here is just a zero filled array the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#Multinomial-symmetric-matrices","page":"Multinomial symmetric matrices","title":"Multinomial symmetric matrices","text":"","category":"section"},{"location":"manifolds/multinomialsymmetric/#Manifolds.MultinomialSymmetric","page":"Multinomial symmetric matrices","title":"Manifolds.MultinomialSymmetric","text":"MultinomialSymmetric{T} <: AbstractMultinomialDoublyStochastic\n\nThe multinomial symmetric matrices manifold consists of all symmetric nn matrices with positive entries such that each column sums to one, i.e.\n\nbeginaligned\nmathcalSP(n) coloneqq biglp  ℝ^nn big p_ij  0 text for all  i=1n j=1m\n p^mathrmT = p\n pmathbf1_n = mathbf1_n\nbigr\nendaligned\n\nwhere mathbf1_n is the vector of length n containing ones.\n\nIt is modeled as IsometricallyEmbeddedManifoldType. via the AbstractMultinomialDoublyStochastic type, since it shares a few functions also with AbstractMultinomialDoublyStochastic, most and foremost projection of a point from the embedding onto the manifold.\n\nThe tangent space can be written as\n\nT_pmathcalSP(n) coloneqq bigl\nX  ℝ^nn big X = X^mathrmT text and \nXmathbf1_n = mathbf0_n\nbigr\n\nwhere mathbf0_n is the vector of length n containing zeros.\n\nMore details can be found in Section IV [DH19].\n\nConstructor\n\nMultinomialSymmetric(n)\n\nGenerate the manifold of matrices ℝ^nn that are doubly stochastic and symmetric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialsymmetric/#Base.rand-Tuple{MultinomialSymmetric}","page":"Multinomial symmetric matrices","title":"Base.rand","text":"rand(::MultinomialSymmetric; vector_at=nothing, σ::Real=1.0, kwargs...)\n\nGenerate random points on the MultinomialSymmetric manifold or tangent vectors at the point vector_at if that is not nothing.\n\nLet nn denote the matrix dimension of the MultinomialSymmetric.\n\nWhen vector_at is nothing, this is done by generating a random matrix rand(n, n) with positive entries and projecting it onto the manifold. The kwargs... are passed to this projection.\n\nWhen vector_at is not nothing, a random matrix in the ambient space is generated and projected onto the tangent space\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#ManifoldDiff.riemannian_Hessian-Tuple{MultinomialSymmetric, Vararg{Any, 4}}","page":"Multinomial symmetric matrices","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::MultinomialSymmetric, p, G, H, X)\nriemannian_Hessian!(M::MultinomialSymmetric, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nThe Riemannian Hessian can be computed as stated in Corollary 3 [DH19].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#ManifoldsBase.check_point-Tuple{MultinomialSymmetric, Any}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.check_point","text":"check_point(M::MultinomialSymmetric, p)\n\nChecks whether p is a valid point on the MultinomialSymmetric(m,n) M, i.e. is a symmetric matrix with positive entries whose rows sum to one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#ManifoldsBase.check_vector-Tuple{MultinomialSymmetric, Any, Any}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::MultinomialSymmetric p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialSymmetric M. This means, that p is valid, that X is of correct dimension, symmetric, and sums to zero along any row.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#ManifoldsBase.is_flat-Tuple{MultinomialSymmetric}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::MultinomialSymmetric)\n\nReturn false. MultinomialSymmetric is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#ManifoldsBase.manifold_dimension-Tuple{MultinomialSymmetric}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::MultinomialSymmetric)\n\nreturns the dimension of the MultinomialSymmetric manifold namely\n\noperatornamedim_mathcalSP(n) = fracn(n-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#ManifoldsBase.project-Tuple{MultinomialSymmetric, Any, Any}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.project","text":"project(M::MultinomialSymmetric, p, Y)\n\nProject Y onto the tangent space at p on the MultinomialSymmetric M, return the result in X.\n\nThe formula from [DH19], Sec. VI reads\n\n    operatornameproj_p(Y) = Y - (αmathbf1_n^mathrmT + mathbf1_n α^mathrmT)  p\n\nwhere  denotes the Hadamard or elementwise product and mathbb1_n is the vector of length n containing ones. The two vector α  ℝ^nn is given by solving\n\n    (I_n+p)α =  Ymathbf1\n\nwhere I_n is teh nn unit matrix and mathbf1_n is the vector of length n containing ones.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#ManifoldsBase.retract-Tuple{MultinomialSymmetric, Any, Any, ProjectionRetraction}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.retract","text":"retract(M::MultinomialSymmetric, p, X, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting pexp(Xp) back onto the manifold, where  are elementwise multiplication and division, respectively. Similarly, exp refers to the elementwise exponentiation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric/#Literature","page":"Multinomial symmetric matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/multinomialsymmetric/","page":"Multinomial symmetric matrices","title":"Multinomial symmetric matrices","text":"A. Douik and B. Hassibi. Manifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry. IEEE Transactions on Signal Processing 67, 5761–5774 (2019), arXiv:1802.02628.\n\n\n\n","category":"page"},{"location":"manifolds/centeredmatrices/#Centered-matrices","page":"Centered matrices","title":"Centered matrices","text":"","category":"section"},{"location":"manifolds/centeredmatrices/#Manifolds.CenteredMatrices","page":"Centered matrices","title":"Manifolds.CenteredMatrices","text":"CenteredMatrices{𝔽,T} <: AbstractDecoratorManifold{𝔽}\n\nThe manifold of mn real-valued or complex-valued matrices whose columns sum to zero, i.e.\n\nbigl p  𝔽^mn big 1  1 * p = 0  0 bigr\n\nwhere 𝔽  ℝℂ.\n\nConstructor\n\nCenteredMatrices(m, n[, field=ℝ]; parameter::Symbol=:type)\n\nGenerate the manifold of m-by-n (field-valued) matrices whose columns sum to zero.\n\nparameter: whether a type parameter should be used to store m and n. By default size is stored in type. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/centeredmatrices/#ManifoldsBase.Weingarten-Tuple{CenteredMatrices, Any, Any, Any}","page":"Centered matrices","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::CenteredMatrices, p, X, V)\nWeingarten!(M::CenteredMatrices, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the CenteredMatrices M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices/#ManifoldsBase.check_point-Union{Tuple{T}, Tuple{CenteredMatrices, T}} where T","page":"Centered matrices","title":"ManifoldsBase.check_point","text":"check_point(M::CenteredMatrices, p; kwargs...)\n\nCheck whether the matrix is a valid point on the CenteredMatrices M, i.e. is an m-by-n matrix whose columns sum to zero.\n\nThe tolerance for the column sums of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{CenteredMatrices, Any, T}} where T","page":"Centered matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::CenteredMatrices, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the CenteredMatrices M, i.e. that X is a matrix of size (m, n) whose columns sum to zero and its values are from the correct AbstractNumbers. The tolerance for the column sums of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices/#ManifoldsBase.is_flat-Tuple{CenteredMatrices}","page":"Centered matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::CenteredMatrices)\n\nReturn true. CenteredMatrices is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices/#ManifoldsBase.manifold_dimension-Union{Tuple{CenteredMatrices{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Centered matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::CenteredMatrices)\n\nReturn the manifold dimension of the CenteredMatrices m-by-n matrix M over the number system 𝔽, i.e.\n\ndim(mathcal M) = (m*n - n) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices/#ManifoldsBase.project-Tuple{CenteredMatrices, Any, Any}","page":"Centered matrices","title":"ManifoldsBase.project","text":"project(M::CenteredMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the CenteredMatrices M, i.e.\n\noperatornameproj_p(X) = X - beginbmatrix\n1\n\n1\nendbmatrix * c_1 dots c_n\n\nwhere c_i = frac1msum_j=1^m x_ji  for i = 1 dots n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices/#ManifoldsBase.project-Tuple{CenteredMatrices, Any}","page":"Centered matrices","title":"ManifoldsBase.project","text":"project(M::CenteredMatrices, p)\n\nProjects p from the embedding onto the CenteredMatrices M, i.e.\n\noperatornameproj_mathcal M(p) = p - beginbmatrix\n1\n\n1\nendbmatrix * c_1 dots c_n\n\nwhere c_i = frac1msum_j=1^m p_ji for i = 1 dots n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#HyperrectangleSection","page":"Hyperrectangle","title":"Hyperrectangle","text":"","category":"section"},{"location":"manifolds/hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Hyperrectangle is a manifold with corners [Joy10], and also a subset of the real Euclidean manifold. It is useful for box-constrained optimization, for example it is implicitly used in the classic L-BFGS-B algorithm.","category":"page"},{"location":"manifolds/hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"note: Note\nThis is a manifold with corners. Some parts of its interface specific to this property are experimental and may change without a breaking release.","category":"page"},{"location":"manifolds/hyperrectangle/#Manifolds.Hyperrectangle","page":"Hyperrectangle","title":"Manifolds.Hyperrectangle","text":"Hyperrectangle{T} <: AbstractManifold{ℝ}\n\nHyperrectangle, also known as orthotope or box. This is a manifold with corners [Joy10] with the standard Euclidean metric.\n\nConstructor\n\nHyperrectangle(lb::AbstractArray, ub::AbstractArray)\n\nGenerate the hyperrectangle of arrays such that each element of the array is between lower and upper bound with the same index.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperrectangle/#Base.exp-Tuple{Hyperrectangle, Any, Any}","page":"Hyperrectangle","title":"Base.exp","text":"exp(M::Hyperrectangle, p, X)\n\nCompute the exponential map on the Hyperrectangle manifold M from p in direction X, which in this case is just\n\nexp_p X = p + X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#Base.log-Tuple{Hyperrectangle, Vararg{Any}}","page":"Hyperrectangle","title":"Base.log","text":"log(M::Hyperrectangle, p, q)\n\nCompute the logarithmic map on the Hyperrectangle M from p to q, which in this case is just\n\nlog_p q = q-p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#LinearAlgebra.norm-Tuple{Hyperrectangle, Any, Any}","page":"Hyperrectangle","title":"LinearAlgebra.norm","text":"norm(M::Hyperrectangle, p, X)\n\nCompute the norm of a tangent vector X at p on the Hyperrectangle M, i.e. since every tangent space can be identified with M itself in this case, just the (Frobenius) norm of X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#Manifolds.manifold_volume-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"Manifolds.manifold_volume","text":"manifold_volume(::Hyperrectangle)\n\nReturn volume of the Hyperrectangle manifold, i.e. infinity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#Manifolds.volume_density-Tuple{Hyperrectangle, Any, Any}","page":"Hyperrectangle","title":"Manifolds.volume_density","text":"volume_density(M::Hyperrectangle, p, X)\n\nReturn volume density function of Hyperrectangle manifold M, i.e. 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.Weingarten-Tuple{Hyperrectangle, Any, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::Hyperrectangle, p, X, V)\nWeingarten!(M::Hyperrectangle, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the Hyperrectangle M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.default_retraction_method-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::Hyperrectangle)\n\nReturn ProjectionRetraction as the default retraction for the Hyperrectangle manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.distance-Tuple{Hyperrectangle, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.distance","text":"distance(M::Hyperrectangle, p, q)\n\nCompute the euclidean distance between two points on the Hyperrectangle manifold M, i.e. for vectors it's just the norm of the difference, for matrices and higher order arrays, the matrix and tensor Frobenius norm, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.embed-Tuple{Hyperrectangle, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.embed","text":"embed(M::Hyperrectangle, p, X)\n\nEmbed the tangent vector X at point p in M. Equivalent to an identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.embed-Tuple{Hyperrectangle, Any}","page":"Hyperrectangle","title":"ManifoldsBase.embed","text":"embed(M::Hyperrectangle, p)\n\nEmbed the point p in M. Equivalent to an identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.injectivity_radius-Tuple{Hyperrectangle, Any}","page":"Hyperrectangle","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Hyperrectangle, p)\n\nReturn the injectivity radius on the Hyperrectangle M at point p, which is the distance to the nearest boundary the point is not on.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.inner-Tuple{Hyperrectangle, Any, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.inner","text":"inner(M::Hyperrectangle, p, X, Y)\n\nCompute the inner product on the Hyperrectangle M, which is just the inner product on the real-valued vector space of arrays (or tensors) of size n_1  n_2       n_i, i.e.\n\ng_p(XY) = sum_k  I X_k Y_k\n\nwhere I is the set of vectors k  ℕ^i, such that for all\n\ni  j  i it holds 1  k_j  n_j.\n\nFor the special case of i  2, i.e. matrices and vectors, this simplifies to\n\ng_p(XY) = operatornametr(X^mathrmTY)\n\nwhere ^mathrmT denotes transposition.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.is_flat-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"ManifoldsBase.is_flat","text":"is_flat(::Hyperrectangle)\n\nReturn true. Hyperrectangle is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.manifold_dimension-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Hyperrectangle)\n\nReturn the manifold dimension of the Hyperrectangle M, i.e. the product of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.parallel_transport_direction-Tuple{Hyperrectangle, Any, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::Hyperrectangle, p, X, d)\n\nthe parallel transport on Hyperrectangle is the identity, i.e. returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.parallel_transport_to-Tuple{Hyperrectangle, Any, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Hyperrectangle, p, X, q)\n\nthe parallel transport on Hyperrectangle is the identity, i.e. returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.project-Tuple{Hyperrectangle, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.project","text":"project(M::Hyperrectangle, p, X)\n\nProject an arbitrary vector X into the tangent space of a point p on the Hyperrectangle M, which is just the identity, since any tangent space of M can be identified with all of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.project-Tuple{Hyperrectangle, Any}","page":"Hyperrectangle","title":"ManifoldsBase.project","text":"project(M::Hyperrectangle, p)\n\nProject an arbitrary point p onto the Hyperrectangle manifold M, which is of course just the identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.representation_size-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"ManifoldsBase.representation_size","text":"representation_size(M::Hyperrectangle)\n\nReturn the array dimensions required to represent an element on the Hyperrectangle M, i.e. the vector of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.riemann_tensor-Tuple{Hyperrectangle, Vararg{Any, 4}}","page":"Hyperrectangle","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::Hyperrectangle, p, X, Y, Z)\n\nCompute the Riemann tensor R(XY)Z at point p on Hyperrectangle manifold M. Its value is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.sectional_curvature-Tuple{Hyperrectangle, Any, Any, Any}","page":"Hyperrectangle","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(::Hyperrectangle, p, X, Y)\n\nSectional curvature of Hyperrectangle manifold M is 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.sectional_curvature_max-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(::Hyperrectangle)\n\nSectional curvature of Hyperrectangle manifold M is 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.sectional_curvature_min-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::Hyperrectangle)\n\nSectional curvature of Hyperrectangle manifold M is 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.vector_transport_to-Tuple{Hyperrectangle, Any, Any, Any, AbstractVectorTransportMethod}","page":"Hyperrectangle","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Hyperrectangle, p, X, q, ::AbstractVectorTransportMethod)\n\nTransport the vector X from the tangent space at p to the tangent space at q on the Hyperrectangle M, which simplifies to the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#ManifoldsBase.zero_vector-Tuple{Hyperrectangle, Vararg{Any}}","page":"Hyperrectangle","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Hyperrectangle, p)\n\nReturn the zero vector in the tangent space of p on the Hyperrectangle M, which here is just a zero filled array the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperrectangle/#Literature","page":"Hyperrectangle","title":"Literature","text":"","category":"section"},{"location":"manifolds/hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"D. Joyce. On manifolds with corners (2010), arXiv:0910.3518.\n\n\n\n","category":"page"},{"location":"manifolds/metric/#Metric-manifold","page":"Metric manifold","title":"Metric manifold","text":"","category":"section"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"A Riemannian manifold always consists of a topological manifold together with a smoothly varying metric tensor g. This metric tensor defines an inner product on each tangent space of the manifold. In Manifolds.jl, a concrete implementation of an AbstractManifold has an implicit metric, which we refer to as the default metric. For example on Euclidean space, this is the usual inner product. For the Sphere, this default metric is the metric induced by the embedding in the ambient Euclidean space, restricted to the tangent spaces of the sphere.","category":"page"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"Such a default metric is usually not the only possible metric on a manifold.","category":"page"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"The MetricManifold decorator allows to introduce further metrics for a manifold by acting as a wrapper. This allows to define further metrics for an existing manifold, while only having to implement functions that depend on the metric. All functions that are independent of the metric are automatically forwarded to the underlying manifold. When wrapping a manifold M with a MetricManifold together with the default metric(M), this wrapper acts completely transparent and passes all function calls to the underlying manifold M.","category":"page"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"Pages = [\"metric.md\"]\nDepth = 2","category":"page"},{"location":"manifolds/metric/#Types","page":"Metric manifold","title":"Types","text":"","category":"section"},{"location":"manifolds/metric/#Manifolds.DefaultMetric","page":"Metric manifold","title":"Manifolds.DefaultMetric","text":"DefaultMetric <: AbstractMetric\n\nIndicating that a manifold uses the default metric, that one has implicitly assumed when defining the manifold\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric/#Manifolds.MetricManifold","page":"Metric manifold","title":"Manifolds.MetricManifold","text":"MetricManifold{𝔽,M<:AbstractManifold{𝔽},G<:AbstractMetric} <: AbstractDecoratorManifold{𝔽}\n\nEquip a AbstractManifold explicitly with an AbstractMetric G.\n\nFor a Metric AbstractManifold, by default, assumes, that you implement the linear form from local_metric in order to evaluate the exponential map.\n\nIf the corresponding AbstractMetric G yields closed form formulae for e.g. the exponential map and this is implemented directly (without solving the ode), you can of course still implement that directly.\n\nConstructor\n\nMetricManifold(M, G)\n\nGenerate the AbstractManifold M as a manifold with the AbstractMetric G.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric/#Implement-Different-Metrics-on-the-same-Manifold","page":"Metric manifold","title":"Implement Different Metrics on the same Manifold","text":"","category":"section"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"In order to distinguish different metrics on one manifold, one can introduce two AbstractMetrics and use this type to dispatch on the metric, see SymmetricPositiveDefinite. To avoid overhead, one AbstractMetric can then be marked as being the default, i.e. the one that is used, when no MetricManifold decorator is present. This avoids reimplementation of the first existing metric, access to the metric-dependent functions that were implemented using the undecorated manifold, as well as the transparent fallback of the corresponding MetricManifold with default metric to the undecorated implementations. This does not cause any runtime overhead. Introducing a default AbstractMetric serves a better readability of the code when working with different metrics.","category":"page"},{"location":"manifolds/metric/#Implementation-of-Metrics","page":"Metric manifold","title":"Implementation of Metrics","text":"","category":"section"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"For the case that a local_metric is implemented as a bilinear form that is positive definite, the following further functions are provided, unless the corresponding AbstractMetric is marked as default – then the fallbacks mentioned in the last section are used for e.g. the exponential map.","category":"page"},{"location":"manifolds/metric/#Base.log-Tuple{MetricManifold, Vararg{Any}}","page":"Metric manifold","title":"Base.log","text":"log(N::MetricManifold{M,G}, p, q)\n\nCompute the logarithmic map on the AbstractManifold M equipped with the AbstractMetric G.\n\nIf the metric was declared the default metric, this method falls back to log(M,p,q). Otherwise, you have to provide an implementation for the non-default AbstractMetric G metric within its MetricManifold{M,G}.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.det_local_metric-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.det_local_metric","text":"det_local_metric(M::AbstractManifold, p, B::AbstractBasis)\n\nReturn the determinant of local matrix representation of the metric tensor g, i.e. of the matrix G(p) representing the metric in the tangent space at p with as a matrix.\n\nSee also local_metric\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.einstein_tensor-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.einstein_tensor","text":"einstein_tensor(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = diff_badefault_differential_backendckend())\n\nCompute the Einstein tensor of the manifold M at the point p, see https://en.wikipedia.org/wiki/Einstein_tensor\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.flat-Tuple{MetricManifold, Any, TFVector}","page":"Metric manifold","title":"Manifolds.flat","text":"flat(N::MetricManifold{M,G}, p, X::TFVector)\n\nCompute the musical isomorphism to transform the tangent vector X from the AbstractManifold M equipped with AbstractMetric G to a cotangent by computing\n\nX^= G_p X\n\nwhere G_p is the local matrix representation of G, see local_metric\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.inverse_local_metric-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.inverse_local_metric","text":"inverse_local_metric(M::AbstractcManifold{𝔽}, p, B::AbstractBasis)\n\nReturn the local matrix representation of the inverse metric (cometric) tensor of the tangent space at p on the AbstractManifold M with respect to the AbstractBasis basis B.\n\nThe metric tensor (see local_metric) is usually denoted by G = (g_ij)  𝔽^dd, where d is the dimension of the manifold.\n\nThen the inverse local metric is denoted by G^-1 = g^ij.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.is_default_metric-Tuple{AbstractManifold, AbstractMetric}","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(M::AbstractManifold, G::AbstractMetric)\n\nreturns whether an AbstractMetric is the default metric on the manifold M or not.\n\nIf M is a |MetricManifold](@ref) this indicates whether the metric now used is the same as the default one on the wrapped manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.local_metric-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.local_metric","text":"local_metric(M::AbstractManifold{𝔽}, p, B::AbstractBasis)\n\nReturn the local matrix representation at the point p of the metric tensor g with respect to the AbstractBasis B on the AbstractManifold M. Let ddenote the dimension of the manifold and b_1ldotsb_d the basis vectors. Then the local matrix representation is a matrix Gin 𝔽^nn whose entries are given by g_ij = g_p(b_ib_j) ijin1d.\n\nThis yields the property for two tangent vectors (using Einstein summation convention) X = X^ib_i Y=Y^ib_i in T_pmathcal M we get g_p(X Y) = g_ij X^i Y^j.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.local_metric_jacobian-Tuple{AbstractManifold, Any, AbstractBasis, Any}","page":"Metric manifold","title":"Manifolds.local_metric_jacobian","text":"local_metric_jacobian(M::AbstractManifold, p, B::AbstractBasis;\nbackend::AbstractDiffBackend,\n\n)\n\nGet partial derivatives of the local metric of M at p in basis B with respect to the coordinates of p, frac p^k g_ij = g_ijk. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.log_local_metric_density-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.log_local_metric_density","text":"log_local_metric_density(M::AbstractManifold, p, B::AbstractBasis)\n\nReturn the natural logarithm of the metric density ρ of M at p, which is given by ρ = log sqrtdet g_ij for the metric tensor expressed in basis B.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.metric-Tuple{AbstractManifold}","page":"Metric manifold","title":"Manifolds.metric","text":"metric(M::MetricManifold)\n\nGet the metric g of the AbstractManifold(M).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.ricci_curvature-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.ricci_curvature","text":"ricci_curvature(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = default_differential_backend())\n\nCompute the Ricci scalar curvature of the manifold M at the point p using basis B. The curvature is computed as the trace of the Ricci curvature tensor with respect to the metric, that is R=g^ijR_ij where R is the scalar Ricci curvature at p, g^ij is the inverse local metric (see inverse_local_metric) at p and R_ij is the Ricci curvature tensor, see ricci_tensor. Both the tensor and inverse local metric are expressed in local coordinates defined by B, and the formula uses the Einstein summation convention.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Manifolds.sharp-Tuple{MetricManifold, Any, CoTFVector}","page":"Metric manifold","title":"Manifolds.sharp","text":"sharp(N::MetricManifold{M,G}, p, ξ::CoTFVector)\n\nCompute the musical isomorphism to transform the cotangent vector ξ from the AbstractManifold M equipped with AbstractMetric G to a tangent by computing\n\nξ^ = G_p^-1 ξ\n\nwhere G_p is the local matrix representation of G, i.e. one employs inverse_local_metric here to obtain G_p^-1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#ManifoldsBase.inner-Tuple{MetricManifold, Any, Any, Any}","page":"Metric manifold","title":"ManifoldsBase.inner","text":"inner(N::MetricManifold{M,G}, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on the AbstractManifold M using the AbstractMetric G.\n\ng_p(X Y) = X G_p Y\n\nwhere G_p is the local matrix representation of the AbstractMetric G.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#ManifoldsBase.inverse_retract-Tuple{MetricManifold, Any, Any}","page":"Metric manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::MetricManifold, p, q)\ninverse_retract!(M::MetricManifold, X, p, q)\n\nCompute the inverse retraction on the MetricManifold M. Since every inverse retraction is an inverse retraction with respect to any logarithmic map (induced by the metric), this method falls back to calling inverse_retract on the base manifold. The two exceptions are the LogarithmicInverseRetraction and ShootingInverseRetraction, in which case the method falls back to the default, that is to calling, respectively, log and inverse_retract_shooting!.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#ManifoldsBase.retract-Tuple{MetricManifold, Any, Any}","page":"Metric manifold","title":"ManifoldsBase.retract","text":"retract(M::MetricManifold, p, X)\nretract!(M::MetricManifold, q, p, X)\n\nCompute the retraction on the MetricManifold M. Since every retraction is a retraction with respect to any exponential map (here induced by the metric), this method falls back to calling retract on the inner manifold. The one exception is the ExponentialRetraction, in which case the method falls back to the default, i.e. to calling exp but still on M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#ManifoldsBase.vector_transport_direction-Tuple{MetricManifold, Any, Any, Any}","page":"Metric manifold","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::MetricManifold, p, X, d)\nvector_transport_direction!(M::MetricManifold, Y, p, X, d)\n\nCompute the vector transport of the tangent vector X at point p in the direction d on the MetricManifold M.\n\nSince a vector transport is usually defined with respect to a retraction, cf. e.g. [AMS08], and the vector transport is closely related to an affine connection, it is to some extent metric dependent. Therefore, this method only falls back to calling its corresponding method on the base manifold, if the metric is the default one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#ManifoldsBase.vector_transport_to-Tuple{MetricManifold, Any, Any, Any}","page":"Metric manifold","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::MetricManifold, p, X, d)\nvector_transport_to!(M::MetricManifold, Y, p, X, d)\n\nCompute the vector transport of the tangent vector X at point p to a point q on the MetricManifold M.\n\nSince a vector transport is usually defined with respect to a retraction, cf. e.g. [AMS08], and the vector transport is closely related to an affine connection, it is to some extent metric dependent. Therefore, this method only falls back to calling its corresponding method on the base manifold, if the metric is the default one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric/#Metrics,-charts-and-bases-of-vector-spaces","page":"Metric manifold","title":"Metrics, charts and bases of vector spaces","text":"","category":"section"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"Metric-related functions, similarly to connection-related functions, need to operate in a basis of a vector space, see here.","category":"page"},{"location":"manifolds/metric/","page":"Metric manifold","title":"Metric manifold","text":"Metric-related functions can take bases of associated tangent spaces as arguments. For example local_metric can take the basis of the tangent space it is supposed to operate on instead of a custom basis of the space of symmetric bilinear operators.","category":"page"},{"location":"manifolds/symmetric/#Symmetric-matrices","page":"Symmetric matrices","title":"Symmetric matrices","text":"","category":"section"},{"location":"manifolds/symmetric/#Manifolds.SymmetricMatrices","page":"Symmetric matrices","title":"Manifolds.SymmetricMatrices","text":"SymmetricMatrices{𝔽, T} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold  operatornameSym(n) consisting of the real- or complex-valued symmetric matrices of size nn, i.e. the set\n\noperatornameSym(n) = biglp   𝔽^nn big p^mathrmH = p bigr\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ. The dimension n is stored in either a field or within T\n\nThough it is slightly redundant, usually the matrices are stored as nn arrays.\n\nNote that in this representation, the complex valued case has to have a real-valued diagonal, which is also reflected in the manifold_dimension.\n\nConstructor\n\nSymmetricMatrices(n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of nn symmetric matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetric/#ManifoldsBase.Weingarten-Tuple{SymmetricMatrices, Any, Any, Any}","page":"Symmetric matrices","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::SymmetricMatrices, p, X, V)\nWeingarten!(M::SymmetricMatrices, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the SymmetricMatrices M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#ManifoldsBase.check_point-Tuple{SymmetricMatrices, Any}","page":"Symmetric matrices","title":"ManifoldsBase.check_point","text":"check_point(M::SymmetricMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether p is a valid manifold point on the SymmetricMatrices M, i.e. whether p is a symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽.\n\nThe tolerance for the symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#ManifoldsBase.check_vector-Tuple{SymmetricMatrices, Any, Any}","page":"Symmetric matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymmetricMatrices{n,𝔽}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SymmetricMatrices M, i.e. X has to be a symmetric matrix of size (n,n) and its values have to be from the correct AbstractNumbers.\n\nThe tolerance for the symmetry of X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#ManifoldsBase.is_flat-Tuple{SymmetricMatrices}","page":"Symmetric matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::SymmetricMatrices)\n\nReturn true. SymmetricMatrices is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricMatrices{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricMatrices{n,𝔽})\n\nReturn the dimension of the SymmetricMatrices matrix M over the number system 𝔽, i.e.\n\nbeginaligned\ndim mathrmSym(nℝ) = fracn(n+1)2\ndim mathrmSym(nℂ) = 2fracn(n+1)2 - n = n^2\nendaligned\n\nwhere the last -n is due to the zero imaginary part for Hermitian matrices\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#ManifoldsBase.project-Tuple{SymmetricMatrices, Any, Any}","page":"Symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SymmetricMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SymmetricMatrices M,\n\noperatornameproj_p(X) = frac12 bigl( X + X^mathrmH bigr)\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#ManifoldsBase.project-Tuple{SymmetricMatrices, Any}","page":"Symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SymmetricMatrices, p)\n\nProjects p from the embedding onto the SymmetricMatrices M, i.e.\n\noperatornameproj_operatornameSym(n)(p) = frac12 bigl( p + p^mathrmH bigr)\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hamiltonian/#Hamiltonian-matrices","page":"Hamiltonian","title":"Hamiltonian matrices","text":"","category":"section"},{"location":"manifolds/hamiltonian/#Manifolds.Hamiltonian","page":"Hamiltonian","title":"Manifolds.Hamiltonian","text":"Hamiltonian{T,S<:AbstractMatrix{<:T}} <: AbstractMatrix{T}\n\nA type to store a Hamiltonian matrix, that is a square matrix for which A^+ = -A where\n\nA^+ = J_2nA^mathrmTJ_2n qquad J_2n beginpmatrix 0  I_n-I_n  0 endpmatrix\n\nand I_n denotes the nn\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hamiltonian/#Manifolds.HamiltonianMatrices","page":"Hamiltonian","title":"Manifolds.HamiltonianMatrices","text":"HamiltonianMatrices{𝔽, T} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold consisting of (real-valued) hamiltonian matrices of size nn, i.e. the set\n\nmathfraksp(2n𝔽) = biglp   𝔽^2n2n big p^+ = p bigr\n\nwhere ^+ denotes the symplectic_inverse, and 𝔽   ℝ ℂ.\n\nThough it is slightly redundant, usually the matrices are stored as 2n2n arrays.\n\nThe symbol mathfaksp refers to the main usage within Manifolds.jl that is the Lie algebra to the SymplecticMatrices interpreted as a Lie group with the matrix multiplication as group operation.\n\nConstructor\n\nHamiltonianMatrices(2n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of 2n2n Hamiltonian matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hamiltonian/#Base.:^-Tuple{Hamiltonian, typeof(+)}","page":"Hamiltonian","title":"Base.:^","text":"^(A::Hamiltonian, ::typeof(+))\n\nCompute the symplectic_inverse of a Hamiltonian (A)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hamiltonian/#Base.rand-Tuple{HamiltonianMatrices}","page":"Hamiltonian","title":"Base.rand","text":"pX = rand(M::HamiltonianMatrices; σ::Real=1.0, vector_at=nothing)\nrand!(M::HamiltonianMatrices, pX; σ::Real=1.0, vector_at=nothing)\n\nGenerate a random Hamiltonian matrix. Since these are a submanifold of ℝ^2n2n, the same method applies for points and tangent vectors. This can also be done in-place of pX.\n\nThe construction is based on generating one normally-distributed nn matrix A and two symmetric nn matrices B C which are then stacked:\n\np = beginpmatrix A  B C  -A^mathrmT endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hamiltonian/#Manifolds.is_hamiltonian-Tuple{AbstractMatrix}","page":"Hamiltonian","title":"Manifolds.is_hamiltonian","text":"is_hamiltonian(A::AbstractMatrix; kwargs...)\n\nTest whether a matrix A is hamiltonian. The test consists of verifying whether\n\nA^+ = -A\n\nwhere A^+ denotes the symplectic_inverse of A.\n\nThe passed keyword arguments are passed on to isapprox check within\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hamiltonian/#ManifoldsBase.check_point-Tuple{HamiltonianMatrices, Any}","page":"Hamiltonian","title":"ManifoldsBase.check_point","text":"check_point(M::HamiltonianMatrices, p; kwargs...)\n\nCheck whether p is a valid manifold point on the HamiltonianMatrices M, i.e. whether p is_hamiltonian.\n\nThe tolerance for the test of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hamiltonian/#ManifoldsBase.check_vector-Tuple{HamiltonianMatrices, Any, Any}","page":"Hamiltonian","title":"ManifoldsBase.check_vector","text":"check_vector(M::HamiltonianMatrices, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the HamiltonianMatrices M, i.e. X has to be a Hamiltonian matrix The tolerance for is_hamiltonian X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hamiltonian/#ManifoldsBase.is_flat-Tuple{HamiltonianMatrices}","page":"Hamiltonian","title":"ManifoldsBase.is_flat","text":"is_flat(::HamiltonianMatrices)\n\nReturn true. HamiltonianMatrices is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#Grassmannian-manifold","page":"Grassmann","title":"Grassmannian manifold","text":"","category":"section"},{"location":"manifolds/grassmann/#Manifolds.Grassmann","page":"Grassmann","title":"Manifolds.Grassmann","text":"Grassmann{T,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe Grassmann manifold mathrmGr(nk) consists of all subspaces spanned by k linear independent vectors 𝔽^n, where 𝔽   ℝ ℂ is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of ℝ^n for the real-valued case and all 2k-dimensional subspaces of ℂ^n for the second.\n\nThe manifold can be represented as\n\nmathrmGr(nk) = bigl operatornamespan(p)  p  𝔽^nk p^mathrmHp = I_k\n\nwhere ^mathrmH denotes the complex conjugate transpose or Hermitian and I_k is the kk identity matrix. This means, that the columns of p form an unitary basis of the subspace, that is a point on operatornameGr(nk), and hence the subspace can actually be represented by a whole equivalence class of representers. Another interpretation is, that\n\nmathrmGr(nk) = mathrmSt(nk)  operatornameO(k)\n\ni.e the Grassmann manifold is the quotient of the Stiefel manifold and the orthogonal group operatornameO(k) of orthogonal kk matrices. Note that it doesn't matter whether we start from the Euclidean or canonical metric on the Stiefel manifold, the resulting quotient metric on Grassmann is the same.\n\nThe tangent space at a point (subspace) p is given by\n\nT_pmathrmGr(nk) = bigl\nX  𝔽^nk \nX^mathrmHp + p^mathrmHX = 0_k bigr\n\nwhere 0_k is the kk zero matrix.\n\nNote that a point p  operatornameGr(nk) might be represented by different matrices (i.e. matrices with unitary column vectors that span the same subspace). Different representations of p also lead to different representation matrices for the tangent space T_pmathrmGr(nk)\n\nFor a representation of points as orthogonal projectors. Here\n\noperatornameGr(nk) = bigl p in mathbb R^nn  p = p^mathrmT p^2 = p operatornamerank(p) = k\n\nwith tangent space\n\nT_pmathrmGr(nk) = bigl\nX  mathbb R^nn  X=X^mathrmT text and  X = pX+Xp bigr\n\nsee also ProjectorPoint and ProjectorTangentVector.\n\nThe manifold is named after Hermann G. Graßmann (1809-1877).\n\nA good overview can be found in[BZA20].\n\nConstructor\n\nGrassmann(n, k, field=ℝ, parameter::Symbol=:type)\n\nGenerate the Grassmann manifold operatornameGr(nk), where the real-valued case field=ℝ is the default.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann/#Base.convert-Tuple{Type{ProjectorPoint}, AbstractMatrix}","page":"Grassmann","title":"Base.convert","text":"convert(::Type{ProjectorPoint}, p::AbstractMatrix)\n\nConvert a point p on Stiefel that also represents a point (i.e. subspace) on Grassmann to a projector representation of said subspace, i.e. compute the canonical_project! for\n\n  π^mathrmSG(p) = pp^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#Base.convert-Tuple{Type{ProjectorPoint}, StiefelPoint}","page":"Grassmann","title":"Base.convert","text":"convert(::Type{ProjectorPoint}, ::Stiefelpoint)\n\nConvert a point p on Stiefel that also represents a point (i.e. subspace) on Grassmann to a projector representation of said subspace, i.e. compute the canonical_project! for\n\n  π^mathrmSG(p) = pp^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.change_metric-Tuple{Grassmann, EuclideanMetric, Any, Any}","page":"Grassmann","title":"ManifoldsBase.change_metric","text":"change_metric(M::Grassmann, ::EuclideanMetric, p, X)\n\nChange X to the corresponding vector with respect to the metric of the Grassmann M, which is just the identity, since the manifold is isometrically embedded.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.change_representer-Tuple{Grassmann, EuclideanMetric, Any, Any}","page":"Grassmann","title":"ManifoldsBase.change_representer","text":"change_representer(M::Grassmann, ::EuclideanMetric, p, X)\n\nChange X to the corresponding representer of a cotangent vector at p. Since the Grassmann manifold M, is isometrically embedded, this is the identity\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.default_retraction_method-Tuple{Grassmann}","page":"Grassmann","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::Grassmann)\ndefault_retraction_method(M::Grassmann, ::Type{StiefelPoint})\ndefault_retraction_method(M::Grassmann, ::Type{ProjectorPoint})\n\nReturn ExponentialRetraction as the default on the Grassmann manifold for both representations.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.default_vector_transport_method-Tuple{Grassmann}","page":"Grassmann","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::Grassmann)\n\nReturn the default vector transport method for the Grassmann manifold, which is ParallelTransport().\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.get_total_space-Union{Tuple{Grassmann{𝔽, ManifoldsBase.TypeParameter{Tuple{n, k}}}}, Tuple{𝔽}, Tuple{k}, Tuple{n}} where {n, k, 𝔽}","page":"Grassmann","title":"ManifoldsBase.get_total_space","text":"get_total_space(::Grassmann)\n\nReturn the total space of the Grassmann manifold, which is the corresponding Stiefel manifold, independent of whether the points are represented already in the total space or as ProjectorPoints.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.injectivity_radius-Tuple{Grassmann}","page":"Grassmann","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Grassmann)\ninjectivity_radius(M::Grassmann, p)\n\nReturn the injectivity radius on the Grassmann M, which is fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.is_flat-Tuple{Grassmann}","page":"Grassmann","title":"ManifoldsBase.is_flat","text":"is_flat(M::Grassmann)\n\nReturn true if Grassmann M is one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.manifold_dimension-Union{Tuple{Grassmann{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Grassmann","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Grassmann)\n\nReturn the dimension of the Grassmann(n,k,𝔽) manifold M, i.e.\n\ndim operatornameGr(nk) = k(n-k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#Statistics.mean-Tuple{Grassmann, Vararg{Any}}","page":"Grassmann","title":"Statistics.mean","text":"mean(\n    M::Grassmann,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#The-Grassmanian-represented-as-points-on-the-[Stiefel](@ref)-manifold","page":"Grassmann","title":"The Grassmanian represented as points on the Stiefel manifold","text":"","category":"section"},{"location":"manifolds/grassmann/#Manifolds.StiefelPoint","page":"Grassmann","title":"Manifolds.StiefelPoint","text":"StiefelPoint <: AbstractManifoldPoint\n\nA point on a Stiefel manifold. This point is mainly used for representing points on the Grassmann where this is also the default representation and hence equivalent to using AbstractMatrices thereon. they can also used be used as points on Stiefel.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann/#Manifolds.StiefelTangentVector","page":"Grassmann","title":"Manifolds.StiefelTangentVector","text":"StiefelTangentVector <: AbstractTangentVector\n\nA tangent vector on the Grassmann manifold represented by a tangent vector from the tangent space of a corresponding point from the Stiefel manifold, see StiefelPoint. This is the default representation so is can be used interchangeably with just abstract matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann/#Base.exp-Tuple{Grassmann, Any, Any}","page":"Grassmann","title":"Base.exp","text":"exp(M::Grassmann, p, X)\n\nCompute the exponential map on the Grassmann M = mathrmGr(nk) starting in p with tangent vector (direction) X. Let X = USV denote the SVD decomposition of X. Then the exponential map is written using\n\nz = p Vcos(S)V^mathrmH + Usin(S)V^mathrmH\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian and the cosine and sine are applied element wise to the diagonal entries of S. A final QR decomposition z=QR is performed for numerical stability reasons, yielding the result as\n\nexp_p X = Q\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#Base.log-Tuple{Grassmann, Vararg{Any}}","page":"Grassmann","title":"Base.log","text":"log(M::Grassmann, p, q)\n\nCompute the logarithmic map on the Grassmann M = mathcal M=mathrmGr(nk), i.e. the tangent vector X whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = V operatornameatan(S)  U^mathrmH\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian. The matrices U and V are the unitary matrices, and S is the diagonal matrix containing the singular values of the SVD-decomposition\n\nUSV = (q^mathrmHp)^-1 ( q^mathrmH - q^mathrmHpp^mathrmH)\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#Base.rand-Tuple{Grassmann}","page":"Grassmann","title":"Base.rand","text":"rand(M::Grassmann; σ::Real=1.0, vector_at=nothing)\n\nWhen vector_at is nothing, return a random point p on Grassmann manifold M by generating a random (Gaussian) matrix with standard deviation σ in matching size, which is orthonormal.\n\nWhen vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_pmathrmGr(nk) with mean zero and standard deviation σ by projecting a random Matrix onto the tangent space at vector_at.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldDiff.riemannian_Hessian-Tuple{Grassmann, Vararg{Any, 4}}","page":"Grassmann","title":"ManifoldDiff.riemannian_Hessian","text":"riemannian_Hessian(M::Grassmann, p, G, H, X)\n\nThe Riemannian Hessian can be computed by adopting Eq. (6.6) [Ngu23], where we use for the EuclideanMetric α_0=α_1=1 in their formula. Let nabla f(p) denote the Euclidean gradient G, nabla^2 f(p)X the Euclidean Hessian H. Then the formula reads\n\n    operatornameHessf(p)X\n    =\n    operatornameproj_T_pmathcal MBigl(\n        ^2f(p)X - X p^mathrmHf(p)\n    Bigr)\n\nCompared to Eq. (5.6) also the metric conversion simplifies to the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.distance-Tuple{Grassmann, Any, Any}","page":"Grassmann","title":"ManifoldsBase.distance","text":"distance(M::Grassmann, p, q)\n\nCompute the Riemannian distance on Grassmann manifold M= mathrmGr(nk).\n\nThe distance is given by\n\nd_mathrmGr(nk)(pq) = operatornamenorm(log_p(q))\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.inner-Tuple{Grassmann, Any, Any, Any}","page":"Grassmann","title":"ManifoldsBase.inner","text":"inner(M::Grassmann, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the Grassmann manifold M. The formula reads\n\ng_p(XY) = operatornametr(X^mathrmHY)\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.inverse_retract-Tuple{Grassmann, Any, Any, PolarInverseRetraction}","page":"Grassmann","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Grassmann, p, q, ::PolarInverseRetraction)\n\nCompute the inverse retraction for the PolarRetraction, on the Grassmann manifold M, i.e.,\n\noperatornameretr_p^-1q = q*(p^mathrmHq)^-1 - p\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.inverse_retract-Tuple{Grassmann, Any, Any, QRInverseRetraction}","page":"Grassmann","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, p, q, ::QRInverseRetraction)\n\nCompute the inverse retraction for the QRRetraction, on the Grassmann manifold M, i.e.,\n\noperatornameretr_p^-1q = q(p^mathrmHq)^-1 - p\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.parallel_transport_direction-Tuple{Grassmann, Any, Any, Any}","page":"Grassmann","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::Grassmann, p, X, Y)\n\nCompute the parallel transport of X in   T_pmathcal M along the geodesic starting in direction dot γ (0) = Y.\n\nLet Y = USV denote the SVD decomposition of Y. Then the parallel transport is given by the formula according to Equation (8.5) (p. 171) [AMS08] as\n\nmathcal P_pY X = -pV sin(S)U^mathrmTX + Ucos(S)U^mathrmTX + (I-UU^mathrmT)X\n\nwhere the sine and cosine applied to the diagonal matrix S are meant to be elementwise\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.parallel_transport_to-Tuple{Grassmann, Any, Any, Any}","page":"Grassmann","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Grassmann, p, X, q)\n\nCompute the parallel transport of X   T_pmathcal M along the geodesic connecting p to q.\n\nThis method uses the logarithmic map and the parallel transport in that direction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.project-Tuple{Grassmann, Any}","page":"Grassmann","title":"ManifoldsBase.project","text":"project(M::Grassmann, p)\n\nProject p from the embedding onto the Grassmann M, i.e. compute q as the polar decomposition of p such that q^mathrmHq is the identity, where ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.project-Tuple{Grassmann, Vararg{Any}}","page":"Grassmann","title":"ManifoldsBase.project","text":"project(M::Grassmann, p, X)\n\nProject the n-by-k X onto the tangent space of p on the Grassmann M, which is computed by\n\noperatornameproj_p(X) = X - pp^mathrmHX\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.representation_size-Tuple{Grassmann}","page":"Grassmann","title":"ManifoldsBase.representation_size","text":"representation_size(M::Grassmann)\n\nReturn the representation size or matrix dimension of a point on the Grassmann M, i.e. (nk) for both the real-valued and the complex value case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.retract-Tuple{Grassmann, Any, Any, PolarRetraction}","page":"Grassmann","title":"ManifoldsBase.retract","text":"retract(M::Grassmann, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Grassmann M. With USV = p + X the retraction reads\n\noperatornameretr_p X = UV^mathrmH\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.retract-Tuple{Grassmann, Any, Any, QRRetraction}","page":"Grassmann","title":"ManifoldsBase.retract","text":"retract(M::Grassmann, p, X, ::QRRetraction )\n\nCompute the QR-based retraction QRRetraction on the Grassmann M. With QR = p + X the retraction reads\n\noperatornameretr_p X = QD\n\nwhere D is a mn matrix with\n\nD = operatornamediagleft( operatornamesgnleft(R_ii+frac12right)_i=1^n right)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.riemann_tensor-Tuple{Grassmann{ℝ}, Vararg{Any, 4}}","page":"Grassmann","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(::Grassmann{<:Any,ℝ}, p, X, Y, Z)\n\nCompute the value of Riemann tensor on the real Grassmann manifold. The formula reads [Ren11]\n\nR(XY)Z = (XY^mathrmT - YX^mathrmT)Z + Z(Y^mathrmTX - X^mathrmTY)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.vector_transport_to-Tuple{Grassmann, Any, Any, Any, ProjectionTransport}","page":"Grassmann","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Grassmann, p, X, q, ::ProjectionTransport)\n\ncompute the projection based transport on the Grassmann M by interpreting X from the tangent space at p as a point in the embedding and projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.zero_vector-Tuple{Grassmann, Vararg{Any}}","page":"Grassmann","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Grassmann, p)\n\nReturn the zero tangent vector from the tangent space at p on the Grassmann M, which is given by a zero matrix the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#The-Grassmannian-represented-as-projectors","page":"Grassmann","title":"The Grassmannian represented as projectors","text":"","category":"section"},{"location":"manifolds/grassmann/#Manifolds.ProjectorPoint","page":"Grassmann","title":"Manifolds.ProjectorPoint","text":"ProjectorPoint <: AbstractManifoldPoint\n\nA type to represent points on a manifold Grassmann that are orthogonal projectors, i.e. a matrix p  mathbb F^nn projecting onto a k-dimensional subspace.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann/#Manifolds.ProjectorTangentVector","page":"Grassmann","title":"Manifolds.ProjectorTangentVector","text":"ProjectorTangentVector <: AbstractTangentVector\n\nA type to represent tangent vectors to points on a Grassmann manifold that are orthogonal projectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann/#Base.exp-Tuple{Grassmann, ProjectorPoint, ProjectorTangentVector}","page":"Grassmann","title":"Base.exp","text":"exp(M::Grassmann, p::ProjectorPoint, X::ProjectorTangentVector)\n\nCompute the exponential map on the Grassmann as\n\n    exp_pX = operatornameExp(Xp)poperatornameExp(-Xp)\n\nwhere operatornameExp denotes the matrix exponential and AB = AB-BA denotes the matrix commutator.\n\nFor details, see Proposition 3.2 in [BZA20].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#Manifolds.diff_canonical_project!-Tuple{Grassmann, ProjectorTangentVector, Any, Any}","page":"Grassmann","title":"Manifolds.diff_canonical_project!","text":"diff_canonical_project!(M::Grassmann, q::ProjectorPoint, p)\n\nCompute the differential of canonical projection π(p) from the Stiefel manifold onto the Grassmann manifold when represented as ProjectorPoint, i.e.\n\n    Dπ^mathrmSG(p)X = Xp^mathrmT + pX^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.canonical_project!-Tuple{Grassmann, ProjectorPoint, Any}","page":"Grassmann","title":"ManifoldsBase.canonical_project!","text":"canonical_project!(M::Grassmann, q::ProjectorPoint, p)\n\nCompute the canonical projection π(p) from the Stiefel manifold onto the Grassmann manifold when represented as ProjectorPoint, i.e.\n\n    π^mathrmSG(p) = pp^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.check_point-Tuple{Grassmann, ProjectorPoint}","page":"Grassmann","title":"ManifoldsBase.check_point","text":"check_point(::Grassmann, p::ProjectorPoint; kwargs...)\n\nCheck whether an orthogonal projector is a point from the Grassmann(n,k) manifold, i.e. the ProjectorPoint p  mathbb F^nn, mathbb F  mathbb R mathbb C has to fulfill p^mathrmT = p, p^2=p, and `\\operatorname{rank} p = k.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.check_size-Tuple{Grassmann, ProjectorPoint}","page":"Grassmann","title":"ManifoldsBase.check_size","text":"check_size(M::Grassmann, p::ProjectorPoint; kwargs...)\n\nCheck that the ProjectorPoint is of correct size, i.e. from mathbb F^nn\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.check_vector-Tuple{Grassmann, ProjectorPoint, ProjectorTangentVector}","page":"Grassmann","title":"ManifoldsBase.check_vector","text":"check_vector(::Grassmann, p::ProjectorPoint, X::ProjectorTangentVector; kwargs...)\n\nCheck whether the ProjectorTangentVector X is from the tangent space T_poperatornameGr(nk) at the ProjectorPoint p on the Grassmann manifold operatornameGr(nk). This means that X has to be symmetric and that\n\nXp + pX = X\n\nmust hold, where the kwargs can be used to check both for symmetrix of X` and this equality up to a certain tolerance.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.get_embedding-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{Grassmann{𝔽, ManifoldsBase.TypeParameter{Tuple{n, k}}}, Type{<:ProjectorPoint}}} where {n, k, 𝔽}","page":"Grassmann","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::Grassmann, ::Type{<:ProjectorPoint})\n\nReturn the embedding of the ProjectorPoint representation of the Grassmann manifold, i.e. the Euclidean space mathbb F^nn.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.horizontal_lift-Tuple{Stiefel, Any, ProjectorTangentVector}","page":"Grassmann","title":"ManifoldsBase.horizontal_lift","text":"horizontal_lift(N::Stiefel{n,k}, q, X::ProjectorTangentVector)\n\nCompute the horizontal lift of X from the tangent space at p=π(q) on the Grassmann manifold, i.e.\n\nY = Xq  T_qmathrmSt(nk)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.parallel_transport_direction-Tuple{Grassmann, ProjectorPoint, ProjectorTangentVector, ProjectorTangentVector}","page":"Grassmann","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(\n    M::Grassmann,\n    p::ProjectorPoint,\n    X::ProjectorTangentVector,\n    d::ProjectorTangentVector\n)\n\nCompute the parallel transport of X from the tangent space at p into direction d, i.e. to q=exp_pd. The formula is given in Proposition 3.5 of [BZA20] as\n\nmathcalP_q  p(X) = operatornameExp(dp)XoperatornameExp(-dp)\n\nwhere operatornameExp denotes the matrix exponential and AB = AB-BA denotes the matrix commutator.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#ManifoldsBase.representation_size-Tuple{Grassmann, ProjectorPoint}","page":"Grassmann","title":"ManifoldsBase.representation_size","text":"representation_size(M::Grassmann, p::ProjectorPoint)\n\nReturn the representation size or matrix dimension of a point on the Grassmann M when using ProjectorPoints, i.e. (nn).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann/#Literature","page":"Grassmann","title":"Literature","text":"","category":"section"},{"location":"manifolds/grassmann/","page":"Grassmann","title":"Grassmann","text":"P.-A. Absil, R. Mahony and R. Sepulchre. Optimization Algorithms on Matrix Manifolds (Princeton University Press, 2008), available online at press.princeton.edu/chapters/absil/.\n\n\n\nT. Bendokat, R. Zimmermann and P.-A. Absil. A Grassmann Manifold Handbook: Basic Geometry and Computational Aspects, arXiv Preprint (2020), arXiv:2011.13699.\n\n\n\nD. Nguyen. Operator-Valued Formulas for Riemannian Gradient and Hessian and Families of Tractable Metrics in Riemannian Optimization. Journal of Optimization Theory and Applications 198, 135–164 (2023), arXiv:2009.10159.\n\n\n\nQ. Rentmeesters. A gradient method for geodesic data fitting on some symmetric Riemannian manifolds. In: IEEE Conference on Decision and Control and European Control Conference (2011); pp. 7141–7146.\n\n\n\n","category":"page"},{"location":"misc/references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"misc/references/","page":"References","title":"References","text":"We are slowly moving to using DocumenterCitations.jl. The goal is to have all references used / mentioned in the documentation of Manifolds.jl also listed here. If you notice a reference still defined in a footnote, please change it into a BibTeX reference and open a PR","category":"page"},{"location":"misc/references/","page":"References","title":"References","text":"Usually you will find a small reference section at the end of every documentation page that contains references for just that page.","category":"page"},{"location":"misc/references/","page":"References","title":"References","text":"P. -.-A. Absil, R. Mahony and J. Trumpf. An Extrinsic Look at the Riemannian Hessian. In: Geometric Science of Information, edited by F. Nielsen and F. Barbaresco (Springer Berlin Heidelberg, 2013); pp. 361–368.\n\n\n\nP.-A. Absil, R. Mahony and R. Sepulchre. Optimization Algorithms on Matrix Manifolds (Princeton University Press, 2008), available online at press.princeton.edu/chapters/absil/.\n\n\n\nP.-A. Absil and J. Malick. Projection-like Retractions on Matrix Manifolds. SIAM Journal on Optimization 22, 135–158 (2012).\n\n\n\nP.-A. Absil and I. V. Oseledets. Low-rank retractions: a survey and new results. Computational Optimization and Applications 62, 5–29 (2014).\n\n\n\nB. Afsari, R. Tron and R. Vidal. On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass. SIAM Journal on Control and Optimization 51, 2230–2260 (2013), arXiv:1201.0925.\n\n\n\nD. Andrica and R.-A. Rohan. Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications 18, 1–10 (2013).\n\n\n\nS. D. Axen, M. Baran, R. Bergmann and K. Rzecki. Manifolds.Jl: An Extensible Julia Framework for Data Analysis on Manifolds. ACM Transactions on Mathematical Software 49 (2023).\n\n\n\nN. Ay, J. Jost, H. V. Lê and L. Schwachhöfer. Information Geometry (Springer Cham, 2017).\n\n\n\nM. Bačák. Computing medians and means in Hadamard spaces. SIAM Journal on Optimization 24, 1542–1566 (2014), arXiv:1210.2145.\n\n\n\nT. Bendokat and R. Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv Preprint, 2108.12447 (2021), arXiv:2108.12447.\n\n\n\nT. Bendokat, R. Zimmermann and P.-A. Absil. A Grassmann Manifold Handbook: Basic Geometry and Computational Aspects, arXiv Preprint (2020), arXiv:2011.13699.\n\n\n\nR. Bergmann and P.-Y. Gousenbourger. A variational model for data fitting on manifolds by minimizing the acceleration of a Bézier curve. Frontiers in Applied Mathematics and Statistics 4 (2018), arXiv:1807.10090.\n\n\n\nR. Bergmann, J. Persch and G. Steidl. A parallel Douglas Rachford algorithm for minimizing ROF-like functionals on images with values in symmetric Hadamard manifolds, arXiv Preprint (2015), arXiv:1512.02814.\n\n\n\nR. Bergmann, J. Persch and G. Steidl. A parallel Douglas Rachford algorithm for minimizing ROF-like functionals on images with values in symmetric Hadamard manifolds. SIAM Journal on Imaging Sciences 9, 901–937 (2016).\n\n\n\nE. Biny and S. Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\nP. Birtea, I. Caçu and D. Comănescu. Optimization on the real symplectic group. Monatshefte für Mathematik 191, 465–485 (2020).\n\n\n\nL. J. Boya, E. Sudarshan and T. Tilma. Volumes of compact manifolds. Reports on Mathematical Physics 52, 401–422 (2003).\n\n\n\nA. L. Brigant and S. Puechmorel. Approximation of Densities on Riemannian Manifolds. Entropy 21, 43 (2019).\n\n\n\nJ. Cheeger and D. G. Ebin. Comparison Theorems in Riemannian Geometry (American Mathematical Society, Providence, R.I, 2008).\n\n\n\nE. Chevallier, D. Li, Y. Lu and D. B. Dunson. Exponential-wrapped distributions on symmetric spaces. ArXiv Preprint (2022).\n\n\n\nE. Chevallier, E. Kalunga and J. Angulo. Kernel Density Estimation on Spaces of Gaussian Distributions and Symmetric Positive Definite Matrices. SIAM Journal on Imaging Sciences 10, 191–215 (2017).\n\n\n\nG. S. Chirikjian. Stochastic Models, Information Theory, and Lie Groups, Volume 2. 1 Edition, Vol. 2 of Applied and Numerical Harmonic Analysis (Birkhäuser Boston, MA, 2012).\n\n\n\nL. Devroye. Non-Uniform Random Variate Generation (Springer New York, NY, 1986).\n\n\n\nN. Dewaele, P. Breiding and N. Vannieuwenhoven. The condition number of many tensor decompositions is invariant under Tucker compression, arXiv Preprint (2021), arXiv:2106.13034.\n\n\n\nA. Douik and B. Hassibi. Manifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry. IEEE Transactions on Signal Processing 67, 5761–5774 (2019), arXiv:1802.02628.\n\n\n\nA. Edelman, T. A. Arias and S. T. Smith. The Geometry of Algorithms with Orthogonality Constraints. SIAM Journal on Matrix Analysis and Applications 20, 303–353 (1998), arXiv:806030.\n\n\n\nL. Falorsi, P. de Haan, T. R. Davidson and P. Forré. Reparameterizing Distributions on Lie Groups, arXiv Preprint (2019).\n\n\n\nS. Fiori. Solving Minimal-Distance Problems over the Manifold of Real-Symplectic Matrices. SIAM Journal on Matrix Analysis and Applications 32, 938–968 (2011).\n\n\n\nP. T. Fletcher, S. Venkatasubramanian and S. Joshi. Robust statistics on Riemannian manifolds via the geometric median. In: 2008 IEEE Conference on Computer Vision and Pattern Recognition (2008).\n\n\n\nJ. Gallier and D. Xu. Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation 17, 1–11 (2002).\n\n\n\nB. Gao, N. T. Son, P.-A. Absil and T. Stykel. Riemannian Optimization on the Symplectic Stiefel Manifold. SIAM Journal on Optimization 31, 1546–1575 (2021).\n\n\n\nJ. Ge. DDVV-type inequality for skew-symmetric matrices and Simons-type inequality for Riemannian submersions. Advances in Mathematics 251, 62–86 (2014).\n\n\n\nN. Guigui, E. Maignant, A. Trouvé and X. Pennec. Parallel Transport on Kendall Shape Spaces. In: Geometric Science of Information (SPringer Cham, 2021); pp. 103–110.\n\n\n\nA. Han, B. Mushra, P. Jawapanpuria and J. Gao. Learning with symmetric positive definite matrices via generalized Bures-Wasserstein geometry, arXive preprint (2021), arXiv:2110.10464.\n\n\n\nS. Hosseini and A. Uschmajew. A Riemannian Gradient Sampling Algorithm for Nonsmooth Optimization on Manifolds. SIAM J. Optim. 27, 173–189 (2017).\n\n\n\nW. Huang, K. A. Gallivan and P.-A. Absil. A Broyden Class of Quasi-Newton Methods for Riemannian Optimization. SIAM Journal on Optimization 25, 1660–1685 (2015).\n\n\n\nK. Hüper, I. Markina and F. S. Leite. A Lagrangian approach to extremal curves on Stiefel manifolds. Journal of Geometric Mechanics 13, 55 (2021).\n\n\n\nS. Jacobsson, L. Swijsen, J. V. Veken and N. Vannieuwenhoven. Warped geometries of Segre-Veronese manifolds (2024), arXiv:2410.00664 [math.NA].\n\n\n\nM. Journée, F. Bach, P.-A. Absil and R. Sepulchre. Low-Rank Optimization on the Cone of Positive Semidefinite Matrices. SIAM Journal on Optimization 20, 2327–2351 (2010), arXiv:0807.4423.\n\n\n\nD. Joyce. On manifolds with corners (2010), arXiv:0910.3518.\n\n\n\nT. Kaneko, S. Fiori and T. Tanaka. Empirical Arithmetic Averaging Over the Compact Stiefel Manifold. IEEE Transactions on Signal Processing 61, 883–894 (2013).\n\n\n\nH. Karcher. Riemannian center of mass and mollifier smoothing. Communications on Pure and Applied Mathematics 30, 509–541 (1977).\n\n\n\nD. G. Kendall. Shape Manifolds, Procrustean Metrics, and Complex Projective Spaces. Bulletin of the London Mathematical Society 16, 81–121 (1984).\n\n\n\nD. G. Kendall. A Survey of the Statistical Theory of Shape. Statistical Sciences 4, 87–99 (1989).\n\n\n\nO. Koch and C. Lubich. Dynamical Tensor Approximation. SIAM Journal on Matrix Analysis and Applications 31, 2360–2375 (2010).\n\n\n\nD. Kressner, M. Steinlechner and B. Vandereycken. Low-rank tensor completion by Riemannian optimization. BIT Numerical Mathematics 54, 447–468 (2013).\n\n\n\nN. Langrené and X. Warin. Fast and Stable Multivariate Kernel Density Estimation by Fast Sum Updating. Journal of Computational and Graphical Statistics 28, 596–608 (2019).\n\n\n\nL. D. Lathauwer, B. D. Moor and J. Vandewalle. A Multilinear Singular Value Decomposition. SIAM Journal on Matrix Analysis and Applications 21, 1253–1278 (2000).\n\n\n\nJ. M. Lee. Introduction to Riemannian Manifolds (Springer Cham, 2019).\n\n\n\nZ. Lin. Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition. SIAM Journal on Matrix Analysis and Applications 40, 1353–1370 (2019), arXiv:1908.09326.\n\n\n\nL. Malagó, L. Montrucchio and G. Pistone. Wasserstein Riemannian geometry of Gaussian densities. Information Geometry 1, 137–179 (2018).\n\n\n\nG. Marsaglia. Choosing a Point from the Surface of a Sphere. Annals of Mathematical Statistics 43, 645–646 (1972).\n\n\n\nE. Massart and P.-A. Absil. Quotient Geometry with Simple Geodesics for the Manifold of Fixed-Rank Positive-Semidefinite Matrices. SIAM Journal on Matrix Analysis and Applications 41, 171–198 (2020). Preprint: sites.uclouvain.be/absil/2018.06.\n\n\n\nP. Muralidharan and P. T. Fletcher. Sasaki metrics for analysis of longitudinal data on manifolds. In: 2012 IEEE Conference on Computer Vision and Pattern Recognition (2012).\n\n\n\nD. Nguyen. Operator-Valued Formulas for Riemannian Gradient and Hessian and Families of Tractable Metrics in Riemannian Optimization. Journal of Optimization Theory and Applications 198, 135–164 (2023), arXiv:2009.10159.\n\n\n\nX. Pennec. Intrinsic Statistics on Riemannian Manifolds: Basic Tools for Geometric Measurements. Journal of Mathematical Imaging and Vision 25, 127–154 (2006).\n\n\n\nX. Pennec and V. Arsigny. Exponential Barycenters of the Canonical Cartan Connection and Invariant Means on Lie Groups. In: Matrix Information Geometry (Springer, Berlin, Heidelberg, 2012); pp. 123–166, arXiv:00699361.\n\n\n\nQ. Rentmeesters. A gradient method for geodesic data fitting on some symmetric Riemannian manifolds. In: IEEE Conference on Decision and Control and European Control Conference (2011); pp. 7141–7146.\n\n\n\nS. Sasaki. On the differential geometry of tangent bundles of Riemannian manifolds. Tohoku Math. J. 10 (1958).\n\n\n\nJ. Solà, J. Deray and D. Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\nA. Srivastava and E. P. Klassen. Functional and Shape Data Analysis (Springer New York, 2016).\n\n\n\nS. Tornier. Haar Measures (2020).\n\n\n\nR. Tron and K. Daniilidis. The Space of Essential Matrices as a Riemannian Quotient Manifold. SIAM J. Imaging Sci. 10, 1416–1445 (2017).\n\n\n\nB. Vandereycken. Low-rank matrix completion by Riemannian optimization. SIAM Journal on Optimization 23, 1214–1236 (2013).\n\n\n\nN. Vannieuwenhoven, R. Vandebril and K. Meerbergen. A New Truncation Strategy for the Higher-Order Singular Value Decomposition. SIAM Journal on Scientific Computing 34, A1027–A1052 (2012).\n\n\n\nJ. Wang, H. Sun and S. Fiori. A Riemannian-steepest-descent approach for optimization on the real symplectic group. Mathematical Methods in the Applied Science 41, 4273–4286 (2018).\n\n\n\nK. Ye, K. S.-W. Wong and L.-H. Lim. Optimization on flag manifolds. Mathematical Programming 194, 621–660 (2021).\n\n\n\nX. Zhu. A Riemannian conjugate gradient method for optimization on the Stiefel manifold. Computational Optimization and Applications 67, 73–110 (2016).\n\n\n\nX. Zhu and C. Duan. On matrix exponentials and their approximations related to optimization on the Stiefel manifold. Optimization Letters 13, 1069–1083 (2018).\n\n\n\nR. Zimmermann. A Matrix-Algebraic Algorithm for the Riemannian Logarithm on the Stiefel Manifold under the Canonical Metric. SIAM J. Matrix Anal. Appl. 38, 322–342 (2017), arXiv:1604.05054.\n\n\n\nR. Zimmermann and K. Hüper. Computing the Riemannian Logarithm on the Stiefel Manifold: Metrics, Methods, and Performance. SIAM Journal on Matrix Analysis and Applications 43, 953–980 (2022), arXiv:2103.12046.\n\n\n\nR. Zimmermann and J. Stoye. The injectivity radius of the compact Stiefel manifold under the Euclidean metric, arXiv Preprint (2024), arXiv:2405.02268.\n\n\n\nF. Åström, S. Petra, B. Schmitzer and C. Schnörr. Image Labeling by Assignment. Journal of Mathematical Imaging and Vision 58, 211–238 (2017), arXiv:1603.05285.\n\n\n\n","category":"page"},{"location":"manifolds/essentialmanifold/#Essential-Manifold","page":"Essential manifold","title":"Essential Manifold","text":"","category":"section"},{"location":"manifolds/essentialmanifold/","page":"Essential manifold","title":"Essential manifold","text":"The essential manifold is modeled as an AbstractPowerManifold  of the 33 Rotations and uses NestedPowerRepresentation.","category":"page"},{"location":"manifolds/essentialmanifold/#Manifolds.EssentialManifold","page":"Essential manifold","title":"Manifolds.EssentialManifold","text":"EssentialManifold <: AbstractPowerManifold{ℝ}\n\nThe essential manifold is the space of the essential matrices which is represented as a quotient space of the Rotations manifold product mathrmSO(3)^2.\n\nLet R_x(θ) R_y(θ) R_x(θ) in ℝ^x3 denote the rotation around the z, y, and x axis in ℝ^3, respectively, and further the groups\n\nH_z = bigl(R_z(θ)R_z(θ)) big θ  -ππ) bigr\n\nand\n\nH_π = bigl (II) (R_x(π) R_x(π)) (IR_z(π)) (R_x(π) R_y(π))  bigr\n\nacting elementwise on the left from mathrmSO(3)^2 (component wise).\n\nThen the unsigned Essential manifold mathcalM_textE can be identified with the quotient space\n\nmathcalM_textE = (textSO(3)textSO(3))(H_z  H_π)\n\nand for the signed Essential manifold mathcalM_textƎ, the quotient reads\n\nmathcalM_textƎ = (textSO(3)textSO(3))(H_z)\n\nAn essential matrix is defined as\n\nE = (R_1)^T T_2 - T_1_ R_2\n\nwhere the poses of two cameras (R_i T_i) i=12, are contained in the space of rigid body transformations SE(3) and the operator _colon ℝ^3  operatornameSkewSym(3) denotes the matrix representation of the cross product operator. For more details see [TD17].\n\nConstructor\n\nEssentialManifold(is_signed=true)\n\nGenerate the manifold of essential matrices, either the signed (is_signed=true) or unsigned (is_signed=false) variant.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/essentialmanifold/#Functions","page":"Essential manifold","title":"Functions","text":"","category":"section"},{"location":"manifolds/essentialmanifold/#Base.exp-Tuple{EssentialManifold, Vararg{Any}}","page":"Essential manifold","title":"Base.exp","text":"exp(M::EssentialManifold, p, X)\n\nCompute the exponential map on the EssentialManifold from p into direction X, i.e.\n\ntextexp_p(X) =textexp_g( tilde X)  quad g in text(SO)(3)^2\n\nwhere tilde X is the horizontal lift of X[TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#Base.log-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"Base.log","text":"log(M::EssentialManifold, p, q)\n\nCompute the logarithmic map on the EssentialManifold M, i.e. the tangent vector, whose geodesic starting from p reaches q after time 1. Here, p=(R_p_1R_p_2) and q=(R_q_1R_q_2) are elements of SO(3)^2. We use that any essential matrix can, up to scale, be decomposed to\n\nE = R_1^T e_z_R_2\n\nwhere (R_1R_2)SO(3)^2. Two points in SO(3)^2 are equivalent iff their corresponding essential matrices are equal (up to a sign flip). To compute the logarithm, we first move q to another representative of its equivalence class. For this, we find t= t_textopt for which the function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nwhere d() is the distance function in SO(3), is minimized. Further, the group H_z acting on the left on SO(3)^2 is defined as\n\nH_z = (R_z(θ)R_z(θ))colon θ in -ππ) \n\nwhere R_z(θ) is the rotation around the z axis with angle θ. Points in H_z are denoted by S_z. Then, the logarithm is defined as\n\nlog_p (S_z(t_textopt)q) = textLog(R_p_i^T R_z(t_textopt)R_b_i)_i=12\n\nwhere textLog is the logarithm on SO(3). For more details see [TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#ManifoldsBase.check_point-Tuple{EssentialManifold, Any}","page":"Essential manifold","title":"ManifoldsBase.check_point","text":"check_point(M::EssentialManifold, p; kwargs...)\n\nCheck whether the matrix is a valid point on the EssentialManifold M, i.e. a 2-element array containing SO(3) matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#ManifoldsBase.check_vector-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.check_vector","text":"check_vector(M::EssentialManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the EssentialManifold M, i.e. X has to be a 2-element array of 3-by-3 skew-symmetric matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#ManifoldsBase.distance-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.distance","text":"distance(M::EssentialManifold, p, q)\n\nCompute the Riemannian distance between the two points p and q on the EssentialManifold. This is done by computing the distance of the equivalence classes p and q of the points p=(R_p_1R_p_2) q=(R_q_1R_q_2)  SO(3)^2, respectively. Two points in SO(3)^2 are equivalent iff their corresponding essential matrices, given by\n\nE = R_1^T e_z_R_2\n\nare equal (up to a sign flip). Using the logarithmic map, the distance is given by\n\ntextdist(pq) =  textlog_p q  =  log_p (S_z(t_textopt)q) \n\nwhere S_z  H_z = (R_z(θ)R_z(θ))colon θ in -ππ)  in which R_z(θ) is the rotation around the z axis with angle θ and t_textopt is the minimizer of the cost function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nwhere d() is the distance function in SO(3) [TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#ManifoldsBase.is_flat-Tuple{EssentialManifold}","page":"Essential manifold","title":"ManifoldsBase.is_flat","text":"is_flat(::EssentialManifold)\n\nReturn false. EssentialManifold is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#ManifoldsBase.manifold_dimension-Tuple{EssentialManifold}","page":"Essential manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::EssentialManifold{is_signed, ℝ})\n\nReturn the manifold dimension of the EssentialManifold, which is 5[TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#ManifoldsBase.parallel_transport_to-Tuple{EssentialManifold, Any, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::EssentialManifold, p, X, q)\n\nCompute the vector transport of the tangent vector X at p to q on the EssentialManifold M using left translation of the ambient group.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#ManifoldsBase.project-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.project","text":"project(M::EssentialManifold, p, X)\n\nProject the matrix X onto the tangent space\n\nT_p textSO(3)^2 = T_textvptextSO(3)^2  T_texthptextSO(3)^2\n\nby first computing its projection onto the vertical space T_textvptextSO(3)^2 using vert_proj. Then the orthogonal projection of X onto the horizontal space T_texthptextSO(3)^2 is defined as\n\nPi_h(X) = X - fractextvert_proj_p(X)2 beginbmatrix R_1^T e_z  R_2^T e_z endbmatrix\n\nwith R_i = R_0 R_i i=12 where R_i is part of the pose of camera i g_i = (R_iT_i)  textSE(3) and R_0  textSO(3) such that R_0(T_2-T_1) = e_z.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#Internal-Functions","page":"Essential manifold","title":"Internal Functions","text":"","category":"section"},{"location":"manifolds/essentialmanifold/#Manifolds.dist_min_angle_pair-Tuple{Any, Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair","text":"dist_min_angle_pair(p, q)\n\nThis function computes the global minimizer of the function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nfor the given values. This is done by finding the discontinuity points t_d_i i=12 of its derivative and using Newton's method to minimize the function over the intervals t_d_1t_d_2 and t_d_2t_d_1+2π separately. Then, the minimizer for which f is minimal is chosen and given back together with the minimal value. For more details see Algorithm 1 in [TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#Manifolds.dist_min_angle_pair_compute_df_break-Tuple{Any, Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair_compute_df_break","text":"dist_min_angle_pair_compute_df_break(t_break, q)\n\nThis function computes the derivatives of each term f_i i=12 at discontinuity point t_break. For more details see [TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#Manifolds.dist_min_angle_pair_df_newton-NTuple{9, Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair_df_newton","text":"dist_min_angle_pair_df_newton(m1, Φ1, c1, m2, Φ2, c2, t_min, t_low, t_high)\n\nThis function computes the minimizer of the function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nin the interval t_low, t_high using Newton's method. For more details see [TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#Manifolds.dist_min_angle_pair_discontinuity_distance-Tuple{Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair_discontinuity_distance","text":"dist_min_angle_pair_discontinuity_distance(q)\n\nThis function computes the point t_textdi for which the first derivative of\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\ndoes not exist. This is the case for sin(θ_i(t_textdi)) = 0. For more details see Proposition 9 and its proof, as well as Lemma 1 in [TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#Manifolds.vert_proj-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"Manifolds.vert_proj","text":"vert_proj(M::EssentialManifold, p, X)\n\nProject X onto the vertical space T_textvptextSO(3)^2 with\n\ntextvert_proj_p(X) = e_z^T(R_1 X_1 + R_2 X_2)\n\nwhere e_z is the third unit vector, X_i  T_ptextSO(3) for i=12 and it holds R_i = R_0 R_i i=12 where R_i is part of the pose of camera i g_i = (R_iT_i)  textSE(3) and R_0  textSO(3) such that R_0(T_2-T_1) = e_z [TD17].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold/#Literature","page":"Essential manifold","title":"Literature","text":"","category":"section"},{"location":"manifolds/power/#PowerManifoldSection","page":"Power manifold","title":"Power manifold","text":"","category":"section"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"A power manifold is based on a AbstractManifold  mathcal M to build a mathcal M^n_1n_2 n_m. In the case where m=1 we can represent a manifold-valued vector of data of length n_1, for example a time series. The case where m=2 is useful for representing manifold-valued matrices of data of size n_1n_2, for example certain types of images.","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"There are three available representations for points and vectors on a power manifold:","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"ArrayPowerRepresentation (the default one), very efficient but only applicable when points on the underlying manifold are represented using plain AbstractArrays.\nNestedPowerRepresentation, applicable to any manifold. It assumes that points on the underlying manifold are represented using mutable data types.\nNestedReplacingPowerRepresentation, applicable to any manifold. It does not mutate points on the underlying manifold, replacing them instead when appropriate.","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"Below are some examples of usage of these representations.","category":"page"},{"location":"manifolds/power/#Example","page":"Power manifold","title":"Example","text":"","category":"section"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"There are two ways to store the data: in a multidimensional array or in a nested array.","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"Let's look at an example for both. Let mathcal M be Sphere(2) the 2-sphere and we want to look at vectors of length 4.","category":"page"},{"location":"manifolds/power/#ArrayPowerRepresentation","page":"Power manifold","title":"ArrayPowerRepresentation","text":"","category":"section"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"For the default, the ArrayPowerRepresentation, we store the data in a multidimensional array,","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), 4)\np = cat([1.0, 0.0, 0.0],\n        [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n        [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n        [0.0, 1.0, 0.0]\n    ,dims=2)","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"which is a valid point i.e.","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"is_point(M, p)","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"This can also be used in combination with HybridArrays.jl and StaticArrays.jl, by setting","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"using HybridArrays, StaticArrays\nq = HybridArray{Tuple{3,StaticArrays.Dynamic()},Float64,2}(p)","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"which is still a valid point on M and PowerManifold works with these, too.","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"An advantage of this representation is that it is quite efficient, especially when a HybridArray (from the HybridArrays.jl package) is used to represent a point on the power manifold. A disadvantage is not being able to easily identify parts of the multidimensional array that correspond to a single point on the base manifold. Another problem is, that accessing a single point is p[:, 1] which might be unintuitive.","category":"page"},{"location":"manifolds/power/#NestedPowerRepresentation","page":"Power manifold","title":"NestedPowerRepresentation","text":"","category":"section"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"For the NestedPowerRepresentation we can now do","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), NestedPowerRepresentation(), 4)\np = [ [1.0, 0.0, 0.0],\n      [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n      [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n      [0.0, 1.0, 0.0],\n    ]","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"which is again a valid point so is_point(M, p) here also yields true. A disadvantage might be that with nested arrays one loses a little bit of performance. The data however is nicely encapsulated. Accessing the first data item is just p[1].","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"For accessing points on power manifolds in both representations you can use get_component and set_component! functions. They work work both point representations.","category":"page"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), NestedPowerRepresentation(), 4)\np = [ [1.0, 0.0, 0.0],\n      [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n      [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n      [0.0, 1.0, 0.0],\n    ]\nset_component!(M, p, [0.0, 0.0, 1.0], 4)\nget_component(M, p, 4)","category":"page"},{"location":"manifolds/power/#NestedReplacingPowerRepresentation","page":"Power manifold","title":"NestedReplacingPowerRepresentation","text":"","category":"section"},{"location":"manifolds/power/","page":"Power manifold","title":"Power manifold","text":"The final representation is the NestedReplacingPowerRepresentation. It is similar to the NestedPowerRepresentation but it does not perform in-place operations on the points on the underlying manifold.","category":"page"},{"location":"manifolds/power/#Types-and-Functions","page":"Power manifold","title":"Types and Functions","text":"","category":"section"},{"location":"manifolds/power/#Manifolds.ArrayPowerRepresentation","page":"Power manifold","title":"Manifolds.ArrayPowerRepresentation","text":"ArrayPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using multidimensional arrays where first dimensions are equal to representation_size of the wrapped manifold and the following ones are equal to the number of elements in each direction.\n\nTorus uses this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power/#Manifolds.PowerMetric","page":"Power manifold","title":"Manifolds.PowerMetric","text":"PowerMetric <: AbstractMetric\n\nRepresent the AbstractMetric on an AbstractPowerManifold, i.e. the inner product on the tangent space is the sum of the inner product of each elements tangent space of the power manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power/#ManifoldDiff.riemannian_Hessian-Tuple{AbstractPowerManifold, Vararg{Any, 4}}","page":"Power manifold","title":"ManifoldDiff.riemannian_Hessian","text":"Y = riemannian_Hessian(M::AbstractPowerManifold, p, G, H, X)\nriemannian_Hessian!(M::AbstractPowerManifold, Y, p, G, H, X)\n\nCompute the Riemannian Hessian operatornameHess f(p)X given the Euclidean gradient  f(tilde p) in G and the Euclidean Hessian ^2 f(tilde p)tilde X in H, where tilde p tilde X are the representations of pX in the embedding,.\n\nOn an abstract power manifold, this decouples and can be computed elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power/#Manifolds.flat-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Power manifold","title":"Manifolds.flat","text":"flat(M::AbstractPowerManifold, p, X)\n\nuse the musical isomorphism to transform the tangent vector X from the tangent space at p on an AbstractPowerManifold  M to a cotangent vector. This can be done elementwise for each entry of X (and p).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power/#Manifolds.manifold_volume-Tuple{PowerManifold}","page":"Power manifold","title":"Manifolds.manifold_volume","text":"manifold_volume(M::PowerManifold)\n\nReturn the manifold volume of an PowerManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power/#Manifolds.sharp-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Power manifold","title":"Manifolds.sharp","text":"sharp(M::AbstractPowerManifold, p, ξ::RieszRepresenterCotangentVector)\n\nUse the musical isomorphism to transform the cotangent vector ξ from the tangent space at p on an AbstractPowerManifold  M to a tangent vector. This can be done elementwise for every entry of ξ (and p).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power/#Manifolds.volume_density-Tuple{PowerManifold, Any, Any}","page":"Power manifold","title":"Manifolds.volume_density","text":"volume_density(M::PowerManifold, p, X)\n\nReturn volume density on the PowerManifold M, i.e. product of constituent volume densities.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Rotations","page":"Rotations","title":"Rotations","text":"","category":"section"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"The manifold mathrmSO(n) of orthogonal matrices with determinant +1 in ℝ^nn, i.e.","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"mathrmSO(n) = biglR  ℝ^nn big R R^mathrmT =\nR^mathrmTR = I_n det(R) = 1 bigr","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"The tangent space to a point p  mathrmSO(n) is given by","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"T_pmathrmSO(n) = X  X=pYqquad Y=-Y^mathrmT","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"i.e. all vectors that are a product of a skew symmetric matrix multiplied with p.","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"Since the orthogonal matrices mathrmSO(n) are a Lie group, tangent vectors can also be represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. In the notation above, this means we just store the component Y of X.","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"Let L_R mathrmSO(n)  mathrmSO(n) where R  mathrmSO(n) be the left-multiplication by R, that is L_R(S) = RS. The tangent space at rotation R, T_R mathrmSO(n), is related to the tangent space at the identity rotation I_n by the differential of L_R at identity, (mathrmdL_R)_I_n  T_I_n mathrmSO(n)  T_R mathrmSO(n). To convert the tangent vector representation at the identity rotation X  T_I_n mathrmSO(n) (i.e., the default) to the matrix representation of the corresponding tangent vector Y at a rotation R use the embed which implements the following multiplication: Y = RX  T_R mathrmSO(n). You can compare the functions log and exp to see how it works in practice.","category":"page"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"Several common functions are also implemented together with orthogonal and unitary matrices.","category":"page"},{"location":"manifolds/rotations/#Manifolds.Rotations","page":"Rotations","title":"Manifolds.Rotations","text":"Rotations{T} <: AbstractManifold{ℝ}\n\nThe manifold of rotation matrices of size nn, i.e. real-valued orthogonal matrices with determinant +1.\n\nConstructor\n\nRotations(n::Int; parameter::Symbol=:type)\n\nGenerate the manifold of nn rotation matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations/#ManifoldDiff.jacobian_exp_argument-Tuple{Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Rotations","title":"ManifoldDiff.jacobian_exp_argument","text":"jacobian_exp_argument(M::Rotations{TypeParameter{Tuple{2}}}, p, X)\n\nCompute Jacobian of the exponential map with respect to the argument X in orthonormal coordinates on the Rotations(2) manifold. It is equal to matrix 1, see [SDA21], Appendix A.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldDiff.jacobian_exp_argument-Tuple{Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Rotations","title":"ManifoldDiff.jacobian_exp_argument","text":"jacobian_exp_argument(M::Rotations{TypeParameter{Tuple{3}}}, p, X)\n\nCompute Jacobian of the exponential map with respect to the argument X in orthonormal coordinates on the Rotations(3) manifold. The formula reads\n\n𝕀 + fraccos(θ) - 1θ^2 X + fracθ - sin(θ)θ^3 X^2\n\nwhere θ is the norm of X. It is adapted from [Chi12], Eq. (10.86), to Manifolds.jl conventions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldDiff.riemannian_Hessian-Tuple{Rotations, Vararg{Any, 4}}","page":"Rotations","title":"ManifoldDiff.riemannian_Hessian","text":"riemannian_Hessian(M::Rotations, p, G, H, X)\n\nThe Riemannian Hessian can be computed by adopting Eq. (5.6) [Ngu23], so very similar to the Stiefel manifold. The only difference is, that here the tangent vectors are stored in the Lie algebra, i.e. the update direction is actually pX instead of just X (in Stiefel). and that means the inverse has to be applied to the (Euclidean) Hessian to map it into the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manifolds._exp_half-Tuple{Rotations, Any}","page":"Rotations","title":"Manifolds._exp_half","text":"_exp_half(::Rotations, d)\n\nCalculate exp(d / 2).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manifolds._exp_half-Tuple{Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Rotations","title":"Manifolds._exp_half","text":"_exp_half(::Rotations{TypeParameter{Tuple{3}}}, d)\n\nCalculate exp(d / 2) for the manifold of Rotations(3) based on the Rodrigues' rotation formula.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra of Rotations(4) in ℝ^44, 𝔰𝔬(4), consists of 44 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order (corresponding to the same ordering of angles as cos_angles_4d_rotation_matrix).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manifolds.normal_rotation_distribution","page":"Rotations","title":"Manifolds.normal_rotation_distribution","text":"normal_rotation_distribution(M::Rotations, p, σ::Real)\n\nReturn a random point on the manifold Rotations M by generating a (Gaussian) random orthogonal matrix with determinant +1. Let\n\nQR = A\n\nbe the QR decomposition of a random matrix A, then the formula reads\n\np = QD\n\nwhere D is a diagonal matrix with the signs of the diagonal entries of R, i.e.\n\nD_ij=begincases\n operatornamesgn(R_ij)  textif  i=j \n 0   textotherwise\nendcases\n\nIt can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.\n\nThe argument p is used to determine the type of returned points.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/rotations/#ManifoldsBase.Weingarten-Tuple{Rotations, Any, Any, Any}","page":"Rotations","title":"ManifoldsBase.Weingarten","text":"Weingarten(M::Rotations, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the Stiefel M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nThe formula is due to [AMT13] given by\n\nmathcal W_p(XV) = -frac12pbigl(V^mathrmTX - X^mathrmTVbigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.injectivity_radius-Tuple{Rotations, PolarRetraction}","page":"Rotations","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Rotations, ::PolarRetraction)\n\nReturn the radius of injectivity for the PolarRetraction on the Rotations M which is fracπsqrt2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, PolarInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, p, q, ::PolarInverseRetraction)\n\nCompute a vector from the tangent space T_pmathrmSO(n) of the point p on the Rotations manifold M with which the point q can be reached by the PolarRetraction from the point p after time 1.\n\nThe formula reads\n\noperatornameretr^-1_p(q)\n= -frac12(p^mathrmTqs - (p^mathrmTqs)^mathrmT)\n\nwhere s is the solution to the Sylvester equation\n\np^mathrmTqs + s(p^mathrmTq)^mathrmT + 2I_n = 0\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, QRInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Rotations, p, q, ::QRInverseRetraction)\n\nCompute a vector from the tangent space T_pmathrmSO(n) of the point p on the Rotations manifold M with which the point q can be reached by the QRRetraction from the point q after time 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.parallel_transport_direction-Tuple{Rotations, Any, Any, Any}","page":"Rotations","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::Rotations, p, X, d)\n\nCompute parallel transport of vector X tangent at p on the Rotations manifold in the direction d. The formula, provided in [Ren11], reads:\n\nmathcal P_qgets pX = q^mathrmTp operatornameExp(d2) X operatornameExp(d2)\n\nwhere q=exp_p d.\n\nThe formula simplifies to identity for 2-D rotations.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.project-Tuple{Rotations, Any}","page":"Rotations","title":"ManifoldsBase.project","text":"project(M::Rotations, p; check_det = true)\n\nProject p to the nearest point on manifold M.\n\nGiven the singular value decomposition p = U Σ V^mathrmT, with the singular values sorted in descending order, the projection is\n\noperatornameproj_mathrmSO(n)(p) =\nUoperatornamediagleft11det(U V^mathrmT)right V^mathrmT\n\nThe diagonal matrix ensures that the determinant of the result is +1. If p is expected to be almost special orthogonal, then you may avoid this check with check_det = false.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.sectional_curvature_max-Tuple{Rotations}","page":"Rotations","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(::Rotations)\n\nSectional curvature of Rotations M is equal to 0 for Rotations(1) and Rotations(2), less than or equal to 1/8 for Rotations(3) and less than or equal to 1/4 for higher-dimensional rotations manifolds.\n\nFor reference, see [Ge14], Lemma 2.5 and [CE08], Corollary 3.19.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.sectional_curvature_min-Tuple{Rotations}","page":"Rotations","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::Rotations)\n\nSectional curvature of Rotations M is greater than or equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#ManifoldsBase.zero_vector-Tuple{Rotations, Any}","page":"Rotations","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Rotations, p)\n\nReturn the zero tangent vector from the tangent space art p on the Rotations as an element of the Lie group, i.e. the zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Literature","page":"Rotations","title":"Literature","text":"","category":"section"},{"location":"manifolds/rotations/","page":"Rotations","title":"Rotations","text":"P. -.-A. Absil, R. Mahony and J. Trumpf. An Extrinsic Look at the Riemannian Hessian. In: Geometric Science of Information, edited by F. Nielsen and F. Barbaresco (Springer Berlin Heidelberg, 2013); pp. 361–368.\n\n\n\nJ. Cheeger and D. G. Ebin. Comparison Theorems in Riemannian Geometry (American Mathematical Society, Providence, R.I, 2008).\n\n\n\nG. S. Chirikjian. Stochastic Models, Information Theory, and Lie Groups, Volume 2. 1 Edition, Vol. 2 of Applied and Numerical Harmonic Analysis (Birkhäuser Boston, MA, 2012).\n\n\n\nJ. Ge. DDVV-type inequality for skew-symmetric matrices and Simons-type inequality for Riemannian submersions. Advances in Mathematics 251, 62–86 (2014).\n\n\n\nD. Nguyen. Operator-Valued Formulas for Riemannian Gradient and Hessian and Families of Tractable Metrics in Riemannian Optimization. Journal of Optimization Theory and Applications 198, 135–164 (2023), arXiv:2009.10159.\n\n\n\nQ. Rentmeesters. A gradient method for geodesic data fitting on some symmetric Riemannian manifolds. In: IEEE Conference on Decision and Control and European Control Conference (2011); pp. 7141–7146.\n\n\n\nJ. Solà, J. Deray and D. Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"manifolds/generalizedgrassmann/#Generalized-Grassmann","page":"Generalized Grassmann","title":"Generalized Grassmann","text":"","category":"section"},{"location":"manifolds/generalizedgrassmann/#Manifolds.GeneralizedGrassmann","page":"Generalized Grassmann","title":"Manifolds.GeneralizedGrassmann","text":"GeneralizedGrassmann{𝔽,T,TB<:AbstractMatrix} <: AbstractDecoratorManifold{𝔽}\n\nThe generalized Grassmann manifold operatornameGr(nkB) consists of all subspaces spanned by k linear independent vectors 𝔽^n, where 𝔽   ℝ ℂ is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of ℝ^n for the real-valued case and all 2k-dimensional subspaces of ℂ^n for the second.\n\nThe manifold can be represented as\n\noperatornameGr(n k B) = bigl operatornamespan(p) big p  𝔽^nk p^mathrmHBp = I_k\n\nwhere ^mathrmH denotes the complex conjugate (or Hermitian) transpose and I_k is the kk identity matrix. This means, that the columns of p form an unitary basis of the subspace with respect to the scaled inner product, that is a point on operatornameGr(nkB), and hence the subspace can actually be represented by a whole equivalence class of representers. For B=I_n this simplifies to the Grassmann manifold.\n\nThe tangent space at a point (subspace) p is given by\n\nT_xmathrmGr(nkB) = bigl\nX  𝔽^nk \nX^mathrmHBp + p^mathrmHBX = 0_k bigr\n\nwhere 0_k denotes the kk zero matrix.\n\nNote that a point p  operatornameGr(nkB) might be represented by different matrices (i.e. matrices with B-unitary column vectors that span the same subspace). Different representations of p also lead to different representation matrices for the tangent space T_pmathrmGr(nkB)\n\nThe manifold is named after Hermann G. Graßmann (1809-1877).\n\nConstructor\n\nGeneralizedGrassmann(n, k, B=I_n, field=ℝ)\n\nGenerate the (real-valued) Generalized Grassmann manifold of nk dimensional orthonormal matrices with scalar product B.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalizedgrassmann/#Base.exp-Tuple{GeneralizedGrassmann, Vararg{Any}}","page":"Generalized Grassmann","title":"Base.exp","text":"exp(M::GeneralizedGrassmann, p, X)\n\nCompute the exponential map on the GeneralizedGrassmann M = mathrmGr(nkB) starting in p with tangent vector (direction) X. Let X^mathrmHBX = USV denote the SVD decomposition of X^mathrmHBX. Then the exponential map is written using\n\nexp_p X = p Vcos(S)V^mathrmH + Usin(S)V^mathrmH\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian and the cosine and sine are applied element wise to the diagonal entries of S.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#Base.log-Tuple{GeneralizedGrassmann, Vararg{Any}}","page":"Generalized Grassmann","title":"Base.log","text":"log(M::GeneralizedGrassmann, p, q)\n\nCompute the logarithmic map on the GeneralizedGrassmann M = mathcal M=mathrmGr(nkB), i.e. the tangent vector X whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = V operatornameatan(S)  U^mathrmH\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian. The matrices U and V are the unitary matrices, and S is the diagonal matrix containing the singular values of the SVD-decomposition\n\nUSV = (q^mathrmHBp)^-1 ( q^mathrmH - q^mathrmHBpp^mathrmH)\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#Base.rand-Tuple{GeneralizedGrassmann}","page":"Generalized Grassmann","title":"Base.rand","text":"rand(::GeneralizedGrassmann; vector_at=nothing, σ::Real=1.0)\n\nWhen vector_at is nothing, return a random (Gaussian) point p on the GeneralizedGrassmann manifold M by generating a (Gaussian) matrix with standard deviation σ and return the (generalized) orthogonalized version, i.e. return the projection onto the manifold of the Q component of the QR decomposition of the random matrix of size nk.\n\nWhen vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_vector_atmathrmSt(nk) with mean zero and standard deviation σ by projecting a random Matrix onto the tangent vector at vector_at.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.change_metric-Tuple{GeneralizedGrassmann, EuclideanMetric, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.change_metric","text":"change_metric(M::GeneralizedGrassmann, ::EuclideanMetric, p X)\n\nChange X to the corresponding vector with respect to the metric of the GeneralizedGrassmann M, i.e. let B=LL be the Cholesky decomposition of the matrix M.B, then the corresponding vector is LX.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.change_representer-Tuple{GeneralizedGrassmann, EuclideanMetric, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.change_representer","text":"change_representer(M::GeneralizedGrassmann, ::EuclideanMetric, p, X)\n\nChange X to the corresponding representer of a cotangent vector at p with respect to the scaled metric of the GeneralizedGrassmann M, i.e, since\n\ng_p(XY) = operatornametr(Y^mathrmHBZ) = operatornametr(X^mathrmHZ) = XZ\n\nhas to hold for all Z, where the repreenter X is given, the resulting representer with respect to the metric on the GeneralizedGrassmann is given by Y = B^-1X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.check_point-Tuple{GeneralizedGrassmann, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.check_point","text":"check_point(M::GeneralizedGrassmann, p)\n\nCheck whether p is representing a point on the GeneralizedGrassmann M, i.e. its a n-by-k matrix of unitary column vectors with respect to the B inner product and of correct eltype with respect to 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.check_vector-Tuple{GeneralizedGrassmann, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.check_vector","text":"check_vector(M::GeneralizedGrassmann, p, X; kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the GeneralizedGrassmann M, i.e. that X is of size and type as well as that\n\n    p^mathrmHBX + overlineX^mathrmHBp = 0_k\n\nwhere ^mathrmH denotes the complex conjugate transpose or Hermitian, overline the (elementwise) complex conjugate, and 0_k denotes the kk zero natrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.distance-Tuple{GeneralizedGrassmann, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.distance","text":"distance(M::GeneralizedGrassmann, p, q)\n\nCompute the Riemannian distance on GeneralizedGrassmann manifold M= mathrmGr(nkB).\n\nThe distance is given by\n\nd_mathrmGr(nkB)(pq) = operatornamenorm(log_p(q))\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.injectivity_radius-Tuple{GeneralizedGrassmann}","page":"Generalized Grassmann","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::GeneralizedGrassmann)\ninjectivity_radius(M::GeneralizedGrassmann, p)\n\nReturn the injectivity radius on the GeneralizedGrassmann M, which is fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.inner-Tuple{GeneralizedGrassmann, Any, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.inner","text":"inner(M::GeneralizedGrassmann, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the GeneralizedGrassmann manifold M. The formula reads\n\ng_p(XY) = operatornametr(X^mathrmHBY)\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.is_flat-Tuple{GeneralizedGrassmann}","page":"Generalized Grassmann","title":"ManifoldsBase.is_flat","text":"is_flat(M::GeneralizedGrassmann)\n\nReturn true if GeneralizedGrassmann M is one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.manifold_dimension-Union{Tuple{GeneralizedGrassmann{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Generalized Grassmann","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::GeneralizedGrassmann)\n\nReturn the dimension of the GeneralizedGrassmann(n,k,𝔽) manifold M, i.e.\n\ndim operatornameGr(nkB) = k(n-k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.project-Tuple{GeneralizedGrassmann, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.project","text":"project(M::GeneralizedGrassmann, p, X)\n\nProject the n-by-k X onto the tangent space of p on the GeneralizedGrassmann M, which is computed by\n\noperatornameproj_p(X) = X - pp^mathrmHB^mathrmTX\n\nwhere ^mathrmH denotes the complex conjugate transposed or Hermitian and ^mathrmT the transpose.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.project-Tuple{GeneralizedGrassmann, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.project","text":"project(M::GeneralizedGrassmann, p)\n\nProject p from the embedding onto the GeneralizedGrassmann M, i.e. compute q as the polar decomposition of p such that q^mathrmHBq is the identity, where ^mathrmH denotes the Hermitian, i.e. complex conjugate transpose.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.representation_size-Tuple{GeneralizedGrassmann}","page":"Generalized Grassmann","title":"ManifoldsBase.representation_size","text":"representation_size(M::GeneralizedGrassmann)\n\nReturn the representation size or matrix dimension of a point on the GeneralizedGrassmann M, i.e. (nk) for both the real-valued and the complex value case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.retract-Tuple{GeneralizedGrassmann, Any, Any, PolarRetraction}","page":"Generalized Grassmann","title":"ManifoldsBase.retract","text":"retract(M::GeneralizedGrassmann, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the GeneralizedGrassmann M, by projecting p + X onto M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#ManifoldsBase.zero_vector-Tuple{GeneralizedGrassmann, Vararg{Any}}","page":"Generalized Grassmann","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::GeneralizedGrassmann, p)\n\nReturn the zero tangent vector from the tangent space at p on the GeneralizedGrassmann M, which is given by a zero matrix the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann/#Statistics.mean-Tuple{GeneralizedGrassmann, Vararg{Any}}","page":"Generalized Grassmann","title":"Statistics.mean","text":"mean(\n    M::GeneralizedGrassmann,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian/#Skew-hermitian-matrices","page":"Skew-Hermitian matrices","title":"Skew-hermitian matrices","text":"","category":"section"},{"location":"manifolds/skewhermitian/#Manifolds.SkewHermitianMatrices","page":"Skew-Hermitian matrices","title":"Manifolds.SkewHermitianMatrices","text":"SkewHermitianMatrices{𝔽, T} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold  operatornameSkewHerm(n) consisting of the real- or complex-valued skew-hermitian matrices of size nn, i.e. the set\n\noperatornameSkewHerm(n) = biglp   𝔽^nn big p^mathrmH = -p bigr\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ ℍ.\n\nThough it is slightly redundant, usually the matrices are stored as nn arrays.\n\nNote that in this representation, the real-valued part of the diagonal must be zero, which is also reflected in the manifold_dimension.\n\nConstructor\n\nSkewHermitianMatrices(n::Int, field::AbstractNumbers=ℝ; parameter::Symbol=:type)\n\nGenerate the manifold of nn skew-hermitian matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/skewhermitian/#Manifolds.SkewSymmetricMatrices","page":"Skew-Hermitian matrices","title":"Manifolds.SkewSymmetricMatrices","text":"SkewSymmetricMatrices{T}\n\nGenerate the manifold of nn real skew-symmetric matrices. This is equivalent to SkewHermitianMatrices(n, ℝ).\n\nConstructor\n\nSkewSymmetricMatrices(n::Int)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/skewhermitian/#ManifoldsBase.Weingarten-Tuple{SkewSymmetricMatrices, Any, Any, Any}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::SkewSymmetricMatrices, p, X, V)\nWeingarten!(M::SkewSymmetricMatrices, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the SkewSymmetricMatrices M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian/#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{SkewHermitianMatrices{𝔽}, Any}} where 𝔽","page":"Skew-Hermitian matrices","title":"ManifoldsBase.check_point","text":"check_point(M::SkewHermitianMatrices, p; kwargs...)\n\nCheck whether p is a valid manifold point on the SkewHermitianMatrices M, i.e. whether p is a skew-hermitian matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽.\n\nThe tolerance for the skew-symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian/#ManifoldsBase.check_vector-Tuple{SkewHermitianMatrices, Any, Any}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::SkewHermitianMatrices, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SkewHermitianMatrices M, i.e. X must be a skew-hermitian matrix of size (n,n) and its values have to be from the correct AbstractNumbers. The tolerance for the skew-symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian/#ManifoldsBase.is_flat-Tuple{SkewHermitianMatrices}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::SkewHermitianMatrices)\n\nReturn true. SkewHermitianMatrices is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian/#ManifoldsBase.manifold_dimension-Union{Tuple{SkewHermitianMatrices{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Skew-Hermitian matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SkewHermitianMatrices)\n\nReturn the dimension of the SkewHermitianMatrices matrix M over the number system 𝔽, i.e.\n\ndim mathrmSkewHerm(nℝ) = fracn(n+1)2 dim_ℝ 𝔽 - n\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽. The first term corresponds to only the upper triangular elements of the matrix being unique, and the second term corresponds to the constraint that the real part of the diagonal be zero.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian/#ManifoldsBase.project-Tuple{SkewHermitianMatrices, Any, Any}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.project","text":"project(M::SkewHermitianMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SkewHermitianMatrices M,\n\noperatornameproj_p(X) = frac12 bigl( X - X^mathrmH bigr)\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian/#ManifoldsBase.project-Tuple{SkewHermitianMatrices, Any}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.project","text":"project(M::SkewHermitianMatrices, p)\n\nProjects p from the embedding onto the SkewHermitianMatrices M, i.e.\n\noperatornameproj_operatornameSkewHerm(n)(p) = frac12 bigl( p - p^mathrmH bigr)\n\nwhere ^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/invertible/#Invertible-matrices","page":"Invertible matrices","title":"Invertible matrices","text":"","category":"section"},{"location":"manifolds/invertible/#Manifolds.InvertibleMatrices","page":"Invertible matrices","title":"Manifolds.InvertibleMatrices","text":"InvertibleMatrices{𝔽,T} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold consisting of the real- or complex-valued invertible matrices, that is the set\n\nbiglp   𝔽^nn big det(p) neq 0 bigr\n\nwhere the field 𝔽   ℝ ℂ.\n\nConstructor\n\nInvertibleMatrices(n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of nn invertible matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/invertible/#Base.rand-Tuple{InvertibleMatrices}","page":"Invertible matrices","title":"Base.rand","text":"Random.rand(M::InvertibleMatrices; vector_at=nothing, kwargs...)\n\nIf vector_at is nothing, return a random point on the InvertibleMatrices manifold M by using rand in the embedding.\n\nIf vector_at is not nothing, return a random tangent vector from the tangent space of the point vector_at on the InvertibleMatrices by using by using rand in the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/invertible/#ManifoldsBase.Weingarten-Tuple{InvertibleMatrices, Any, Any, Any}","page":"Invertible matrices","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::InvertibleMatrices, p, X, V)\nWeingarten!(M::InvertibleMatrices, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_p at p on the InvertibleMatrices M with respect to the tangent vector X in T_pmathcal M and the normal vector V in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/invertible/#ManifoldsBase.check_point-Tuple{InvertibleMatrices, Any}","page":"Invertible matrices","title":"ManifoldsBase.check_point","text":"check_point(M::InvertibleMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether p is a valid manifold point on the InvertibleMatrices M, i.e. whether p is an invertible matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/invertible/#ManifoldsBase.check_vector-Tuple{InvertibleMatrices, Any, Any}","page":"Invertible matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::InvertibleMatrices{n,𝔽}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the InvertibleMatrices M, which are all matrices of size nn its values have to be from the correct AbstractNumbers.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/invertible/#ManifoldsBase.is_flat-Tuple{InvertibleMatrices}","page":"Invertible matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::InvertibleMatrices)\n\nReturn true. InvertibleMatrices is a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/invertible/#ManifoldsBase.manifold_dimension-Union{Tuple{InvertibleMatrices{<:Any, 𝔽}}, Tuple{𝔽}} where 𝔽","page":"Invertible matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::InvertibleMatrices{n,𝔽})\n\nReturn the dimension of the InvertibleMatrices matrix M over the number system 𝔽, which is the same dimension as its embedding, the Euclidean(n, n; field=𝔽).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#Tucker","page":"Tucker","title":"Tucker manifold","text":"","category":"section"},{"location":"manifolds/tucker/#Manifolds.Tucker","page":"Tucker","title":"Manifolds.Tucker","text":"Tucker{T, D, 𝔽} <: AbstractManifold{𝔽}\n\nThe manifold of N_1dotsN_D real-valued or complex-valued tensors of fixed multilinear rank (R_1 dots R_D) . If R_1 = dots = R_D = 1, this is the Segre manifold, i.e., the set of rank-1 tensors.\n\nRepresentation in HOSVD format\n\nLet 𝔽 be the real or complex numbers. Any tensor p on the Tucker manifold can be represented as a multilinear product in HOSVD [LMV00] form\n\np = (U_1dotsU_D)  mathcalC\n\nwhere mathcal C in 𝔽^R_1dotsR_D and, for d=1dotsD, the matrix U_d in 𝔽^N_dR_d contains the singular vectors of the dth unfolding of mathcalA\n\nTangent space\n\nThe tangent space to the Tucker manifold at p = (U_1dotsU_D)  mathcalC is [KL10]\n\nT_p mathcalM =\nbigl\n(U_1dotsU_D)  mathcalC^prime\n+ sum_d=1^D bigl(\n    (U_1 dots U_d-1 U_d^prime U_d+1 dots U_D)\n     mathcalC\nbigr)\nbigr\n\nwhere mathcalC^prime is arbitrary, U_d^mathrmH is the Hermitian adjoint of U_d, and U_d^mathrmH U_d^prime = 0 for all d.\n\nConstructor\n\nTucker(N::NTuple{D, Int}, R::NTuple{D, Int}[, field=ℝ]; parameter::Symbol=:type)\n\nGenerate the manifold of field-valued tensors of dimensions  N[1] × … × N[D] and multilinear rank R = (R[1], …, R[D]).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/tucker/#Manifolds.TuckerPoint","page":"Tucker","title":"Manifolds.TuckerPoint","text":"TuckerPoint{T,D}\n\nAn order D tensor of fixed multilinear rank and entries of type T, which makes it a point on the Tucker manifold. The tensor is represented in HOSVD form.\n\nConstructors:\n\nTuckerPoint(core::AbstractArray{T,D}, factors::Vararg{<:AbstractMatrix{T},D}) where {T,D}\n\nConstruct an order D tensor of element type T that can be represented as the multilinear product (factors[1], …, factors[D]) ⋅ core. It is assumed that the dimensions of the core are the multilinear rank of the tensor and that the matrices factors each have full rank. No further assumptions are made.\n\nTuckerPoint(p::AbstractArray{T,D}, mlrank::NTuple{D,Int}) where {T,D}\n\nThe low-multilinear rank tensor arising from the sequentially truncated the higher-order singular value decomposition of the D-dimensional array p of type T. The singular values are truncated to get a multilinear rank mlrank [VVM12].\n\n\n\n\n\n","category":"type"},{"location":"manifolds/tucker/#Manifolds.TuckerTangentVector","page":"Tucker","title":"Manifolds.TuckerTangentVector","text":"TuckerTangentVector{T, D} <: AbstractTangentVector\n\nTangent vector to the D-th order Tucker manifold at p = (U_1dotsU_D)  mathcalC. The numbers are of type T and the vector is represented as\n\nX =\n(U_1dotsU_D)  mathcalC^prime +\nsum_d=1^D (U_1dotsU_d-1U_d^primeU_d+1dotsU_D)  mathcalC\n\nwhere U_d^mathrmH U_d^prime = 0.\n\nConstructor\n\nTuckerTangentVector(C′::Array{T,D}, U′::NTuple{D,Matrix{T}}) where {T,D}\n\nConstructs a Dth order TuckerTangentVector of number type T with C^prime and U^prime, so that, together with a TuckerPoint p as above, the tangent vector can be represented as X in the above expression.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/tucker/#Base.convert-Union{Tuple{D}, Tuple{T}, Tuple{𝔽}, Tuple{Type{Matrix{T}}, CachedBasis{𝔽, DefaultOrthonormalBasis{𝔽, TangentSpaceType}, Manifolds.HOSVDBasis{T, D}}}} where {𝔽, T, D}","page":"Tucker","title":"Base.convert","text":"Base.convert(::Type{Matrix{T}}, basis::CachedBasis{𝔽,DefaultOrthonormalBasis{𝔽, TangentSpaceType},HOSVDBasis{T, D}}) where {𝔽, T, D}\nBase.convert(::Type{Matrix}, basis::CachedBasis{𝔽,DefaultOrthonormalBasis{𝔽, TangentSpaceType},HOSVDBasis{T, D}}) where {𝔽, T, D}\n\nConvert a HOSVD-derived cached basis from [DBV21] of the Dth order Tucker manifold with number type T to a matrix. The columns of this matrix are the vectorisations of the embeddings of the basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#Base.foreach","page":"Tucker","title":"Base.foreach","text":"Base.foreach(f, M::Tucker, p::TuckerPoint, basis::AbstractBasis, indices=1:manifold_dimension(M))\n\nLet basis be and AbstractBasis at a point p on M. Suppose f is a function that takes an index and a vector as an argument. This function applies f to i and the ith basis vector sequentially for each i in indices. Using a CachedBasis may speed up the computation.\n\nNOTE: The i'th basis vector is overwritten in each iteration. If any information about the vector is to be stored, f must make a copy.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/tucker/#Base.ndims-Union{Tuple{TuckerPoint{T, D}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Tucker","title":"Base.ndims","text":"Base.ndims(p::TuckerPoint{T,D}) where {T,D}\n\nThe order of the tensor corresponding to the TuckerPoint p, i.e., D.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#Base.size-Tuple{TuckerPoint}","page":"Tucker","title":"Base.size","text":"Base.size(p::TuckerPoint)\n\nThe dimensions of a TuckerPoint p, when regarded as a full tensor (see embed).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.check_point-Tuple{Tucker, Any}","page":"Tucker","title":"ManifoldsBase.check_point","text":"check_point(M::Tucker, p; kwargs...)\n\nCheck whether the multidimensional array or TuckerPoint p is a point on the Tucker manifold, i.e. it is a Dth order N[1] × … × N[D] tensor of multilinear rank (R[1], …, R[D]). The keyword arguments are passed to the matrix rank function applied to the unfoldings. For a TuckerPoint it is checked that the point is in correct HOSVD form.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{D}, Tuple{T}, Tuple{Tucker{𝔽, <:Any, D}, TuckerPoint{T, D}, TuckerTangentVector}} where {T, D, 𝔽}","page":"Tucker","title":"ManifoldsBase.check_vector","text":"check_vector(M::Tucker{<:Any,D}, p::TuckerPoint{T,D}, X::TuckerTangentVector) where {T,D}\n\nCheck whether a TuckerTangentVector X is is in the tangent space to the Dth order Tucker manifold M at the Dth order TuckerPoint p. This is the case when the dimensions of the factors in X agree with those of p and the factor matrices of X are in the orthogonal complement of the HOSVD factors of p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.embed-Tuple{Tucker, TuckerPoint, TuckerTangentVector}","page":"Tucker","title":"ManifoldsBase.embed","text":"embed(::Tucker, p::TuckerPoint, X::TuckerTangentVector)\n\nConvert a tangent vector X with base point p on the rank R Tucker manifold to a full tensor, represented as an N[1] × … × N[D]-array.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.embed-Tuple{Tucker, TuckerPoint}","page":"Tucker","title":"ManifoldsBase.embed","text":"embed(::Tucker, p::TuckerPoint)\n\nConvert a TuckerPoint p on the rank R Tucker manifold to a full N[1] × … × N[D]-array by evaluating the Tucker decomposition.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.get_basis-Union{Tuple{𝔽}, Tuple{Tucker, TuckerPoint}, Tuple{Tucker, TuckerPoint, DefaultOrthonormalBasis{𝔽, TangentSpaceType}}} where 𝔽","page":"Tucker","title":"ManifoldsBase.get_basis","text":"get_basis(:: Tucker, p::TuckerPoint, basisType::DefaultOrthonormalBasis{𝔽, TangentSpaceType}) where 𝔽\n\nAn implicitly stored basis of the tangent space to the Tucker manifold. Assume p = (U_1dotsU_D)  mathcalC is in HOSVD format and that, for d=1dotsD, the singular values of the d'th unfolding are sigma_dj, with j = 1dotsR_d. The basis of the tangent space is as follows: [DBV21]\n\nbigl\n(U_1dotsU_D) e_i\nbigr cup bigl\n(U_1dots sigma_dj^-1 U_d^perp e_i e_j^TdotsU_D)  mathcalC\nbigr\n\nfor all d = 1dotsD and all canonical basis vectors e_i and e_j. Every U_d^perp is such that U_d quad U_d^perp forms an orthonormal basis of ℝ^N_d.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.inner-Tuple{Tucker, TuckerPoint, TuckerTangentVector, TuckerTangentVector}","page":"Tucker","title":"ManifoldsBase.inner","text":"inner(M::Tucker, p::TuckerPoint, X::TuckerTangentVector, Y::TuckerTangentVector)\n\nThe Euclidean inner product between tangent vectors X and X at the point p on the Tucker manifold. This is equal to embed(M, p, X) ⋅ embed(M, p, Y).\n\ninner(::Tucker, A::TuckerPoint, X::TuckerTangentVector, Y)\ninner(::Tucker, A::TuckerPoint, X, Y::TuckerTangentVector)\n\nThe Euclidean inner product between X and Y where X is a vector tangent to the Tucker manifold at p and Y is a vector in the ambient space or vice versa. The vector in the ambient space is represented as a full tensor, i.e., a multidimensional array.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.inverse_retract-Tuple{Tucker, Any, TuckerPoint, TuckerPoint, ProjectionInverseRetraction}","page":"Tucker","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Tucker, p::TuckerPoint, q::TuckerPoint, ::ProjectionInverseRetraction)\n\nThe projection inverse retraction on the Tucker manifold interprets q as a point in the ambient Euclidean space (see embed) and projects it onto the tangent space at to M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.is_flat-Tuple{Tucker}","page":"Tucker","title":"ManifoldsBase.is_flat","text":"is_flat(::Tucker)\n\nReturn false. Tucker is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.manifold_dimension-Tuple{Tucker}","page":"Tucker","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(::Tucker)\n\nThe dimension of the manifold of N_1dotsN_D tensors of multilinear rank (R_1 dots R_D), i.e.\n\nmathrmdim(mathcalM) = prod_d=1^D R_d + sum_d=1^D R_d (N_d - R_d)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.project-Tuple{Tucker, Any, TuckerPoint, Any}","page":"Tucker","title":"ManifoldsBase.project","text":"project(M::Tucker, p::TuckerPoint, X)\n\nThe least-squares projection of a dense tensor X onto the tangent space to M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.retract-Tuple{Tucker, Any, Any, PolarRetraction}","page":"Tucker","title":"ManifoldsBase.retract","text":"retract(::Tucker, p::TuckerPoint, X::TuckerTangentVector, ::PolarRetraction)\n\nThe truncated HOSVD-based retraction [KSV13] to the Tucker manifold, i.e. the result is the sequentially truncated HOSVD approximation of p + X.\n\nIn the exceptional case that the multilinear rank of p + X is lower than that of p, this retraction produces a boundary point, which is outside the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#ManifoldsBase.zero_vector-Tuple{Tucker, TuckerPoint}","page":"Tucker","title":"ManifoldsBase.zero_vector","text":"zero_vector(::Tucker, p::TuckerPoint)\n\nThe zero element in the tangent space to p on the Tucker manifold, represented as a TuckerTangentVector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker/#Literature","page":"Tucker","title":"Literature","text":"","category":"section"},{"location":"manifolds/tucker/","page":"Tucker","title":"Tucker","text":"N. Dewaele, P. Breiding and N. Vannieuwenhoven. The condition number of many tensor decompositions is invariant under Tucker compression, arXiv Preprint (2021), arXiv:2106.13034.\n\n\n\nO. Koch and C. Lubich. Dynamical Tensor Approximation. SIAM Journal on Matrix Analysis and Applications 31, 2360–2375 (2010).\n\n\n\nD. Kressner, M. Steinlechner and B. Vandereycken. Low-rank tensor completion by Riemannian optimization. BIT Numerical Mathematics 54, 447–468 (2013).\n\n\n\nL. D. Lathauwer, B. D. Moor and J. Vandewalle. A Multilinear Singular Value Decomposition. SIAM Journal on Matrix Analysis and Applications 21, 1253–1278 (2000).\n\n\n\nN. Vannieuwenhoven, R. Vandebril and K. Meerbergen. A New Truncation Strategy for the Higher-Order Singular Value Decomposition. SIAM Journal on Scientific Computing 34, A1027–A1052 (2012).\n\n\n\n","category":"page"},{"location":"manifolds/elliptope/#Elliptope","page":"Elliptope","title":"Elliptope","text":"","category":"section"},{"location":"manifolds/elliptope/#Manifolds.Elliptope","page":"Elliptope","title":"Manifolds.Elliptope","text":"Elliptope{T} <: AbstractDecoratorManifold{ℝ}\n\nThe Elliptope manifold, also known as the set of correlation matrices, consists of all symmetric positive semidefinite matrices of rank k with unit diagonal, i.e.,\n\nbeginaligned\nmathcal E(nk) =\nbiglp  ℝ^nn big a^mathrmTpa geq 0 text for all  a  ℝ^n\np_ii = 1 text for all  i=1ldotsn\ntextand  p = qq^mathrmT text for  q in  ℝ^nk text with  operatornamerank(p) = operatornamerank(q) = k\nbigr\nendaligned\n\nAnd this manifold is working solely on the matrices q. Note that this q is not unique, indeed for any orthogonal matrix A we have (qA)(qA)^mathrmT = qq^mathrmT = p, so the manifold implemented here is the quotient manifold. The unit diagonal translates to unit norm columns of q.\n\nThe tangent space at p, denoted T_pmathcal E(nk), is also represented by matrices Yin ℝ^nk and reads as\n\nT_pmathcal E(nk) = bigl\nX  ℝ^nnX = qY^mathrmT + Yq^mathrmT text with  X_ii = 0 text for  i=1ldotsn\nbigr\n\nendowed with the Euclidean metric from the embedding, i.e. from the ℝ^nk\n\nThis manifold was for example investigated in[JBAS10].\n\nConstructor\n\nElliptope(n::Int, k::Int; parameter::Symbol=:type)\n\ngenerates the manifold mathcal E(nk) subset ℝ^nn.\n\nparameter: whether a type parameter should be used to store n and k. By default size is stored in type. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/elliptope/#ManifoldsBase.check_point-Tuple{Elliptope, Any}","page":"Elliptope","title":"ManifoldsBase.check_point","text":"check_point(M::Elliptope, q; kwargs...)\n\nchecks, whether q is a valid representation of a point p=qq^mathrmT on the Elliptope M, i.e. is a matrix of size (N,K), such that p is symmetric positive semidefinite and has unit trace. Since by construction p is symmetric, this is not explicitly checked. Since p is by construction positive semidefinite, this is not checked. The tolerances for positive semidefiniteness and unit trace can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{Elliptope, Any, T}} where T","page":"Elliptope","title":"ManifoldsBase.check_vector","text":"check_vector(M::Elliptope, q, Y; kwargs... )\n\nCheck whether X = qY^mathrmT + Yq^mathrmT is a tangent vector to p=qq^mathrmT on the Elliptope M, i.e. Y has to be of same dimension as q and a X has to be a symmetric matrix with zero diagonal.\n\nThe tolerance for the base point check and zero diagonal can be set using the kwargs.... Note that symmetric of X holds by construction an is not explicitly checked.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.is_flat-Tuple{Elliptope}","page":"Elliptope","title":"ManifoldsBase.is_flat","text":"is_flat(::Elliptope)\n\nReturn false. Elliptope is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.manifold_dimension-Tuple{Elliptope}","page":"Elliptope","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Elliptope)\n\nreturns the dimension of Elliptope M =mathcal E(nk) nk  ℕ, i.e.\n\ndim mathcal E(nk) = n(k-1) - frack(k-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.project-Tuple{Elliptope, Any}","page":"Elliptope","title":"ManifoldsBase.project","text":"project(M::Elliptope, q)\n\nproject q onto the manifold Elliptope M, by normalizing the rows of q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.project-Tuple{Elliptope, Vararg{Any}}","page":"Elliptope","title":"ManifoldsBase.project","text":"project(M::Elliptope, q, Y)\n\nProject Y onto the tangent space at q, i.e. row-wise onto the oblique manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.representation_size-Tuple{Elliptope}","page":"Elliptope","title":"ManifoldsBase.representation_size","text":"representation_size(M::Elliptope)\n\nReturn the size of an array representing an element on the Elliptope manifold M, i.e. nk, the size of such factor of p=qq^mathrmT on mathcal M = mathcal E(nk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.retract-Tuple{Elliptope, Any, Any, ProjectionRetraction}","page":"Elliptope","title":"ManifoldsBase.retract","text":"retract(M::Elliptope, q, Y, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting q+Y back onto the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.vector_transport_to-Tuple{Elliptope, Any, Any, Any, ProjectionTransport}","page":"Elliptope","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Elliptope, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#ManifoldsBase.zero_vector-Tuple{Elliptope, Vararg{Any}}","page":"Elliptope","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Elliptope,p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the Elliptope manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope/#Literature","page":"Elliptope","title":"Literature","text":"","category":"section"},{"location":"manifolds/multinomial/#Multinomial-matrices","page":"Multinomial matrices","title":"Multinomial matrices","text":"","category":"section"},{"location":"manifolds/multinomial/#Manifolds.MultinomialMatrices","page":"Multinomial matrices","title":"Manifolds.MultinomialMatrices","text":"MultinomialMatrices{n,m} <: AbstractPowerManifold{ℝ}\n\nThe multinomial manifold consists of m column vectors, where each column is of length n and unit norm, i.e.\n\nmathcalMN(nm) coloneqq bigl\n    p  ℝ^nm big p_ij  0 text for all  i=1n j=1m\n    text and  p^mathrmTmathbb1_m = mathbb1_nbigr\n\nwhere mathbb1_k is the vector of length k containing ones.\n\nThis yields exactly the same metric as considering the product metric of the probablity vectors, i.e. PowerManifold of the (n-1)-dimensional ProbabilitySimplex.\n\nThe ProbabilitySimplex is stored internally within M.manifold, such that all functions of AbstractPowerManifold  can be used directly.\n\nConstructor\n\nMultinomialMatrices(n::Int, m::Int; parameter::Symbol=:type)\n\nGenerate the manifold of matrices ℝ^nm such that the m columns are discrete probability distributions, i.e. sum up to one.\n\nparameter: whether a type parameter should be used to store n and m. By default size is stored in type. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomial/#Functions","page":"Multinomial matrices","title":"Functions","text":"","category":"section"},{"location":"manifolds/multinomial/","page":"Multinomial matrices","title":"Multinomial matrices","text":"Most functions are directly implemented for an AbstractPowerManifold  with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/multinomial/#ManifoldDiff.riemannian_gradient-Tuple{MultinomialMatrices, Any, Any}","page":"Multinomial matrices","title":"ManifoldDiff.riemannian_gradient","text":"riemannian_gradient(M::MultinomialMatrices, p, Y; kwargs...)\n\nLet Y denote the Euclidean gradient of a function tilde f defined in the embedding neighborhood of M, then the Riemannian gradient is given by Equation 5 of [DH19] as\n\n  operatornamegrad f(p) = proj_T_pmathcal M(Yp)\n\nwhere  denotes the Hadamard or elementwise product.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomial/#ManifoldsBase.check_point-Tuple{MultinomialMatrices, Any}","page":"Multinomial matrices","title":"ManifoldsBase.check_point","text":"check_point(M::MultinomialMatrices, p)\n\nChecks whether p is a valid point on the MultinomialMatrices(m,n) M, i.e. is a matrix of m discrete probability distributions as columns from ℝ^n, i.e. each column is a point from ProbabilitySimplex(n-1).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomial/#ManifoldsBase.check_vector-Tuple{MultinomialMatrices, Any, Any}","page":"Multinomial matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::MultinomialMatrices p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialMatrices M. This means, that p is valid, that X is of correct dimension and columnswise a tangent vector to the columns of p on the ProbabilitySimplex.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Symplectic-matrices","page":"Symplectic matrices","title":"Symplectic matrices","text":"","category":"section"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"The SymplecticMatrices manifold, denoted operatornameSp(2n 𝔽), is a closed, embedded, submanifold of 𝔽^2n2n that represents transformations into symplectic subspaces which keep the canonical symplectic form over 𝔽^2n2n invariant under the standard embedding inner product. The canonical symplectic form is a non-degenerate bilinear and skew symmetric map omegacolon 𝔽 𝔽^2n𝔽^2n  𝔽, given by omega(x y) = x^T Q_2n y for elements x y in 𝔽^2n, with","category":"page"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"    Q_2n =\n    beginbmatrix\n     0_n    I_n \n    -I_n    0_n\n    endbmatrix","category":"page"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"That means that an element p in operatornameSp(2n) must fulfill the requirement that","category":"page"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"    omega (p x p y) = x^T(p^TQp)y = x^TQy = omega(x y)","category":"page"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"leading to the requirement on p that p^TQp = Q.","category":"page"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"The symplectic manifold also forms a group under matrix multiplication, called the textitsymplectic group. Since all the symplectic matrices necessarily have determinant one, the symplectic group operatornameSp(2n 𝔽) is a subgroup of the special linear group, operatornameSL(2n 𝔽). When the underlying field is either ℝ or ℂ the symplectic group with a manifold structure constitutes a Lie group, with the Lie Algebra","category":"page"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"    mathfraksp(2nF) = H in 𝔽^2n2n  Q H + H^T Q = 0","category":"page"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"This set is also known as the Hamiltonian matrices, which have the property that (QH)^T = QH and are commonly used in physics.","category":"page"},{"location":"manifolds/symplectic/#Manifolds.ExtendedSymplecticMetric","page":"Symplectic matrices","title":"Manifolds.ExtendedSymplecticMetric","text":"ExtendedSymplecticMetric <: AbstractMetric\n\nThe extension of the RealSymplecticMetric at a point p in mathrmSp(2n) as an inner product over the embedding space ℝ^2n2n, i.e.\n\n    x y_p = p^-1x p^-1_mathrmFr\n    = operatornametr(x^mathrmT(pp^mathrmT)^-1y) text for all  x y in ℝ^2n2n\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic/#Manifolds.RealSymplecticMetric","page":"Symplectic matrices","title":"Manifolds.RealSymplecticMetric","text":"RealSymplecticMetric <: RiemannianMetric\n\nThe canonical Riemannian metric on the symplectic manifold, defined pointwise for p in mathrmSp(2n) by [Fio11]]\n\nbeginalign*\n   g_p colon T_pmathrmSp(2n)T_pmathrmSp(2n)  ℝ \n   g_p(Z_1 Z_2) = operatornametr((p^-1Z_1)^mathrmT (p^-1Z_2))\nendalign*\n\nThis metric is also the default metric for the SymplecticMatrices manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic/#Manifolds.SymplecticElement","page":"Symplectic matrices","title":"Manifolds.SymplecticElement","text":"SymplecticElement{T}\n\nA lightweight structure to represent the action of the matrix representation of the canonical symplectic form,\n\nJ_2n(λ) = λbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix  ℝ^2n2n\n\nwhere we write J_2n = J_2n(1) for short. The canonical symplectic form is represented by\n\nomega_2n(x y) = x^mathrmTJ_2ny quad x y  ℝ^2n\n\nThe entire matrix is however not instantiated in memory, instead a scalar λ of type T is stored, which is used to keep track of scaling and transpose operations applied  to each SymplecticElement. This type acts similar to I from LinearAlgeba.\n\nConstructor\n\nSymplecticElement(λ=1)\n\nGenerate the sumplectic matrix with scaling 1.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic/#Manifolds.SymplecticMatrices","page":"Symplectic matrices","title":"Manifolds.SymplecticMatrices","text":"SymplecticMatrices{𝔽, T} <: AbstractDecoratorManifold{𝔽}\n\nThe symplectic manifold consists of all 2n2n matrices which preserve the canonical symplectic form over 𝔽^2n2n𝔽^2n2n given by\n\n  omegacolon 𝔽^2n2n𝔽^2n2n  𝔽\n  quad omega(x y) = p^mathrmT J_2n q   x y in 𝔽^2n2n\n\nwhere J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\nThe symplectic manifold consists of\n\nmathrmSp(2n ℝ) = bigl p  ℝ^2n2n  big  p^mathrmTJ_2np = J_2n bigr\n\nThe tangent space at a point p is given by [BZ21]\n\nbeginalign*\n  T_pmathrmSp(2n)\n    = X in ℝ^2n2n   p^TJ_2nX + X^TJ_2np = 0  \n    = X = pJ_2nS  mid S  R^2n2n S^mathrmT = S \nendalign*\n\nConstructor\n\nSymplecticMatrices(2n, field=ℝ; parameter::Symbol=:type)\n\nGenerate the (real-valued) symplectic manifold of 2n2n symplectic matrices. The constructor for the SymplecticMatrices manifold accepts the even column/row embedding dimension 2n for the real symplectic manifold, ℝ^2n2n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic/#Base.exp-Tuple{SymplecticMatrices, Any, Any}","page":"Symplectic matrices","title":"Base.exp","text":"exp(M::SymplecticMatrices, p, X)\nexp!(M::SymplecticMatrices, q, p, X)\n\nThe Exponential mapping on the Symplectic manifold with the RealSymplecticMetric Riemannian metric.\n\nFor the point p in mathrmSp(2n) the exponential mapping along the tangent vector X in T_pmathrmSp(2n) is computed as [WSF18]\n\n    operatornameexp_p(X) = p operatornameExp((p^-1X)^mathrmT)\n                                operatornameExp(p^-1X - (p^-1X)^mathrmT)\n\nwhere operatornameExp() denotes the matrix exponential.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Base.inv-Tuple{SymplecticMatrices{ℝ}, Any}","page":"Symplectic matrices","title":"Base.inv","text":"inv(::SymplecticMatrices, A)\ninv!(::SymplecticMatrices, A)\n\nCompute the symplectic inverse A^+ of matrix A  ℝ^2n2n. See symplectic_inverse for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Base.rand-Tuple{Any}","page":"Symplectic matrices","title":"Base.rand","text":"rand(::SymplecticMatrices; vector_at=nothing, σ::Real=1.0)\n\nGenerate a random point on mathrmSp(2n) or a random tangent vector X in T_pmathrmSp(2n) if vector_at is set to a point p in mathrmSp(2n).\n\nA random point on mathrmSp(2n) is constructed by generating a random Hamiltonian matrix Ω in mathfraksp(2nF) with norm σ, and then transforming it to a symplectic matrix by applying the Cayley transform\n\n  operatornamecay mathfraksp(2nF)  mathrmSp(2n)\n   Omega mapsto (I - Omega)^-1(I + Omega)\n\nTo generate a random tangent vector in T_pmathrmSp(2n), this code employs the second tangent vector space parametrization of SymplecticMatrices. It first generates a random symmetric matrix S by S = randn(2n, 2n) and then symmetrizes it as S = S + S'. Then S is normalized to have Frobenius norm of σ and X = pJS is returned, where J is the SymplecticElement.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldDiff.gradient-Tuple{SymplecticMatrices, Any, Any, ManifoldDiff.RiemannianProjectionBackend}","page":"Symplectic matrices","title":"ManifoldDiff.gradient","text":"gradient(M::SymplecticMatrices, f, p, backend::RiemannianProjectionBackend; extended_metric=true)\ngradient!(M::SymplecticMatrices, f, p, backend::RiemannianProjectionBackend; extended_metric=true)\n\nCompute the manifold gradient textgradf(p) of a scalar function f colon mathrmSp(2n)  ℝ at p in mathrmSp(2n).\n\nThe element textgradf(p) is found as the Riesz representer of the differential textDf(p) colon T_pmathrmSp(2n)  ℝ with respect to the Riemannian metric inner product at p [Fio11]]. That is, textgradf(p) in T_pmathrmSp(2n) solves the relation\n\n    g_p(textgradf(p) X) = textDf(p) quadforall X in T_pmathrmSp(2n)\n\nThe default behaviour is to first change the representation of the Euclidean gradient from the Euclidean metric to the RealSymplecticMetric at p, and then we projecting the result onto the correct tangent tangent space T_pmathrmSp(2n ℝ) w.r.t the Riemannian metric g_p extended to the entire embedding space.\n\nArguments:\n\nextended_metric = true: If true, compute the gradient textgradf(p) by   first changing the representer of the Euclidean gradient of a smooth extension   of f, f(p), with respect to the RealSymplecticMetric at p   extended to the entire embedding space, before projecting onto the correct   tangent vector space with respect to the same extended metric g_p.   If false, compute the gradient by first projecting f(p) onto the   tangent vector space, before changing the representer in the tangent   vector space to comply with the RealSymplecticMetric.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldDiff.riemannian_gradient-Tuple{SymplecticMatrices, Any, Any}","page":"Symplectic matrices","title":"ManifoldDiff.riemannian_gradient","text":"riemannian_gradient(M::SymplecticMatrices, p, Y)\n\nGiven a gradient Y = operatornamegrad tilde f(p) in the embedding ℝ^2n2n or at least around the SymplecticMatrices M where p (the embedding of) a point on M, we restrict tilde f to the manifold and denote that by f. Then the Riemannian gradient X = operatornamegrad f(p) is given by\n\n  X = Yp^mathrmTp + J_2npY^mathrmTJ_2np\n\nwhere J_2n denotes the SymplecticElement.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Manifolds.inv!-Tuple{SymplecticMatrices{ℝ}, Any}","page":"Symplectic matrices","title":"Manifolds.inv!","text":"inv!(M::SymplecticMatrices, A)\n\nCompute the symplectic_inverse of a square matrix A in place of A\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Manifolds.project_normal!-Union{Tuple{𝔽}, Tuple{MetricManifold{𝔽, <:Euclidean, ExtendedSymplecticMetric}, Any, Any, Any}} where 𝔽","page":"Symplectic matrices","title":"Manifolds.project_normal!","text":"project_normal!(::MetricManifold{𝔽,<:Euclidean,ExtendedSymplecticMetric}, Y, p, X)\n\nProject onto the normal of the tangent space (T_pmathrmSp(2n))^perp_g at a point p  mathrmSp(2n), relative to the riemannian metric g RealSymplecticMetric.\n\nThat is,\n\n(T_pmathrmSp(2n))^perp_g\n = Y  ℝ^2n2n  g_p(Y X) = 0 test for all  X in T_pmathrmSp(2n)\n\nThe closed form projection operator onto the normal space is given by [GSAS21]\n\noperatornameP^(T_pmathrmSp(2n))perp_g_p(X) = pJ_2noperatornameskew(p^mathrmTJ_2n^mathrmTX)\n\nwhere operatornameskew(A) = frac12(A - A^mathrmT) and J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\nThis function is not exported.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Manifolds.symplectic_inverse-Tuple{AbstractMatrix}","page":"Symplectic matrices","title":"Manifolds.symplectic_inverse","text":"symplectic_inverse(A)\n\nGiven a matrix\n\n  A  ℝ^2n2kquad\n  A =\n  beginbmatrix\n  A_11  A_12 \n  A_21  A_2 2\n  endbmatrix\n\nthe symplectic inverse is defined as:\n\nA^+ = J_2k^mathrmT A^mathrmT J_2n\n\nwhere J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\nThe symplectic inverse of A can be expressed explicitly as:\n\nA^+ =\n  beginbmatrix\n    A_2 2^mathrmT  -A_1 2^mathrmT 12mm\n   -A_2 1^mathrmT   A_1 1^mathrmT\n  endbmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Manifolds.symplectic_inverse_times-Tuple{SymplecticMatrices, Any, Any}","page":"Symplectic matrices","title":"Manifolds.symplectic_inverse_times","text":"symplectic_inverse_times(::SymplecticMatrices, p, q)\nsymplectic_inverse_times!(::SymplecticMatrices, A, p, q)\n\nDirectly compute the symplectic inverse of p in mathrmSp(2n), multiplied with q in mathrmSp(2n). That is, this function efficiently computes p^+q = (J_2np^mathrmTJ_2n)q  ℝ^2n2n, where J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.change_representer-Tuple{MetricManifold{<:Any, <:Euclidean, ExtendedSymplecticMetric}, EuclideanMetric, Any, Any}","page":"Symplectic matrices","title":"ManifoldsBase.change_representer","text":"change_representer(MetMan::MetricManifold{<:Any, <:Euclidean, ExtendedSymplecticMetric},\n                   EucMet::EuclideanMetric, p, X)\nchange_representer!(MetMan::MetricManifold{<:Any, <:Euclidean, ExtendedSymplecticMetric},\n                    Y, EucMet::EuclideanMetric, p, X)\n\nChange the representation of a matrix ξ  ℝ^2n2n into the inner product space (ℝ^2n2n g_p) where the inner product is given by g_p(ξ η) = langle p^-1ξ p^-1η rangle = operatornametr(ξ^mathrmT(pp^mathrmT)^-1η), as the extension of the RealSymplecticMetric onto the entire embedding space.\n\nBy changing the representation we mean to apply a mapping\n\n    c_p  ℝ^2n2n  ℝ^2n2n\n\ndefined by requiring that it satisfy the metric compatibility condition\n\n    g_p(c_p(ξ) η) = p^-1c_p(ξ) p^-1η = ξ η^textEuc\n         η  T_pmathrmSp(2n ℝ)\n\nIn this case, we compute the mapping\n\n    c_p(ξ) = pp^mathrmT ξ\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.change_representer-Tuple{SymplecticMatrices, EuclideanMetric, Any, Any}","page":"Symplectic matrices","title":"ManifoldsBase.change_representer","text":"change_representer(::SymplecticMatrices, ::EuclideanMetric, p, X)\nchange_representer!(::SymplecticMatrices, Y, ::EuclideanMetric, p, X)\n\nCompute the representation of a tangent vector ξ  T_pmathrmSp(2n ℝ) s.t.\n\n  g_p(c_p(ξ) η) = ξ η^textEuc textfor all  η  T_pmathrmSp(2n ℝ)\n\nwith the conversion function\n\n  c_p  T_pmathrmSp(2n ℝ)  T_pmathrmSp(2n ℝ) quad\n  c_p(ξ) = frac12 pp^mathrmT ξ + frac12 pJ_2n ξ^mathrmT pJ_2n\n\nwhere J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\nEach of the terms c_p^1(ξ) = p p^mathrmT ξ and c_p^2(ξ) = pJ_2n ξ^mathrmT pJ_2n from the above definition of c_p(η) are themselves metric compatible in the sense that\n\n    c_p^i  T_pmathrmSp(2n ℝ)  ℝ^2n2nquad\n    g_p^i(c_p(ξ) η) = ξ η^textEuc  η  T_pmathrmSp(2n ℝ)\n\nfor i in 1 2. However the range of each function alone is not confined to   T_pmathrmSp(2n ℝ), but the convex combination\n\n    c_p(ξ) = frac12c_p^1(ξ) + frac12c_p^2(ξ)\n\ndoes have the correct range T_pmathrmSp(2n ℝ).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.check_point-Union{Tuple{T}, Tuple{SymplecticMatrices, T}} where T","page":"Symplectic matrices","title":"ManifoldsBase.check_point","text":"check_point(M::SymplecticMatrices, p; kwargs...)\n\nCheck whether p is a valid point on the SymplecticMatrices M=mathrmSp(2n), i.e. that it has the right AbstractNumbers type and p^+p is (approximately) the identity, where A^+ denotes the symplectic_inverse.\n\nThe tolerance can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.check_vector-Tuple{SymplecticMatrices, Vararg{Any}}","page":"Symplectic matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymplecticMatrices, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector at p on the SymplecticMatrices M=mathrmSp(2n), which requires that\n\np^TJ_2nX + X^TJ_2np = 0\n\nholds (approximately), where J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\nThe tolerance can be set with kwargs...\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.distance-Tuple{SymplecticMatrices, Any, Any}","page":"Symplectic matrices","title":"ManifoldsBase.distance","text":"distance(M::SymplecticMatrices, p, q)\n\nCompute an approximate geodesic distance between two Symplectic matrices p q in mathrmSp(2n), as done in [WSF18].\n\n  operatornamedist(p q)\n     lVertoperatornameLog(p^+q)rVert_mathrmFr\n\nwhere the operatornameLog() operator is the matrix logarithm.\n\nThis approximation is justified by first recalling the Baker-Campbell-Hausdorf formula,\n\noperatornameLog(operatornameExp(A)operatornameExp(B))\n = A + B + frac12A B + frac112A A B + frac112B B A\n    + ldots \n\nThen we write the expression for the exponential map from p to q as\n\n    q =\n    operatornameexp_p(X)\n    =\n    p operatornameExp((p^+X)^mathrmT)\n    operatornameExp(p^+X - (p^+X)^mathrmT)\n    X in T_pmathrmSp\n\nand with the geodesic distance between p and q given by\n\noperatornamedist(p q) = lVert X rVert_p = lVert p^+ X rVert_mathrmFr\n\nwe see that\n\n  beginalign*\n   lVertoperatornameLog(p^+q)rVert_mathrmFr\n    =BigllVert\n        operatornameLogbigl(\n            operatornameExp((p^+X)^mathrmT)\n            operatornameExp(p^+X - (p^+X)^mathrmT)\n        bigr)\n    BigrrVert_mathrmFr \n    =lVert p^+X + frac12(p^+X)^mathrmT p^+X - (p^+X)^mathrmT\n        + ldotslVert_mathrmFr \n    lVert p^+XrVert_mathrmFr = operatornamedist(p q)\n  endalign*\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.inner-Tuple{SymplecticMatrices{ℝ}, Any, Any, Any}","page":"Symplectic matrices","title":"ManifoldsBase.inner","text":"inner(::SymplecticMatrices{ℝ}, p, X, Y)\n\nCompute the canonical Riemannian inner product RealSymplecticMetric\n\n    g_p(X Y) = operatornametr((p^-1X)^mathrmT (p^-1Y))\n\nbetween the two tangent vectors X Y in T_pmathrmSp(2n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.inverse_retract-Tuple{SymplecticMatrices, Any, Any, CayleyInverseRetraction}","page":"Symplectic matrices","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::SymplecticMatrices, p, q, ::CayleyInverseRetraction)\n\nCompute the Cayley Inverse Retraction X = mathcalL_p^mathrmSp(q) such that the Cayley Retraction from p along X lands at q, i.e. mathcalR_p(X) = q [BZ21].\n\nFor p q  mathrmSp(2n ℝ) then, we can define the inverse Cayley retraction as long as the following matrices exist.\n\n    U = (I + p^+ q)^-1 quad V = (I + q^+ p)^-1\n\nwhere ()^+ denotes the symplectic_inverse.\n\nThen inverse Cayley retraction at p applied to q is\n\nmathcalL_p^mathrmSp(q)\n  = 2pbigl(V - Ubigr) + 2bigl((p + q)U - pbigr)  T_pmathrmSp(2n)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.is_flat-Tuple{SymplecticMatrices}","page":"Symplectic matrices","title":"ManifoldsBase.is_flat","text":"is_flat(::SymplecticMatrices)\n\nReturn false. SymplecticMatrices is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.manifold_dimension-Tuple{SymplecticMatrices}","page":"Symplectic matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(::SymplecticMatrices)\n\nReturns the dimension of the symplectic manifold embedded in ℝ^2n2n, i.e.\n\n  operatornamedim(mathrmSp(2n)) = (2n + 1)n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.project!-Tuple{MetricManifold{<:Any, <:Euclidean, ExtendedSymplecticMetric}, Any, Any, Any}","page":"Symplectic matrices","title":"ManifoldsBase.project!","text":"project!(::MetricManifold{𝔽,<:Euclidean,ExtendedSymplecticMetric}, Y, p, X) where {𝔽}\n\nCompute the projection of X  R^2n2n onto T_pmathrmSp(2n ℝ) with respect to the RealSymplecticMetric g.\n\nThe closed form projection mapping is given by [GSAS21]\n\n  operatornameP^T_pmathrmSp(2n)_g_p(X) = pJ_2noperatornamesym(p^mathrmTJ_2n^mathrmTX)\n\nwhere operatornamesym(A) = frac12(A + A^mathrmT) and and J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.project-Tuple{SymplecticMatrices, Any, Any}","page":"Symplectic matrices","title":"ManifoldsBase.project","text":"project(::SymplecticMatrices, p, A)\nproject!(::SymplecticMatrices, Y, p, A)\n\nGiven a point p in mathrmSp(2n), project an element A in ℝ^2n2n onto the tangent space T_pmathrmSp(2n) relative to the euclidean metric of the embedding ℝ^2n2n.\n\nThat is, we find the element X in T_poperatornameSp(2n) which solves the constrained optimization problem\n\n    operatornamemin_X in ℝ^2n2n frac12lVert X - ArVert^2 quad\n    textsuch that\n    h(X) = X^mathrmT J_2n p + p^mathrmT J_2n X = 0\n\nwhere h ℝ^2n2n  operatornameskew(2n) denotes the restriction of X onto the tangent space T_poperatornameSpSt(2n 2k) and J_2n = beginbmatrix 0_n  I_n  -I_n  0_n endbmatrix denotes the SymplecticElement.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#ManifoldsBase.retract-Tuple{SymplecticMatrices, Any, Any}","page":"Symplectic matrices","title":"ManifoldsBase.retract","text":"retract(::SymplecticMatrices, p, X, ::CayleyRetraction)\nretract!(::SymplecticMatrices, q, p, X, ::CayleyRetraction)\n\nCompute the Cayley retraction on p  mathrmSp(2n ℝ) in the direction of tangent vector X  T_pmathrmSp(2n ℝ), as defined in by Birtea et al in proposition 2 [BCC20].\n\nUsing the symplectic_inverse A^+ of a matrix A in ℝ^2n2n the retraction mathcalR TmathrmSp(2n)  mathrmSp(2n) is defined pointwise as\n\nbeginalign*\nmathcalR_p(X) = p operatornamecayleft(frac12p^+Xright) \n                 = p operatornameexp_11(p^+X) \n                 = p (2I - p^+X)^-1(2I + p^+X)\nendalign*\n\nHere operatornameexp_11(z) = (2 - z)^-1(2 + z) denotes the Padé (1, 1) approximation to operatornameexp(z).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic/#Literature","page":"Symplectic matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/symplectic/","page":"Symplectic matrices","title":"Symplectic matrices","text":"T. Bendokat and R. Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv Preprint, 2108.12447 (2021), arXiv:2108.12447.\n\n\n\nP. Birtea, I. Caçu and D. Comănescu. Optimization on the real symplectic group. Monatshefte für Mathematik 191, 465–485 (2020).\n\n\n\nS. Fiori. Solving Minimal-Distance Problems over the Manifold of Real-Symplectic Matrices. SIAM Journal on Matrix Analysis and Applications 32, 938–968 (2011).\n\n\n\nB. Gao, N. T. Son, P.-A. Absil and T. Stykel. Riemannian Optimization on the Symplectic Stiefel Manifold. SIAM Journal on Optimization 31, 1546–1575 (2021).\n\n\n\nJ. Wang, H. Sun and S. Fiori. A Riemannian-steepest-descent approach for optimization on the real symplectic group. Mathematical Methods in the Applied Science 41, 4273–4286 (2018).\n\n\n\n","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#SymmetricPositiveDefiniteSection","page":"Symmetric positive definite","title":"Symmetric positive definite matrices","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.SymmetricPositiveDefinite","page":"Symmetric positive definite","title":"Manifolds.SymmetricPositiveDefinite","text":"SymmetricPositiveDefinite{T} <: AbstractDecoratorManifold{ℝ}\n\nThe manifold of symmetric positive definite matrices, i.e.\n\nmathcal P(n) =\nbigl\np  ℝ^nn big a^mathrmTpa  0 text for all  a  ℝ^nbackslash0\nbigr\n\nThe tangent space at T_pmathcal P(n) reads\n\n    T_pmathcal P(n) =\n    bigl\n        X in mathbb R^nn big X=X^mathrmT\n    bigr\n\ni.e. the set of symmetric matrices,\n\nConstructor\n\nSymmetricPositiveDefinite(n; parameter::Symbol=:type)\n\ngenerates the manifold mathcal P(n) subset ℝ^nn\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"This manifold can – for example – be illustrated as ellipsoids:  since the eigenvalues are all positive they can be taken as lengths of the axes of an ellipsoids while the directions are given by the eigenvectors.","category":"page"},{"location":"manifolds/symmetricpositivedefinite/","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"(Image: An example set of data)","category":"page"},{"location":"manifolds/symmetricpositivedefinite/","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"The manifold can be equipped with different metrics","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#Common-and-metric-independent-functions","page":"Symmetric positive definite","title":"Common and metric independent functions","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Base.convert-Tuple{Type{AbstractMatrix}, SPDPoint}","page":"Symmetric positive definite","title":"Base.convert","text":"convert(::Type{AbstractMatrix}, p::SPDPoint)\n\nreturn the point p as a matrix. The matrix is either stored within the SPDPoint or reconstructed from p.eigen.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Base.rand-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"Base.rand","text":"rand(M::SymmetricPositiveDefinite; σ::Real=1)\n\nGenerate a random symmetric positive definite matrix on the SymmetricPositiveDefinite manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.check_point-Tuple{SymmetricPositiveDefinite, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.check_point","text":"check_point(M::SymmetricPositiveDefinite, p; kwargs...)\n\nchecks, whether p is a valid point on the SymmetricPositiveDefinite M, i.e. is a matrix of size (N,N), symmetric and positive definite. The tolerance for the second to last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.check_vector-Tuple{SymmetricPositiveDefinite, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymmetricPositiveDefinite, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the SymmetricPositiveDefinite M, i.e. atfer check_point(M,p), X has to be of same dimension as p and a symmetric matrix, i.e. this stores tangent vectors as elements of the corresponding Lie group. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.injectivity_radius-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::SymmetricPositiveDefinite[, p])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,AffineInvariantMetric}[, p])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}[, p])\n\nReturn the injectivity radius of the SymmetricPositiveDefinite. Since M is a Hadamard manifold with respect to the AffineInvariantMetric and the LogCholeskyMetric, the injectivity radius is globally .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.is_flat-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.is_flat","text":"is_flat(::SymmetricPositiveDefinite)\n\nReturn false. SymmetricPositiveDefinite is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.manifold_dimension-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricPositiveDefinite)\n\nreturns the dimension of SymmetricPositiveDefinite M =mathcal P(n) n  ℕ, i.e.\n\ndim mathcal P(n) = fracn(n+1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.project-Tuple{SymmetricPositiveDefinite, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.project","text":"project(M::SymmetricPositiveDefinite, p, X)\n\nproject a matrix from the embedding onto the tangent space T_pmathcal P(n) of the SymmetricPositiveDefinite matrices, i.e. the set of symmetric matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.representation_size-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.representation_size","text":"representation_size(M::SymmetricPositiveDefinite)\n\nReturn the size of an array representing an element on the SymmetricPositiveDefinite manifold M, i.e. nn, the size of such a symmetric positive definite matrix on mathcal M = mathcal P(n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.zero_vector-Tuple{SymmetricPositiveDefinite, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::SymmetricPositiveDefinite, p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the SymmetricPositiveDefinite manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Default-metric:-the-affine-invariant-metric","page":"Symmetric positive definite","title":"Default metric: the affine invariant metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.AffineInvariantMetric","page":"Symmetric positive definite","title":"Manifolds.AffineInvariantMetric","text":"AffineInvariantMetric <: AbstractMetric\n\nThe linear affine metric is the metric for symmetric positive definite matrices, that employs matrix logarithms and exponentials, which yields a linear and affine metric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"This metric is also the default metric, i.e. any call of the following functions with P=SymmetricPositiveDefinite(3) will result in MetricManifold(P,AffineInvariantMetric())and hence yield the formulae described in this section.","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#Base.exp-Tuple{SymmetricPositiveDefinite, Vararg{Any}}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::SymmetricPositiveDefinite, p, X)\nexp(M::MetricManifold{<:SymmetricPositiveDefinite,AffineInvariantMetric}, p, X)\n\nCompute the exponential map from p with tangent vector X on the SymmetricPositiveDefinite M with its default MetricManifold having the AffineInvariantMetric. The formula reads\n\nexp_p X = p^frac12operatornameExp(p^-frac12 X p^-frac12)p^frac12\n\nwhere operatornameExp denotes to the matrix exponential.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Base.log-Tuple{SymmetricPositiveDefinite, Vararg{Any}}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::SymmetricPositiveDefinite, p, q)\nlog(M::MetricManifold{SymmetricPositiveDefinite,AffineInvariantMetric}, p, q)\n\nCompute the logarithmic map from p to q on the SymmetricPositiveDefinite as a MetricManifold with AffineInvariantMetric. The formula reads\n\nlog_p q =\np^frac12operatornameLog(p^-frac12qp^-frac12)p^frac12\n\nwhere operatornameLog denotes to the matrix logarithm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldDiff.riemannian_Hessian-Tuple{SymmetricPositiveDefinite, Vararg{Any, 4}}","page":"Symmetric positive definite","title":"ManifoldDiff.riemannian_Hessian","text":"riemannian_Hessian(M::SymmetricPositiveDefinite, p, G, H, X)\n\nThe Riemannian Hessian can be computed as stated in Eq. (7.3) [Ngu23]. Let nabla f(p) denote the Euclidean gradient G, nabla^2 f(p)X the Euclidean Hessian H, and operatornamesym(X) = frac12bigl(X^mathrmT+Xbigr) the symmetrization operator. Then the formula reads\n\n    operatornameHessf(p)X\n    =\n    poperatornamesym(^2 f(p)X)p\n    + operatornamesymbigl( Xoperatornamesymbigl( f(p)bigr)p)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.manifold_volume-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"Manifolds.manifold_volume","text":"manifold_volume(::SymmetricPositiveDefinite)\n\nReturn volume of the SymmetricPositiveDefinite manifold, i.e. infinity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.volume_density-Tuple{SymmetricPositiveDefinite, Any, Any}","page":"Symmetric positive definite","title":"Manifolds.volume_density","text":"volume_density(::SymmetricPositiveDefinite, p, X)\n\nCompute the volume density of the SymmetricPositiveDefinite manifold at p in direction X. See [CKA17], Section 6.2 for details. Note that metric in Manifolds.jl has a different scaling factor than the reference.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.change_metric-Tuple{SymmetricPositiveDefinite, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.change_metric","text":"change_metric(M::SymmetricPositiveDefinite, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal P(n) with respect to the EuclideanMetric g_E, this function changes into the AffineInvariantMetric (default) metric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ccolon T_pmathcal P(n)  T_pmathcal P(n) such that for all YZ  T_pmathcal P(n)` it holds\n\nYZ = operatornametr(YZ) = operatornametr(p^-1c(Y)p^-1c(Z)) = g_p(c(Z)c(Y))\n\nand hence c(X) = pX is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.change_representer-Tuple{SymmetricPositiveDefinite, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.change_representer","text":"change_representer(M::SymmetricPositiveDefinite, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function on the tangent space at p with respect to the EuclideanMetric g_E, this is turned into the representer with respect to the (default) metric, the AffineInvariantMetric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ZT_pmathcal P(n) such that for all YT_pmathcal P(n)` it holds\n\nXY = operatornametr(XY) = operatornametr(p^-1Zp^-1Y) = g_p(ZY)\n\nand hence Z = pXp.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.distance-Tuple{SymmetricPositiveDefinite, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::SymmetricPositiveDefinite, p, q)\ndistance(M::MetricManifold{SymmetricPositiveDefinite,AffineInvariantMetric}, p, q)\n\nCompute the distance on the SymmetricPositiveDefinite manifold between p and q, as a MetricManifold with AffineInvariantMetric. The formula reads\n\nd_mathcal P(n)(pq)\n= lVert operatornameLog(p^-frac12qp^-frac12)rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.get_basis-Tuple{SymmetricPositiveDefinite, Any, DefaultOrthonormalBasis}","page":"Symmetric positive definite","title":"ManifoldsBase.get_basis","text":"[Ξ,κ] = get_basis(M::SymmetricPositiveDefinite, p, B::DefaultOrthonormalBasis)\n[Ξ,κ] = get_basis(M::MetricManifold{<:SymmetricPositiveDefinite,AffineInvariantMetric}, p, B::DefaultOrthonormalBasis)\n\nReturn a default ONB for the tangent space T_pmathcal P(n) of the SymmetricPositiveDefinite with respect to the AffineInvariantMetric.\n\n    g_p(XY) = operatornametr(p^-1 X p^-1 Y)\n\nThe basis constructed here is based on the ONB for symmetric matrices constructed as follows. Let\n\nDelta_ij = (a_kl)_kl=1^n quad text with \na_kl =\nbegincases\n  1  mbox for  k=l text if  i=j\n  frac1sqrt2  mbox for  k=i l=j text or  k=j l=i\n  0  text else\nendcases\n\nwhich forms an ONB for the space of symmetric matrices.\n\nWe then form the ONB by\n\n   Xi_ij = p^frac12Delta_ijp^frac12qquad i=1ldotsn j=ildotsn\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.get_basis_diagonalizing-Tuple{SymmetricPositiveDefinite, Any, DiagonalizingOrthonormalBasis}","page":"Symmetric positive definite","title":"ManifoldsBase.get_basis_diagonalizing","text":"[Ξ,κ] = get_basis_diagonalizing(M::SymmetricPositiveDefinite, p, B::DiagonalizingOrthonormalBasis)\n[Ξ,κ] = get_basis_diagonalizing(M::MetricManifold{<:SymmetricPositiveDefinite,AffineInvariantMetric}, p, B::DiagonalizingOrthonormalBasis)\n\nReturn a orthonormal basis Ξ as a vector of tangent vectors (of length manifold_dimension of M) in the tangent space of p on the MetricManifold of SymmetricPositiveDefinite manifold M with AffineInvariantMetric that diagonalizes the curvature tensor R(uv)w with eigenvalues κ and where the direction B.frame_direction V has curvature 0.\n\nThe construction is based on an ONB for the symmetric matrices similar to get_basis(::SymmetricPositiveDefinite, p, ::DefaultOrthonormalBasis just that the ONB here is build from the eigen vectors of p^frac12Vp^frac12.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.get_coordinates-Tuple{SymmetricPositiveDefinite, Any, Any, Any, DefaultOrthonormalBasis}","page":"Symmetric positive definite","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(::SymmetricPositiveDefinite, p, X, ::DefaultOrthonormalBasis)\n\nUsing the basis from get_basis the coordinates with respect to this ONB can be simplified to\n\n   c_k = mathrmtr(p^-frac12Delta_ij X)\n\nwhere k is trhe linearized index of the i=1ldotsn j=ildotsn.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.get_vector-Tuple{SymmetricPositiveDefinite, Any, Any, Any, DefaultOrthonormalBasis}","page":"Symmetric positive definite","title":"ManifoldsBase.get_vector","text":"get_vector(::SymmetricPositiveDefinite, p, c, ::DefaultOrthonormalBasis)\n\nUsing the basis from get_basis the vector reconstruction with respect to this ONB can be simplified to\n\n   X = p^frac12 Biggl( sum_i=1j=i^n c_k Delta_ij Biggr) p^frac12\n\nwhere k is the linearized index of the i=1ldotsn j=ildotsn.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.inner-Tuple{SymmetricPositiveDefinite, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::SymmetricPositiveDefinite, p, X, Y)\ninner(M::MetricManifold{SymmetricPositiveDefinite,AffineInvariantMetric}, p, X, Y)\n\nCompute the inner product of X, Y in the tangent space of p on the SymmetricPositiveDefinite manifold M, as a MetricManifold with AffineInvariantMetric. The formula reads\n\ng_p(XY) = operatornametr(p^-1 X p^-1 Y)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.is_flat-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, AffineInvariantMetric}}","page":"Symmetric positive definite","title":"ManifoldsBase.is_flat","text":"is_flat(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,AffineInvariantMetric})\n\nReturn false. SymmetricPositiveDefinite with AffineInvariantMetric is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.parallel_transport_to-Tuple{SymmetricPositiveDefinite, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::SymmetricPositiveDefinite, p, X, q)\nparallel_transport_to(M::MetricManifold{SymmetricPositiveDefinite,AffineInvariantMetric}, p, X, y)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the SymmetricPositiveDefinite as a MetricManifold with the AffineInvariantMetric. The formula reads\n\nmathcal P_qpX = p^frac12\noperatornameExpbigl(\nfrac12p^-frac12log_p(q)p^-frac12\nbigr)\np^-frac12X p^-frac12\noperatornameExpbigl(\nfrac12p^-frac12log_p(q)p^-frac12\nbigr)\np^frac12\n\nwhere operatornameExp denotes the matrix exponential and log the logarithmic map on SymmetricPositiveDefinite (again with respect to the AffineInvariantMetric).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.riemann_tensor-Tuple{SymmetricPositiveDefinite, Vararg{Any, 4}}","page":"Symmetric positive definite","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(::SymmetricPositiveDefinite, p, X, Y, Z)\n\nCompute the value of Riemann tensor on the SymmetricPositiveDefinite manifold. The formula reads [Ren11] R(XY)Z=p^12R(X_I Y_I)Z_Ip^12, where R_I(X_I Y_I)Z_I=frac14Z_I X_I Y_I,  X_I=p^-12Xp^-12, Y_I=p^-12Yp^-12 and Z_I=p^-12Zp^-12.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.sectional_curvature_max-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(M::SymmetricPositiveDefinite)\n\nReturn minimum sectional curvature of SymmetricPositiveDefinite manifold, that is 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.sectional_curvature_min-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::SymmetricPositiveDefinite)\n\nReturn minimum sectional curvature of SymmetricPositiveDefinite manifold, that is 0 for SPD(1) and SPD(2) and -0.25 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#BuresWassersteinMetricSection","page":"Symmetric positive definite","title":"Bures-Wasserstein metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.BuresWassersteinMetric","page":"Symmetric positive definite","title":"Manifolds.BuresWassersteinMetric","text":"BurresWassertseinMetric <: AbstractMetric\n\nThe Bures Wasserstein metric for symmetric positive definite matrices [MMP18]\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/#Base.exp-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, BuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(::MetricManifold{ℝ,SymmetricPositiveDefinite,BuresWassersteinMetric}, p, X)\n\nCompute the exponential map on SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    exp_p(X) = p+X+L_p(X)pL_p(X)\n\nwhere q=L_p(X) denotes the Lyapunov operator, i.e. it solves pq + qp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Base.log-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, BuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.log","text":"log(::MetricManifold{SymmetricPositiveDefinite,BuresWassersteinMetric}, p, q)\n\nCompute the logarithmic map on SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    log_p(q) = (pq)^frac12 + (qp)^frac12 - 2 p\n\nwhere q=L_p(X) denotes the Lyapunov operator, i.e. it solves pq + qp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.change_representer-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, BuresWassersteinMetric}, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.change_representer","text":"change_representer(M::MetricManifold{ℝ,<:SymmetricPositiveDefinite,BuresWassersteinMetric}, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function on the tangent space at p with respect to the EuclideanMetric g_E, this is turned into the representer with respect to the (default) metric, the BuresWassersteinMetric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ZT_pmathcal P(n) such that for all YT_pmathcal P(n)` it holds\n\nXY = operatornametr(XY) = ZY_mathrmBW\n\nfor all Y and hence we get Z= 2(A+A^{\\mathrm{T}})withA=Xp``.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.distance-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, BuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(::MetricManifold{SymmetricPositiveDefinite,BuresWassersteinMetric}, p, q)\n\nCompute the distance with respect to the BuresWassersteinMetric on SymmetricPositiveDefinite matrices, i.e.\n\nd(pq) =\n    operatornametr(p) + operatornametr(q) - 2operatornametrBigl( (p^frac12qp^frac12 bigr)^frac12 Bigr)\n\nwhere the last trace can be simplified (by rotating the matrix products in the trace) to operatornametr(pq).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.inner-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, BuresWassersteinMetric}, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(::MetricManifold{ℝ,SymmetricPositiveDefinite,BuresWassersteinMetric}, p, X, Y)\n\nCompute the inner product SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    XY = frac12operatornametr(L_p(X)Y)\n\nwhere q=L_p(X) denotes the Lyapunov operator, i.e. it solves pq + qp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.is_flat-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, BuresWassersteinMetric}}","page":"Symmetric positive definite","title":"ManifoldsBase.is_flat","text":"is_flat(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,BuresWassersteinMetric})\n\nReturn false. SymmetricPositiveDefinite with BuresWassersteinMetric is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Generalized-Bures-Wasserstein-metric","page":"Symmetric positive definite","title":"Generalized Bures-Wasserstein metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.GeneralizedBuresWassersteinMetric","page":"Symmetric positive definite","title":"Manifolds.GeneralizedBuresWassersteinMetric","text":"GeneralizedBurresWassertseinMetric{T<:AbstractMatrix} <: AbstractMetric\n\nThe generalized Bures Wasserstein metric for symmetric positive definite matrices, see [HMJG21].\n\nThis metric internally stores the symmetric positive definite matrix M to generalise the metric, where the name also follows the mentioned preprint.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/#Base.exp-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, <:GeneralizedBuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,<:GeneralizedBuresWassersteinMetric}, p, X)\n\nCompute the exponential map on SymmetricPositiveDefinite with respect to the GeneralizedBuresWassersteinMetric given by\n\n    exp_p(X) = p+X+mathcal ML_pM(X)pML_pM(X)\n\nwhere q=L_Mp(X) denotes the generalized Lyapunov operator, i.e. it solves pqM + Mqp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Base.log-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, <:GeneralizedBuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.log","text":"log(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,<:GeneralizedBuresWassersteinMetric}, p, q)\n\nCompute the logarithmic map on SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    log_p(q) = M(M^-1pM^-1q)^frac12 + (qM^-1pM^-1)^frac12M - 2 p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.change_representer-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, <:GeneralizedBuresWassersteinMetric}, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.change_representer","text":"change_representer(M::MetricManifold{ℝ,<:SymmetricPositiveDefinite,<:GeneralizedBuresWassersteinMetric}, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function on the tangent space at p with respect to the EuclideanMetric g_E, this is turned into the representer with respect to the (default) metric, the GeneralizedBuresWassersteinMetric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ZT_pmathcal P(n) such that for all YT_pmathcal P(n) it holds\n\nXY = operatornametr(XY) = ZY_mathrmBW\n\nfor all Y and hence we get Z = 2pXM + 2MXp.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.distance-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, <:GeneralizedBuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(::MetricManifold{SymmetricPositiveDefinite,GeneralizedBuresWassersteinMetric}, p, q)\n\nCompute the distance with respect to the BuresWassersteinMetric on SymmetricPositiveDefinite matrices, i.e.\n\nd(pq) = operatornametr(M^-1p) + operatornametr(M^-1q)\n       - 2operatornametrbigl( (p^frac12M^-1qM^-1p^frac12 bigr)^frac12\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.inner-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, <:GeneralizedBuresWassersteinMetric}, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,<:GeneralizedBuresWassersteinMetric}, p, X, Y)\n\nCompute the inner product SymmetricPositiveDefinite with respect to the GeneralizedBuresWassersteinMetric given by\n\n    XY = frac12operatornametr(L_pM(X)Y)\n\nwhere q=L_Mp(X) denotes the generalized Lyapunov operator, i.e. it solves pqM + Mqp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.is_flat-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, <:GeneralizedBuresWassersteinMetric}}","page":"Symmetric positive definite","title":"ManifoldsBase.is_flat","text":"is_flat(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,<:GeneralizedBuresWassersteinMetric})\n\nReturn false. SymmetricPositiveDefinite with GeneralizedBuresWassersteinMetric is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Log-Euclidean-metric","page":"Symmetric positive definite","title":"Log-Euclidean metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.LogEuclideanMetric","page":"Symmetric positive definite","title":"Manifolds.LogEuclideanMetric","text":"LogEuclideanMetric <: RiemannianMetric\n\nThe LogEuclidean Metric consists of the Euclidean metric applied to all elements after mapping them into the Lie Algebra, i.e. performing a matrix logarithm beforehand.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.distance-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, LogEuclideanMetric}, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{ℝ,<:SymmetricPositiveDefinite,LogEuclideanMetric}, p, q)\n\nCompute the distance on the SymmetricPositiveDefinite manifold between p and q as a MetricManifold with LogEuclideanMetric. The formula reads\n\n    d_mathcal P(n)(pq) = lVert operatornameLog p - operatornameLog q rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.is_flat-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, LogEuclideanMetric}}","page":"Symmetric positive definite","title":"ManifoldsBase.is_flat","text":"is_flat(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,LogEuclideanMetric})\n\nReturn false. SymmetricPositiveDefinite with LogEuclideanMetric is not a flat manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Log-Cholesky-metric","page":"Symmetric positive definite","title":"Log-Cholesky metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.LogCholeskyMetric","page":"Symmetric positive definite","title":"Manifolds.LogCholeskyMetric","text":"LogCholeskyMetric <: RiemannianMetric\n\nThe Log-Cholesky metric imposes a metric based on the Cholesky decomposition as introduced by [Lin19].\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/#Base.exp-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, LogCholeskyMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, X)\n\nCompute the exponential map on the SymmetricPositiveDefinite M with LogCholeskyMetric from p into direction X. The formula reads\n\nexp_p X = (exp_y W)(exp_y W)^mathrmT\n\nwhere exp_xW is the exponential map on CholeskySpace, y is the Cholesky decomposition of p, W = y(y^-1Xy^-mathrmT)_frac12, and ()_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Base.log-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, LogCholeskyMetric}, Vararg{Any}}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::MetricManifold{ℝ,<:SymmetricPositiveDefinite,LogCholeskyMetric}, p, q)\n\nCompute the logarithmic map on SymmetricPositiveDefinite M with respect to the LogCholeskyMetric emanating from p to q. The formula can be adapted from the CholeskySpace as\n\nlog_p q = xW^mathrmT + Wx^mathrmT\n\nwhere x is the Cholesky factor of p and W=log_x y for y the Cholesky factor of q and the just mentioned logarithmic map is the one on CholeskySpace.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.distance-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, LogCholeskyMetric}, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, q)\n\nCompute the distance on the manifold of SymmetricPositiveDefinite nmatrices, i.e. between two symmetric positive definite matrices p and q with respect to the LogCholeskyMetric. The formula reads\n\nd_mathcal P(n)(pq) = sqrt\n lVert  x  -  y  rVert_mathrmF^2\n + lVert log(operatornamediag(x)) - log(operatornamediag(y))rVert_mathrmF^2   \n\nwhere x and y are the Cholesky factors of p and q, respectively,  denbotes the strictly lower triangular matrix of its argument, and lVertrVert_mathrmF the Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.inner-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, LogCholeskyMetric}, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{ℝ,<:SymmetricPositiveDefinite,LogCholeskyMetric}, p, X, Y)\n\nCompute the inner product of two matrices X, Y in the tangent space of p on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LogCholeskyMetric. The formula reads\n\n    g_p(XY) = a_z(X)a_z(Y)_z\n\nwhere _x denotes inner product on the CholeskySpace, z is the Cholesky factor of p, a_z(W) = z (z^-1Wz^-mathrmT)_frac12, and ()_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.is_flat-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, LogCholeskyMetric}}","page":"Symmetric positive definite","title":"ManifoldsBase.is_flat","text":"is_flat(::MetricManifold{ℝ,<:SymmetricPositiveDefinite,LogCholeskyMetric})\n\nReturn true. SymmetricPositiveDefinite with LogCholeskyMetric is a flat manifold. See Proposition 8 of [Lin19].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#ManifoldsBase.parallel_transport_to-Tuple{MetricManifold{ℝ, <:SymmetricPositiveDefinite, LogCholeskyMetric}, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.parallel_transport_to","text":"vector_transport_to(\n    M::MetricManifold{ℝ,<:SymmetricPositiveDefinite,LogCholeskyMetric},\n    p,\n    X,\n    q,\n    ::ParallelTransport,\n)\n\nParallel transport the tangent vector X at p along the geodesic to q with respect to the SymmetricPositiveDefinite manifold M and LogCholeskyMetric. The parallel transport is based on the parallel transport on CholeskySpace: Let x and y denote the Cholesky factors of p and q, respectively and W = x(x^-1Xx^-mathrmT)_frac12, where ()_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12. With V the parallel transport on CholeskySpace from x to y. The formula hear reads\n\nmathcal P_qpX = yV^mathrmT + Vy^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Statistics","page":"Symmetric positive definite","title":"Statistics","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#Statistics.mean-Tuple{SymmetricPositiveDefinite, Any}","page":"Symmetric positive definite","title":"Statistics.mean","text":"mean(\n    M::SymmetricPositiveDefinite,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Efficient-representation","page":"Symmetric positive definite","title":"Efficient representation","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"When a point p is used in several occasions, it might be beneficial to store the eigenvalues and vectors of p and optionally its square root and the inverse of the square root. The SPDPoint can be used for exactly that.","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.SPDPoint","page":"Symmetric positive definite","title":"Manifolds.SPDPoint","text":"SPDPoint <: AbstractManifoldsPoint\n\nStore the result of eigen(p) of an SPD matrix and (optionally) p^12 and p^-12 to avoid their repeated computations.\n\nThis result only has the result of eigen as a mandatory storage, the other three can be stored. If they are not stored they are computed and returned (but then still not stored) when required.\n\nConstructor\n\nSPDPoint(p::AbstractMatrix; store_p=true, store_sqrt=true, store_sqrt_inv=true)\n\nCreate an SPD point using an symmetric positive defincite matrix p, where you can optionally store p, sqrt and sqrt_inv\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"and there are three internal functions to be able to use SPDPoint interchangeably with the default representation as a matrix.","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.spd_sqrt","page":"Symmetric positive definite","title":"Manifolds.spd_sqrt","text":"spd_sqrt(p::AbstractMatrix)\nspd_sqrt(p::SPDPoint)\n\nreturn p^frac12 by either computing it (if it is missing or for the AbstractMatrix) or returning the stored value from within the SPDPoint.\n\nThis method assumes that p represents an spd matrix.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.spd_sqrt_inv","page":"Symmetric positive definite","title":"Manifolds.spd_sqrt_inv","text":"spd_sqrt_inv(p::SPDPoint)\n\nreturn p^-frac12 by either computing it (if it is missing or for the AbstractMatrix) or returning the stored value from within the SPDPoint.\n\nThis method assumes that p represents an spd matrix.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/symmetricpositivedefinite/#Manifolds.spd_sqrt_and_sqrt_inv","page":"Symmetric positive definite","title":"Manifolds.spd_sqrt_and_sqrt_inv","text":"spd_sqrt_and_sqrt_inv(p::AbstractMatrix)\nspd_sqrt_and_sqrt_inv(p::SPDPoint)\n\nreturn p^frac12 and p^-frac12 by either computing them (if they are missing or for the AbstractMatrix) or returning their stored value from within the SPDPoint.\n\nCompared to calling single methods spd_sqrt and spd_sqrt_inv this method only computes the eigenvectors once for the case of the AbstractMatrix or if both are missing.\n\nThis method assumes that p represents an spd matrix.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/symmetricpositivedefinite/#Literature","page":"Symmetric positive definite","title":"Literature","text":"","category":"section"},{"location":"manifolds/fiber_bundle/#FiberBundleSection","page":"Fiber bundle","title":"Fiber bundles","text":"","category":"section"},{"location":"manifolds/fiber_bundle/","page":"Fiber bundle","title":"Fiber bundle","text":"Fiber bundle E is a manifold that is built on top of another manifold mathcal M (base space). It is characterized by a continuous function Π  E  mathcal M. For each point p  mathcal M the preimage of p by Π, Π^-1(p) is called a fiber F. Bundle projection can be performed using function bundle_projection.","category":"page"},{"location":"manifolds/fiber_bundle/","page":"Fiber bundle","title":"Fiber bundle","text":"Manifolds.jl primarily deals with the case of trivial bundles, where E can be topologically identified with a product MF.","category":"page"},{"location":"manifolds/fiber_bundle/","page":"Fiber bundle","title":"Fiber bundle","text":"Vector bundles is a special case of a fiber bundle. Other examples include unit tangent bundle. Note that in general fiber bundles don't have a canonical Riemannian structure but can at least be equipped with an Ehresmann connection, providing notions of parallel transport and curvature.","category":"page"},{"location":"manifolds/fiber_bundle/#Documentation","page":"Fiber bundle","title":"Documentation","text":"","category":"section"},{"location":"manifolds/fiber_bundle/#Manifolds.FiberBundle","page":"Fiber bundle","title":"Manifolds.FiberBundle","text":"FiberBundle{𝔽,TVS<:FiberType,TM<:AbstractManifold{𝔽},TVT<:FiberBundleProductVectorTransport} <: AbstractManifold{𝔽}\n\nFiber bundle on a AbstractManifold M of type FiberType. Examples include vector bundles, principal bundles or unit tangent bundles, see also Fiber Bundle.\n\nFields\n\nmanifold – the AbstractManifold              manifold the Fiber bundle is defined on,\ntype     – representing the type of fiber we use.\n\nConstructor\n\nFiberBundle(M::AbstractManifold, type::FiberType)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fiber_bundle/#Manifolds.FiberBundleInverseProductRetraction","page":"Fiber bundle","title":"Manifolds.FiberBundleInverseProductRetraction","text":"struct FiberBundleInverseProductRetraction <: AbstractInverseRetractionMethod end\n\nInverse retraction of the point y at point p from vector bundle B over manifold B.fiber (denoted mathcal M). The inverse retraction is derived as a product manifold-style approximation to the logarithmic map in the Sasaki metric. The considered product manifold is the product between the manifold mathcal M and the topological vector space isometric to the fiber.\n\nNotation\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B. Similarly, q = (x_q V_q).\n\nThe inverse retraction is calculated as\n\noperatornameretr^-1_p q = (operatornameretr^-1_x_p(x_q) V_operatornameretr^-1 - V_p)\n\nwhere V_operatornameretr^-1 is the result of vector transport of V_q to the point x_p. The difference V_operatornameretr^-1 - V_p corresponds to the logarithmic map in the vector space F.\n\nSee also FiberBundleProductRetraction.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fiber_bundle/#Manifolds.FiberBundleProductRetraction","page":"Fiber bundle","title":"Manifolds.FiberBundleProductRetraction","text":"struct FiberBundleProductRetraction <: AbstractRetractionMethod end\n\nProduct retraction map of tangent vector X at point p from vector bundle B over manifold B.fiber (denoted mathcal M). The retraction is derived as a product manifold-style approximation to the exponential map in the Sasaki metric. The considered product manifold is the product between the manifold mathcal M and the topological vector space isometric to the fiber.\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe tangent vector X = (V_XM V_XF)  T_pB where V_XM is a tangent vector from the tangent space T_x_pmathcal M and V_XF is a tangent vector from the tangent space T_V_pF (isomorphic to F).\n\nThe retraction is calculated as\n\nmath \\operatorname{retr}_p(X) = (\\exp_{x_p}(V_{X,M}), V_{\\exp})`\n\nwhere V_exp is the result of vector transport of V_p + V_XF to the point exp_x_p(V_XM). The sum V_p + V_XF corresponds to the exponential map in the vector space F.\n\nSee also FiberBundleInverseProductRetraction.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fiber_bundle/#Manifolds.FiberBundleProductVectorTransport","page":"Fiber bundle","title":"Manifolds.FiberBundleProductVectorTransport","text":"FiberBundleProductVectorTransport{\n    TMP<:AbstractVectorTransportMethod,\n    TMV<:AbstractVectorTransportMethod,\n} <: AbstractVectorTransportMethod\n\nVector transport type on FiberBundle.\n\nFields\n\nmethod_horizontal – vector transport method of the horizontal part (related to manifold M)\nmethod_vertical – vector transport method of the vertical part (related to fibers).\n\nThe vector transport is derived as a product manifold-style vector transport. The considered product manifold is the product between the manifold mathcal M and the space corresponding to the fiber.\n\nConstructor\n\nFiberBundleProductVectorTransport(\n    M::AbstractManifold=DefaultManifold();\n    vector_transport_method_horizontal::AbstractVectorTransportMethod = default_vector_transport_method(M),\n    vector_transport_method_vertical::AbstractVectorTransportMethod = default_vector_transport_method(M),\n)\n\nConstruct the FiberBundleProductVectorTransport using the default_vector_transport_method, which uses ParallelTransport if no manifold is provided.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fiber_bundle/#Manifolds.bundle_projection-Tuple{FiberBundle, Any}","page":"Fiber bundle","title":"Manifolds.bundle_projection","text":"bundle_projection(B::FiberBundle, p)\n\nProjection of point p from the bundle M to the base manifold. Returns the point on the base manifold B.manifold at which the vector part of p is attached.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fiber_bundle/#Manifolds.bundle_transport_tangent_direction","page":"Fiber bundle","title":"Manifolds.bundle_transport_tangent_direction","text":"bundle_transport_tangent_direction(B::FiberBundle, p, pf, X, d)\n\nCompute parallel transport of vertical vector X according to Ehresmann connection on FiberBundle B, in direction din T_p mathcal M. X is an element of the vertical bundle VFmathcal M at pf from tangent to fiber pi^-1(p), pin mathcal M.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/fiber_bundle/#Manifolds.bundle_transport_tangent_to","page":"Fiber bundle","title":"Manifolds.bundle_transport_tangent_to","text":"bundle_transport_tangent_to(B::FiberBundle, p, pf, X, q)\n\nCompute parallel transport of vertical vector X according to Ehresmann connection on FiberBundle B, to point qin mathcal M. X is an element of the vertical bundle VFmathcal M at pf from tangent to fiber pi^-1(p), pin mathcal M.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/fiber_bundle/#Manifolds.bundle_transport_to-Tuple{FiberBundle, Any, Any, Any}","page":"Fiber bundle","title":"Manifolds.bundle_transport_to","text":"bundle_transport_to(B::FiberBundle, p, X, q)\n\nGiven a fiber bundle B=F mathcal M, points p qinmathcal M, an element X of the fiber over p, transport X to fiber over q.\n\nExact meaning of the operation depends on the fiber bundle, or may even be undefined. Some fiber bundles may declare a default local section around each point crossing X, represented by this function.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fiber_bundle/#ManifoldsBase.base_manifold-Tuple{FiberBundle}","page":"Fiber bundle","title":"ManifoldsBase.base_manifold","text":"base_manifold(B::FiberBundle)\n\nReturn the manifold the FiberBundles is build on.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fiber_bundle/#ManifoldsBase.zero_vector-Tuple{FiberBundle, Vararg{Any}}","page":"Fiber bundle","title":"ManifoldsBase.zero_vector","text":"zero_vector(B::FiberBundle, p)\n\nZero tangent vector at point p from the fiber bundle B over manifold B.fiber (denoted mathcal M). The zero vector belongs to the space T_pB\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe zero vector is calculated as\n\nmathbf0_p = (mathbf0_x_p mathbf0_F)\n\nwhere mathbf0_x_p is the zero tangent vector from T_x_pmathcal M and mathbf0_F is the zero element of the vector space F.\n\n\n\n\n\n","category":"method"}]
}
