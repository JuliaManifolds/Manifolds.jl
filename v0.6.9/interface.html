<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ManifoldsBase.jl · Manifolds.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Manifolds.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="interface.html">ManifoldsBase.jl</a><ul class="internal"><li><a class="tocitem" href="#interface-types-and-functions"><span>Types and functions</span></a></li><li><a class="tocitem" href="#Number-systems"><span>Number systems</span></a></li><li><a class="tocitem" href="#Allocation"><span>Allocation</span></a></li><li><a class="tocitem" href="#Bases"><span>Bases</span></a></li><li><a class="tocitem" href="#Vector-transport"><span>Vector transport</span></a></li><li><a class="tocitem" href="#A-Decorator-for-manifolds"><span>A Decorator for manifolds</span></a></li><li><a class="tocitem" href="#Abstract-Power-Manifold"><span>Abstract Power Manifold</span></a></li><li><a class="tocitem" href="#ValidationManifold"><span>ValidationManifold</span></a></li><li><a class="tocitem" href="#EmbeddedmanifoldSec"><span>EmbeddedManifold</span></a></li><li><a class="tocitem" href="#DefaultManifold"><span>DefaultManifold</span></a></li><li><a class="tocitem" href="#Error-Messages"><span>Error Messages</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/manifold.html">How to implement a Manifold</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/centeredmatrices.html">Centered matrices</a></li><li><a class="tocitem" href="manifolds/choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="manifolds/elliptope.html">Elliptope</a></li><li><a class="tocitem" href="manifolds/essentialmanifold.html">Essential manifold</a></li><li><a class="tocitem" href="manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="manifolds/fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="manifolds/generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="manifolds/generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="manifolds/grassmann.html">Grassmann</a></li><li><a class="tocitem" href="manifolds/hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="manifolds/lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="manifolds/multinomialdoublystochastic.html">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="manifolds/multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="manifolds/multinomialsymmetric.html">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="manifolds/oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="manifolds/probabilitysimplex.html">Probability simplex</a></li><li><a class="tocitem" href="manifolds/positivenumbers.html">Positive numbers</a></li><li><a class="tocitem" href="manifolds/projectivespace.html">Projective space</a></li><li><a class="tocitem" href="manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="manifolds/skewhermitian.html">Skew-Hermitian matrices</a></li><li><a class="tocitem" href="manifolds/spectrahedron.html">Spectrahedron</a></li><li><a class="tocitem" href="manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="manifolds/symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="manifolds/symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="manifolds/symmetricpsdfixedrank.html">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="manifolds/torus.html">Torus</a></li><li><a class="tocitem" href="manifolds/tucker.html">Tucker</a></li><li><a class="tocitem" href="manifolds/spheresymmetricmatrices.html">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/graph.html">Graph manifold</a></li><li><a class="tocitem" href="manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/connection.html">Connection manifold</a></li><li><a class="tocitem" href="manifolds/group.html">Group manifold</a></li><li><a class="tocitem" href="manifolds/metric.html">Metric manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="features/atlases.html">Atlases and charts</a></li><li><a class="tocitem" href="features/differentiation.html">Differentiation</a></li><li><a class="tocitem" href="features/distributions.html">Distributions</a></li><li><a class="tocitem" href="features/statistics.html">Statistics</a></li><li><a class="tocitem" href="features/testing.html">Testing</a></li><li><a class="tocitem" href="features/utilities.html">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="misc/about.html">About</a></li><li><a class="tocitem" href="misc/contributing.html">Contributing</a></li><li><a class="tocitem" href="misc/internals.html">Internals</a></li><li><a class="tocitem" href="misc/notation.html">Notation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ManifoldsBase.jl-–-an-interface-for-manifolds"><a class="docs-heading-anchor" href="#ManifoldsBase.jl-–-an-interface-for-manifolds"><code>ManifoldsBase.jl</code> – an interface for manifolds</a><a id="ManifoldsBase.jl-–-an-interface-for-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#ManifoldsBase.jl-–-an-interface-for-manifolds" title="Permalink"></a></h1><p>The interface for a manifold is provided in the lightweight package <a href="https://github.com/JuliaManifolds/ManifoldsBase.jl">ManifoldsBase.jl</a>. You can easily implement your algorithms and even your own manifolds just using the interface. All manifolds from the package here are also based on this interface, so any project based on the interface can benefit from all manifolds, as soon as a certain manifold provides implementations of the functions a project requires.</p><ul><li><a href="interface.html#ManifoldsBase.jl-–-an-interface-for-manifolds"><code>ManifoldsBase.jl</code> – an interface for manifolds</a></li><ul><li><a href="interface.html#interface-types-and-functions">Types and functions</a></li><li><a href="interface.html#Number-systems">Number systems</a></li><li><a href="interface.html#Allocation">Allocation</a></li><li><a href="interface.html#Bases">Bases</a></li><li><a href="interface.html#Vector-transport">Vector transport</a></li><li><a href="interface.html#A-Decorator-for-manifolds">A Decorator for manifolds</a></li><li><a href="interface.html#Abstract-Power-Manifold">Abstract Power Manifold</a></li><li><a href="interface.html#ValidationManifold">ValidationManifold</a></li><li><a href="interface.html#EmbeddedmanifoldSec">EmbeddedManifold</a></li><li><a href="interface.html#DefaultManifold">DefaultManifold</a></li><li><a href="interface.html#Error-Messages">Error Messages</a></li></ul></ul><p>Additionally the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> is provided as well as the <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> as a specific example of such a decorator.</p><h2 id="interface-types-and-functions"><a class="docs-heading-anchor" href="#interface-types-and-functions">Types and functions</a><a id="interface-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#interface-types-and-functions" title="Permalink"></a></h2><p>The following functions are currently available from the interface. If a manifold that you implement for your own package fits this interface, we happily look forward to a <a href="https://github.com/JuliaManifolds/Manifolds.jl/compare">Pull Request</a> to add it here.</p><p>We would like to highlight a few of the types and functions in the next two sections before listing the remaining types and functions alphabetically.</p><h3 id="The-Manifold-Type"><a class="docs-heading-anchor" href="#The-Manifold-Type">The Manifold Type</a><a id="The-Manifold-Type-1"></a><a class="docs-heading-anchor-permalink" href="#The-Manifold-Type" title="Permalink"></a></h3><p>Besides the most central type, that of an <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> accompanied by <a href="interface.html#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a> to represent points thereon, note that the point type is meant in a lazy fashion. This is mean as follows: if you implement a new manifold and your points are represented by matrices, vectors or arrays, then it is best to not restrict types of the points <code>p</code> in functions, such that the methods work for example for other array representation types as well. You should subtype your new points on a manifold, if the structure you use is more structured, see for example <a href="manifolds/fixedrankmatrices.html#Manifolds.FixedRankMatrices"><code>FixedRankMatrices</code></a>. Another reason is, if you want to distinguish (and hence dispatch on) different representation of points on the manifold. For an example, see the <a href="manifolds/hyperbolic.html#HyperbolicSpace">Hyperbolic</a> manifold, which has different models to be represented.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractManifold" href="#ManifoldsBase.AbstractManifold"><code>ManifoldsBase.AbstractManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifold{F}</code></pre><p>A manifold type. The <code>AbstractManifold</code> is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential and <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic maps as well as more general functions that are built on them like the <a href="interface.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>geodesic</code></a>.</p><p>The manifold is parametrized by an <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> to distinguish for example real (ℝ) and complex (ℂ) manifolds.</p><p>For subtypes the preferred order of parameters is: size and simple value parameters, followed by the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> <code>field</code>, followed by data type parameters, which might depend on the abstract number field type.</p><p>For more details see <a href="interface.html#interface-types-and-functions">interface-types-and-functions</a> in the ManifoldsBase.jl documentation at <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/interface.html#Types-and-functions">https://juliamanifolds.github.io/Manifolds.jl/stable/interface.html#Types-and-functions</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractManifoldPoint" href="#ManifoldsBase.AbstractManifoldPoint"><code>ManifoldsBase.AbstractManifoldPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldPoint</code></pre><p>Type for a point on a manifold. While a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of points on a manifold.</p></div></section></article><h3 id="The-exponential-and-the-logarithmic-map,-and-geodesics"><a class="docs-heading-anchor" href="#The-exponential-and-the-logarithmic-map,-and-geodesics">The exponential and the logarithmic map, and geodesics</a><a id="The-exponential-and-the-logarithmic-map,-and-geodesics-1"></a><a class="docs-heading-anchor-permalink" href="#The-exponential-and-the-logarithmic-map,-and-geodesics" title="Permalink"></a></h3><p>Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector “points towards” the other point.</p><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractManifold, Any, Any}" href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractManifold, p, X)
exp(M::AbstractManifold, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from the manifold <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[\exp_p X = γ_{p,X}(1),\]</p><p>where <span>$γ_{p,X}$</span> is the unique geodesic starting in <span>$γ(0)=p$</span> such that <span>$\dot γ(0) = X$</span>.</p><p>See also <a href="interface.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a>, <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{AbstractManifold, Any, Any}" href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractManifold, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The logarithmic map is the inverse of the <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>See also <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}"><code>inverse_retract</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.exp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp!(M::AbstractManifold, q, p, X)
exp!(M::AbstractManifold, q, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from the manifold <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>q</code>.</p><p>See also <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.</p><p>This function returns a function of (time) <code>t</code>.</p><pre><code class="nohighlight hljs">geodesic(M::AbstractManifold, p, X, t::Real)
geodesic(M::AbstractManifold, p, X, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the geodesic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.log!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log!(M::AbstractManifold, X, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>X</code>. The logarithmic map is the inverse of the <a href="interface.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>see also <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> and <a href="interface.html#ManifoldsBase.inverse_retract!-Tuple{AbstractManifold, Any, Any, Any}"><code>inverse_retract!</code></a>,</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AbstractManifold, p, q) -&gt; Function</code></pre><p>Get a <a href="interface.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p><p>This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p><pre><code class="nohighlight hljs">shortest_geodesic(M::AabstractManifold, p, q, t::Real)
shortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the shortest <a href="interface.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>geodesic</code></a>.</p></div></section></article><h3 id="Retractions-and-inverse-Retractions"><a class="docs-heading-anchor" href="#Retractions-and-inverse-Retractions">Retractions and inverse Retractions</a><a id="Retractions-and-inverse-Retractions-1"></a><a class="docs-heading-anchor-permalink" href="#Retractions-and-inverse-Retractions" title="Permalink"></a></h3><p>The exponential and logarithmic map might be too expensive to evaluate or not be available in a very stable numerical way. Retractions provide a possibly cheap, fast and stable alternative.</p><p>The following figure compares the exponential map <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a><code>(M, p, X)</code> on the <a href="manifolds/circle.html#Manifolds.Circle"><code>Circle</code></a><code>(ℂ)</code> (or <a href="manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a><code>(1)</code> embedded in <span>$ℝ^2$</span> with one possible retraction, the one based on projections. Note especially that <span>$\mathrm{dist}(p,q)=\lVert X\rVert_p$</span> while this is not the case for <span>$q&#39;$</span>.</p><p><img src="assets/images/retraction_illustration_600.png" alt="A comparson of the exponential map and a retraction on the Circle."/></p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}" href="#ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}"><code>ManifoldsBase.default_inverse_retraction_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_inverse_retraction_method(M::AbstractManifold)</code></pre><p>The <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> that is used when calling <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}"><code>inverse_retract</code></a> without specifying the inverse retraction method. By default, this is the <a href="interface.html#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}" href="#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}"><code>ManifoldsBase.default_retraction_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_retraction_method(M::AbstractManifold)</code></pre><p>The <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> that is used when calling <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a> without specifying the retraction method. By default, this is the <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.inverse_retract!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.inverse_retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract!(M::AbstractManifold, X, p, q[, method::AbstractInverseRetractionMethod])</code></pre><p>Compute the inverse retraction, a cheaper, approximate version of the <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic map), of points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Result is saved to <code>X</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}"><code>default_inverse_retraction_method</code></a><code>(M)</code>. See the documentation of respective manifolds for available methods.</p><p>See also <a href="interface.html#ManifoldsBase.retract!-Tuple{AbstractManifold, Any, Any, Any}"><code>retract!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.inverse_retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::AbstractManifold, p, q)
inverse_retract(M::AbstractManifold, p, q, method::AbstractInverseRetractionMethod</code></pre><p>Compute the inverse retraction, a cheaper, approximate version of the <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic map), of points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}"><code>default_inverse_retraction_method</code></a><code>(M)</code>. For available inverse retractions on certain manifolds see the documentation on the corresponding manifold.</p><p>See also <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.retract!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract!(M::AbstractManifold, q, p, X)
retract!(M::AbstractManifold, q, p, X, t::Real=1)
retract!(M::AbstractManifold, q, p, X, method::AbstractRetractionMethod)
retract!(M::AbstractManifold, q, p, X, t::Real=1, method::AbstractRetractionMethod)</code></pre><p>Compute a retraction, a cheaper, approximate version of the <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map, from <code>p</code> into direction <code>X</code>, scaled by <code>t</code>, on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> manifold <code>M</code>. Result is saved to <code>q</code>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}"><code>default_retraction_method</code></a><code>(M)</code>. See the documentation of respective manifolds for available methods.</p><p>See <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a> for more details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::AbstractManifold, p, X)
retract(M::AbstractManifold, p, X, t::Real=1)
retract(M::AbstractManifold, p, X, method::AbstractRetractionMethod)
retract(M::AbstractManifold, p, X, t::Real=1, method::AbstractRetractionMethod)</code></pre><p>Compute a retraction, a cheaper, approximate version of the <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map, from <code>p</code> into direction <code>X</code>, scaled by <code>t</code>, on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>A retraction <span>$\operatorname{retr}_p: T_p\mathcal M → \mathcal M$</span> is a smooth map that fulfills</p><ol><li><span>$\operatorname{retr}_p(0) = p$</span></li><li><span>$D\operatorname{retr}_p(0): T_p\mathcal M \to T_p\mathcal M$</span> is the identity map, i.e. <span>$D\operatorname{retr}_p(0)[X]=X$</span>,</li></ol><p>where <span>$D\operatorname{retr}_p$</span> denotes the differential of the retraction</p><p>The retraction is called of second order if for all <span>$X$</span> the curves <span>$c(t) = R_p(tX)$</span> have a zero acceleration at <span>$t=0$</span>, i.e. <span>$c&#39;&#39;(0) = 0$</span>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}"><code>default_retraction_method</code></a><code>(M)</code>. For further available retractions see the documentation of respective manifolds.</p><p>Locally, the retraction is invertible. For the inverse operation, see <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}"><code>inverse_retract</code></a>.</p></div></section></article><p>To distinguish different types of retractions, the last argument of the (inverse) retraction specifies a type. The following ones are available.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractInverseRetractionMethod" href="#ManifoldsBase.AbstractInverseRetractionMethod"><code>ManifoldsBase.AbstractInverseRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractInverseRetractionMethod</code></pre><p>Abstract type for methods for inverting a retraction (see <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}"><code>inverse_retract</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractRetractionMethod" href="#ManifoldsBase.AbstractRetractionMethod"><code>ManifoldsBase.AbstractRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRetractionMethod</code></pre><p>Abstract type for methods for <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a>ing a tangent vector to a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ApproximateInverseRetraction" href="#ManifoldsBase.ApproximateInverseRetraction"><code>ManifoldsBase.ApproximateInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproximateInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>An abstract type for representing approximate inverse retraction methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ApproximateRetraction" href="#ManifoldsBase.ApproximateRetraction"><code>ManifoldsBase.ApproximateRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproximateRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>An abstract type for representing approximate retraction methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ExponentialRetraction" href="#ManifoldsBase.ExponentialRetraction"><code>ManifoldsBase.ExponentialRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExponentialRetraction</code></pre><p>Retraction using the exponential map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.LogarithmicInverseRetraction" href="#ManifoldsBase.LogarithmicInverseRetraction"><code>ManifoldsBase.LogarithmicInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogarithmicInverseRetraction</code></pre><p>Inverse retraction using the <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.NLsolveInverseRetraction" href="#ManifoldsBase.NLsolveInverseRetraction"><code>ManifoldsBase.NLsolveInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NLsolveInverseRetraction{T&lt;:AbstractRetractionMethod,TV,TK} &lt;:
    ApproximateInverseRetraction</code></pre><p>An inverse retraction method for approximating the inverse of a retraction using <code>NLsolve</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">NLsolveInverseRetraction(
    method::AbstractRetractionMethod[, X0];
    project_tangent=false,
    project_point=false,
    nlsolve_kwargs...,
)</code></pre><p>Constructs an approximate inverse retraction for the retraction <code>method</code> with initial guess <code>X0</code>, defaulting to the zero vector. If <code>project_tangent</code> is <code>true</code>, then the tangent vector is projected before the retraction using <code>project</code>. If <code>project_point</code> is <code>true</code>, then the resulting point is projected after the retraction. <code>nlsolve_kwargs</code> are keyword arguments passed to <code>NLsolve.nlsolve</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PolarInverseRetraction" href="#ManifoldsBase.PolarInverseRetraction"><code>ManifoldsBase.PolarInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolarInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PolarRetraction" href="#ManifoldsBase.PolarRetraction"><code>ManifoldsBase.PolarRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolarRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on singular value decompositions of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionInverseRetraction" href="#ManifoldsBase.ProjectionInverseRetraction"><code>ManifoldsBase.ProjectionInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectionInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a projection (or its inversion).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionRetraction" href="#ManifoldsBase.ProjectionRetraction"><code>ManifoldsBase.ProjectionRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectionRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on projection and usually addition in the embedding.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QRInverseRetraction" href="#ManifoldsBase.QRInverseRetraction"><code>ManifoldsBase.QRInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QRInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QRRetraction" href="#ManifoldsBase.QRRetraction"><code>ManifoldsBase.QRRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QRRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a></p></div></section></article><h3 id="Projections"><a class="docs-heading-anchor" href="#Projections">Projections</a><a id="Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Projections" title="Permalink"></a></h3><p>A manifold might be embedded in some space. Often this is implicitly assumed, for example the complex <a href="manifolds/circle.html#Manifolds.Circle"><code>Circle</code></a> is embedded in the complex plane. Let‘s keep the circle in mind in the following as a simple example. For the general case see of explicitly stating an embedding and/or distinguising several, different embeddings, see <a href="interface.html#EmbeddedmanifoldSec">Embedded Manifolds</a> below.</p><p>To make this a little more concrete, let‘s assume we have a manifold <span>$\mathcal M$</span> which is embedded in some manifold <span>$\mathcal N$</span> and the image <span>$i(\mathcal M)$</span> of the embedding function <span>$i$</span> is a closed set (with respect to the topology on <span>$\mathcal N$</span>). Then we can do two kinds of projections.</p><p>To make this concrete in an example for the Circle <span>$\mathcal M=\mathcal C := \{ p ∈ ℂ | |p| = 1\}$</span> the embedding can be chosen to be the manifold <span>$N = ℂ$</span> and due to our representation of <span>$\mathcal C$</span> as complex numbers already, we have <span>$i(p) = p$</span> the identity as the embedding function.</p><ol><li>Given a point <span>$p∈\mathcal N$</span> we can look for the closest point on the manifold <span>$\mathcal M$</span> formally as</li></ol><p class="math-container">\[  \operatorname*{arg\,min}_{q\in \mathcal M} d_{\mathcal N}(i(q),p)\]</p><p>And this resulting <span>$q$</span> we call the projection of <span>$p$</span> onto the manifold <span>$\mathcal M$</span>.</p><ol><li>Given a point <span>$p∈\mathcal M$</span> and a vector in <span>$X\inT_{i(p)}\mathcal N$</span> in the embedding we can similarly look for the closest point to <span>$Y∈ T_p\mathcal M$</span> using the pushforward <span>$\mathrm{d}i_p$</span> of the embedding.</li></ol><p class="math-container">\[  \operatorname*{arg\,min}_{Y\in T_p\mathcal M} \lVert \mathrm{d}i(p)[Y] - X \rVert_{i(p)}\]</p><p>And we call the resulting <span>$Y$</span> the projection of <span>$X$</span> onto the tangent space <span>$T_p\mathcal M$</span> at <span>$p$</span>.</p><p>Let‘s look at the little more concrete example of the complex Circle again. Here, the closest point of <span>$p ∈ ℂ$</span> is just the projection onto the circle, or in other words <span>$q = \frac{p}{\lvert p \rvert}$</span>. A tangent space <span>$T_p\mathcal C$</span> in the embedding is the line orthogonal to a point <span>$p∈\mathcal C$</span> through the origin. This can be better visualized by looking at <span>$p+T_p\mathcal C$</span> which is actually the line tangent to <span>$p$</span>. Note that this shift does not change the resulting projection relative to the origin of the tangent space.</p><p>Here the projection can be computed as the classical projection onto the line, i.e.  <span>$Y = X - ⟨X,p⟩X$</span>.</p><p>this is illustrated in the following figure</p><p><img src="assets/images/projection_illustration_600.png" alt="An example illustrating the two kinds of projections on the Circle."/></p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(M::AbstractManifold, Y, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved in vector <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>project!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(M::AbstractManifold, q, p)</code></pre><p>Project point <code>p</code> from the ambient space onto the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is storedin <code>q</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same array data, the data is changed accordingly.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}"><code>embed!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractManifold, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>project</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>embed</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.project-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractManifold, p)</code></pre><p>Project point <code>p</code> from the ambient space of the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> to <code>M</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same array data, the data is changed accordingly.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any}"><code>embed</code></a></p></div></section></article><h3 id="Remaining-functions"><a class="docs-heading-anchor" href="#Remaining-functions">Remaining functions</a><a id="Remaining-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Remaining-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.OutOfInjectivityRadiusError" href="#ManifoldsBase.OutOfInjectivityRadiusError"><code>ManifoldsBase.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic map or <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}"><code>inverse_retract</code></a>) is given arguments outside of its <a href="interface.html#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>injectivity_radius</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.angle-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the angle between tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with respect to the inner product from <a href="interface.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any, Any}" href="#Base.copy-Tuple{AbstractManifold, Any, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(M, p, X)</code></pre><p>Copy the value(s) from the tangent vector <code>X</code> at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new tangent vector. See <a href="interface.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any, N} where N}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="interface.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any}" href="#Base.copy-Tuple{AbstractManifold, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(M, p)</code></pre><p>Copy the value(s) from the point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new point. See <a href="interface.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any, N} where N}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="interface.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, Y, p, X)</code></pre><p>Copy the value(s) from <code>X</code> to <code>Y</code>, where both are tangent vectors from the tangent space at <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(Y, X)</code>, but it might be useful to overwrite the function at the level, where also information from <code>p</code> and <code>M</code> can be accessed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, q, p)</code></pre><p>Copy the value(s) from <code>p</code> to <code>q</code>, where both are points on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(q, p)</code>, but it might be useful to overwrite the function at the level, where also information from <code>M</code> can be accessed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, X, Y; kwargs...)</code></pre><p>Check if vectors <code>X</code> and <code>Y</code> tangent at <code>p</code> from <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, q; kwargs...)</code></pre><p>Check if points <code>p</code> and <code>q</code> from <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractManifold, p, X)</code></pre><p>Compute the norm of tangent vector <code>X</code> at point <code>p</code> from a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. By default this is computed using <a href="interface.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate-Tuple{Any, Vararg{Any, N} where N}" href="#ManifoldsBase.allocate-Tuple{Any, Vararg{Any, N} where N}"><code>ManifoldsBase.allocate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate(a)
allocate(a, dims::Integer...)
allocate(a, dims::Tuple)
allocate(a, T::Type)
allocate(a, T::Type, dims::Integer...)
allocate(a, T::Type, dims::Tuple)</code></pre><p>Allocate an object similar to <code>a</code>. It is similar to function <code>similar</code>, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls <code>similar</code> on the innermost array-like object only. Type <code>T</code> is the new number element type <a href="interface.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a>, if it is not given the element type of <code>a</code> is retained. The <code>dims</code> argument can be given for non-nested allocation and is forwarded to the function <code>similar</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any, N} where N}" href="#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any, N} where N}"><code>ManifoldsBase.allocate_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result(M::AbstractManifold, f, x...)</code></pre><p>Allocate an array for the result of function <code>f</code> on <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}" href="#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}"><code>ManifoldsBase.allocate_result_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> and the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> on given arguments <code>args</code> (passed as a tuple).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold" href="#ManifoldsBase.base_manifold"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">base_manifold(M::AbstractManifold, depth = Val(-1))</code></pre><p>Return the internally stored <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> for decorated manifold <code>M</code> and the base manifold for vector bundles or power manifolds. The optional parameter <code>depth</code> can be used to remove only the first <code>depth</code> many decorators and return the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> from that level, whether its decorated or not. Any negative value deactivates this depth limit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractManifold, p; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>p</code> is a point on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Otherwise, return an error with description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="interface.html#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_size-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_size(M::AbstractManifold, p)
check_size(M::AbstractManifold, p, X)</code></pre><p>Check whether <code>p</code> has the right <a href="interface.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a> for a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Additionally if a tangent vector is given, both <code>p</code> and <code>X</code> are checked to be of corresponding correct representation sizes for points and tangent vectors on <code>M</code>.</p><p>By default, <code>check_size</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractManifold, p, X; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>X</code> is a valid tangent vector in the tangent space of <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. An implementation does not have to validate the point <code>p</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="interface.html#ManifoldsBase.TVector"><code>TVector</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractManifold, p, q)</code></pre><p>Shortest distance between the points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[d(p,q) = \inf_{γ} L(γ),\]</p><p>where the infimum is over all piecewise smooth curves <span>$γ: [a,b] \to \mathcal M$</span> connecting <span>$γ(a)=p$</span> and <span>$γ(b)=q$</span> and</p><p class="math-container">\[L(γ) = \displaystyle\int_{a}^{b} \lVert \dotγ(t)\rVert_{γ(t)} \mathrm{d}t\]</p><p>is the length of the curve <span>$γ$</span>.</p><p>If <span>$\mathcal M$</span> is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be <span>$∞$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, Y, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space and return the result in <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, q, p)</code></pre><p>Embed point <code>p</code> from the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if points on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>If you have more than one embedding, see <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your point <code>p</code> is already represented in some embedding, see <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}"><code>project!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).</p><p>Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if tangent vectors on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>If you have more than one embedding, see <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your tangent vector <code>X</code> is already represented in some embedding, see <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p)</code></pre><p>Embed point <code>p</code> from the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed</code> includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project-Tuple{AbstractManifold, Any}"><code>project</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractManifold, p)</code></pre><p>Return the distance <span>$d$</span> such that <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp(M, p, X)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse).</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold)</code></pre><p>Infimum of the injectivity radius of all manifold points.</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)
injectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract(M, p, X, method)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse) for point <code>p</code> if provided or all manifold points otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the inner product of tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>See also: <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_point" href="#ManifoldsBase.is_point"><code>ManifoldsBase.is_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_point(M::AbstractManifold, p, throw_error = false; kwargs...)</code></pre><p>Return whether <code>p</code> is a valid point on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="interface.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point(M, p; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_vector" href="#ManifoldsBase.is_vector"><code>ManifoldsBase.is_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_vector(M::AbstractManifold, p, X, throw_error = false; check_base_point=true, kwargs...)</code></pre><p>Return whether <code>X</code> is a valid tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="interface.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector(M, p, X; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p><p>If <code>check_base_point</code> is true, then the point <code>p</code> will be first checked using the <a href="interface.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}" href="#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::AbstractManifold)</code></pre><p>The dimension <span>$n=\dim_{\mathcal M}$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> is homeomorphic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.mid_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid_point!(M::AbstractManifold, q, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="interface.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>. Saves the result in <code>q</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.mid_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid_point(M::AbstractManifold, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_eltype-Tuple{Any}" href="#ManifoldsBase.number_eltype-Tuple{Any}"><code>ManifoldsBase.number_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_eltype(x)</code></pre><p>Numeric element type of the a nested representation of a point or a vector. To be used in conjuntion with <a href="interface.html#ManifoldsBase.allocate-Tuple{Any, Vararg{Any, N} where N}"><code>allocate</code></a> or <a href="interface.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any, N} where N}"><code>allocate_result</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Tuple{AbstractManifold}" href="#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>ManifoldsBase.representation_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">representation_size(M::AbstractManifold)</code></pre><p>The size of an array representing a point on <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns <code>nothing</code> by default indicating that points are not represented using an <code>AbstractArray</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple" href="#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple"><code>ManifoldsBase.size_to_tuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size_to_tuple(::Type{S}) where S&lt;:Tuple</code></pre><p>Converts a size given by <code>Tuple{N, M, ...}</code> into a tuple <code>(N, M, ...)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.zero_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector!(M::AbstractManifold, X, p)</code></pre><p>Save to <code>X</code> the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> that represents the zero vector, i.e. such that retracting <code>X</code> to the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> at <code>p</code> produces <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.zero_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(M::AbstractManifold, p)</code></pre><p>Return the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, that represents the zero vector, i.e. such that a retraction at <code>p</code> produces <code>p</code>.</p></div></section></article><h2 id="Number-systems"><a class="docs-heading-anchor" href="#Number-systems">Number systems</a><a id="Number-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Number-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractNumbers" href="#ManifoldsBase.AbstractNumbers"><code>ManifoldsBase.AbstractNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractNumbers</code></pre><p>An abstract type to represent the number system on which a manifold is built.</p><p>This provides concrete number types for dispatch. The two most common number types are the fields <a href="interface.html#ManifoldsBase.RealNumbers"><code>RealNumbers</code></a> (<code>ℝ</code> for short) and <a href="interface.html#ManifoldsBase.ComplexNumbers"><code>ComplexNumbers</code></a> (<code>ℂ</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ComplexNumbers" href="#ManifoldsBase.ComplexNumbers"><code>ManifoldsBase.ComplexNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComplexNumbers &lt;: AbstractNumbers
ℂ = ComplexNumbers()</code></pre><p>The field of complex numbers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QuaternionNumbers" href="#ManifoldsBase.QuaternionNumbers"><code>ManifoldsBase.QuaternionNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuaternionNumbers &lt;: AbstractNumbers
ℍ = QuaternionNumbers()</code></pre><p>The division algebra of quaternions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.RealNumbers" href="#ManifoldsBase.RealNumbers"><code>ManifoldsBase.RealNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealNumbers &lt;: AbstractNumbers
ℝ = RealNumbers()</code></pre><p>The field of real numbers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._unify_number_systems-Tuple{AbstractNumbers, Vararg{AbstractNumbers, N} where N}" href="#ManifoldsBase._unify_number_systems-Tuple{AbstractNumbers, Vararg{AbstractNumbers, N} where N}"><code>ManifoldsBase._unify_number_systems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_unify_number_systems(𝔽s::AbstractNumbers...)</code></pre><p>Compute a number system that includes all given number systems (as sub-systems) and is closed under addition and multiplication.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_system-Union{Tuple{AbstractManifold{𝔽}}, Tuple{𝔽}} where 𝔽" href="#ManifoldsBase.number_system-Union{Tuple{AbstractManifold{𝔽}}, Tuple{𝔽}} where 𝔽"><code>ManifoldsBase.number_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_system(M::AbstractManifold{𝔽})</code></pre><p>Return the number system the manifold <code>M</code> is based on, i.e. the parameter <code>𝔽</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.real_dimension-Tuple{AbstractNumbers}" href="#ManifoldsBase.real_dimension-Tuple{AbstractNumbers}"><code>ManifoldsBase.real_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real_dimension(𝔽::AbstractNumbers)</code></pre><p>Return the real dimension <span>$\dim_ℝ 𝔽$</span> of the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> system <code>𝔽</code>. The real dimension is the dimension of a real vector space with which a number in <code>𝔽</code> can be identified. For example, <a href="interface.html#ManifoldsBase.ComplexNumbers"><code>ComplexNumbers</code></a> have a real dimension of 2, and <a href="interface.html#ManifoldsBase.QuaternionNumbers"><code>QuaternionNumbers</code></a> have a real dimension of 4.</p></div></section></article><h2 id="Allocation"><a class="docs-heading-anchor" href="#Allocation">Allocation</a><a id="Allocation-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation" title="Permalink"></a></h2><p>Non-mutating functions in <code>ManifoldsBase.jl</code> are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:</p><ul><li><a href="interface.html#ManifoldsBase.allocate-Tuple{Any, Vararg{Any, N} where N}"><code>allocate</code></a> that allocates a new point or vector similar to the given one. This function behaves like <code>similar</code> for simple representations of points and vectors (for example <code>Array{Float64}</code>). For more complex types, such as nested representations of <a href="interface.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> (see <a href="interface.html#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a>), <a href="interface.html#ManifoldsBase.FVector"><code>FVector</code></a> types, checked types like <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a> and more it operates differently. While <code>similar</code> only concerns itself with the higher level of nested structures, <code>allocate</code> maps itself through all levels of nesting until a simple array of numbers is reached and then calls <code>similar</code>. The difference can be most easily seen in the following example:</li></ul><pre><code class="language-julia hljs">julia&gt; x = similar([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 #undef
 #undef

julia&gt; y = Manifolds.allocate([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 [6.90031725726027e-310]
 [6.9003678131654e-310]

julia&gt; x[1]
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744
 [2] top-level scope at REPL[12]:1

julia&gt; y[1]
1-element Array{Float64,1}:
 6.90031725726027e-310</code></pre><ul><li><a href="interface.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any, N} where N}"><code>allocate_result</code></a> allocates a result of a particular function (for example <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>, <a href="features/atlases.html#Manifolds.flat-Tuple{AbstractManifold, Any, Any}"><code>flat</code></a>, etc.) on a particular manifold with particular arguments. It takes into account the possibility that different arguments may have different numeric <a href="interface.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a> types thorough the <a href="interface.html#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}"><code>ManifoldsBase.allocate_result_type</code></a> function.</li></ul><h2 id="Bases"><a class="docs-heading-anchor" href="#Bases">Bases</a><a id="Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Bases" title="Permalink"></a></h2><p>The following functions and types provide support for bases of the tangent space of different manifolds. Moreover, bases of the cotangent space are also supported, though this description focuses on the tangent space. An orthonormal basis of the tangent space <span>$T_p \mathcal M$</span> of (real) dimension <span>$n$</span> has a real-coefficient basis <span>$e_1, e_2, …, e_n$</span> if <span>$\mathrm{Re}(g_p(e_i, e_j)) = δ_{ij}$</span> for each <span>$i,j ∈ \{1, 2, …, n\}$</span> where <span>$g_p$</span> is the Riemannian metric at point <span>$p$</span>. A vector <span>$X$</span> from the tangent space <span>$T_p \mathcal M$</span> can be expressed in Einstein notation as a sum <span>$X = X^i e_i$</span>, where (real) coefficients <span>$X^i$</span> are calculated as <span>$X^i = \mathrm{Re}(g_p(X, e_i))$</span>.</p><p>Bases are closely related to <a href="features/atlases.html#atlases_and_charts">atlases</a>.</p><p>The main types are:</p><ul><li><a href="interface.html#ManifoldsBase.DefaultOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a>, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_coordinates</code></a> and <a href="interface.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_vector</code></a> fast.</li><li><a href="interface.html#ManifoldsBase.DiagonalizingOrthonormalBasis"><code>DiagonalizingOrthonormalBasis</code></a>, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.</li><li><a href="interface.html#ManifoldsBase.ProjectedOrthonormalBasis"><code>ProjectedOrthonormalBasis</code></a>, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.</li><li><a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a>, which stores (explicitly or implicitly) a precomputed basis at a certain point.</li></ul><p>The main functions are:</p><ul><li><a href="interface.html#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, AbstractBasis}"><code>get_basis</code></a> precomputes a basis at a certain point.</li><li><a href="interface.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_coordinates</code></a> returns coordinates of a tangent vector.</li><li><a href="interface.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_vector</code></a> returns a vector for the specified coordinates.</li><li><a href="interface.html#ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, AbstractBasis}"><code>get_vectors</code></a> returns a vector of basis vectors. Calling it should be avoided for high-dimensional manifolds.</li></ul><p>Coordinates of a vector in a basis can be stored in an <a href="interface.html#ManifoldsBase.FVector"><code>FVector</code></a> to explicitly indicate which basis they are expressed in. It is useful to avoid potential ambiguities.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractBasis" href="#ManifoldsBase.AbstractBasis"><code>ManifoldsBase.AbstractBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBasis{𝔽,VST&lt;:VectorSpaceType}</code></pre><p>Abstract type that represents a basis of vector space of type <code>VST</code> on a manifold or a subset of it.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>See also</strong></p><p><a href="interface.html#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractOrthogonalBasis" href="#ManifoldsBase.AbstractOrthogonalBasis"><code>ManifoldsBase.AbstractOrthogonalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOrthogonalBasis{𝔽,VST&lt;:VectorSpaceType}</code></pre><p>Abstract type that represents an orthonormal basis of vector space of type <code>VST</code> on a manifold or a subset of it.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>See also</strong></p><p><a href="interface.html#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractOrthonormalBasis" href="#ManifoldsBase.AbstractOrthonormalBasis"><code>ManifoldsBase.AbstractOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOrthonormalBasis{𝔽,VST&lt;:VectorSpaceType}</code></pre><p>Abstract type that represents an orthonormal basis of vector space of type <code>VST</code> on a manifold or a subset of it.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>See also</strong></p><p><a href="interface.html#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CachedBasis" href="#ManifoldsBase.CachedBasis"><code>ManifoldsBase.CachedBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CachedBasis{𝔽,V,&lt;:AbstractBasis{𝔽}} &lt;: AbstractBasis{𝔽}</code></pre><p>A cached version of the given <code>basis</code> with precomputed basis vectors. The basis vectors are stored in <code>data</code>, either explicitly (like in cached variants of <a href="interface.html#ManifoldsBase.ProjectedOrthonormalBasis"><code>ProjectedOrthonormalBasis</code></a>) or implicitly.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">CachedBasis(basis::AbstractBasis, data)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultBasis" href="#ManifoldsBase.DefaultBasis"><code>ManifoldsBase.DefaultBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultBasis{𝔽,VST&lt;:VectorSpaceType}</code></pre><p>An arbitrary basis of vector space of type <code>VST</code> on a manifold. This will usually be the fastest basis available for a manifold.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>See also</strong></p><p><a href="interface.html#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultOrthogonalBasis" href="#ManifoldsBase.DefaultOrthogonalBasis"><code>ManifoldsBase.DefaultOrthogonalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultOrthogonalBasis{𝔽,VST&lt;:VectorSpaceType}</code></pre><p>An arbitrary orthogonal basis of vector space of type <code>VST</code> on a manifold. This will usually be the fastest orthogonal basis available for a manifold.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>See also</strong></p><p><a href="interface.html#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultOrthonormalBasis" href="#ManifoldsBase.DefaultOrthonormalBasis"><code>ManifoldsBase.DefaultOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultOrthonormalBasis(𝔽::AbstractNumbers = ℝ, vs::VectorSpaceType = TangentSpace)</code></pre><p>An arbitrary orthonormal basis of vector space of type <code>VST</code> on a manifold. This will usually be the fastest orthonormal basis available for a manifold.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>See also</strong></p><p><a href="interface.html#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DiagonalizingOrthonormalBasis" href="#ManifoldsBase.DiagonalizingOrthonormalBasis"><code>ManifoldsBase.DiagonalizingOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiagonalizingOrthonormalBasis{𝔽,TV} &lt;: AbstractOrthonormalBasis{𝔽,TangentSpaceType}</code></pre><p>An orthonormal basis <code>Ξ</code> as a vector of tangent vectors (of length determined by <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a>) in the tangent space that diagonalizes the curvature tensor <span>$R(u,v)w$</span> and where the direction <code>frame_direction</code> <span>$v$</span> has curvature <code>0</code>.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DiagonalizingOrthonormalBasis(frame_direction, 𝔽::AbstractNumbers = ℝ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.GramSchmidtOrthonormalBasis" href="#ManifoldsBase.GramSchmidtOrthonormalBasis"><code>ManifoldsBase.GramSchmidtOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GramSchmidtOrthonormalBasis{𝔽} &lt;: AbstractOrthonormalBasis{𝔽}</code></pre><p>An orthonormal basis obtained from a basis.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GramSchmidtOrthonormalBasis(𝔽::AbstractNumbers = ℝ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectedOrthonormalBasis" href="#ManifoldsBase.ProjectedOrthonormalBasis"><code>ManifoldsBase.ProjectedOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedOrthonormalBasis(method::Symbol, 𝔽::AbstractNumbers = ℝ)</code></pre><p>An orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p>Available methods:</p><ul><li><code>:gram_schmidt</code> uses a modified Gram-Schmidt orthonormalization.</li><li><code>:svd</code> uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorSpaceType" href="#ManifoldsBase.VectorSpaceType"><code>ManifoldsBase.VectorSpaceType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceType</code></pre><p>Abstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.</p><p>Every vector space <code>fiber</code> is supposed to provide:</p><ul><li>a method of constructing vectors,</li><li>basic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),</li><li><a href="interface.html#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}"><code>zero_vector(fiber, p)</code></a> to construct zero vectors at point <code>p</code>,</li><li><code>allocate(X)</code> and <code>allocate(X, T)</code> for vector <code>X</code> and type <code>T</code>,</li><li><code>copyto!(X, Y)</code> for vectors <code>X</code> and <code>Y</code>,</li><li><code>number_eltype(v)</code> for vector <code>v</code>,</li><li><a href="interface.html#ManifoldsBase.vector_space_dimension-Tuple{AbstractManifold, VectorSpaceType}"><code>vector_space_dimension</code></a>.</li></ul><p>Optionally:</p><ul><li>inner product via <code>inner</code> (used to provide Riemannian metric on vector bundles),</li><li><a href="features/atlases.html#Manifolds.flat-Tuple{AbstractManifold, Any, Any}"><code>flat</code></a> and <a href="features/atlases.html#Manifolds.sharp-Tuple{AbstractManifold, Any, Any}"><code>sharp</code></a>,</li><li><code>norm</code> (by default uses <code>inner</code>),</li><li><a href="interface.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a> (for embedded vector spaces),</li><li><a href="interface.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a> (if support for <a href="features/utilities.html#Manifolds.ProductArray"><code>ProductArray</code></a> is desired),</li><li>broadcasting for basic operations.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocation_promotion_function-Tuple{AbstractManifold, Any, Tuple}" href="#ManifoldsBase.allocation_promotion_function-Tuple{AbstractManifold, Any, Tuple}"><code>ManifoldsBase.allocation_promotion_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocation_promotion_function(M::AbstractManifold, f, args::Tuple)</code></pre><p>Determine the function that must be used to ensure that the allocated representation is of the right type. This is needed for <a href="interface.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_vector</code></a> when a point on a complex manifold is represented by a real-valued vectors with a real-coefficient basis, so that a complex-valued vector representation is allocated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.dual_basis-Tuple{AbstractManifold, Any, AbstractBasis}" href="#ManifoldsBase.dual_basis-Tuple{AbstractManifold, Any, AbstractBasis}"><code>ManifoldsBase.dual_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_basis(M::AbstractManifold, p, B::AbstractBasis)</code></pre><p>Get the dual basis to <code>B</code>, a basis of a vector space at point <code>p</code> from manifold <code>M</code>.</p><p>The dual to the <span>$i$</span>th vector <span>$v_i$</span> from basis <code>B</code> is a vector <span>$v^i$</span> from the dual space such that <span>$v^i(v_j) = δ^i_j$</span>, where <span>$δ^i_j$</span> is the Kronecker delta symbol:</p><p class="math-container">\[δ^i_j = \begin{cases}
1 &amp; \text{ if } i=j, \\
0 &amp; \text{ otherwise.}
\end{cases}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, AbstractBasis}" href="#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, AbstractBasis}"><code>ManifoldsBase.get_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_basis(M::AbstractManifold, p, B::AbstractBasis) -&gt; CachedBasis</code></pre><p>Compute the basis vectors of the tangent space at a point on manifold <code>M</code> represented by <code>p</code>.</p><p>Returned object derives from <a href="interface.html#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> and may have a field <code>.vectors</code> that stores tangent vectors or it may store them implicitly, in which case the function <a href="interface.html#ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, AbstractBasis}"><code>get_vectors</code></a> needs to be used to retrieve the basis vectors.</p><p>See also: <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_coordinates</code></a>, <a href="interface.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_vector</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}" href="#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>ManifoldsBase.get_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_coordinates(M::AbstractManifold, p, X, B::AbstractBasis)
get_coordinates(M::AbstractManifold, p, X, B::CachedBasis)</code></pre><p>Compute a one-dimensional vector of coefficients of the tangent vector <code>X</code> at point denoted by <code>p</code> on manifold <code>M</code> in basis <code>B</code>.</p><p>Depending on the basis, <code>p</code> may not directly represent a point on the manifold. For example if a basis transported along a curve is used, <code>p</code> may be the coordinate along the curve. If a <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a> is provided, their stored vectors are used, otherwise the user has to provide a method to compute the coordinates.</p><p>For the <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a> keep in mind that the reconstruction with <a href="interface.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_vector</code></a> requires either a dual basis or the cached basis to be selfdual, for example orthonormal</p><p>See also: <a href="interface.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_vector</code></a>, <a href="interface.html#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, AbstractBasis}"><code>get_basis</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}" href="#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>ManifoldsBase.get_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vector(M::AbstractManifold, p, X, B::AbstractBasis)</code></pre><p>Convert a one-dimensional vector of coefficients in a basis <code>B</code> of the tangent space at <code>p</code> on manifold <code>M</code> to a tangent vector <code>X</code> at <code>p</code>.</p><p>Depending on the basis, <code>p</code> may not directly represent a point on the manifold. For example if a basis transported along a curve is used, <code>p</code> may be the coordinate along the curve.</p><p>For the <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a> keep in mind that the reconstruction from <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_coordinates</code></a> requires either a dual basis or the cached basis to be selfdual, for example orthonormal</p><p>See also: <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_coordinates</code></a>, <a href="interface.html#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, AbstractBasis}"><code>get_basis</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, AbstractBasis}" href="#ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, AbstractBasis}"><code>ManifoldsBase.get_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vectors(M::AbstractManifold, p, B::AbstractBasis)</code></pre><p>Get the basis vectors of basis <code>B</code> of the tangent space at point <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.gram_schmidt-Union{Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, Any, AbstractBasis{𝔽, VST} where VST&lt;:VectorSpaceType}} where 𝔽" href="#ManifoldsBase.gram_schmidt-Union{Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, Any, AbstractBasis{𝔽, VST} where VST&lt;:VectorSpaceType}} where 𝔽"><code>ManifoldsBase.gram_schmidt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gram_schmidt(M::AbstractManifold{𝔽}, p, B::AbstractBasis{𝔽}) where {𝔽}
gram_schmidt(M::AbstractManifold, p, V::AbstractVector)</code></pre><p>Compute an ONB in the tangent space at <code>p</code> on the [<code>AbstractManifold</code>](@ref} <code>M</code> from either an <a href="interface.html#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> basis ´B´ or a set of (at most) <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a><code>(M)</code> many vectors. Note that this method requires the manifold and basis to work on the same <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> <code>𝔽</code>, i.e. with real coefficients.</p><p>The method always returns a basis, i.e. linearly dependent vectors are removed.</p><p><strong>Keyword arguments</strong></p><ul><li><code>warn_linearly_dependent</code> (<code>false</code>) – warn if the basis vectors are not linearly independent</li><li><code>skip_linearly_dependent</code> (<code>false</code>) – whether to just skip (<code>true</code>) a vector that is linearly dependent to the previous ones or to stop (<code>false</code>, default) at that point</li><li><code>return_incomplete_set</code> (<code>false</code>) – throw an error if the resulting set of vectors is not a basis but contains less vectors</li></ul><p>further keyword arguments can be passed to set the accuracy of the independence test. Especially <code>atol</code> is raised slightly by default to <code>atol = 5*1e-16</code>.</p><p><strong>Return value</strong></p><p>When a set of vectors is orthonormalized a set of vectors is returned. When an <a href="interface.html#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> is orthonormalized, a <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.hat-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.hat-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.hat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hat(M::AbstractManifold, p, Xⁱ)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <code>p</code> and tangent component vector <span>$X^i$</span>, compute the equivalent vector representation <span>$X=X^i e_i$</span>, where Einstein summation notation is used:</p><p class="math-container">\[∧ : X^i ↦ X^i e_i\]</p><p>For array manifolds, this converts a vector representation of the tangent vector to an array representation. The <a href="interface.html#ManifoldsBase.vee-Tuple{AbstractManifold, Any, Any}"><code>vee</code></a> map is the <code>hat</code> map&#39;s inverse.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_of_coordinates-Union{Tuple{𝔾}, Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, AbstractBasis{𝔾, VST} where VST&lt;:VectorSpaceType}} where {𝔽, 𝔾}" href="#ManifoldsBase.number_of_coordinates-Union{Tuple{𝔾}, Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, AbstractBasis{𝔾, VST} where VST&lt;:VectorSpaceType}} where {𝔽, 𝔾}"><code>ManifoldsBase.number_of_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_of_coordinates(M::AbstractManifold, B::AbstractBasis)</code></pre><p>Compute the number of coordinates in basis <code>B</code> of manifold <code>M</code>. This also corresponds to the number of vectors represented by <code>B</code>, or stored within <code>B</code> in case of a <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_system-Union{Tuple{AbstractBasis{𝔽, VST} where VST&lt;:VectorSpaceType}, Tuple{𝔽}} where 𝔽" href="#ManifoldsBase.number_system-Union{Tuple{AbstractBasis{𝔽, VST} where VST&lt;:VectorSpaceType}, Tuple{𝔽}} where 𝔽"><code>ManifoldsBase.number_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_system(::AbstractBasis)</code></pre><p>The number system for the vectors of the given basis.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vee-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.vee-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.vee</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vee(M::AbstractManifold, p, X)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <code>p</code> and tangent vector <code>X</code>, compute the vector components <span>$X^i$</span>, such that <span>$X = X^i e_i$</span>, where Einstein summation notation is used:</p><p class="math-container">\[\vee : X^i e_i ↦ X^i\]</p><p>For array manifolds, this converts an array representation of the tangent vector to a vector representation. The <a href="interface.html#ManifoldsBase.hat-Tuple{AbstractManifold, Any, Any}"><code>hat</code></a> map is the <code>vee</code> map&#39;s inverse.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractFibreVector" href="#ManifoldsBase.AbstractFibreVector"><code>ManifoldsBase.AbstractFibreVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFibreVector{TType&lt;:VectorSpaceType}</code></pre><p>Type for a vector from a vector space (fibre of a vector bundle) of type <code>TType</code> of a manifold. While a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CoTVector" href="#ManifoldsBase.CoTVector"><code>ManifoldsBase.CoTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoTVector = AbstractFibreVector{CotangentSpaceType}</code></pre><p>Type for a cotangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.FVector" href="#ManifoldsBase.FVector"><code>ManifoldsBase.FVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FVector(type::VectorSpaceType, data, basis::AbstractBasis)</code></pre><p>Decorator indicating that the vector <code>data</code> contains coordinates of a vector from a fiber of a vector bundle of type <code>type</code>. <code>basis</code> is an object describing the basis of that space in which the coordinates are given.</p><p>Conversion between <code>FVector</code> representation and the default representation of an object (for example a tangent vector) for a manifold should be done using <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_coordinates</code></a> and <a href="interface.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, AbstractBasis}"><code>get_vector</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Manifolds

julia&gt; M = Sphere(2)
Sphere(2, ℝ)

julia&gt; p = [1.0, 0.0, 0.0]
3-element Vector{Float64}:
 1.0
 0.0
 0.0

julia&gt; X = [0.0, 2.0, -1.0]
3-element Vector{Float64}:
  0.0
  2.0
 -1.0

julia&gt; B = DefaultOrthonormalBasis()
DefaultOrthonormalBasis(ℝ)

julia&gt; fX = TFVector(get_coordinates(M, p, X, B), B)
TFVector([2.0, -1.0], DefaultOrthonormalBasis(ℝ))

julia&gt; X_back = get_vector(M, p, fX.data, fX.basis)
3-element Vector{Float64}:
 -0.0
  2.0
 -1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TVector" href="#ManifoldsBase.TVector"><code>ManifoldsBase.TVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TVector = AbstractFibreVector{TangentSpaceType}</code></pre><p>Type for a tangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_space_dimension-Tuple{AbstractManifold, VectorSpaceType}" href="#ManifoldsBase.vector_space_dimension-Tuple{AbstractManifold, VectorSpaceType}"><code>ManifoldsBase.vector_space_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_space_dimension(M::AbstractManifold, V::VectorSpaceType)</code></pre><p>Dimension of the vector space of type <code>V</code> on manifold <code>M</code>.</p></div></section></article><h2 id="Vector-transport"><a class="docs-heading-anchor" href="#Vector-transport">Vector transport</a><a id="Vector-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-transport" title="Permalink"></a></h2><p>There are three main functions for vector transport:</p><ul><li><a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_along</code></a></li><li><a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a></li><li><a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a></li></ul><p>Different types of vector transport are implemented using subtypes of <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>:</p><ul><li><a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a></li><li><a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a></li><li><a href="interface.html#ManifoldsBase.ProjectionTransport"><code>ProjectionTransport</code></a></li><li><a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractLinearVectorTransportMethod" href="#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>ManifoldsBase.AbstractLinearVectorTransportMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLinearVectorTransportMethod &lt;: AbstractVectorTransportMethod</code></pre><p>Abstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractVectorTransportMethod" href="#ManifoldsBase.AbstractVectorTransportMethod"><code>ManifoldsBase.AbstractVectorTransportMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVectorTransportMethod</code></pre><p>Abstract type for methods for transporting vectors. Such vector transports are not necessarily linear.</p><p><strong>See also</strong></p><p><a href="interface.html#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>AbstractLinearVectorTransportMethod</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DifferentiatedRetractionVectorTransport" href="#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>ManifoldsBase.DifferentiatedRetractionVectorTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DifferentiatedRetractionVectorTransport{R&lt;:AbstractRetractionMethod} &lt;:
    AbstractVectorTransportMethod</code></pre><p>A type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let <span>$\mathcal M$</span> be a Riemannian manifold, <span>$p\in\mathcal M$</span> a point, and <span>$X,Y\in T_p\mathcal M$</span> denote two tangent vectors at <span>$p$</span>.</p><p>Given a retraction (cf. <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>) <span>$\operatorname{retr}$</span>, the vector transport of <code>X</code> in direction <code>Y</code> (cf. <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a>) by differentiation this retraction, is given by</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{p,Y}X
= D_Y\operatorname{retr}_p(Y)[X]
= \frac{\mathrm{d}}{\mathrm{d}t}\operatorname{retr}_p(Y+tX)\Bigr|_{t=0}.\]</p><p>see <sup class="footnote-reference"><a id="citeref-AbsilMahonySepulchre2008" href="#footnote-AbsilMahonySepulchre2008">[AbsilMahonySepulchre2008]</a></sup>, Section 8.1.2 for more details.</p><p>This can be phrased similarly as a <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a> by introducing <span>$q=\operatorname{retr}_pX$</span> and defining</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{q \gets p}X = \mathcal T^{\operatorname{retr}}_{p,Y}X\]</p><p>which in practice usually requires the <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{AbstractManifold, Any, Any}"><code>inverse_retract</code></a> to exists in order to compute <span>$Y = \operatorname{retr}_p^{-1}q$</span>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ParallelTransport" href="#ManifoldsBase.ParallelTransport"><code>ManifoldsBase.ParallelTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParallelTransport = DifferentiatedRetractionVectorTransport{ExponentialRetraction}</code></pre><p>Specify to use parallel transport vector transport method.</p><p>To be precise let <span>$c(t)$</span> be a curve depending on the method</p><ul><li>the (assumed to be unique) geodesic <span>$c(t) = γ_{p,q}(t)$</span> from <span>$γ_{p,q}(0)=p$</span> to <span>$γ_{p,q}(1)=q$</span> for <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a> <span>$\mathcal P_{q\gets p}Y$</span></li><li>the unique geodesic <span>$c(t)=γ_{p,X}(t)$</span> from <span>$γ_{p,X}(0)=p$</span> into direction <span>$\dot γ_{p,X}(0)=X$</span> for <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a> <span>$\mathcal P_{p,X}Y$</span></li><li>a given curve <span>$c(0)=p$</span> for <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_along</code></a> <span>$\mathcal P^cY$</span></li></ul><p>In these cases <span>$Y\in T_p\mathcal M$</span> is the vector that we would like to transport from the tangent space at <span>$p=c(0)$</span> to the tangent space at <span>$c(1)$</span>.</p><p>Let <span>$Z\colon [0,1] \to T\mathcal M$</span>, <span>$Z(t)\in T_{c(t)}\mathcal M$</span> be a smooth vector field along the curve <span>$c$</span> with <span>$Z(0) = Y$</span>, such that <span>$Z$</span> is <em>parallel</em>, i.e. its covariant derivative <span>$\frac{\mathrm{D}}{\mathrm{d}t}Z$</span> is zero. Note that such a <span>$Z$</span> always exists and is unique.</p><p>Then the parallel transport is given by <span>$Z(1)$</span>.</p><p>Note that since it is technically the <a href="interface.html#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>DifferentiatedRetractionVectorTransport</code></a> of the <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> (cf. <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>), we define <code>ParallelTransport</code> as an alias.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PoleLadderTransport" href="#ManifoldsBase.PoleLadderTransport"><code>ManifoldsBase.PoleLadderTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoleLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X\in T_p\mathcal M$</span> be a tangent vector at <span>$p\in\mathcal M$</span> and <span>$q\in\mathcal M$</span> the point to transport to. Then <span>$x = \exp_pX$</span> is used to call <code>y =</code><a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a><code>(M, p, x, q)</code> and the resulting vector is obtained by computing <span>$Y = -\log_qy$</span>.</p><p>The <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> posesses two advantages compared to <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>:</p><ul><li>it is cheaper to evaluate, if you want to transport several vectors, since the mid point <span>$c$</span> then stays unchanged.</li><li>while both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds<sup class="footnote-reference"><a id="citeref-Pennec2018" href="#footnote-Pennec2018">[Pennec2018]</a></sup></li></ul><p>The pole ladder was was proposed in <sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PoleLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical pole ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. For an even cheaper transport the inner operations can be changed to an <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionTransport" href="#ManifoldsBase.ProjectionTransport"><code>ManifoldsBase.ProjectionTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectionTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use projection onto tangent space as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_along</code></a>. See <a href="interface.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a> for details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ScaledVectorTransport" href="#ManifoldsBase.ScaledVectorTransport"><code>ManifoldsBase.ScaledVectorTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScaledVectorTransport{T} &lt;: AbstractVectorTransportMethod</code></pre><p>Introduce a scaled variant of any <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>T</code>, as introduced in <sup class="footnote-reference"><a id="citeref-SatoIwai2013" href="#footnote-SatoIwai2013">[SatoIwai2013]</a></sup> for some <span>$X\in T_p\mathcal M$</span> as</p><p class="math-container">\[    \mathcal T^{\mathrm{S}}(X) = \frac{\lVert X\rVert_p}{\lVert \mathcal T(X)\rVert_q}\mathcal T(X).\]</p><p>Note that the resulting point <code>q</code> has to be known, i.e. for <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a> the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ScaledVectorTransport(m::AbstractVectorTransportMethod)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.SchildsLadderTransport" href="#ManifoldsBase.SchildsLadderTransport"><code>ManifoldsBase.SchildsLadderTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SchildsLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X\in T_p\mathcal M$</span> be a tangent vector at <span>$p\in\mathcal M$</span> and <span>$q\in\mathcal M$</span> the point to transport to. Then</p><p class="math-container">\[P^{\mathrm{S}}_{q\gets p}(X) =
    \log_q\bigl( \operatorname{retr}_p ( 2\operatorname{retr}_p^{-1}c ) \bigr),\]</p><p>where <span>$c$</span> is the mid point between <span>$q$</span> and <span>$d=\exp_pX$</span>.</p><p>This method employs the internal function <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a><code>(M, p, d, q)</code> that avoids leaving the manifold.</p><p>The name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in <sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SchildsLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical Schilds ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>. For an even cheaper transport these inner operations can be changed to an <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}" href="#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>ManifoldsBase.default_vector_transport_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_vector_transport_method(M::AbstractManifold)</code></pre><p>The <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> that is used when calling <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_along</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_direction</code></a> without specifying the vector transport method. By default, this is <a href="interface.html#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>DifferentiatedRetractionVectorTransport</code></a>(<a href="interface.html#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}"><code>default_retraction_method</code></a><code>(M))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder" href="#ManifoldsBase.pole_ladder"><code>ManifoldsBase.pole_ladder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, p, q);
    retraction=default_retraction_method(M),
    inverse_retraction=default_inverse_retraction_method(M)
)</code></pre><p>Compute an inner step of the pole ladder, that can be used as a <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a>. Let <span>$c = \gamma_{p,q}(\frac{1}{2})$</span> mid point between <code>p</code> and <code>q</code>, then the pole ladder is given by</p><p class="math-container">\[    \operatorname{Pl}(p,d,q) = \operatorname{retr}_d (2\operatorname{retr}_d^{-1}c)\]</p><p>Where the classical pole ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = -\log_q \operatorname{Pl}(p,d,q)$</span>, you will obtain the <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. When performing multiple steps, this method avoidsd the switching to the tangent space. Keep in mind that after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = (-1)^n\log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p><p>It is cheaper to evaluate than <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a>, sinc if you want to form multiple ladder steps between <code>p</code> and <code>q</code>, but with different <code>d</code>, there is just one evaluation of a geodesic each., since the center <code>c</code> can be reused.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder!" href="#ManifoldsBase.pole_ladder!"><code>ManifoldsBase.pole_ladder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M,
    pl,
    p,
    d,
    q,
    c = mid_point(M, p, q),
    X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M),
    inverse_retraction = default_inverse_retraction_method(M),
)</code></pre><p>Compute the <a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a>, i.e. the result is saved in <code>pl</code>. <code>X</code> is used for storing intermediate inverse retraction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder" href="#ManifoldsBase.schilds_ladder"><code>ManifoldsBase.schilds_ladder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schilds_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, q, d);
    retraction = default_retraction_method(M),
    inverse_retraction = default_inverse_retraction_method(M),
)</code></pre><p>Perform an inner step of schilds ladder, which can be used as a <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>vector_transport_to</code></a>, see <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>. Let <span>$c = \gamma_{q,d}(\frac{1}{2})$</span> denote the mid point on the shortest geodesic connecting <span>$q$</span> and the point <span>$d$</span>. Then Schild&#39;s ladder reads as</p><p class="math-container">\[\operatorname{Sl}(p,d,q) = \operatorname{retr}_x( 2\operatorname{retr}_p^{-1} c)\]</p><p>Where the classical Schilds ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>In consistency with <a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> you can change the way the mid point is computed using the optional parameter <code>c</code>, but note that here it&#39;s the mid point between <code>q</code> and <code>d</code>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = \log_q \operatorname{Sl}(p,d,q)$</span>, you will obtain the <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. Then the approximation to the transported vector is given by <span>$\log_q\operatorname{Sl}(p,d,q)$</span>.</p><p>When performing multiple steps, this method avoidsd the switching to the tangent space. Hence after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = \log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder!" href="#ManifoldsBase.schilds_ladder!"><code>ManifoldsBase.schilds_ladder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schilds_ladder!(
    M,
    sl
    p,
    d,
    q,
    c = mid_point(M, q, d),
    X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M),
    inverse_retraction = default_inverse_retraction_method(M),
)</code></pre><p>Compute <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> and return the value in the parameter <code>sl</code>. If the required mid point <code>c</code> was computed before, it can be passed using <code>c</code>, and the allocation of new memory can be avoided providing a tangent vector <code>X</code> for the interims result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector{T} where T, AbstractVectorTransportMethod}" href="#ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector{T} where T, AbstractVectorTransportMethod}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along!(
    M::AbstractManifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::AbstractVectorTransportMethod
) where {T}</code></pre><p>Compute the vector transport along a discretized curve <code>c</code> using an <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> succesively along the sampled curve.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector{T} where T, PoleLadderTransport}" href="#ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector{T} where T, PoleLadderTransport}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function vector_transport_along!(
    M::AbstractManifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::PoleLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector{T} where T, SchildsLadderTransport}" href="#ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector{T} where T, SchildsLadderTransport}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along!(
    M::AbstractManifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::SchildsLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, Any}" href="#ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, Any}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along!(M::AbstractManifold, Y, p, X, c)
vector_transport_along!(M::AbstractManifold, Y, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. The result is saved to <code>Y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.vector_transport_along</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along(M::AbstractManifold, p, X, c)
vector_transport_along(M::AbstractManifold, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction!-Tuple{AbstractManifold, Any, Any, Any, Any}" href="#ManifoldsBase.vector_transport_direction!-Tuple{AbstractManifold, Any, Any, Any, Any}"><code>ManifoldsBase.vector_transport_direction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction!(M::AbstractManifold, Y, p, X, d)
vector_transport_direction!(M::AbstractManifold, Y, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a> and <a href="interface.html#ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. The result is saved to <code>Y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.vector_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.vector_transport_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction(M::AbstractManifold, p, X, d)
vector_transport_direction(M::AbstractManifold, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="interface.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a> and <a href="interface.html#ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::PoleLadderTransport)</code></pre><p>Perform a vector transport by using <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, ProjectionTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, ProjectionTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::ProjectionTransport)</code></pre><p>Transport a vector <code>X</code> from the tangent space at <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> by interpreting it as an element of the embedding and then projecting it onto the tangent space at <code>q</code>. This function needs to be separately implemented for each manifold because projection <a href="interface.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a> may also change vector representation (if it&#39;s different than in the embedding) and it is assumed that the vector <code>X</code> already has the correct representation for <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, SchildsLadderTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, SchildsLadderTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::SchildsLadderTransport)</code></pre><p>Perform a vector transport by using <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any}" href="#ManifoldsBase.vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to!(M::AbstractManifold, Y, p, X, q)
vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the <a href="interface.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a> to the tangent space at another point <code>q</code>. By default, the <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="interface.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. The result is saved to <code>Y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.vector_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.vector_transport_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractManifold, p, X, q)
vector_transport_to(M::AbstractManifold, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the <a href="interface.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a> to the tangent space at another point <code>q</code>. By default, the <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="interface.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>.</p></div></section></article><h2 id="A-Decorator-for-manifolds"><a class="docs-heading-anchor" href="#A-Decorator-for-manifolds">A Decorator for manifolds</a><a id="A-Decorator-for-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#A-Decorator-for-manifolds" title="Permalink"></a></h2><p>A decorator manifold extends the functionality of a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> in a semi-transparent way. It internally stores the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> it extends and by default for functions defined in the <a href="interface.html"><code>ManifoldsBase</code></a> it acts transparently in the sense that it passes all functions through to the base except those that it actually affects. For example, because the <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> affects nearly all functions, it overwrites nearly all functions, except a few like <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a>. On the other hand, the <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a> only affects functions that involve metrics, especially <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> and <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> but not the <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a>. Contrary to the previous decorator, the <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a> does not overwrite functions. The decorator sets functions like <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> and <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> to be implemented anew but required to be implemented when specifying a new metric. An exception is not issued if a metric is additionally set to be the default metric (see <a href="manifolds/metric.html#Manifolds.is_default_metric-Tuple{AbstractManifold, AbstractMetric}"><code>is_default_metric</code></a>, since this makes all functions act transparently. this last case assumes that the newly specified metric type is actually the one already implemented on a manifold initially.</p><p>By default, i.e. for a plain new decorator, all functions are transparent, i.e. passed down to the manifold the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> decorates. To implement a method for a decorator that behaves differently from the method of the same function for the internal manifold, two steps are required. Let&#39;s assume the function is called <code>f(M, arg1, arg2)</code>, and our decorator manifold <code>DM</code> of type <code>OurDecoratorManifold</code> decorates <code>M</code>. Then</p><ol><li>set <code>decorator_transparent_dispatch(f, M::OurDecoratorManifold, args...) = Val(:intransparent)</code></li><li>implement <code>f(DM::OurDecoratorManifold, arg1, arg2)</code></li></ol><p>This makes it possible to extend a manifold or all manifolds with a feature or replace a feature of the original manifold.</p><p>The <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a> is the best example of the second case, since the default metric indicates for which metric the manifold was originally implemented, such that those functions are just passed through. This can best be seen in the <a href="manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite"><code>SymmetricPositiveDefinite</code></a> manifold with its <a href="manifolds/symmetricpositivedefinite.html#Manifolds.LinearAffineMetric"><code>LinearAffineMetric</code></a>.</p><p>A final technical note – if several manifolds have similar transparency rules concerning functions from the interface, the last parameter <code>T</code> of the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a><code>{𝔽,T&lt;:</code><a href="interface.html#ManifoldsBase.AbstractDecoratorType"><code>AbstractDecoratorType</code></a><code>}</code> can be used to dispatch on different transparency schemes.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractDecoratorManifold" href="#ManifoldsBase.AbstractDecoratorManifold"><code>ManifoldsBase.AbstractDecoratorManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDecoratorManifold{𝔽,T&lt;:AbstractDecoratorType} &lt;: AbstractManifold{𝔽}</code></pre><p>An <code>AbstractDecoratorManifold</code> indicates that to some extent a manifold subtype decorates another <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> in the sense that it either</p><ul><li>it extends the functionality of a manifold with further features</li><li>it defines a new manifold that internally uses functions from the decorated manifold</li></ul><p>with the main intent that several or most functions of <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> are transparently passed through to the manifold that is decorated. This way a function implemented for a decorator acts transparent on all other decorators, i.e. they just pass them through. If the decorator the function is implemented for is not among the decorators, an error is issued. By default all base manifold functions, for example <a href="interface.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> and <a href="interface.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> are transparent for all decorators.</p><p>Transparency of functions with respect to decorators can be specified using the macros <a href="interface.html#ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}"><code>@decorator_transparent_fallback</code></a>, <a href="interface.html#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>@decorator_transparent_function</code></a> and <a href="interface.html#ManifoldsBase.@decorator_transparent_signature-Tuple{Any}"><code>@decorator_transparent_signature</code></a>.</p><p>There are currently three modes given a new <code>AbstractDecoratorManifold</code> <code>M</code></p><ul><li><code>:intransparent</code> – this function has to be implmented for the new manifold <code>M</code></li><li><code>:transparent</code> – this function is transparent, in the sense that the function is invoked on the decorated <code>M.manifold</code>. This is the default, when introducing a function or signature.</li><li><code>:parent</code> specifies that (unless implemented) for this function, the classical inheritance is issued, i.e. the function is invoked on <code>M</code>s supertype.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractDecoratorType" href="#ManifoldsBase.AbstractDecoratorType"><code>ManifoldsBase.AbstractDecoratorType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDecoratorType</code></pre><p>Decorator types can be used to specify a basic transparency for an <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>. This can be seen as an initial (rough) transparency pattern to start a type with.</p><p>Note that for a function <code>f</code> and it&#39;s mutating variant <code>f!</code></p><ul><li>The function <code>f</code> is set to <code>:parent</code> to first invoke allocation and call of <code>f!</code></li><li>The mutating function <code>f!</code> is set to <code>transparent</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultDecoratorType" href="#ManifoldsBase.DefaultDecoratorType"><code>ManifoldsBase.DefaultDecoratorType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultDecoratorType &lt;: AbstractDecoratorType</code></pre><p>A default decorator type, where all new functions are transparent by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_fallback</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decorator_transparent_fallback(ex)
@decorator_transparent_fallback(fallback_case = :intransparent, ex)</code></pre><p>This macro introduces an additional implementation for a certain additional case. This can especially be used if for an already transparent function and an abstract intermediate type a change in the default is required. For implementing a concrete type, neither this nor any other trick is necessary. One just implements the function as before. Note that a decorator that <a href="interface.html#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>is_default_decorator</code></a> still dispatches to the transparent case.</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="interface.html#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>decorated_manifold</code></a>.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold.</li></ul><p>Inline definitions are not supported. The function signature however may contain keyword arguments and a where clause. It does not allow for parameters with default values.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@decorator_transparent_fallback function log!(M::AbstractGroupManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end
@decorator_transparent_fallback :transparent function log!(M::AbstractGroupManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_function-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_function</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decorator_transparent_function(ex)
@decorator_transparent_function(fallback_case = :intransparent, ex)</code></pre><p>Introduce the function specified by <code>ex</code> to act transparently with respect to <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>s. This introduces the possibility to modify the kind of transparency the implementation is done for. This optional first argument, the <code>Symbol</code> within <code>fallback_case</code>. This macro can be used to define a function and introduce it as transparent to other decorators. Note that a decorator that <a href="interface.html#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>is_default_decorator</code></a> still dispatches to the transparent case.</p><p>The cases of transparency are</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="interface.html#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>decorated_manifold</code></a>.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold. Passing is performed using the <code>invoke</code> function where the type of manifold is replaced by its supertype.</li></ul><p>Innkoline-definitions are not yet covered – the function signature however may contain keyword arguments and a where clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@decorator_transparent_function log!(M::AbstractDecoratorManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end
@decorator_transparent_function :parent log!(M::AbstractDecoratorManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_signature-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_signature-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_signature</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decorator_transparent_signature(ex)</code></pre><p>Introduces a given function to be transparent with respect to all decorators. The function is adressed by its signature in <code>ex</code>.</p><p>Supports standard, keyword arguments and <code>where</code> clauses. Doesn&#39;t support parameters with default values. It introduces a dispatch on several transparency modes</p><p>The cases of transparency are</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="interface.html#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>decorated_manifold</code></a>. This is the default.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold.</li></ul><p>Inline definitions are not supported. The function signature however may contain keyword arguments and a where clause.</p><p>The dispatch kind can later still be set to something different, see <a href="interface.html#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}"><code>decorator_transparent_dispatch</code></a></p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">@decorator_transparent_signature log!(M::AbstractDecoratorManifold, X, p, q)
@decorator_transparent_signature log!(M::TD, X, p, q) where {TD&lt;:AbstractDecoratorManifold}
@decorator_transparent_signature isapprox(M::AbstractDecoratorManifold, p, q; kwargs...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}" href="#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>ManifoldsBase.decorated_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decorated_manifold(M::AbstractDecoratorManifold)</code></pre><p>Return the manifold decorated by the decorator <code>M</code>. Defaults to <code>M.manifold</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}" href="#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}"><code>ManifoldsBase.decorator_transparent_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decorator_transparent_dispatch(f, M::AbstractManifold, args...) -&gt; Val</code></pre><p>Given a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and a function <code>f(M,args...)</code>, indicate, whether a function is <code>Val(:transparent)</code> or <code>Val(:intransparent)</code> for the (decorated) <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Another possibility is, that for <code>M</code> and given <code>args...</code> the function <code>f</code> should invoke <code>M</code>s <code>Val(:parent)</code> implementation, see <a href="interface.html#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>@decorator_transparent_function</code></a> for details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_decorator_dispatch-Tuple{AbstractManifold}" href="#ManifoldsBase.default_decorator_dispatch-Tuple{AbstractManifold}"><code>ManifoldsBase.default_decorator_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_decorator_dispatch(M) -&gt; Val</code></pre><p>Return whether by default to dispatch the the inner manifold of a decorator (<code>Val(true)</code>) or not (<code>Val(false</code>). For more details see <a href="interface.html#ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}"><code>is_decorator_transparent</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}" href="#ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}"><code>ManifoldsBase.is_decorator_transparent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_decorator_transparent(f, M::AbstractManifold, args...) -&gt; Bool</code></pre><p>Given a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and a function <code>f(M, args...)</code>, indicate, whether an <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> acts transparently for <code>f</code>. This means, it just passes through down to the internally stored manifold. Transparency is only defined for decorator manifolds and by default all decorators are transparent. A function that is affected by the decorator indicates this by returning <code>false</code>. To change this behaviour, see <a href="interface.html#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}"><code>decorator_transparent_dispatch</code></a>.</p><p>If a decorator manifold is not in general transparent, it might still pass down for the case that a decorator is the default decorator, see <a href="interface.html#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>is_default_decorator</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}" href="#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>ManifoldsBase.is_default_decorator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_default_decorator(M) -&gt; Bool</code></pre><p>For any manifold that is a subtype of <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>, this function indicates whether a certain manifold <code>M</code> acts as a default decorator.</p><p>This yields that <em>all</em> functions are passed through to the decorated <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> if <code>M</code> is indicated as default. This overwrites all <a href="interface.html#ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any, N} where N}"><code>is_decorator_transparent</code></a> values.</p><p>This yields the following advantange: For a manifold one usually implicitly assumes for example a metric. To avoid reimplementation of this metric when introducing a second metric, the first metric can be set to be the default, i.e. its implementaion is already given by the undecorated case.</p><p>Value returned by this function is determined by <a href="interface.html#ManifoldsBase.default_decorator_dispatch-Tuple{AbstractManifold}"><code>default_decorator_dispatch</code></a>, which returns a <code>Val</code>-wrapped boolean for type stability of certain functions.</p></div></section></article><h2 id="Abstract-Power-Manifold"><a class="docs-heading-anchor" href="#Abstract-Power-Manifold">Abstract Power Manifold</a><a id="Abstract-Power-Manifold-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Power-Manifold" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractPowerManifold" href="#ManifoldsBase.AbstractPowerManifold"><code>ManifoldsBase.AbstractPowerManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerManifold{𝔽,M,TPR} &lt;: AbstractManifold{𝔽}</code></pre><p>An abstract <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> to represent manifolds that are build as powers of another <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with representation type <code>TPR</code>, a subtype of <a href="interface.html#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractPowerRepresentation" href="#ManifoldsBase.AbstractPowerRepresentation"><code>ManifoldsBase.AbstractPowerRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerRepresentation</code></pre><p>An abstract representation type of points and tangent vectors on a power manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.InversePowerRetraction" href="#ManifoldsBase.InversePowerRetraction"><code>ManifoldsBase.InversePowerRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InversePowerRetraction{TR&lt;:AbstractInverseRetractionMethod} &lt;: AbstractInverseRetractionMethod</code></pre><p>The <code>InversePowerRetraction</code> avoids ambiguities between dispatching on the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> and dispatching on the <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> should define a way how to treat its <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>s.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InversePowerRetraction(inverse_retractions::AbstractInverseRetractionMethod...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.NestedPowerRepresentation" href="#ManifoldsBase.NestedPowerRepresentation"><code>ManifoldsBase.NestedPowerRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="interface.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is modified in-place, differently than in <a href="interface.html#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.NestedReplacingPowerRepresentation" href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>ManifoldsBase.NestedReplacingPowerRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedReplacingPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="interface.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for <a href="interface.html#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerBasisData" href="#ManifoldsBase.PowerBasisData"><code>ManifoldsBase.PowerBasisData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerBasisData{TB&lt;:AbstractArray}</code></pre><p>Data storage for an array of basis data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerManifold" href="#ManifoldsBase.PowerManifold"><code>ManifoldsBase.PowerManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerManifold{𝔽,TM&lt;:AbstractManifold,TSize&lt;:Tuple,TPR&lt;:AbstractPowerRepresentation} &lt;: AbstractPowerManifold{𝔽,TM}</code></pre><p>The power manifold <span>$\mathcal M^{n_1× n_2 × … × n_d}$</span> with power geometry  <code>TSize</code> statically defines the number of elements along each axis.</p><p>For example, a manifold-valued time series would be represented by a power manifold with <span>$d$</span> equal to 1 and <span>$n_1$</span> equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (<span>$d=2$</span>) with <span>$n_1$</span> and <span>$n_2$</span> equal to width and height of the image.</p><p>While the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerManifold(M::PowerManifold, N_1, N_2, ..., N_d)
PowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d)
M^(N_1, N_2, ..., N_d)</code></pre><p>Generate the power manifold <span>$M^{N_1 × N_2 × … × N_d}$</span>. By default, a [<code>PowerManifold</code>](@ref} is expanded further, i.e. for <code>M=PowerManifold(N,3)</code> <code>PowerManifold(M,2)</code> is equivalend to <code>PowerManifold(N,3,2)</code>. Points are then 3×2 matrices of points on <code>N</code>. Providing a <a href="interface.html#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a> as the second argument to the constructor can be used to nest manifold, i.e. <code>PowerManifold(M,NestedPowerRepresentation(),2)</code> represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.</p><p>Since there is no default <a href="interface.html#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a> within this interface, the <code>^</code> operator is only available for <code>PowerManifold</code>s and concatenates dimensions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerRetraction" href="#ManifoldsBase.PowerRetraction"><code>ManifoldsBase.PowerRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerRetraction{TR&lt;:AbstractRetractionMethod} &lt;: AbstractRetractionMethod</code></pre><p>The <code>PowerRetraction</code> avoids ambiguities between dispatching on the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> and dispatching on the <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> should define a way how to treat its <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>s.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerRetraction(retraction::AbstractRetractionMethod)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerVectorTransport" href="#ManifoldsBase.PowerVectorTransport"><code>ManifoldsBase.PowerVectorTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerVectorTransport{TR&lt;:AbstractVectorTransportMethod} &lt;:
   AbstractVectorTransportMethod</code></pre><p>The <code>PowerVectorTransport</code> avoids ambiguities between dispatching on the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> and dispatching on the <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> should define a way how to treat its <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>s.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerVectorTransport(method::AbstractVectorTransportMethod)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{𝔽, var&quot;#s136&quot;, NestedPowerRepresentation} where {𝔽, var&quot;#s136&quot;&lt;:AbstractManifold{𝔽}}, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{𝔽, var&quot;#s136&quot;, NestedPowerRepresentation} where {𝔽, var&quot;#s136&quot;&lt;:AbstractManifold{𝔽}}, Any, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, Y, p, X)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, B, a, A)</code> for all elements <code>A</code>, <code>a</code> and <code>B</code> of <code>X</code>, <code>p</code>, and <code>Y</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{𝔽, var&quot;#s136&quot;, NestedPowerRepresentation} where {𝔽, var&quot;#s136&quot;&lt;:AbstractManifold{𝔽}}, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{𝔽, var&quot;#s136&quot;, NestedPowerRepresentation} where {𝔽, var&quot;#s136&quot;&lt;:AbstractManifold{𝔽}}, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, q, p)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, b, a)</code> for all elements <code>a</code> and <code>b</code> of <code>p</code> and <code>q</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}" href="#Base.exp-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the exponential map from <code>p</code> in direction <code>X</code> on the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds exponential map elementwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector{T} where T}, N} where N}" href="#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector{T} where T}, N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
p[M::AbstractPowerManifold, i...]</code></pre><p>Access the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}" href="#Base.log-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the logarithmic map from <code>p</code> to <code>q</code> on the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds logarithmic map elementwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector{T} where T}, N} where N}" href="#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector{T} where T}, N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
q[M::AbstractPowerManifold, i...] = p</code></pre><p>Set the element(s) at index <code>[i...]</code> of a point <code>q</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing to <code>q</code>. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.view-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector{T} where T}, N} where N}" href="#Base.view-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector{T} where T}, N} where N}"><code>Base.view</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)</code></pre><p>Get the view of the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the norm of <code>X</code> from the tangent space of <code>p</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. from the element wise norms the Frobenius norm is computed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.check_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractPowerManifold, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. each element of <code>p</code> has to be a valid point on the base manifold. If <code>p</code> is not a point on <code>M</code> a <a href="interface.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractPowerManifold, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> an the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. atfer <a href="interface.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a><code>(M, p)</code>, and all projections to base manifolds must be respective tangent vectors. If <code>X</code> is not a tangent vector to <code>p</code> on <code>M</code> a <a href="interface.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the distance between <code>q</code> and <code>p</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>, i.e. from the element wise distances the Forbenius norm is computed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any, N} where N}" href="#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any, N} where N}"><code>ManifoldsBase.get_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_component(M::AbstractPowerManifold, p, idx...)</code></pre><p>Get the component of a point <code>p</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractPowerManifold[, p])</code></pre><p>the injectivity radius on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> is for the global case equal to the one of its base manifold. For a given point <code>p</code> it&#39;s equal to the minimum of all radii in the array entries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractPowerManifold, p, X, Y)</code></pre><p>Compute the inner product of <code>X</code> and <code>Y</code> from the tangent space at <code>p</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. for each arrays entry the tangent vector entries from <code>X</code> and <code>Y</code> are in the tangent space of the corresponding element from <code>p</code>. The inner product is then the sum of the elementwise inner products.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}" href="#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}"><code>ManifoldsBase.inverse_retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::AbstractPowerManifold, p, q, m::InversePowerRetraction)</code></pre><p>Compute the inverse retraction from <code>p</code> with respect to <code>q</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using an <a href="interface.html#ManifoldsBase.InversePowerRetraction"><code>InversePowerRetraction</code></a>, which by default encapsulates a inverse retraction of the base manifold. Then this method is performed elementwise, so the encapsulated inverse retraction method has to be one that is available on the base <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{𝔽, var&quot;#s135&quot;, TSize, TPR} where {var&quot;#s135&quot;&lt;:AbstractManifold, TPR&lt;:AbstractPowerRepresentation}}, Tuple{TSize}, Tuple{𝔽}} where {𝔽, TSize}" href="#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{𝔽, var&quot;#s135&quot;, TSize, TPR} where {var&quot;#s135&quot;&lt;:AbstractManifold, TPR&lt;:AbstractPowerRepresentation}}, Tuple{TSize}, Tuple{𝔽}} where {𝔽, TSize}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::PowerManifold)</code></pre><p>Returns the manifold-dimension of an <a href="interface.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> <span>$=\mathcal N = (\mathcal M)^{n_1,…,n_d}$</span>, i.e. with <span>$n=(n_1,…,n_d)$</span> the array size of the power manifold and <span>$d_{\mathcal M}$</span> the dimension of the base manifold <span>$\mathcal M$</span>, the manifold is of dimension</p><p class="math-container">\[\dim(\mathcal N) = \dim(\mathcal M)\prod_{i=1}^d n_i = n_1n_2\cdot…\cdot n_d \dim(\mathcal M).\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{𝔽, var&quot;#s135&quot;, TSize, TPR} where {var&quot;#s135&quot;&lt;:AbstractManifold, TPR&lt;:AbstractPowerRepresentation}}, Tuple{TSize}, Tuple{𝔽}} where {𝔽, TSize}" href="#ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{𝔽, var&quot;#s135&quot;, TSize, TPR} where {var&quot;#s135&quot;&lt;:AbstractManifold, TPR&lt;:AbstractPowerRepresentation}}, Tuple{TSize}, Tuple{𝔽}} where {𝔽, TSize}"><code>ManifoldsBase.power_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">power_dimensions(M::PowerManifold)</code></pre><p>return the power of <code>M</code>,</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p, X)</code></pre><p>Project the point <code>X</code> onto the tangent space at <code>p</code> on the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p)</code></pre><p>Project the point <code>p</code> from the embedding onto the <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}" href="#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}"><code>ManifoldsBase.retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::AbstractPowerManifold, p, X, method::PowerRetraction)</code></pre><p>Compute the retraction from <code>p</code> with tangent vector <code>X</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using a <a href="interface.html#ManifoldsBase.PowerRetraction"><code>PowerRetraction</code></a>, which by default encapsulates a retraction of the base manifold. Then this method is performed elementwise, so the encapsulated retraction method has to be one that is available on the base <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any, N} where N}" href="#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any, N} where N}"><code>ManifoldsBase.set_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_component!(M::AbstractPowerManifold, q, p, idx...)</code></pre><p>Set the component of a point <code>q</code> on an <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code> to <code>p</code>, which itself is a point on the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> the power manifold is build on.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, PowerVectorTransport}" href="#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, PowerVectorTransport}"><code>ManifoldsBase.vector_transport_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractPowerManifold, p, X, q, method::PowerVectorTransport)</code></pre><p>Compute the vector transport the tangent vector <code>X</code>at <code>p</code> to <code>q</code> on the <a href="interface.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> using an <a href="interface.html#ManifoldsBase.PowerVectorTransport"><code>PowerVectorTransport</code></a> <code>m</code>. This method is performed elementwise, i.e. the method <code>m</code> has to be implemented on the base manifold.</p></div></section></article><h2 id="ValidationManifold"><a class="docs-heading-anchor" href="#ValidationManifold">ValidationManifold</a><a id="ValidationManifold-1"></a><a class="docs-heading-anchor-permalink" href="#ValidationManifold" title="Permalink"></a></h2><p><a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> is a simple decorator using the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> that “decorates” a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling <a href="interface.html#ManifoldsBase.is_point"><code>is_point</code></a> or <a href="interface.html#ManifoldsBase.is_vector"><code>is_vector</code></a> whenever applicable.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationCoTVector" href="#ManifoldsBase.ValidationCoTVector"><code>ManifoldsBase.ValidationCoTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationCoTVector = ValidationFibreVector{CotangentSpaceType}</code></pre><p>Represent a cotangent vector to a point on an <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationFibreVector" href="#ManifoldsBase.ValidationFibreVector"><code>ManifoldsBase.ValidationFibreVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationFibreVector{TType&lt;:VectorSpaceType} &lt;: AbstractFibreVector{TType}</code></pre><p>Represent a tangent vector to a point on an <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationMPoint" href="#ManifoldsBase.ValidationMPoint"><code>ManifoldsBase.ValidationMPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationMPoint &lt;: AbstractManifoldPoint</code></pre><p>Represent a point on an <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="interface.html#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>s and <a href="interface.html#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationManifold" href="#ManifoldsBase.ValidationManifold"><code>ManifoldsBase.ValidationManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationManifold{𝔽,M&lt;:AbstractManifold{𝔽}} &lt;: AbstractDecoratorManifold{𝔽}</code></pre><p>A manifold to encapsulate manifolds working on array representations of <a href="interface.html#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a>s and <a href="interface.html#ManifoldsBase.TVector"><code>TVector</code></a>s in a transparent way, such that for these manifolds it&#39;s not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.</p><p>This manifold is a decorator for a manifold, i.e. it decorates a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with types points, vectors, and covectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationTVector" href="#ManifoldsBase.ValidationTVector"><code>ManifoldsBase.ValidationTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationTVector = ValidationFibreVector{TangentSpaceType}</code></pre><p>Represent a tangent vector to a point on an <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.array_value-Tuple{AbstractArray}" href="#ManifoldsBase.array_value-Tuple{AbstractArray}"><code>ManifoldsBase.array_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array_value(p)</code></pre><p>Return the internal array value of an <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>, <a href="interface.html#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>, or <a href="interface.html#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a> if the value <code>p</code> is encapsulated as such. Return <code>p</code> if it is already an array.</p></div></section></article><h2 id="EmbeddedmanifoldSec"><a class="docs-heading-anchor" href="#EmbeddedmanifoldSec">EmbeddedManifold</a><a id="EmbeddedmanifoldSec-1"></a><a class="docs-heading-anchor-permalink" href="#EmbeddedmanifoldSec" title="Permalink"></a></h2><p>Some manifolds can easily be defined by using a certain embedding. For example the <a href="manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a><code>(n)</code> is embedded in <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a><code>(n+1)</code>. Similar to the metric and <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a>, an embedding is often implicitly assumed. We introduce the embedded manifolds hence as an <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>.</p><p>This decorator enables to use such an embedding in an transparent way. Different types of embeddings can be distinguished using the <a href="interface.html#ManifoldsBase.AbstractEmbeddingType"><code>AbstractEmbeddingType</code></a>, which is an <a href="interface.html#ManifoldsBase.AbstractDecoratorType"><code>AbstractDecoratorType</code></a>.</p><h3 id="Isometric-Embeddings"><a class="docs-heading-anchor" href="#Isometric-Embeddings">Isometric Embeddings</a><a id="Isometric-Embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Isometric-Embeddings" title="Permalink"></a></h3><p>For isometric embeddings the type <a href="interface.html#ManifoldsBase.AbstractIsometricEmbeddingType"><code>AbstractIsometricEmbeddingType</code></a> can be used to avoid reimplementing the metric. See <a href="manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a> or <a href="manifolds/hyperbolic.html#Manifolds.Hyperbolic"><code>Hyperbolic</code></a> for example. Here, the exponential map, the logarithmic map, the retraction and its inverse are set to <code>:intransparent</code>, i.e. they have to be implemented.</p><p>Furthermore, the <a href="interface.html#ManifoldsBase.TransparentIsometricEmbedding"><code>TransparentIsometricEmbedding</code></a> type even states that the exponential and logarithmic maps as well as retractions and vector transports of the embedding can be used for the embedded manifold as well. See <a href="manifolds/symmetric.html#Manifolds.SymmetricMatrices"><code>SymmetricMatrices</code></a> for an example.</p><p>In both cases of course <a href="interface.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> and <a href="interface.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a> have to be implemented.</p><h3 id="Further-Embeddings"><a class="docs-heading-anchor" href="#Further-Embeddings">Further Embeddings</a><a id="Further-Embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Embeddings" title="Permalink"></a></h3><p>A first embedding can also just be given implementing <a href="interface.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a> ann <a href="interface.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a> for a manifold. This is considered to be the most usual or default embedding.</p><p>If you have two different embeddings for your manifold, a second one can be specified using the <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, a type that “couples” two manifolds, more precisely a manifold and its embedding, to define embedding and projection functions between these two manifolds.</p><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractEmbeddedManifold" href="#ManifoldsBase.AbstractEmbeddedManifold"><code>ManifoldsBase.AbstractEmbeddedManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEmbeddedManifold{𝔽,T&lt;:AbstractEmbeddingType,𝔽} &lt;: AbstractDecoratorManifold{𝔽}</code></pre><p>This abstract type indicates that a concrete subtype is an embedded manifold with the additional property, that its points are given in the embedding. This also means, that the default implementation of <a href="interface.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>embed</code></a> is just the identity, since the points are already stored in the form suitable for this embedding specified. This also holds true for tangent vectors.</p><p>Furthermore, depending on the <a href="interface.html#ManifoldsBase.AbstractEmbeddingType"><code>AbstractEmbeddingType</code></a> different methods are transparently used from the embedding, for example the <a href="interface.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a> product or even the <a href="interface.html#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}"><code>distance</code></a> function. Specifying such an embedding type transparently passes the compuation onwards to the embedding (note again, that no <a href="interface.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>embed</code></a> is required) and hence avoids to reimplement these methods in the manifold that is embedded.</p><p>This should be used for example for <a href="interface.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> or <a href="interface.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a>, which should first invoke the test of the embedding and then test further constraints the representation in the embedding has for these points to be valid.</p><p>Technically this is realised by making the <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> is a decorator for the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>s that are subtypes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractEmbeddingType" href="#ManifoldsBase.AbstractEmbeddingType"><code>ManifoldsBase.AbstractEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEmbeddingType &lt;: AbstractDecoratorType</code></pre><p>A type used to specify properties of an <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractIsometricEmbeddingType" href="#ManifoldsBase.AbstractIsometricEmbeddingType"><code>ManifoldsBase.AbstractIsometricEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractIsometricEmbeddingType &lt;: AbstractEmbeddingType</code></pre><p>Characterizes an embedding as isometric. For this case the <a href="interface.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a> product is passed from the embedded manifold to the embedding.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultEmbeddingType" href="#ManifoldsBase.DefaultEmbeddingType"><code>ManifoldsBase.DefaultEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultEmbeddingType &lt;: AbstractEmbeddingType</code></pre><p>A type of default embedding that does not have any special properties.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultIsometricEmbeddingType" href="#ManifoldsBase.DefaultIsometricEmbeddingType"><code>ManifoldsBase.DefaultIsometricEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultIsometricEmbeddingType &lt;: AbstractIsometricEmbeddingType</code></pre><p>An isometric embedding type that acts as a default, i.e. it has no specific properties beyond its isometric property.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.EmbeddedManifold" href="#ManifoldsBase.EmbeddedManifold"><code>ManifoldsBase.EmbeddedManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EmbeddedManifold{𝔽, MT &lt;: AbstractManifold, NT &lt;: AbstractManifold} &lt;: AbstractDecoratorManifold{𝔽}</code></pre><p>A type to represent an explicit embedding of a <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> of type <code>MT</code> embedded into a manifold <code>N</code> of type <code>NT</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This type is not required if a manifold <code>M</code> is to be embedded in one specific manifold <code>N</code>. One can then just implement <a href="interface.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a> and <a href="interface.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a>. Only for a second –maybe considered non-default– embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings <code>N</code>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>manifold</code> the manifold that is an embedded manifold</li><li><code>embedding</code> a second manifold, the first one is embedded into</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">EmbeddedManifold(M, N)</code></pre><p>Generate the <code>EmbeddedManifold</code> of the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TransparentIsometricEmbedding" href="#ManifoldsBase.TransparentIsometricEmbedding"><code>ManifoldsBase.TransparentIsometricEmbedding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransparentIsometricEmbedding &lt;: AbstractIsometricEmbeddingType</code></pre><p>Specify that an embedding is the default isometric embedding. This even inherits logarithmic and exponential map as well as retraction and inverse retractions from the embedding.</p><p>For an example, see <a href="manifolds/symmetric.html#Manifolds.SymmetricMatrices"><code>SymmetricMatrices</code></a> which are isometrically embedded in the Euclidean space of matrices but also inherit exponential and logarithmic maps.</p></div></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold-Union{Tuple{AbstractEmbeddedManifold}, Tuple{N}, Tuple{AbstractEmbeddedManifold, Val{N}}} where N" href="#ManifoldsBase.base_manifold-Union{Tuple{AbstractEmbeddedManifold}, Tuple{N}, Tuple{AbstractEmbeddedManifold, Val{N}}} where N"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_manifold(M::AbstractEmbeddedManifold, d::Val{N} = Val(-1))</code></pre><p>Return the base manifold of <code>M</code> that is enhanced with its embedding. While functions like <code>inner</code> might be overwritten to use the (decorated) manifold representing the embedding, the base<em>manifold is the manifold itself in the sense that detemining e.g. the [`is</em>default_metric<code>](@ref) does not fall back to check with the embedding but with the manifold itself. For this abstract case, just</code>M` is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold-Union{Tuple{EmbeddedManifold}, Tuple{N}, Tuple{EmbeddedManifold, Val{N}}} where N" href="#ManifoldsBase.base_manifold-Union{Tuple{EmbeddedManifold}, Tuple{N}, Tuple{EmbeddedManifold, Val{N}}} where N"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))</code></pre><p>Return the base manifold of <code>M</code> that is enhanced with its embedding. For this specific type the internally stored enhanced manifold <code>M.manifold</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractEmbeddedManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractEmbeddedManifold, Any}"><code>ManifoldsBase.check_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractEmbeddedManifold, p; kwargs)</code></pre><p>check whether a point <code>p</code> is a valid point on the <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a>, i.e. that <code>embed(M, p)</code> is a valid point on the embedded manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractEmbeddedManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractEmbeddedManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractEmbeddedManifold, p, X; kwargs...)</code></pre><p>Check that <code>embed(M, p, X)</code> is a valid tangent to <code>embed(M, p)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_embedding_dispatch-Tuple{AbstractEmbeddedManifold}" href="#ManifoldsBase.default_embedding_dispatch-Tuple{AbstractEmbeddedManifold}"><code>ManifoldsBase.default_embedding_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_embedding_dispatch(M::AbstractEmbeddedManifold)</code></pre><p>This method indicates that an <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> is the default and hence acts completely transparently and passes all functions transparently onwards. This is used by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> within <a href="interface.html#ManifoldsBase.default_decorator_dispatch-Tuple{AbstractManifold}"><code>default_decorator_dispatch</code></a>. By default this is set to <code>Val(false)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_embedding-Tuple{AbstractEmbeddedManifold}" href="#ManifoldsBase.get_embedding-Tuple{AbstractEmbeddedManifold}"><code>ManifoldsBase.get_embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_embedding(M::AbstractEmbeddedManifold)</code></pre><p>Return the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code> an <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> is embedded into.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}" href="#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}"><code>ManifoldsBase.get_embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_embedding(M::EmbeddedManifold)</code></pre><p>Return the <a href="interface.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code> an <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> is embedded into.</p></div></section></article><h2 id="DefaultManifold"><a class="docs-heading-anchor" href="#DefaultManifold">DefaultManifold</a><a id="DefaultManifold-1"></a><a class="docs-heading-anchor-permalink" href="#DefaultManifold" title="Permalink"></a></h2><p><a href="interface.html#ManifoldsBase.DefaultManifold"><code>DefaultManifold</code></a> is a simplified version of <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using <code>Manifolds.jl</code> the <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> is available, the <code>DefaultManifold</code> itself is not exported.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultManifold" href="#ManifoldsBase.DefaultManifold"><code>ManifoldsBase.DefaultManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultManifold &lt;: AbstractManifold</code></pre><p>This default manifold illustrates the main features of the interface and provides a skeleton to build one&#39;s own manifold. It is a simplified/shortened variant of <code>Euclidean</code> from <code>Manifolds.jl</code>.</p><p>This manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.</p></div></section></article><h2 id="Error-Messages"><a class="docs-heading-anchor" href="#Error-Messages">Error Messages</a><a id="Error-Messages-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Messages" title="Permalink"></a></h2><p>especially to collect and display errors on <a href="interface.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>s the following component and collection error messages are available.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ComponentManifoldError" href="#ManifoldsBase.ComponentManifoldError"><code>ManifoldsBase.ComponentManifoldError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompnentError{I,E} &lt;: Exception</code></pre><p>Store an error that occured in a component, where the additional <code>index</code> is stored.</p><p><strong>Fields</strong></p><ul><li><code>index</code> index where the error occured`</li><li><code>error</code> error that occured.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CompositeManifoldError" href="#ManifoldsBase.CompositeManifoldError"><code>ManifoldsBase.CompositeManifoldError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeManifoldError{T} &lt;: Exception</code></pre><p>A composite type to collect a set of errors that occured. Mainly used in conjunction with <a href="interface.html#ManifoldsBase.ComponentManifoldError"><code>ComponentManifoldError</code></a> to store a set of errors that occured.</p><p><strong>Fields</strong></p><ul><li><code>errors</code> a <code>Vector</code> of <code>&lt;:Exceptions</code>.</li></ul></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-AbsilMahonySepulchre2008"><a class="tag is-link" href="#citeref-AbsilMahonySepulchre2008">AbsilMahonySepulchre2008</a><blockquote><p>Absil, P.-A., Mahony, R. and Sepulchre R., <em>Optimization Algorithms on Matrix Manifolds</em> Princeton University Press, 2008, doi: <a href="https://doi.org/10.1515/9781400830244">10.1515/9781400830244</a> <a href="http://press.princeton.edu/chapters/absil/">open access</a></p></blockquote></li><li class="footnote" id="footnote-LorenziPennec2014"><a class="tag is-link" href="#citeref-LorenziPennec2014">LorenziPennec2014</a><blockquote><p>Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild’s to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5–17 doi <a href="https://doi.org/10.1007/s10851-013-0470-3">10.1007/s10851-013-0470-3</a>, hal: <a href="https://hal.inria.fr/hal-00870489">hal-00870489</a></p></blockquote></li><li class="footnote" id="footnote-Pennec2018"><a class="tag is-link" href="#citeref-Pennec2018">Pennec2018</a><blockquote><p>Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: <a href="https://arxiv.org/abs/1805.11436">1805.11436</a></p></blockquote></li><li class="footnote" id="footnote-SatoIwai2013"><a class="tag is-link" href="#citeref-SatoIwai2013">SatoIwai2013</a><blockquote><p>Sato, H., Iwai, T.: <em>A new, globally convergent Riemannian conjugate gradient method</em>, Optimization, 2013, Volume 64(4), pp. 1011–1031. doi: <a href="https://doi.org/10.1080/02331934.2013.836650">10.1080/02331934.2013.836650</a>, arXiv: <a href="https://arxiv.org/abs/1302.0125">1302.0125</a>.</p></blockquote></li><li class="footnote" id="footnote-EhlersPiraniSchild1972"><a class="tag is-link" href="#citeref-EhlersPiraniSchild1972">EhlersPiraniSchild1972</a><blockquote><p>Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O’Raifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63–84. Clarendon Press, Oxford (1972). reprint doi: <a href="https://doi.org/10.1007/s10714-012-1353-4">10.1007/s10714-012-1353-4</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="examples/manifold.html">How to implement a Manifold »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Monday 27 September 2021 09:55">Monday 27 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
