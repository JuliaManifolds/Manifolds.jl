<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Statistics ¬∑ Manifolds.jl</title><meta name="title" content="Statistics ¬∑ Manifolds.jl"/><meta property="og:title" content="Statistics ¬∑ Manifolds.jl"/><meta property="twitter:title" content="Statistics ¬∑ Manifolds.jl"/><meta name="description" content="Documentation for Manifolds.jl."/><meta property="og:description" content="Documentation for Manifolds.jl."/><meta property="twitter:description" content="Documentation for Manifolds.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Manifolds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/getstarted.html">üöÄ Get Started with <code>Manifolds.jl</code></a></li><li><a class="tocitem" href="../tutorials/working-in-charts.html">work in charts</a></li><li><a class="tocitem" href="../tutorials/hand-gestures.html">perform Hand gesture analysis</a></li><li><a class="tocitem" href="../tutorials/integration.html">integrate on manifolds and handle probability densities</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/centeredmatrices.html">Centered matrices</a></li><li><a class="tocitem" href="../manifolds/choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="../manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="../manifolds/elliptope.html">Elliptope</a></li><li><a class="tocitem" href="../manifolds/essentialmanifold.html">Essential manifold</a></li><li><a class="tocitem" href="../manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="../manifolds/fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="../manifolds/flag.html">Flag</a></li><li><a class="tocitem" href="../manifolds/generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="../manifolds/generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="../manifolds/grassmann.html">Grassmann</a></li><li><a class="tocitem" href="../manifolds/hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="../manifolds/lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="../manifolds/multinomialdoublystochastic.html">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="../manifolds/multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="../manifolds/multinomialsymmetric.html">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="../manifolds/oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="../manifolds/probabilitysimplex.html">Probability simplex</a></li><li><a class="tocitem" href="../manifolds/positivenumbers.html">Positive numbers</a></li><li><a class="tocitem" href="../manifolds/projectivespace.html">Projective space</a></li><li><a class="tocitem" href="../manifolds/generalunitary.html">Orthogonal and Unitary Matrices</a></li><li><a class="tocitem" href="../manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="../manifolds/shapespace.html">Shape spaces</a></li><li><a class="tocitem" href="../manifolds/skewhermitian.html">Skew-Hermitian matrices</a></li><li><a class="tocitem" href="../manifolds/spectrahedron.html">Spectrahedron</a></li><li><a class="tocitem" href="../manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="../manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="../manifolds/symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="../manifolds/symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="../manifolds/spdfixeddeterminant.html">SPD, fixed determinant</a></li><li><a class="tocitem" href="../manifolds/symmetricpsdfixedrank.html">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="../manifolds/symplectic.html">Symplectic</a></li><li><a class="tocitem" href="../manifolds/symplecticstiefel.html">Symplectic Stiefel</a></li><li><a class="tocitem" href="../manifolds/torus.html">Torus</a></li><li><a class="tocitem" href="../manifolds/tucker.html">Tucker</a></li><li><a class="tocitem" href="../manifolds/spheresymmetricmatrices.html">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/fiber_bundle.html">Fiber bundle</a></li><li><a class="tocitem" href="../manifolds/graph.html">Graph manifold</a></li><li><a class="tocitem" href="../manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="../manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="../manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/connection.html">Connection manifold</a></li><li><a class="tocitem" href="../manifolds/group.html">Group manifold</a></li><li><a class="tocitem" href="../manifolds/metric.html">Metric manifold</a></li><li><a class="tocitem" href="../manifolds/quotient.html">Quotient manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="atlases.html">Atlases and charts</a></li><li><a class="tocitem" href="differentiation.html">Differentiation</a></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><a class="tocitem" href="group_actions.html">Group actions</a></li><li><a class="tocitem" href="integration.html">Integration</a></li><li class="is-active"><a class="tocitem" href="statistics.html">Statistics</a><ul class="internal"><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="testing.html">Testing</a></li><li><a class="tocitem" href="utilities.html">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="../misc/about.html">About</a></li><li><a class="tocitem" href="../misc/NEWS.html">Changelog</a></li><li><a class="tocitem" href="../misc/CONTRIBUTING.html">Contributing</a></li><li><a class="tocitem" href="../misc/internals.html">Internals</a></li><li><a class="tocitem" href="../misc/notation.html">Notation</a></li><li><a class="tocitem" href="../misc/references.html">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Features on Manifolds</a></li><li class="is-active"><a href="statistics.html">Statistics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="statistics.html">Statistics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/features/statistics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Statistics"><a class="docs-heading-anchor" href="#Statistics">Statistics</a><a id="Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Statistics" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.AbstractEstimationMethod" href="#Manifolds.AbstractEstimationMethod"><code>Manifolds.AbstractEstimationMethod</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEstimationMethod</code></pre><p>Abstract type for defining statistical estimation methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.CyclicProximalPointEstimation" href="#Manifolds.CyclicProximalPointEstimation"><code>Manifolds.CyclicProximalPointEstimation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CyclicProximalPointEstimation &lt;: AbstractEstimationMethod</code></pre><p>Method for estimation using the cyclic proximal point technique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.ExtrinsicEstimation" href="#Manifolds.ExtrinsicEstimation"><code>Manifolds.ExtrinsicEstimation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExtrinsicEstimation &lt;: AbstractEstimationMethod</code></pre><p>Method for estimation in the ambient space and projecting to the manifold.</p><p>For <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, ExtrinsicEstimation}"><code>mean</code></a> estimation, <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> is used for mean estimation in the ambient space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.GeodesicInterpolation" href="#Manifolds.GeodesicInterpolation"><code>Manifolds.GeodesicInterpolation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeodesicInterpolation &lt;: AbstractEstimationMethod</code></pre><p>Repeated weighted geodesic interpolation method for estimating the Riemannian center of mass.</p><p>The algorithm proceeds with the following simple online update:</p><p class="math-container">\[\begin{aligned}
Œº_1 &amp;= x_1\\
t_k &amp;= \frac{w_k}{\sum_{i=1}^k w_i}\\
Œº_{k} &amp;= Œ≥_{Œº_{k-1}}(x_k; t_k),
\end{aligned}\]</p><p>where <span>$x_k$</span> are points, <span>$w_k$</span> are weights, <span>$Œº_k$</span> is the <span>$k$</span>th estimate of the mean, and <span>$Œ≥_x(y; t)$</span> is the point at time <span>$t$</span> along the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold,%20Any,%20Any}"><code>shortest_geodesic</code></a> between points <span>$x,y ‚àà \mathcal M$</span>. The algorithm terminates when all <span>$x_k$</span> have been considered. In the <a href="../manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> case, this exactly computes the weighted mean.</p><p>The algorithm has been shown to converge asymptotically with the sample size for the following manifolds equipped with their default metrics when all sampled points are in an open geodesic ball about the mean with corresponding radius (see <a href="statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a>):</p><ul><li>All simply connected complete Riemannian manifolds with non-positive sectional curvature at radius <span>$‚àû$</span> [<a href="../misc/references.html#ChengHoSalehianVemuri:2016">CHSV16</a>], in particular:<ul><li><a href="../manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a></li><li><a href="../manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite"><code>SymmetricPositiveDefinite</code></a> [<a href="../misc/references.html#HoChengSalehianVemuri:2013">HCSV13</a>]</li></ul></li><li>Other manifolds:<ul><li><a href="../manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a>: <span>$\frac{œÄ}{2}$</span> [<a href="../misc/references.html#SalehianEtAl:2015">SCaO+15</a>]</li><li><a href="../manifolds/grassmann.html#Manifolds.Grassmann"><code>Grassmann</code></a>: <span>$\frac{œÄ}{4}$</span> [<a href="../misc/references.html#ChakrabortyVemuri:2015">CV15</a>]</li><li><a href="../manifolds/stiefel.html#Manifolds.Stiefel"><code>Stiefel</code></a>/<a href="../manifolds/rotations.html#Manifolds.Rotations"><code>Rotations</code></a>: <span>$\frac{œÄ}{2 \sqrt 2}$</span> [<a href="../misc/references.html#ChakrabortyVemuri:2019">CV19</a>]</li></ul></li></ul><p>For online variance computation, the algorithm additionally uses an analogous recursion to the weighted Welford algorithm [<a href="../misc/references.html#West:1979">Wes79</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L41-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.GeodesicInterpolationWithinRadius" href="#Manifolds.GeodesicInterpolationWithinRadius"><code>Manifolds.GeodesicInterpolationWithinRadius</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeodesicInterpolationWithinRadius{T} &lt;: AbstractEstimationMethod</code></pre><p>Estimation of Riemannian center of mass using <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> with fallback to <a href="statistics.html#Manifolds.GradientDescentEstimation"><code>GradientDescentEstimation</code></a> if any points are outside of a geodesic ball of specified <code>radius</code> around the mean.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GeodesicInterpolationWithinRadius(radius)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L83-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.GradientDescentEstimation" href="#Manifolds.GradientDescentEstimation"><code>Manifolds.GradientDescentEstimation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GradientDescentEstimation &lt;: AbstractEstimationMethod</code></pre><p>Method for estimation using gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.WeiszfeldEstimation" href="#Manifolds.WeiszfeldEstimation"><code>Manifolds.WeiszfeldEstimation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeiszfeldEstimation &lt;: AbstractEstimationMethod</code></pre><p>Method for estimation using the Weiszfeld algorithm for the <a href="statistics.html#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, CyclicProximalPointEstimation}"><code>median</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.default_estimation_method-Tuple{AbstractManifold, Any}" href="#Manifolds.default_estimation_method-Tuple{AbstractManifold, Any}"><code>Manifolds.default_estimation_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_estimation_method(M::AbstractManifold, f)</code></pre><p>Specify a default <a href="statistics.html#Manifolds.AbstractEstimationMethod"><code>AbstractEstimationMethod</code></a> for an <code>AbstractManifold</code> for a function <code>f</code>, e.g. the <code>median</code> or the <code>mean</code>.</p><p>Note that his function is decorated, so it can inherit from the embedding, for example for the <code>IsEmbeddedSubmanifold</code> trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L109-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.cov-Tuple{AbstractManifold, AbstractVector}" href="#Statistics.cov-Tuple{AbstractManifold, AbstractVector}"><code>Statistics.cov</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Statistics.cov(
    M::AbstractManifold,
    x::AbstractVector;
    basis::AbstractBasis=DefaultOrthonormalBasis(),
    tangent_space_covariance_estimator::CovarianceEstimator=SimpleCovariance(;
        corrected=true,
    ),
    mean_estimation_method::AbstractEstimationMethod=GradientDescentEstimation(),
    inverse_retraction_method::AbstractInverseRetractionMethod=default_inverse_retraction_method(
        M, eltype(x),
    ),
)</code></pre><p>Estimate the covariance matrix of a set of points <code>x</code> on manifold <code>M</code>. Since the covariance matrix on a manifold is a rank 2 tensor, the function returns its coefficients in basis induced by the given tangent space basis. See Section 5 of [<a href="../misc/references.html#Pennec:2006">Pen06</a>] for details.</p><p>The mean is calculated using the specified <code>mean_estimation_method</code> using [mean](@ref Statistics.mean(::AbstractManifold, ::AbstractVector, ::AbstractEstimationMethod), and tangent vectors at this mean are calculated using the provided <code>inverse_retraction_method</code>. Finally, the covariance matrix in the tangent plane is estimated using the Euclidean space  estimator <code>tangent_space_covariance_estimator</code>. The type <code>CovarianceEstimator</code> is defined  in <a href="https://juliastats.org/StatsBase.jl/stable/cov/#StatsBase.CovarianceEstimator"><code>StatsBase.jl</code></a>  and examples of covariance estimation methods can be found in  <a href="https://github.com/mateuszbaran/CovarianceEstimation.jl/"><code>CovarianceEstimation.jl</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L140-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean!-Tuple{AbstractManifold, Vararg{Any}}" href="#Statistics.mean!-Tuple{AbstractManifold, Vararg{Any}}"><code>Statistics.mean!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean!(M::AbstractManifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)
mean!(
    M::AbstractManifold,
    y,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
)</code></pre><p>Compute the <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> in-place in <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L271-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, ExtrinsicEstimation}" href="#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, ExtrinsicEstimation}"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::ExtrinsicEstimation;
    kwargs...,
)</code></pre><p>Estimate the Riemannian center of mass of <code>x</code> using <a href="statistics.html#Manifolds.ExtrinsicEstimation"><code>ExtrinsicEstimation</code></a>, i.e. by computing the mean in the embedding and projecting the result back. You can specify an <code>extrinsic_method</code> to specify which mean estimation method to use in the embedding, which defaults to <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a>.</p><p>See <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolation}"><code>mean</code></a> for a description of the remaining <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L488-L505">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolationWithinRadius}" href="#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolationWithinRadius}"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::GeodesicInterpolationWithinRadius;
    kwargs...,
)</code></pre><p>Estimate the Riemannian center of mass of <code>x</code> using <a href="statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a>.</p><p>See <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolation}"><code>mean</code></a> for a description of <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L405-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolation}" href="#Statistics.mean-Tuple{AbstractManifold, AbstractVector, AbstractVector, GeodesicInterpolation}"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::GeodesicInterpolation;
    shuffle_rng=nothing,
    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x)),
    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x)),
    kwargs...,
)</code></pre><p>Estimate the Riemannian center of mass of <code>x</code> in an online fashion using repeated weighted geodesic interpolation. See <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> for details.</p><p>If <code>shuffle_rng</code> is provided, it is used to shuffle the order in which the points are considered for computing the mean.</p><p>Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L339-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}" href="#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)</code></pre><p>Compute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector <code>x</code> of points on the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>  <code>M</code>, defined as the point that satisfies the minimizer</p><p class="math-container">\[\argmin_{y ‚àà \mathcal M} \frac{1}{2 \sum_{i=1}^n w_i} \sum_{i=1}^n w_i\mathrm{d}_{\mathcal M}^2(y,x_i),\]</p><p>where <span>$\mathrm{d}_{\mathcal M}$</span> denotes the Riemannian <a href="../manifolds/choleskyspace.html#ManifoldsBase.distance-Tuple{CholeskySpace, Any, Any}"><code>distance</code></a>.</p><p>In the general case, the <a href="statistics.html#Manifolds.GradientDescentEstimation"><code>GradientDescentEstimation</code></a> is used to compute the mean.     mean(         M::AbstractManifold,         x::AbstractVector,         [w::AbstractWeights,]         method::AbstractEstimationMethod=default<em>estimation</em>method(M);         kwargs...,     )</p><p>Compute the mean using the specified <code>method</code>.</p><pre><code class="nohighlight hljs">mean(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::GradientDescentEstimation;
    p0=x[1],
    stop_iter=100,
    retraction::AbstractRetractionMethod = default_retraction_method(M),
    inverse_retraction::AbstractInverseRetractionMethod = default_retraction_method(M, eltype(x)),
    kwargs...,
)</code></pre><p>Compute the mean using the gradient descent scheme <a href="statistics.html#Manifolds.GradientDescentEstimation"><code>GradientDescentEstimation</code></a>.</p><p>Optionally, provide <code>p0</code>, the starting point (by default set to the first data point). <code>stop_iter</code> denotes the maximal number of iterations to perform and the <code>kwargs...</code> are passed to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#Base.isapprox-Tuple{AbstractManifold,%20Any,%20Any}"><code>isapprox</code></a> to stop, when the minimal change between two iterates is small. For more stopping criteria check the <a href="https://manoptjl.org"><code>Manopt.jl</code></a> package and use a solver therefrom.</p><p>Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p><p>The Theory stems from [<a href="../misc/references.html#Karcher:1977">Kar77</a>] and is also described in [<a href="../misc/references.html#PennecArsigny:2012">PA12</a>] as the exponential barycenter. The algorithm is further described in[<a href="../misc/references.html#AfsariTronVidal:2013">ATV13</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L196-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median!-Tuple{AbstractManifold, Vararg{Any}}" href="#Statistics.median!-Tuple{AbstractManifold, Vararg{Any}}"><code>Statistics.median!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median!(M::AbstractManifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)
median!(
    M::AbstractManifold,
    y,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
)</code></pre><p>computes the <a href="statistics.html#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, CyclicProximalPointEstimation}"><code>median</code></a> in-place in <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L703-L715">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, CyclicProximalPointEstimation}" href="#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, CyclicProximalPointEstimation}"><code>Statistics.median</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::CyclicProximalPointEstimation;
    p0=x[1],
    stop_iter=1000000,
    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x),),
    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x),),
    kwargs...,
)</code></pre><p>Compute the median using <a href="statistics.html#Manifolds.CyclicProximalPointEstimation"><code>CyclicProximalPointEstimation</code></a>.</p><p>Optionally, provide <code>p0</code>, the starting point (by default set to the first data point). <code>stop_iter</code> denotes the maximal number of iterations to perform and the <code>kwargs...</code> are passed to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#Base.isapprox-Tuple{AbstractManifold,%20Any,%20Any}"><code>isapprox</code></a> to stop, when the minimal change between two iterates is small. For more stopping criteria check the <a href="https://manoptjl.org"><code>Manopt.jl</code></a> package and use a solver therefrom.</p><p>Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p><p>The algorithm is further described in [<a href="../misc/references.html#Bacak:2014">Bac14</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L567-L594">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, ExtrinsicEstimation}" href="#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, ExtrinsicEstimation}"><code>Statistics.median</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::ExtrinsicEstimation;
    extrinsic_method = CyclicProximalPointEstimation(),
    kwargs...,
)</code></pre><p>Estimate the median of <code>x</code> using <a href="statistics.html#Manifolds.ExtrinsicEstimation"><code>ExtrinsicEstimation</code></a>, i.e. by computing the median in the embedding and projecting the result back. You can specify an <code>extrinsic_method</code> to specify which median estimation method to use in the embedding, which defaults to <a href="statistics.html#Manifolds.CyclicProximalPointEstimation"><code>CyclicProximalPointEstimation</code></a>.</p><p>See <a href="statistics.html#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, CyclicProximalPointEstimation}"><code>median</code></a> for a description of <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L602-L619">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, Manifolds.WeiszfeldEstimation}" href="#Statistics.median-Tuple{AbstractManifold, AbstractVector, AbstractVector, Manifolds.WeiszfeldEstimation}"><code>Statistics.median</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::WeiszfeldEstimation;
    Œ± = 1.0,
    p0=x[1],
    stop_iter=2000,
    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x)),
    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x)),
    kwargs...,
)</code></pre><p>Compute the median using <a href="statistics.html#Manifolds.WeiszfeldEstimation"><code>WeiszfeldEstimation</code></a>.</p><p>Optionally, provide <code>p0</code>, the starting point (by default set to the first data point). <code>stop_iter</code> denotes the maximal number of iterations to perform and the <code>kwargs...</code> are passed to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#Base.isapprox-Tuple{AbstractManifold,%20Any,%20Any}"><code>isapprox</code></a> to stop, when the minimal change between two iterates is small. For more stopping criteria check the <a href="https://manoptjl.org"><code>Manopt.jl</code></a> package and use a solver therefrom.</p><p>The parameter <span>$Œ±\in (0,2]$</span> is a step size.</p><p>The algorithm is further described in [<a href="../misc/references.html#FletcherVenkatasubramanianJoshi:2008">FVJ08</a>], especially the update rule in Eq. (6), i.e. Let <span>$q_{k}$</span> denote the current iterate, <span>$n$</span> the number of points <span>$x_1,\ldots,x_n$</span>, and</p><p class="math-container">\[I_k = \bigl\{ i \in \{1,\ldots,n\} \big| x_i \neq q_k \bigr\}\]</p><p>all indices of points that are not equal to the current iterate. Then the update reads <span>$q_{k+1} = \exp_{q_k}(Œ±X)$</span>, where</p><p class="math-container">\[X = \frac{1}{s}\sum_{i\in I_k} \frac{w_i}{d_{\mathcal M}(q_k,x_i)}\log_{q_k}x_i
\quad
\text{ with }
\quad
s = \sum_{i\in I_k} \frac{w_i}{d_{\mathcal M}(q_k,x_i)},\]</p><p>and where <span>$\mathrm{d}_{\mathcal M}$</span> denotes the Riemannian <a href="../manifolds/choleskyspace.html#ManifoldsBase.distance-Tuple{CholeskySpace, Any, Any}"><code>distance</code></a>.</p><p>Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction, which by default use the exponential and logarithmic map, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L627-L675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median-Tuple{AbstractManifold, Vararg{Any}}" href="#Statistics.median-Tuple{AbstractManifold, Vararg{Any}}"><code>Statistics.median</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)
median(
    M::AbstractManifold,
    x::AbstractVector,
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
)</code></pre><p>Compute the (optionally weighted) Riemannian median of the vector <code>x</code> of points on the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>  <code>M</code>, defined as the point that satisfies the minimizer</p><p class="math-container">\[\argmin_{y ‚àà \mathcal M} \frac{1}{\sum_{i=1}^n w_i} \sum_{i=1}^n w_i\mathrm{d}_{\mathcal M}(y,x_i),\]</p><p>where <span>$\mathrm{d}_{\mathcal M}$</span> denotes the Riemannian <a href="../manifolds/choleskyspace.html#ManifoldsBase.distance-Tuple{CholeskySpace, Any, Any}"><code>distance</code></a>. This function is nonsmooth (i.e nondifferentiable).</p><p>In the general case, the <a href="statistics.html#Manifolds.CyclicProximalPointEstimation"><code>CyclicProximalPointEstimation</code></a> is used to compute the median. However, this default may be overloaded for specific manifolds.</p><p>Compute the median using the specified <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L531-L553">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.std-Tuple{AbstractManifold, Vararg{Any}}" href="#Statistics.std-Tuple{AbstractManifold, Vararg{Any}}"><code>Statistics.std</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">std(M, x, m=mean(M, x); corrected=true, kwargs...)
std(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)</code></pre><p>compute the optionally weighted standard deviation of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>  <code>M</code>, i.e.</p><p class="math-container">\[\sqrt{\frac{1}{c} \sum_{i=1}^n w_i d_{\mathcal M}^2 (x_i,m)},\]</p><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.std">Statistics.std</a>. The mean of <code>x</code> can be specified as <code>m</code>, and the corrected variance can be activated by setting <code>corrected=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L881-L895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.var-Tuple{AbstractManifold, Any}" href="#Statistics.var-Tuple{AbstractManifold, Any}"><code>Statistics.var</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var(M, x, m=mean(M, x); corrected=true)
var(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false)</code></pre><p>compute the (optionally weighted) variance of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>  <code>M</code>, i.e.</p><p class="math-container">\[\frac{1}{c} \sum_{i=1}^n w_i d_{\mathcal M}^2 (x_i,m),\]</p><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.var">Statistics.var</a>. The mean of <code>x</code> can be specified as <code>m</code>, and the corrected variance can be activated by setting <code>corrected=true</code>. All further <code>kwargs...</code> are passed to the computation of the mean (if that is not provided).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L833-L848">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.kurtosis-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights}" href="#StatsBase.kurtosis-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights}"><code>StatsBase.kurtosis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kurtosis(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))</code></pre><p>Compute the excess kurtosis of points in <code>x</code> on manifold <code>M</code>. Optionally provide weights <code>w</code> and/or a precomputed <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L1139-L1145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.mean_and_std-Tuple{AbstractManifold, Vararg{Any}}" href="#StatsBase.mean_and_std-Tuple{AbstractManifold, Vararg{Any}}"><code>StatsBase.mean_and_std</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_and_std(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -&gt; (mean, std)</code></pre><p>Compute the <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> and the standard deviation <a href="statistics.html#Statistics.std-Tuple{AbstractManifold, Vararg{Any}}"><code>std</code></a> simultaneously.</p><pre><code class="nohighlight hljs">mean_and_std(
    M::AbstractManifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use the <code>method</code> for simultaneously computing the mean and standard deviation. To use a mean-specific method, call <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> and then <a href="statistics.html#Statistics.std-Tuple{AbstractManifold, Vararg{Any}}"><code>std</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L1070-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights, GeodesicInterpolationWithinRadius}" href="#StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights, GeodesicInterpolationWithinRadius}"><code>StatsBase.mean_and_var</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_and_var(
    M::AbstractManifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::GeodesicInterpolationWithinRadius;
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.</p><p>See <a href="statistics.html#Manifolds.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a> and <a href="statistics.html#StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights, GeodesicInterpolation}"><code>mean_and_var</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L1024-L1039">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights, GeodesicInterpolation}" href="#StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights, GeodesicInterpolation}"><code>StatsBase.mean_and_var</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_and_var(
    M::AbstractManifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::GeodesicInterpolation;
    shuffle_rng::Union{AbstractRNG,Nothing} = nothing,
    retraction::AbstractRetractionMethod = default_retraction_method(M, eltype(x)),
    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M, eltype(x)),
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use the repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.</p><p>If <code>shuffle_rng</code> is provided, it is used to shuffle the order in which the points are considered. Optionally, pass <code>retraction</code> and <code>inverse_retraction</code> method types to specify the (inverse) retraction.</p><p>See <a href="statistics.html#Manifolds.GeodesicInterpolation"><code>GeodesicInterpolation</code></a> for details on the geodesic interpolation method.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Welford algorithm for the variance is experimental and is not guaranteed to give accurate results except on <a href="../manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L951-L976">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.mean_and_var-Tuple{AbstractManifold, Vararg{Any}}" href="#StatsBase.mean_and_var-Tuple{AbstractManifold, Vararg{Any}}"><code>StatsBase.mean_and_var</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_and_var(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -&gt; (mean, var)</code></pre><p>Compute the <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> and the <a href="statistics.html#Statistics.var-Tuple{AbstractManifold, Any}"><code>var</code></a>iance simultaneously. See those functions for a description of the arguments.</p><pre><code class="nohighlight hljs">mean_and_var(
    M::AbstractManifold,
    x::AbstractVector
    [w::AbstractWeights,]
    method::AbstractEstimationMethod;
    kwargs...,
) -&gt; (mean, var)</code></pre><p>Use the <code>method</code> for simultaneously computing the mean and variance. To use a mean-specific method, call <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> and then <a href="statistics.html#Statistics.var-Tuple{AbstractManifold, Any}"><code>var</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L898-L915">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.moment" href="#StatsBase.moment"><code>StatsBase.moment</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moment(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))</code></pre><p>Compute the <code>k</code>th central moment of points in <code>x</code> on manifold <code>M</code>. Optionally provide weights <code>w</code> and/or a precomputed <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L1096-L1102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.skewness-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights}" href="#StatsBase.skewness-Tuple{AbstractManifold, AbstractVector, StatsBase.AbstractWeights}"><code>StatsBase.skewness</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">skewness(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))</code></pre><p>Compute the standardized skewness of points in <code>x</code> on manifold <code>M</code>. Optionally provide weights <code>w</code> and/or a precomputed <a href="statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b2d83b337e214158f64d22a39776b9a80ffd2981/src/statistics.jl#L1120-L1126">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[ATV13]</dt><dd><div>B.¬†Afsari, R.¬†Tron and R.¬†Vidal. <em>On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass</em>. <a href="https://doi.org/10.1137/12086282x">SIAM¬†Journal¬†on¬†Control¬†and¬†Optimization <strong>51</strong>, 2230‚Äì2260</a> (2013), <a href="https://arxiv.org/abs/1201.0925">arXiv:1201.0925</a>.</div></dd><dt>[Bac14]</dt><dd><div>M.¬†Baƒç√°k. <em>Computing medians and means in Hadamard spaces</em>. <a href="https://doi.org/10.1137/140953393">SIAM¬†Journal¬†on¬†Optimization <strong>24</strong>, 1542‚Äì1566</a> (2014), <a href="https://arxiv.org/abs/1210.2145">arXiv:1210.2145</a>, arXiv: <a href="https://arxiv.org/abs/1210.2145">1210.2145</a>.</div></dd><dt>[CV15]</dt><dd><div>R.¬†Chakraborty and B.¬†C.¬†Vemuri. <a href="https://doi.org/10.1109/iccv.2015.481"><em>Recursive Fr√©chet Mean Computation on the Grassmannian and Its Applications to Computer Vision</em></a>. In: <em>2015 IEEE International Conference on Computer Vision (ICCV)</em> (2015).</div></dd><dt>[CV19]</dt><dd><div>R.¬†Chakraborty and B.¬†C.¬†Vemuri. <em>Statistics on the Stiefel manifold: Theory and applications</em>. <a href="https://doi.org/10.1214/18-aos1692">The¬†Annals¬†of¬†Statistics <strong>47</strong></a> (2019), <a href="https://arxiv.org/abs/1708.00045">arXiv:1708.00045</a>.</div></dd><dt>[CHSV16]</dt><dd><div>G.¬†Cheng, J.¬†Ho, H.¬†Salehian and B.¬†C.¬†Vemuri. <a href="https://doi.org/10.1007/978-3-319-22957-7_2"><em>Recursive Computation of the Fr√©chet Mean on Non-positively Curved Riemannian Manifolds with Applications</em></a>. In: <em>Riemannian Computing in Computer Vision</em> (Springer, Cham, 2016); pp.¬†21‚Äì43.</div></dd><dt>[FVJ08]</dt><dd><div>P.¬†T.¬†Fletcher, S.¬†Venkatasubramanian and S.¬†Joshi. <a href="https://doi.org/10.1109/cvpr.2008.4587747"><em>Robust statistics on Riemannian manifolds via the geometric median</em></a>. In: <em>2008 IEEE Conference on Computer Vision and Pattern Recognition</em> (2008).</div></dd><dt>[HCSV13]</dt><dd><div>J.¬†Ho, G.¬†Cheng, H.¬†Salehian and B.¬†C.¬†Vemuri. <a href="http://proceedings.mlr.press/v31/ho13a.pdf"><em>Recursive Karcher expectation estimators and geometric law of large numbers</em></a>. In: <em>16th International Conference on Artificial Intelligence and Statistics</em> (2013).</div></dd><dt>[Kar77]</dt><dd><div>H.¬†Karcher. <em>Riemannian center of mass and mollifier smoothing</em>. <a href="https://doi.org/10.1002/cpa.3160300502">Communications¬†on¬†Pure¬†and¬†Applied¬†Mathematics <strong>30</strong>, 509‚Äì541</a> (1977).</div></dd><dt>[Pen06]</dt><dd><div>X.¬†Pennec. <em>Intrinsic Statistics on Riemannian Manifolds: Basic Tools for Geometric Measurements</em>. <a href="https://doi.org/10.1007/s10851-006-6228-4">Journal¬†of¬†Mathematical¬†Imaging¬†and¬†Vision <strong>25</strong>, 127‚Äì154</a> (2006).</div></dd><dt>[PA12]</dt><dd><div>X.¬†Pennec and V.¬†Arsigny. <a href="https://doi.org/10.1007/978-3-642-30232-9_7"><em>Exponential Barycenters of the Canonical Cartan Connection and Invariant Means on Lie Groups</em></a>. In: <em>Matrix Information Geometry</em> (Springer, Berlin, Heidelberg, 2012); pp.¬†123‚Äì166, <a href="https://arxiv.org/abs/00699361">arXiv:00699361</a>.</div></dd><dt>[SCaO+15]</dt><dd><div>H.¬†Salehian, R.¬†Chakraborty, E.¬†and¬†Ofori, D.¬†Vaillancourt and B.¬†C.¬†Vemuri. <a href="https://www-sop.inria.fr/asclepios/events/MFCA15/Papers/MFCA15_4_2.pdf"><em>An efficient recursive estimator of the Fr√©chet mean on hypersphere with applications to Medical Image Analysis</em></a>. In: <em>5th MICCAI workshop on Mathematical Foundations of Computational Anatomy</em> (Oct 2015).</div></dd><dt>[Wes79]</dt><dd><div>D.¬†H.¬†West. <em>Updating mean and variance estimates</em>. <a href="https://doi.org/10.1145/359146.359153">Communications¬†of¬†the¬†ACM <strong>22</strong>, 532‚Äì535</a> (1979).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="integration.html">¬´ Integration</a><a class="docs-footer-nextpage" href="testing.html">Testing ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 17 November 2023 17:15">Friday 17 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
