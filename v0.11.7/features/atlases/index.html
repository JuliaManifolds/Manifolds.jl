<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Atlases and charts ¬∑ Manifolds.jl</title><meta name="title" content="Atlases and charts ¬∑ Manifolds.jl"/><meta property="og:title" content="Atlases and charts ¬∑ Manifolds.jl"/><meta property="twitter:title" content="Atlases and charts ¬∑ Manifolds.jl"/><meta name="description" content="Documentation for Manifolds.jl."/><meta property="og:description" content="Documentation for Manifolds.jl."/><meta property="twitter:description" content="Documentation for Manifolds.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manifolds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üöÄ Get Started with <code>Manifolds.jl</code></a></li><li><a class="tocitem" href="../../tutorials/working-in-charts/">work in charts</a></li><li><a class="tocitem" href="../../tutorials/work-with-a-metric-defined-in-a-chart/">work with a metric defined in a chart</a></li><li><a class="tocitem" href="../../tutorials/hand-gestures/">perform Hand gesture analysis</a></li><li><a class="tocitem" href="../../tutorials/integration/">integrate on manifolds and handle probability densities</a></li><li><a class="tocitem" href="../../tutorials/exploring-curvature/">explore curvature without coordinates</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manifolds/centeredmatrices/">Centered matrices</a></li><li><a class="tocitem" href="../../manifolds/choleskyspace/">Cholesky space</a></li><li><a class="tocitem" href="../../manifolds/circle/">Circle</a></li><li><a class="tocitem" href="../../manifolds/determinantone/">Determinant one matrices</a></li><li><a class="tocitem" href="../../manifolds/elliptope/">Elliptope</a></li><li><a class="tocitem" href="../../manifolds/essentialmanifold/">Essential manifold</a></li><li><a class="tocitem" href="../../manifolds/euclidean/">Euclidean</a></li><li><a class="tocitem" href="../../manifolds/fixedrankmatrices/">Fixed-rank matrices</a></li><li><a class="tocitem" href="../../manifolds/flag/">Flag</a></li><li><a class="tocitem" href="../../manifolds/generalizedstiefel/">Generalized Stiefel</a></li><li><a class="tocitem" href="../../manifolds/generalizedgrassmann/">Generalized Grassmann</a></li><li><a class="tocitem" href="../../manifolds/grassmann/">Grassmann</a></li><li><a class="tocitem" href="../../manifolds/hamiltonian/">Hamiltonian</a></li><li><a class="tocitem" href="../../manifolds/heisenberg/">Heisenberg matrices</a></li><li><a class="tocitem" href="../../manifolds/hyperbolic/">Hyperbolic space</a></li><li><a class="tocitem" href="../../manifolds/hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../manifolds/invertible/">Invertible matrices</a></li><li><a class="tocitem" href="../../manifolds/lorentz/">Lorentzian manifold</a></li><li><a class="tocitem" href="../../manifolds/multinomialdoublystochastic/">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="../../manifolds/multinomial/">Multinomial matrices</a></li><li><a class="tocitem" href="../../manifolds/multinomialsymmetric/">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="../../manifolds/multinomialsymmetricpositivedefinite/">Multinomial symmetric positive definite matrices</a></li><li><a class="tocitem" href="../../manifolds/oblique/">Oblique manifold</a></li><li><a class="tocitem" href="../../manifolds/probabilitysimplex/">Probability simplex</a></li><li><a class="tocitem" href="../../manifolds/positivenumbers/">Positive numbers</a></li><li><a class="tocitem" href="../../manifolds/projectivespace/">Projective space</a></li><li><a class="tocitem" href="../../manifolds/generalunitary/">Orthogonal and Unitary Matrices</a></li><li><a class="tocitem" href="../../manifolds/rotations/">Rotations</a></li><li><a class="tocitem" href="../../manifolds/segre/">Segre</a></li><li><a class="tocitem" href="../../manifolds/shapespace/">Shape spaces</a></li><li><a class="tocitem" href="../../manifolds/skewhermitian/">Skew-Hermitian matrices</a></li><li><a class="tocitem" href="../../manifolds/spectrahedron/">Spectrahedron</a></li><li><a class="tocitem" href="../../manifolds/sphere/">Sphere</a></li><li><a class="tocitem" href="../../manifolds/stiefel/">Stiefel</a></li><li><a class="tocitem" href="../../manifolds/symmetric/">Symmetric matrices</a></li><li><a class="tocitem" href="../../manifolds/symmetricpositivedefinite/">Symmetric positive definite</a></li><li><a class="tocitem" href="../../manifolds/spdfixeddeterminant/">SPD, fixed determinant</a></li><li><a class="tocitem" href="../../manifolds/symmetricpsdfixedrank/">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="../../manifolds/symplecticgrassmann/">Symplectic Grassmann</a></li><li><a class="tocitem" href="../../manifolds/symplectic/">Symplectic matrices</a></li><li><a class="tocitem" href="../../manifolds/symplecticstiefel/">Symplectic Stiefel</a></li><li><a class="tocitem" href="../../manifolds/torus/">Torus</a></li><li><a class="tocitem" href="../../manifolds/tucker/">Tucker</a></li><li><a class="tocitem" href="../../manifolds/spheresymmetricmatrices/">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manifolds/fiber_bundle/">Fiber bundle</a></li><li><a class="tocitem" href="../../manifolds/graph/">Graph manifold</a></li><li><a class="tocitem" href="../../manifolds/power/">Power manifold</a></li><li><a class="tocitem" href="../../manifolds/product/">Product manifold</a></li><li><a class="tocitem" href="../../manifolds/vector_bundle/">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manifolds/connection/">Connection manifold</a></li><li><a class="tocitem" href="../../manifolds/metric/">Metric manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li class="is-active"><a class="tocitem" href>Atlases and charts</a><ul class="internal"><li><a class="tocitem" href="#Cotangent-space-and-musical-isomorphisms"><span>Cotangent space and musical isomorphisms</span></a></li><li><a class="tocitem" href="#Computations-in-charts"><span>Computations in charts</span></a></li></ul></li><li><a class="tocitem" href="../differentiation/">Differentiation</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../integration/">Integration</a></li><li><a class="tocitem" href="../statistics/">Statistics</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="../../misc/about/">About</a></li><li><a class="tocitem" href="../../misc/NEWS/">Changelog</a></li><li><a class="tocitem" href="../../misc/CONTRIBUTING/">Contributing</a></li><li><a class="tocitem" href="../../misc/internals/">Internals</a></li><li><a class="tocitem" href="../../misc/testsuite/">Test suite</a></li><li><a class="tocitem" href="../../misc/notation/">Notation</a></li><li><a class="tocitem" href="../../misc/references/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Features on Manifolds</a></li><li class="is-active"><a href>Atlases and charts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Atlases and charts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/features/atlases.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="atlases_and_charts"><a class="docs-heading-anchor" href="#atlases_and_charts">Atlases and charts</a><a id="atlases_and_charts-1"></a><a class="docs-heading-anchor-permalink" href="#atlases_and_charts" title="Permalink"></a></h1><p>Atlases on an <span>$n$</span>-dimensional manifold <span>$\mathcal M$</span>are collections of charts <span>$\mathcal A = \{(U_i, œÜ_i) \colon i \in I\}$</span>, where <span>$I$</span> is a (finite or infinite) index family, such that <span>$U_i \subseteq \mathcal M$</span> is an open set and each chart <span>$œÜ_i: U_i ‚Üí ‚Ñù^n$</span> is a homeomorphism. This means, that <span>$œÜ_i$</span> is bijective ‚Äì sometimes also called one-to-one and onto - and continuous, and its inverse <span>$œÜ_i^{-1}$</span> is continuous as well. The inverse <span>$œÜ_i^{-1}$</span> is called (local) parametrization. The resulting <em>parameters</em> <span>$a=œÜ(p)$</span> of <span>$p$</span> (with respect to the chart <span>$œÜ$</span>) are in the literature also called ‚Äú(local) coordinates‚Äù. To distinguish the parameter <span>$a$</span> from  <a href="../../manifolds/circle/#ManifoldsBase.get_coordinates-Tuple{Circle{‚ÑÇ}, Any, Any, DefaultOrthonormalBasis{&lt;:Any, TangentSpaceType}}"><code>get_coordinates</code></a> in a basis, we use the terminology parameter in this package.</p><p>For an atlas <span>$\mathcal A$</span> we further require that</p><p class="math-container">\[\displaystyle\bigcup_{i\in I} U_i = \mathcal M.\]</p><p>We say that <span>$œÜ_i$</span> is a chart about <span>$p$</span>, if <span>$p\in U_i$</span>. An atlas provides a connection between a manifold and the Euclidean space <span>$‚Ñù^n$</span>, since locally, a chart about <span>$p$</span> can be used to identify its neighborhood (as long as you stay in <span>$U_i$</span>) with a subset of a Euclidean space. Most manifolds we consider are smooth, i.e. any change of charts <span>$œÜ_i \circ œÜ_j^{-1}: ‚Ñù^n ‚Üí ‚Ñù^n$</span>, where <span>$i,j\in I$</span>, is a smooth function. These changes of charts are also called transition maps.</p><p>Most operations on manifolds in <code>Manifolds.jl</code> avoid operating in a chart through appropriate embeddings and formulas derived for particular manifolds, though atlases provide the most general way of working with manifolds. Compared to these approaches, using an atlas is often more technical and time-consuming. They are extensively used in metric-related functions on <a href="../../manifolds/metric/#Manifolds.MetricManifold"><code>MetricManifold</code></a>s.</p><p>Atlases are represented by objects of subtypes of <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a>. There are no type restrictions for indices of charts in atlases.</p><p>Operations using atlases and charts are available through the following functions:</p><ul><li><a href="#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_chart_index</code></a> can be used to select an appropriate chart for the neighborhood of a given point <span>$p$</span>. This function should work deterministically, i.e. for a fixed <span>$p$</span> always return the same chart.</li><li><a href="#Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_parameters</code></a> converts a point to its parameters with respect to the chart in a chart.</li><li><a href="#Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_point</code></a> converts parameters (local coordinates) in a chart to the point that corresponds to them.</li><li><a href="#Manifolds.induced_basis-Tuple{AbstractManifold, AbstractAtlas, Any, VectorSpaceType}"><code>induced_basis</code></a> returns a basis of a given vector space at a point induced by a chart <span>$œÜ$</span>.</li><li><a href="#Manifolds.transition_map-Tuple{AbstractManifold, AbstractAtlas, Any, AbstractAtlas, Any, Any}"><code>transition_map</code></a> converts coordinates of a point between two charts, e.g. computes <span>$œÜ_i\circ œÜ_j^{-1}: ‚Ñù^n ‚Üí ‚Ñù^n$</span>, <span>$i,j\in I$</span>.</li></ul><p>While an atlas could store charts as explicit functions, it is favourable, that the [<code>get_parameters</code>] actually implements a chart <span>$œÜ$</span>, <a href="#Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_point</code></a> its inverse, the prametrization <span>$œÜ^{-1}$</span>.</p><article><details class="docstring" open="true"><summary id="Manifolds.AbstractAtlas"><a class="docstring-binding" href="#Manifolds.AbstractAtlas"><code>Manifolds.AbstractAtlas</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractAtlas{ùîΩ}</code></pre><p>An abstract class for atlases with charts that have values in the vector space <code>ùîΩ‚Åø</code> for some value of <code>n</code>. <code>ùîΩ</code> is a number system determined by an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#number-system"><code>AbstractNumbers</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.InducedBasis"><a class="docstring-binding" href="#Manifolds.InducedBasis"><code>Manifolds.InducedBasis</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InducedBasis(vs::VectorSpaceType, A::AbstractAtlas, i)</code></pre><p>The basis induced by chart with index <code>i</code> from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> of vector space of type <code>vs</code>.</p><p>For the <code>vs</code> a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> this works as  follows:</p><p>Let <span>$n$</span> denote the dimension of the manifold <span>$\mathcal M$</span>.</p><p>Let the parameter <span>$a=œÜ_i(p) ‚àà \mathbb R^n$</span> and <span>$j‚àà\{1,‚Ä¶,n\}$</span>. We can look at the <span>$j$</span>th parameter curve <span>$b_j(t) = a + te_j$</span>, where <span>$e_j$</span> denotes the <span>$j$</span>th unit vector. Using the parametrisation we obtain a curve <span>$c_j(t) = œÜ_i^{-1}(b_j(t))$</span> which fulfills <span>$c(0) = p$</span>.</p><p>Now taking the derivative(s) with respect to <span>$t$</span> (and evaluate at <span>$t=0$</span>), we obtain a tangent vector for each <span>$j$</span> corresponding to an equivalence class of curves (having the same derivative) as</p><p class="math-container">\[X_j = [c_j] = \frac{\mathrm{d}}{\mathrm{d}t} c_i(t) \Bigl|_{t=0}\]</p><p>and the set <span>$\{X_1,\ldots,X_n\}$</span> is the chart-induced basis of <span>$T_p\mathcal M$</span>.</p><p><strong>See also</strong></p><p><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a>, <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L451-L478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.RetractionAtlas"><a class="docstring-binding" href="#Manifolds.RetractionAtlas"><code>Manifolds.RetractionAtlas</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RetractionAtlas{
    ùîΩ,
    TRetr&lt;:AbstractRetractionMethod,
    TInvRetr&lt;:AbstractInverseRetractionMethod,
    TBasis&lt;:AbstractBasis,
} &lt;: AbstractAtlas{ùîΩ}</code></pre><p>An atlas indexed by points on a manifold, <span>$\mathcal M = I$</span> and parameters (local coordinates) are given in <span>$T_p\mathcal M$</span>. This means that a chart <span>$œÜ_p = \mathrm{cord}\circ\mathrm{retr}_p^{-1}$</span> is only locally defined (around <span>$p$</span>), where <span>$\mathrm{cord}$</span> is the decomposition of the tangent vector into coordinates with respect to the given basis of the tangent space, cf. <a href="../../manifolds/circle/#ManifoldsBase.get_coordinates-Tuple{Circle{‚ÑÇ}, Any, Any, DefaultOrthonormalBasis{&lt;:Any, TangentSpaceType}}"><code>get_coordinates</code></a>. The parametrization is given by <span>$œÜ_p^{-1}=\mathrm{retr}_p\circ\mathrm{vec}$</span>, where <span>$\mathrm{vec}$</span> turns the basis coordinates into a tangent vector, cf. <a href="../../manifolds/generalunitary/#ManifoldsBase.get_vector-Tuple{Manifolds.GeneralUnitaryMatrices{‚Ñù}, Vararg{Any}}"><code>get_vector</code></a>.</p><p>In short: The coordinates with respect to a basis are used together with a retraction as a parametrization.</p><p><strong>See also</strong></p><p><a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a>, <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>, <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>, <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L10-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.norm-Tuple{AbstractManifold, AbstractAtlas, Any, Any, Any}"><a class="docstring-binding" href="#LinearAlgebra.norm-Tuple{AbstractManifold, AbstractAtlas, Any, Any, Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm(M::AbstractManifold, A::AbstractAtlas, i, a, Xc)</code></pre><p>Calculate norm on manifold <code>M</code> at point with parameters <code>a</code> in chart <code>i</code> of an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> of vector with coefficients <code>Xc</code> in induced basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L342-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.affine_connection!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><a class="docstring-binding" href="#Manifolds.affine_connection!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><code>Manifolds.affine_connection!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">affine_connection!(M::AbstractManifold, Zc, A::AbstractAtlas, i, a, Xc, Yc)</code></pre><p>Calculate affine connection on manifold <code>M</code> at point with parameters <code>a</code> in chart <code>i</code> of an an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> of vectors with coefficients <code>Zc</code> and <code>Yc</code> in induced basis and save the result in <code>Zc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L68-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.affine_connection-Tuple{AbstractManifold, Vararg{Any, 5}}"><a class="docstring-binding" href="#Manifolds.affine_connection-Tuple{AbstractManifold, Vararg{Any, 5}}"><code>Manifolds.affine_connection</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">affine_connection(M::AbstractManifold, A::AbstractAtlas, i, a, Xc, Yc)</code></pre><p>Calculate affine connection on manifold <code>M</code> at point with parameters <code>a</code> in chart <code>i</code> of <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> of vectors with coefficients <code>Xc</code> and <code>Yc</code> in induced basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L57-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.check_chart_switch-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.check_chart_switch-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.check_chart_switch</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_chart_switch(M::AbstractManifold, A::AbstractAtlas, i, a)</code></pre><p>Determine whether chart should be switched when an operation in chart <code>i</code> from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> reaches parameters <code>a</code> in that chart.</p><p>By default <code>false</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L166-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.christoffel_symbols_second-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.christoffel_symbols_second-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.christoffel_symbols_second</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">christoffel_symbols_second(M::AbstractManifold, A::AbstractAtlas, i, a)</code></pre><p>Compute values of the Christoffel symbol of the second kind in chart <code>i</code> of atlas <code>A</code> at point with parameters <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L77-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.get_chart_index</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_chart_index(M::AbstractManifold, A::AbstractAtlas, i, a)</code></pre><p>Select a chart from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> for manifold <code>M</code> that is suitable for representing the neighborhood of point with parametrization <code>a</code> in chart <code>i</code>. This selection should be deterministic, although different charts may be selected for arbitrarily close but distinct points.</p><p><strong>See also</strong></p><p><a href="#Manifolds.get_default_atlas-Tuple{AbstractManifold}"><code>get_default_atlas</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L237-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any}"><a class="docstring-binding" href="#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any}"><code>Manifolds.get_chart_index</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_chart_index(M::AbstractManifold, A::AbstractAtlas, p)</code></pre><p>Select a chart from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> for manifold <code>M</code> that is suitable for representing the neighborhood of point <code>p</code>. This selection should be deterministic, although different charts may be selected for arbitrarily close but distinct points.</p><p><strong>See also</strong></p><p><a href="#Manifolds.get_default_atlas-Tuple{AbstractManifold}"><code>get_default_atlas</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L222-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.get_coordinates_induced_basis!-Tuple{AbstractManifold, Any, Any, Any, InducedBasis{‚Ñù, TangentSpaceType}}"><a class="docstring-binding" href="#Manifolds.get_coordinates_induced_basis!-Tuple{AbstractManifold, Any, Any, Any, InducedBasis{‚Ñù, TangentSpaceType}}"><code>Manifolds.get_coordinates_induced_basis!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_coordinates_induced_basis!(M::AbstractManifold, c, p, X, B::InducedBasis{‚Ñù, TangentSpaceType, &lt;:AbstractAtlas};
    backend::AbstractADType = AutoForwardDiff())</code></pre><p>Compute the coordinates of a tangent vector <code>X</code> at a point <code>p</code> on the manifold <code>M</code> in the induced basis <code>B</code>  and store the result in <code>c</code>. This function uses automatic differentiation to compute the coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code>: The manifold on which the computation is performed.</li><li><code>c</code>: The output array where the coordinates of the tangent vector will be stored.</li><li><code>p</code>: The point on the manifold where the tangent vector <code>X</code> is located.</li><li><code>X</code>: The tangent vector at <code>p</code> whose coordinates are to be computed.</li><li><code>B::InducedBasis{‚Ñù, TangentSpaceType, &lt;:AbstractAtlas}</code>: The induced basis in which the coordinates are expressed.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>backend::AbstractADType</code>: The automatic differentiation backend used for computing derivatives (default: <code>AutoForwardDiff()</code>).</li></ul><p><strong>Returns</strong></p><p>The result is stored in <code>c</code>, which contains the coordinates of the tangent vector <code>X</code> in the induced basis <code>B</code>.</p><p><strong>Notes</strong></p><ul><li>This function computes the coordinates by differentiating the chart map at the given point <code>p</code> in the direction of <code>X</code>.</li><li>The computation relies on automatic differentiation.</li></ul><p><strong>See also</strong></p><p><a href="#Manifolds.InducedBasis"><code>InducedBasis</code></a>, <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L685-L716">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.get_default_atlas-Tuple{AbstractManifold}"><a class="docstring-binding" href="#Manifolds.get_default_atlas-Tuple{AbstractManifold}"><code>Manifolds.get_default_atlas</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_default_atlas(::AbstractManifold)</code></pre><p>Determine the default real-valued atlas for the given manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.get_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_parameters(M::AbstractManifold, A::AbstractAtlas, i, p)</code></pre><p>Calculate parameters (local coordinates) of point <code>p</code> on manifold <code>M</code> in chart from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> at index <code>i</code>. This function is hence an implementation of the chart <span>$œÜ_i(p), i\in I$</span>. The parameters are in the number system determined by <code>A</code>. If the point <span>$p\notin U_i$</span> is not in the domain of the chart, this method should throw an error.</p><p><strong>See also</strong></p><p><a href="#Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_point</code></a>, <a href="#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_chart_index</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L133-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.get_point</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_point(M::AbstractManifold, A::AbstractAtlas, i, a)</code></pre><p>Calculate point at parameters (local coordinates) <code>a</code> on manifold <code>M</code> in chart from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> at index <code>i</code>. This function is hence an implementation of the inverse <span>$œÜ_i^{-1}(a), i\in I$</span> of a chart, also called a parametrization.</p><p><strong>See also</strong></p><p><a href="#Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_parameters</code></a>, <a href="#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_chart_index</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L184-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.get_vector_induced_basis!-Tuple{AbstractManifold, Any, Any, Any, InducedBasis{‚Ñù, TangentSpaceType}}"><a class="docstring-binding" href="#Manifolds.get_vector_induced_basis!-Tuple{AbstractManifold, Any, Any, Any, InducedBasis{‚Ñù, TangentSpaceType}}"><code>Manifolds.get_vector_induced_basis!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_vector_induced_basis!(M::AbstractManifold, Y, p, Xc, B::InducedBasis{‚Ñù, TangentSpaceType, &lt;:AbstractAtlas};
    backend::AbstractADType = AutoForwardDiff())</code></pre><p>Compute the tangent vector <code>Y</code> at a point <code>p</code> on the manifold <code>M</code> corresponding to the coordinates <code>Xc</code>  in the induced basis <code>B</code> and store the result in <code>Y</code>. This function uses automatic differentiation  to compute the tangent vector.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code>: The manifold on which the computation is performed.</li><li><code>Y</code>: The output tangent vector at <code>p</code> corresponding to the coordinates <code>Xc</code> in the induced basis.</li><li><code>p</code>: The point on the manifold where the tangent vector is located.</li><li><code>Xc</code>: The coordinates of the tangent vector in the induced basis <code>B</code>.</li><li><code>B::InducedBasis{‚Ñù, TangentSpaceType, &lt;:AbstractAtlas}</code>: The induced basis in which the coordinates <code>Xc</code> are expressed.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>backend::AbstractADType</code>: The automatic differentiation backend used for computing derivatives (default: <code>AutoForwardDiff()</code>).</li></ul><p><strong>Returns</strong></p><p>The result is stored in <code>Y</code>, which represents the tangent vector at <code>p</code> corresponding to the coordinates <code>Xc</code>  in the induced basis <code>B</code>.</p><p><strong>Notes</strong></p><ul><li>This function computes the tangent vector by differentiating the chart map at the given point <code>p</code>  in the direction of the coordinates <code>Xc</code>.</li><li>The computation relies on automatic differentiation.</li></ul><p><strong>See also</strong></p><p><a href="#Manifolds.InducedBasis"><code>InducedBasis</code></a>, <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L729-L763">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.induced_basis-Tuple{AbstractManifold, AbstractAtlas, Any, VectorSpaceType}"><a class="docstring-binding" href="#Manifolds.induced_basis-Tuple{AbstractManifold, AbstractAtlas, Any, VectorSpaceType}"><code>Manifolds.induced_basis</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">induced_basis(M::AbstractManifold, A::AbstractAtlas, i, VST::VectorSpaceType)</code></pre><p>Basis of vector space of type <code>VST</code> at point <code>p</code> from manifold <code>M</code> induced by chart (<code>A</code>, <code>i</code>).</p><p><strong>See also</strong></p><p><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a>, <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L439-L448">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.induced_basis-Union{Tuple{ùîΩ}, Tuple{AbstractManifold{ùîΩ}, AbstractAtlas, Any}, Tuple{AbstractManifold{ùîΩ}, AbstractAtlas, Any, VectorSpaceType}} where ùîΩ"><a class="docstring-binding" href="#Manifolds.induced_basis-Union{Tuple{ùîΩ}, Tuple{AbstractManifold{ùîΩ}, AbstractAtlas, Any}, Tuple{AbstractManifold{ùîΩ}, AbstractAtlas, Any, VectorSpaceType}} where ùîΩ"><code>Manifolds.induced_basis</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">induced_basis(::AbstractManifold, A::AbstractAtlas, i, VST::VectorSpaceType = TangentSpaceType())</code></pre><p>Get the basis induced by chart with index <code>i</code> from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> of vector space of type <code>vs</code>. Returns an object of type <a href="#Manifolds.InducedBasis"><code>InducedBasis</code></a>.</p><p><strong>See also</strong></p><p><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a>, <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L485-L494">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.inverse_chart_injectivity_radius-Tuple{AbstractManifold, AbstractAtlas, Any}"><a class="docstring-binding" href="#Manifolds.inverse_chart_injectivity_radius-Tuple{AbstractManifold, AbstractAtlas, Any}"><code>Manifolds.inverse_chart_injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_chart_injectivity_radius(M::AbstractManifold, A::AbstractAtlas, i)</code></pre><p>Injectivity radius of <code>get_point</code> for chart <code>i</code> from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> of a manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L504-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.inverse_local_metric-Tuple{AbstractManifold, AbstractAtlas{‚Ñù}, Any, Any}"><a class="docstring-binding" href="#Manifolds.inverse_local_metric-Tuple{AbstractManifold, AbstractAtlas{‚Ñù}, Any, Any}"><code>Manifolds.inverse_local_metric</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_local_metric(M::AbstractManifold, A::AbstractAtlas{‚Ñù}, i, a)</code></pre><p>Compute the inverse of the local metric tensor on the manifold <code>M</code> at the point with parameters <code>a</code>  in chart <code>i</code> of an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code>. The inverse local metric tensor is represented as a matrix,  where each entry corresponds to the inverse of the inner product of basis vectors in the tangent space  at the point with given parameters.</p><p>In contrast, <code>inverse_local_metric(M::AbstractManifold, p, ::InducedBasis)</code> requires passing a point instead of its parameters in a chart.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code>: The manifold on which the metric is computed.</li><li><code>A::AbstractAtlas{‚Ñù}</code>: The atlas defining the charts and coordinate systems on the manifold.</li><li><code>i</code>: The index of the chart in the atlas.</li><li><code>a</code>: The parameters of the point in the chart.</li></ul><p><strong>Returns</strong></p><p>A matrix representing the inverse of the local metric tensor at the point with given parameters.</p><p><strong>See also</strong></p><p><a href="#Manifolds.local_metric-Tuple{AbstractManifold, AbstractAtlas{‚Ñù}, Any, Any}"><code>local_metric</code></a>, <a href="#ManifoldsBase.inner-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><code>inner</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L305-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.kretschmann_scalar-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.kretschmann_scalar-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.kretschmann_scalar</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kretschmann_scalar(M::AbstractManifold, A::AbstractAtlas, i, a; backend::AbstractADType = AutoForwardDiff())</code></pre><p>Compute the Kretschmann scalar <span>$K = R_{abcd} R^{abcd}$</span> at the point given by coordinates <code>a</code> in chart <code>i</code> of atlas <code>A</code> on manifold <code>M</code>.</p><p>This implementation uses the Riemann tensor in the form <span>$R^u_{ijk}$</span> (returned by <code>riemann_tensor</code>) and the inverse local metric <code>g^{ij}</code> (returned by <code>inverse_local_metric</code>) to form the full contraction:</p><p class="math-container">\[    K = g^{u v} g^{i p} g^{j q} g^{k r} R^u_{i j k} R^v_{p q r}\]</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code> : manifold</li><li><code>A::AbstractAtlas</code>   : atlas providing charts / induced basis</li><li><code>i</code>                  : chart index in <code>A</code></li><li><code>a</code>                  : coordinates of the point in chart <code>i</code> (length <code>n</code>)</li><li><code>backend::AbstractADType</code> : automatic-differentiation backend (default <code>AutoForwardDiff()</code>)</li></ul><p><strong>Returns</strong></p><p>Scalar (same element type as <code>a</code>) equal to the Kretschmann scalar at the point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L552-L577">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.levi_civita_affine_connection!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><a class="docstring-binding" href="#Manifolds.levi_civita_affine_connection!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><code>Manifolds.levi_civita_affine_connection!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">levi_civita_affine_connection!(M::AbstractManifold, Zc, A::AbstractAtlas, i, a, Xc, Yc; backend::AbstractADType = AutoForwardDiff())</code></pre><p>Compute the Levi-Civita affine connection on the manifold <code>M</code> at a point with parameters <code>a</code> in chart <code>i</code> of an  <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code>. The connection is calculated for vectors with coefficients <code>Xc</code> and <code>Yc</code> in the induced basis, and the result is stored in <code>Zc</code>.</p><p>The Levi-Civita connection is computed using the metric tensor (<code>inner</code> called in a chart) of the manifold, ensuring that the connection is torsion-free and compatible with the metric. The computation involves the Christoffel symbols of the second kind, which are derived from the metric tensor and its derivatives using automatic differentiation. Note that this computation is relatively slow. Where performance matters, it should be replaced with custom-derived formulas.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code>: The manifold on which the Levi-Civita connection is computed.</li><li><code>Zc</code>: The output vector where the result of the connection is stored.</li><li><code>A::AbstractAtlas</code>: The atlas defining the charts and coordinate systems on the manifold.</li><li><code>i</code>: The index of the chart in the atlas.</li><li><code>a</code>: The parameters (local coordinates) of the point in the chart.</li><li><code>Xc</code>: The coefficients of the first vector in the induced basis.</li><li><code>Yc</code>: The coefficients of the second vector in the induced basis.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>backend::AbstractADType</code>: The automatic differentiation backend used for computing derivatives (default: <code>AutoForwardDiff()</code>).</li></ul><p><strong>Returns</strong></p><p>The result is stored in <code>Zc</code>, which represents the Levi-Civita connection in the induced basis.</p><p><strong>Notes</strong></p><ul><li>The computation involves the inverse of the local metric tensor, which is used to raise indices.</li><li>The directional derivatives of the metric tensor are computed using the specified automatic differentiation backend.</li><li>The function assumes that the input vectors <code>Xc</code> and <code>Yc</code> are expressed in the induced basis of the chart.</li></ul><p><strong>See also</strong></p><p><a href="#Manifolds.affine_connection!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><code>affine_connection!</code></a>, <a href="#Manifolds.local_metric-Tuple{AbstractManifold, AbstractAtlas{‚Ñù}, Any, Any}"><code>local_metric</code></a>, <a href="#ManifoldsBase.inner-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><code>inner</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L608-L649">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.local_metric-Tuple{AbstractManifold, AbstractAtlas{‚Ñù}, Any, Any}"><a class="docstring-binding" href="#Manifolds.local_metric-Tuple{AbstractManifold, AbstractAtlas{‚Ñù}, Any, Any}"><code>Manifolds.local_metric</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_metric(M::AbstractManifold, A::AbstractAtlas{‚Ñù}, i, a)</code></pre><p>Compute the local metric tensor on the manifold <code>M</code> at the point with parameters <code>a</code> in chart <code>i</code>  of an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code>. The local metric tensor is represented as a matrix, where  each entry corresponds to the inner product of basis vectors in the tangent space at the point with given parameters.</p><p>In contrast, <code>local_metric(M::AbstractManifold, p, ::InducedBasis)</code> requires passing a point instead of its parameters in a chart.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code>: The manifold on which the metric is computed.</li><li><code>A::AbstractAtlas{‚Ñù}</code>: The atlas defining the charts and coordinate systems on the manifold.</li><li><code>i</code>: The index of the chart in the atlas.</li><li><code>a</code>: The parameters of the point in the chart.</li></ul><p><strong>Returns</strong></p><p>A matrix representing the local metric tensor at the point with given parameters.</p><p><strong>See also</strong></p><p><a href="#Manifolds.inverse_local_metric-Tuple{AbstractManifold, AbstractAtlas{‚Ñù}, Any, Any}"><code>inverse_local_metric</code></a>, <a href="#ManifoldsBase.inner-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><code>inner</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L259-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.local_metric-Tuple{AbstractManifold, Any, InducedBasis}"><a class="docstring-binding" href="#Manifolds.local_metric-Tuple{AbstractManifold, Any, InducedBasis}"><code>Manifolds.local_metric</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_metric(M::AbstractManifold, p, B::InducedBasis)</code></pre><p>Compute the local metric tensor for vectors expressed in terms of coordinates in basis <code>B</code> on manifold <code>M</code>. The point <code>p</code> is not checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L600-L605">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.ricci_curvature-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.ricci_curvature-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.ricci_curvature</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ricci_curvature(M::AbstractManifold, A::AbstractAtlas, i, a; backend=AutoForwardDiff())</code></pre><p>Compute the scalar Ricci curvature (Ricci scalar) of the manifold <code>M</code> at the point given by coordinates <code>a</code> in chart <code>i</code> of atlas <code>A</code>.</p><p>The scalar curvature is the trace of the Ricci tensor with respect to the inverse local metric:</p><p class="math-container">\[    R = g^{ij} R_{ij}\]</p><p>math</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code> : manifold</li><li><code>A::AbstractAtlas</code>   : atlas providing charts / induced basis</li><li><code>i</code>                  : chart index in <code>A</code></li><li><code>a</code>                  : coordinates of the point in chart <code>i</code> (length <code>n</code>)</li><li><code>backend::AbstractADType</code> : automatic-differentiation backend (default <code>AutoForwardDiff()</code>)</li></ul><p><strong>Returns</strong></p><ul><li>scalar (same element type as <code>a</code>) equal to the Ricci scalar at the point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L777-L800">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.ricci_tensor-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.ricci_tensor-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>Manifolds.ricci_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ricci_tensor(M::AbstractManifold, A::AbstractAtlas, i, a; backend::AbstractADType=AutoForwardDiff())</code></pre><p>Compute the Ricci tensor of the manifold <code>M</code> at the point specified by coordinates <code>a</code> in chart <code>i</code> of atlas <code>A</code>.</p><p>The Ricci tensor is the contraction of the Riemann tensor:</p><p class="math-container">\[    Ric_{p q} = R^u_{p u q}\]</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code> : manifold</li><li><code>A::AbstractAtlas</code>   : atlas providing charts / induced basis</li><li><code>i</code>                  : chart index in <code>A</code></li><li><code>a</code>                  : coordinates of the point in chart <code>i</code> (length <code>n</code>)</li><li><code>backend::AbstractADType</code> : automatic-differentiation backend (default <code>AutoForwardDiff()</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>n√ón</code> matrix with components <code>Ric[p, q]</code> (same element type as <code>a</code>)</li></ul><p><strong>See also</strong></p><ul><li><a href="#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>riemann_tensor</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L811-L838">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.transition_map-Tuple{AbstractManifold, AbstractAtlas, Any, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#Manifolds.transition_map-Tuple{AbstractManifold, AbstractAtlas, Any, AbstractAtlas, Any, Any}"><code>Manifolds.transition_map</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transition_map(M::AbstractManifold, A_from::AbstractAtlas, i_from, A_to::AbstractAtlas, i_to, a)
transition_map(M::AbstractManifold, A::AbstractAtlas, i_from, i_to, a)</code></pre><p>Given coordinates <code>a</code> in chart <code>(A_from, i_from)</code> of a point on manifold <code>M</code>, returns coordinates of that point in chart <code>(A_to, i_to)</code>. If <code>A_from</code> and <code>A_to</code> are equal, <code>A_to</code> can be omitted.</p><p>Mathematically this function is the transition map or change of charts, but it might even be between two atlases <span>$A_{\text{from}} = \{(U_i,œÜ_i)\}_{i\in I}$</span> and <span>$A_{\text{to}} = \{(V_j,\psi_j)\}_{j\in J}$</span>, and hence <span>$I, J$</span> are their index sets. We have <span>$i_{\text{from}}\in I$</span>, <span>$i_{\text{to}}\in J$</span>.</p><p>This method then computes</p><p class="math-container">\[\bigl(\psi_{i_{\text{to}}}\circ œÜ_{i_{\text{from}}}^{-1}\bigr)(a)\]</p><p>Note that, similarly to <a href="#Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_parameters</code></a>, this method should fail the same way if <span>$V_{i_{\text{to}}}\cap U_{i_{\text{from}}}=\emptyset$</span>.</p><p><strong>See also</strong></p><p><a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a>, <a href="#Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_parameters</code></a>, <a href="#Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>get_point</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L350-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.transition_map_diff!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><a class="docstring-binding" href="#Manifolds.transition_map_diff!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><code>Manifolds.transition_map_diff!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transition_map_diff!(M::AbstractManifold, c_out, A::AbstractAtlas, i_from, a, c, i_to)</code></pre><p>Compute <a href="#Manifolds.transition_map_diff-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><code>transition_map_diff</code></a> on given arguments and save the result in <code>c_out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L419-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.transition_map_diff-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><a class="docstring-binding" href="#Manifolds.transition_map_diff-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><code>Manifolds.transition_map_diff</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transition_map_diff(M::AbstractManifold, A::AbstractAtlas, i_from, a, c, i_to)</code></pre><p>Compute differential of transition map from chart <code>i_from</code> to chart <code>i_to</code> from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> on manifold <code>M</code> at point with parameters <code>a</code> on tangent vector with coordinates <code>c</code> in the induced basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L405-L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.inner-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><a class="docstring-binding" href="#ManifoldsBase.inner-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 4}}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inner(M::AbstractManifold, A::AbstractAtlas, i, a, Xc, Yc)</code></pre><p>Calculate inner product on manifold <code>M</code> at point with parameters <code>a</code> in chart <code>i</code> of an atlas <code>A</code> of vectors with coefficients <code>Xc</code> and <code>Yc</code> in induced basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L251-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>ManifoldsBase.riemann_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">riemann_tensor(M::AbstractManifold, A::AbstractAtlas, i, a;
    backend::AbstractADType = AutoForwardDiff()</code></pre><p>Compute the Riemann curvature tensor of manifold <code>M</code> at the point given by parameters <code>a</code> in chart <code>i</code> of atlas <code>A</code>.</p><p>Returns a 4-dimensional array <code>R</code> of size (n,n,n,n) with components <code>R[u,i,j,k] = R^u_{ijk}</code>, where the first index is the contravariant (upper) index and the remaining three are covariant (lower) indices. The components satisfy, for coordinate vector fields e_i:</p><p class="math-container">\[    R^u_{ijk} e_u = (‚àá_{e_i} ‚àá_{e_j} - ‚àá_{e_j} ‚àá_{e_i} - ‚àá_{[e_i,e_j]}) e_k\]</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code>: manifold</li><li><code>A::AbstractAtlas</code>: atlas used for coordinates/induced basis</li><li><code>i</code>: chart index in <code>A</code></li><li><code>a</code>: coordinates of the point in chart <code>i</code> (length <code>n</code>)</li><li><code>backend::AbstractADType</code> : automatic-differentiation backend (default <code>AutoForwardDiff()</code>)</li></ul><p><strong>Notes</strong></p><ul><li>The default implementation computes connection coefficients via <code>affine_connection</code> and their directional derivatives (using automatic differentiation), so it can be expensive. Manifold-specific overrides yielding closed-form curvature are recommended for performance-critical code.</li><li>Use <code>riemann_tensor!(M, Wc, A, i, a, Xc, Yc, Zc)</code> to compute the action <code>R(X,Y)Z</code> on coordinate vectors <code>Xc</code>, <code>Yc</code>, <code>Zc</code> without constructing the full 4-tensor.</li></ul><p><strong>See also</strong></p><p><a href="#Manifolds.affine_connection-Tuple{AbstractManifold, Vararg{Any, 5}}"><code>affine_connection</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L867-L902">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 5}}"><a class="docstring-binding" href="#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, AbstractAtlas, Vararg{Any, 5}}"><code>ManifoldsBase.riemann_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">riemann_tensor(M::AbstractManifold, A::AbstractAtlas, i, a, Xc, Yc, Zc;
               backend::AbstractADType = AutoForwardDiff())</code></pre><p>Compute the action of the Riemann curvature tensor <code>R</code> on tangent vectors with coordinates <code>Xc</code>, <code>Yc</code> and <code>Zc</code> at the point specified by parameters <code>a</code> in chart <code>i</code> of atlas <code>A</code> on manifold <code>M</code>.</p><p>This function returns the vector <code>W (in induced-chart coordinates) given by</code><code>(R(X, Y) Z)</code><code>, i.e. the result of applying the curvature operator to</code>Zc`.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractManifold</code> : manifold</li><li><code>A::AbstractAtlas</code>   : atlas providing charts / induced basis</li><li><code>i</code>                  : chart index in <code>A</code></li><li><code>a</code>                  : coordinates of the point in chart <code>i</code> (length <code>n</code>)</li><li><code>Xc, Yc, Zc</code>         : coordinates of tangent vectors X, Y, Z in the chart-induced basis</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>backend::AbstractADType = AutoForwardDiff()</code> : AD backend used when numerical derivatives are required</li></ul><p><strong>Returns</strong></p><ul><li>A vector (same shape/type as <code>Xc</code>) containing coordinates of <span>$(R(X, Y) Z)$</span> in the induced basis.</li></ul><p><strong>Notes</strong></p><ul><li>The default implementation builds the full 4-index Riemann tensor using the chart affine connection and its derivatives, then contracts with <code>Xc</code>, <code>Yc</code>, <code>Zc</code>. This is convenient but can be expensive; prefer manifold-specific overrides that compute R(X,Y)Z directly for performance-critical code.</li><li>Inputs are expected to be expressed in the chart-induced basis associated with <code>A</code> and <code>i</code>.</li><li>The function uses automatic differentiation (via <code>backend</code>) when computing directional derivatives of connection coefficients.</li></ul><p><strong>See also</strong></p><ul><li><code>riemann_tensor(M, A, i, a)</code> which returns the full 4-tensor</li><li>[]<code>affine_connection</code>](@ref) used to obtain connection coefficients (see <a href="#Manifolds.levi_civita_affine_connection!-Tuple{AbstractManifold, Any, AbstractAtlas, Vararg{Any, 4}}"><code>levi_civita_affine_connection!</code></a> for a generic implementation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/atlases.jl#L955-L991">source</a></section></details></article><h2 id="Cotangent-space-and-musical-isomorphisms"><a class="docs-heading-anchor" href="#Cotangent-space-and-musical-isomorphisms">Cotangent space and musical isomorphisms</a><a id="Cotangent-space-and-musical-isomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Cotangent-space-and-musical-isomorphisms" title="Permalink"></a></h2><p>Related to atlases, there is also support for the cotangent space and coefficients of cotangent vectors in bases of the cotangent space.</p><p>Functions <a href="#Manifolds.sharp-Tuple{AbstractManifold, Any, Any}"><code>sharp</code></a> and <a href="#Manifolds.flat-Tuple{AbstractManifold, Any, Any}"><code>flat</code></a> implement musical isomorphisms for arbitrary vector bundles.</p><article><details class="docstring" open="true"><summary id="Manifolds.RieszRepresenterCotangentVector"><a class="docstring-binding" href="#Manifolds.RieszRepresenterCotangentVector"><code>Manifolds.RieszRepresenterCotangentVector</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RieszRepresenterCotangentVector(M::AbstractManifold, p, X)</code></pre><p>Cotangent vector in Riesz representer form on manifold <code>M</code> at point <code>p</code> with Riesz representer <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/cotangent_space.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.flat-Tuple{AbstractManifold, Any, Any}"><a class="docstring-binding" href="#Manifolds.flat-Tuple{AbstractManifold, Any, Any}"><code>Manifolds.flat</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flat(M::AbstractManifold, p, X)</code></pre><p>Compute the flat isomorphism (one of the musical isomorphisms) of tangent vector <code>X</code> from the vector space of type <code>M</code> at point <code>p</code> from the underlying <code>AbstractManifold</code>.</p><p>The function can be used for example to transform vectors from the tangent bundle to vectors from the cotangent bundle <span>$‚ô≠ : T\mathcal M ‚Üí T^{*}\mathcal M$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/cotangent_space.jl#L27-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.sharp-Tuple{AbstractManifold, Any, Any}"><a class="docstring-binding" href="#Manifolds.sharp-Tuple{AbstractManifold, Any, Any}"><code>Manifolds.sharp</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sharp(M::AbstractManifold, p, Œæ)</code></pre><p>Compute the sharp isomorphism (one of the musical isomorphisms) of vector <code>Œæ</code> from the vector space <code>M</code> at point <code>p</code> from the underlying <code>AbstractManifold</code>.</p><p>The function can be used for example to transform vectors from the cotangent bundle to vectors from the tangent bundle <span>$‚ôØ : T^{*}\mathcal M ‚Üí T\mathcal M$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/cotangent_space.jl#L143-L152">source</a></section></details></article><h2 id="Computations-in-charts"><a class="docs-heading-anchor" href="#Computations-in-charts">Computations in charts</a><a id="Computations-in-charts-1"></a><a class="docs-heading-anchor-permalink" href="#Computations-in-charts" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Manifolds.IntegratorTerminatorNearChartBoundary"><a class="docstring-binding" href="#Manifolds.IntegratorTerminatorNearChartBoundary"><code>Manifolds.IntegratorTerminatorNearChartBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IntegratorTerminatorNearChartBoundary{TKwargs}</code></pre><p>An object for determining the point at which integration of a differential equation in a chart on a manifold should be terminated for the purpose of switching a chart.</p><p>The value stored in <code>check_chart_switch_kwargs</code> will be passed as keyword arguments to  <a href="#Manifolds.check_chart_switch-Tuple{AbstractManifold, AbstractAtlas, Any, Any}"><code>check_chart_switch</code></a>. By default an empty tuple is stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/src/differentiation/ode_callback.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.estimate_distance_from_bvp"><a class="docstring-binding" href="#Manifolds.estimate_distance_from_bvp"><code>Manifolds.estimate_distance_from_bvp</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_distance_from_bvp(
    M::AbstractManifold, a1, a2, A::AbstractAtlas, i;
    solver=MIRK4(), dt=0.05, kwargs...
)</code></pre><p>Estimate distance between points on <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> M with parameters <code>a1</code> and <code>a2</code> in chart <code>i</code> of <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> using solver <code>solver</code>, employing <a href="#Manifolds.solve_chart_log_bvp"><code>solve_chart_log_bvp</code></a> to solve the geodesic BVP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/ext/ManifoldsBoundaryValueDiffEqExt.jl#L50-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.solve_chart_exp_ode"><a class="docstring-binding" href="#Manifolds.solve_chart_exp_ode"><code>Manifolds.solve_chart_exp_ode</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_chart_exp_ode(
    M::AbstractManifold, a, Xc, A::AbstractAtlas, i0;
    solver=AutoVern9(Rodas5()),
    final_time::Real=1.0,
    check_chart_switch_kwargs=NamedTuple(),
    kwargs...,
)</code></pre><p>Solve geodesic ODE on a manifold <code>M</code> from point of coordinates <code>a</code> in chart <code>i0</code> from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> in direction of coordinates <code>Xc</code> in the induced basis. The geodesic is solved up to time <code>final_time</code> (by default equal to 1).</p><p><strong>Chart switching</strong></p><p>If the solution exceeds the domain of chart <code>i0</code> (which is detected using the <code>check_chart_switch</code> function with additional keyword arguments <code>check_chart_switch_kwargs</code>), a new chart is selected using <code>get_chart_index</code> on the final point in the old chart.</p><p><strong>Returned value</strong></p><p>The function returns an object of type <code>StitchedChartSolution{:Exp}</code> to represent the geodesic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/ext/ManifoldsOrdinaryDiffEqDiffEqCallbacksExt.jl#L119-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.solve_chart_log_bvp"><a class="docstring-binding" href="#Manifolds.solve_chart_log_bvp"><code>Manifolds.solve_chart_log_bvp</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_chart_log_bvp(
    M::AbstractManifold, a1, a2, A::AbstractAtlas, i;
    solver=MIRK4(), dt::Real=0.05, kwargs...
)</code></pre><p>Solve the BVP corresponding to geodesic calculation on <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> M, between points with parameters <code>a1</code> and <code>a2</code> in a chart <code>i</code> of an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> using solver <code>solver</code>. Geodesic Œ≥ is sampled at time interval <code>dt</code>, with Œ≥(0) = a1 and Œ≥(1) = a2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/ext/ManifoldsBoundaryValueDiffEqExt.jl#L22-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.solve_chart_parallel_transport_ode"><a class="docstring-binding" href="#Manifolds.solve_chart_parallel_transport_ode"><code>Manifolds.solve_chart_parallel_transport_ode</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_chart_parallel_transport_ode(
    M::AbstractManifold, a, Xc, A::AbstractAtlas, i0, Yc;
    solver=AutoVern9(Rodas5()), check_chart_switch_kwargs=NamedTuple(), final_time=1.0,
    kwargs...
)</code></pre><p>Parallel transport vector with coordinates <code>Yc</code> along geodesic on a manifold <code>M</code> from point of coordinates <code>a</code> in a chart <code>i0</code> from an <a href="#Manifolds.AbstractAtlas"><code>AbstractAtlas</code></a> <code>A</code> in direction of coordinates <code>Xc</code> in the induced basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/f2960430d512c9679effd390dec3bb878f9ad579/ext/ManifoldsOrdinaryDiffEqDiffEqCallbacksExt.jl#L192-L202">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../manifolds/metric/">¬´ Metric manifold</a><a class="docs-footer-nextpage" href="../differentiation/">Differentiation ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 27 November 2025 18:02">Thursday 27 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
