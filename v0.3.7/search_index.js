var documenterSearchIndex = {"docs":
[{"location":"features/statistics.html#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"features/statistics.html","page":"Statistics","title":"Statistics","text":"Modules = [Manifolds,ManifoldsBase]\nPages = [\"statistics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/statistics.html#Manifolds.AbstractEstimationMethod","page":"Statistics","title":"Manifolds.AbstractEstimationMethod","text":"AbstractEstimationMethod\n\nAbstract type for defining statistical estimation methods.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.CyclicProximalPointEstimation","page":"Statistics","title":"Manifolds.CyclicProximalPointEstimation","text":"CyclicProximalPointEstimation <: AbstractEstimationMethod\n\nMethod for estimation using the cyclic proximal point technique.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.ExtrinsicEstimation","page":"Statistics","title":"Manifolds.ExtrinsicEstimation","text":"ExtrinsicEstimation <: AbstractEstimationMethod\n\nMethod for estimation in the ambient space and projecting to the manifold.\n\nFor mean estimation, GeodesicInterpolation is used for mean estimation in the ambient space.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.GeodesicInterpolation","page":"Statistics","title":"Manifolds.GeodesicInterpolation","text":"GeodesicInterpolation <: AbstractEstimationMethod\n\nRepeated weighted geodesic interpolation method for estimating the Riemannian center of mass.\n\nThe algorithm proceeds with the following simple online update:\n\nbeginaligned\nμ_1 = x_1\nt_k = fracw_ksum_i=1^k w_i\nμ_k = γ_μ_k-1(x_k t_k)\nendaligned\n\nwhere x_k are points, w_k are weights, μ_k is the kth estimate of the mean, and γ_x(y t) is the point at time t along the shortest_geodesic between points xy  mathcal M. The algorithm terminates when all x_k have been considered. In the Euclidean case, this exactly computes the weighted mean.\n\nThe algorithm has been shown to converge asymptotically with the sample size for the following manifolds equipped with their default metrics when all sampled points are in an open geodesic ball about the mean with corresponding radius (see GeodesicInterpolationWithinRadius):\n\nAll simply connected complete Riemannian manifolds with non-positive sectional curvature at radius  [Cheng2016], in particular:\nEuclidean\nSymmetricPositiveDefinite [Ho2013]\nOther manifolds:\nSphere: fracπ2 [Salehian2015]\nGrassmann: fracπ4 [Chakraborty2015]\nStiefel/Rotations: fracπ2 sqrt 2 [Chakraborty2019]\n\nFor online variance computation, the algorithm additionally uses an analogous recursion to the weighted Welford algorithm [West1979].\n\n[Ho2013]: Ho J.; Cheng G.; Salehian H.; Vemuri B. C.; Recursive Karcher expectation estimators and geometric law of large numbers. Proceedings of the 16th International Conference on Artificial Intelligence and Statistics (2013), pp. 325–332. pdf.\n\n[Salehian2015]: Salehian H.; Chakraborty R.; Ofori E.; Vaillancourt D.; An efficient recursive estimator of the Fréchet mean on a hypersphere with applications to Medical Image Analysis. Mathematical Foundations of Computational Anatomy (2015). pdf.\n\n[Chakraborty2015]: Chakraborty R.; Vemuri B. C.; Recursive Fréchet Mean Computation on the Grassmannian and Its Applications to Computer Vision. Proceedings of the IEEE International Conference on Computer Vision (ICCV) (2015), pp. 4229-4237. doi: 10.1109/ICCV.2015.481, link.\n\n[Cheng2016]: Cheng G.; Ho J.; Salehian H.; Vemuri B. C.; Recursive Computation of the Fréchet Mean on Non-positively Curved Riemannian Manifolds with Applications. Riemannian Computing in Computer Vision. Springer, Cham (2016), pp. 21-43. doi: 10.1007/978-3-319-22957-7_2, pdf.\n\n[Chakraborty2019]: Chakraborty R.; Vemuri B. C.; Statistics on the (compact) Stiefel manifold: Theory and Applications. The Annals of Statistics (2019), 47(1), pp. 415-438. doi: 10.1214/18-AOS1692, arxiv: 1708.00045.\n\n[West1979]: West D. H. D.; Updating Mean and Variance Estimates: An Improved Method. Communications of the ACM (1979), 22(9), pp. 532–535. doi: 10.1145/359146.359153.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.GeodesicInterpolationWithinRadius","page":"Statistics","title":"Manifolds.GeodesicInterpolationWithinRadius","text":"GeodesicInterpolationWithinRadius{T} <: AbstractEstimationMethod\n\nEstimation of Riemannian center of mass using GeodesicInterpolation with fallback to GradientDescentEstimation if any points are outside of a geodesic ball of specified radius around the mean.\n\nConstructor\n\nGeodesicInterpolationWithinRadius(radius)\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.GradientDescentEstimation","page":"Statistics","title":"Manifolds.GradientDescentEstimation","text":"GradientDescentEstimation <: AbstractEstimationMethod\n\nMethod for estimation using gradient descent.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Statistics.mean!-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.mean!","text":"mean!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmean!(\n    M::Manifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the mean in-place in y.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,ExtrinsicEstimation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::ExtrinsicEstimation;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using ExtrinsicEstimation, i.e. by computing the mean in the embedding and projecting the result back. You can specify an extrinsic_method to specify which mean estimation method to use in the embedding, which defaults to GeodesicInterpolation.\n\nSee mean for a description of the remaining kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolationWithinRadius}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using GeodesicInterpolationWithinRadius.\n\nSee mean for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng=nothing,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x in an online fashion using repeated weighted geodesic interpolation. See GeodesicInterpolation for details.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered for computing the mean.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.mean","text":"mean(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\n\nCompute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector x of points on the Manifold M, defined as the point that satisfies the minimizer\n\nargmin_y  mathcal M frac12 sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M^2(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance.\n\nIn the general case, the GradientDescentEstimation is used to compute the mean.     mean(         M::Manifold,         x::AbstractVector,         [w::AbstractWeights,]         method::AbstractEstimationMethod;         kwargs...,     )\n\nCompute the mean using the specified method.\n\nmean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GradientDescentEstimation;\n    p0=x[1],\n    stop_iter=100,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nCompute the mean using the gradient descent scheme GradientDescentEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe Theory stems from[Karcher1977] and is also described in[PennecArsigny2013] as the exponential barycenter. The algorithm is further described in[Afsari2013].\n\n[Afsari2013]: Afsari, B; Tron, R.; Vidal, R.: On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass, SIAM Journal on Control and Optimization (2013), 51(3), pp. 2230–2260, doi: 10.1137/12086282X, arxiv: 1201.0925\n\n[PennecArsigny2013]: Pennec X., Arsigny V.: Exponential Barycenters of the Canonical Cartan Connection and Invariant Means on Lie Groups. In: Nielsen F., Bhatia R. (eds) Matrix Information Geometry, (2013), pp. 123-166. doi: 10.1007/978-3-642-30232-9_7, hal: https://hal.inria.fr/hal-00699361/document\n\n[Karcher1977]: Karcher, H.: Riemannian center of mass and mollifier smoothing. Communications on Pure Applied Mathematics (1977), 30, pp. 509–541. doi 10.1002/cpa.3160300502\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median!-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.median!","text":"median!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian!(\n    M::Manifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\ncomputes the median in-place in y.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,CyclicProximalPointEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::CyclicProximalPointEstimation;\n    p0=x[1],\n    stop_iter=1000000,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nCompute the median using CyclicProximalPointEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe algorithm is further described in [Bačák2014].\n\n[Bačák2014]: Bačák, M: Computing Medians and Means in Hadamard Spaces. SIAM Journal on Optimization (2014), 24(3), pp. 1542–1566, doi: 10.1137/140953393, arxiv: 1210.2145\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,ExtrinsicEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::ExtrinsicEstimation;\n    extrinsic_method = CyclicProximalPointEstimation(),\n    kwargs...,\n)\n\nEstimate the median of x using ExtrinsicEstimation, i.e. by computing the median in the embedding and projecting the result back. You can specify an extrinsic_method to specify which median estimation method to use in the embedding, which defaults to CyclicProximalPointEstimation.\n\nSee median for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.median","text":"median(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the (optionally weighted) Riemannian median of the vector x of points on the Manifold M, defined as the point that satisfies the minimizer\n\nargmin_y  mathcal M frac1sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance. This function is nonsmooth (i.e nondifferentiable).\n\nIn the general case, the CyclicProximalPointEstimation is used to compute the median. However, this default may be overloaded for specific manifolds.\n\nCompute the median using the specified method.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.std-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.std","text":"std(M, x, m=mean(M, x); corrected=true, kwargs...)\nstd(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)\n\ncompute the optionally weighted standard deviation of a Vector x of n data points on the Manifold M, i.e.\n\nsqrtfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.std. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.var-Tuple{Manifold,Any}","page":"Statistics","title":"Statistics.var","text":"var(M, x, m=mean(M, x); corrected=true)\nvar(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false)\n\ncompute the (optionally weighted) variance of a Vector x of n data points on the Manifold M, i.e.\n\nfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.var. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true. All further kwargs... are passed to the computation of the mean (if that is not provided).\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.kurtosis-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.kurtosis","text":"kurtosis(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the excess kurtosis of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_std-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"StatsBase.mean_and_std","text":"mean_and_std(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, std)\n\nCompute the mean and the standard deviation std simultaneously.\n\nmean_and_std(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and standard deviation. To use a mean-specific method, call mean and then std.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolationWithinRadius}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n) -> (mean, var)\n\nUse repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nSee GeodesicInterpolationWithinRadius and mean_and_var for more information.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolation}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng::Union{AbstractRNG,Nothing} = nothing,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n) -> (mean, var)\n\nUse the repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered. Optionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nSee GeodesicInterpolation for details on the geodesic interpolation method.\n\nnote: Note\nThe Welford algorithm for the variance is experimental and is not guaranteed to give accurate results except on Euclidean.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_var-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, var)\n\nCompute the mean and the variance simultaneously. See those functions for a description of the arguments.\n\nmean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and variance. To use a mean-specific method, call mean and then var.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.moment","page":"Statistics","title":"StatsBase.moment","text":"moment(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the kth central moment of points in x on manifold M. Optionally provide weights w and/or a precomputed mean.\n\n\n\n\n\n","category":"function"},{"location":"features/statistics.html#StatsBase.skewness-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.skewness","text":"skewness(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the standardized skewness of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Literature","page":"Statistics","title":"Literature","text":"","category":"section"},{"location":"manifolds/spectrahedron.html#Spectrahedron","page":"Spectrahedron","title":"Spectrahedron","text":"","category":"section"},{"location":"manifolds/spectrahedron.html","page":"Spectrahedron","title":"Spectrahedron","text":"Modules = [Manifolds]\nPages = [\"manifolds/Spectrahedron.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/spectrahedron.html#Manifolds.Spectrahedron","page":"Spectrahedron","title":"Manifolds.Spectrahedron","text":"Spectrahedron{N,K} <: AbstractEmbeddedManifold{ℝ,DefaultIsometricEmbeddingType}\n\nThe Spectrahedron manifold, also known as the set of correlation matrices (symmetric positive semidefinite matrices) of rank k with unit trace.\n\nbeginaligned\nmathcal S(nk) =\nbiglp  ℝ^n  n big a^mathrmTpa geq 0 text for all  a  ℝ^n\noperatornametr(p) = sum_i=1^n p_ii = 1\ntextand  p = qq^mathrmT text for  q in  ℝ^n  k\ntext with  operatornamerank(p) = operatornamerank(q) = k\nbigr\nendaligned\n\nThis manifold is working solely on the matrices q. Note that this q is not unique, indeed for any orthogonal matrix A we have (qA)(qA)^mathrmT = qq^mathrmT = p, so the manifold implemented here is the quotient manifold. The unit trace translates to unit frobenius norm of q.\n\nThe tangent space at p, denoted T_pmathcal E(nk), is also represented by matrices Yin ℝ^n  k and reads as\n\nT_pmathcal S(nk) = bigl\nX  ℝ^n  nX = qY^mathrmT + Yq^mathrmT\ntext with  operatornametr(X) = sum_i=1^nX_ii = 0\nbigr\n\nendowed with the Euclidean metric from the embedding, i.e. from the ℝ^n  k\n\nThis manifold was for example investigated in[JourneeBachAbsilSepulchre2010].\n\nConstructor\n\nSpectrahedron(n,k)\n\ngenerates the manifold mathcal S(nk) subset ℝ^n  n.\n\n[JourneeBachAbsilSepulchre2010]: Journée, M., Bach, F., Absil, P.-A., and Sepulchre, R.: “Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”, SIAM Journal on Optimization (20)5, pp. 2327–2351, 2010. doi: 10.1137/080731359, arXiv: 0807.4423.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.check_manifold_point-Union{Tuple{K}, Tuple{N}, Tuple{Spectrahedron{N,K},Any}} where K where N","page":"Spectrahedron","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Spectrahedron, q; kwargs...)\n\nchecks, whether q is a valid reprsentation of a point p=qq^mathrmT on the Spectrahedron M, i.e. is a matrix of size (N,K), such that p is symmetric positive semidefinite and has unit trace, i.e. q has to have unit frobenius norm. Since by construction p is symmetric, this is not explicitly checked. Since p is by construction positive semidefinite, this is not checked. The tolerances for positive semidefiniteness and unit trace can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.check_tangent_vector-Union{Tuple{K}, Tuple{N}, Tuple{Spectrahedron{N,K},Any,Any}} where K where N","page":"Spectrahedron","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Spectrahedron, q, Y; check_base_point = true, kwargs...)\n\nCheck whether X = qY^mathrmT + Yq^mathrmT is a tangent vector to p=qq^mathrmT on the Spectrahedron M, i.e. atfer check_manifold_point of q, Y has to be of same dimension as q and a X has to be a symmetric matrix with trace. The optional parameter check_base_point indicates, whether to call check_manifold_point  for q. The tolerance for the base point check and zero diagonal can be set using the kwargs.... Note that symmetry of X holds by construction and is not explicitly checked.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.manifold_dimension-Union{Tuple{Spectrahedron{N,K}}, Tuple{K}, Tuple{N}} where K where N","page":"Spectrahedron","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Spectrahedron)\n\nreturns the dimension of Spectrahedron M=mathcal S(nk) nk  ℕ, i.e.\n\ndim mathcal S(nk) = nk - 1 - frack(k-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.project-Tuple{Spectrahedron,Any}","page":"Spectrahedron","title":"ManifoldsBase.project","text":"project(M::Spectrahedron, q)\n\nproject q onto the manifold Spectrahedron M, by normalizing w.r.t. the Frobenius norm\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.project-Tuple{Spectrahedron,Vararg{Any,N} where N}","page":"Spectrahedron","title":"ManifoldsBase.project","text":"project(M::Spectrahedron, q, Y)\n\nProject Y onto the tangent space at q, i.e. row-wise onto the oblique manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.representation_size-Union{Tuple{Spectrahedron{N,K}}, Tuple{K}, Tuple{N}} where K where N","page":"Spectrahedron","title":"ManifoldsBase.representation_size","text":"representation_size(M::Spectrahedron)\n\nReturn the size of an array representing an element on the Spectrahedron manifold M, i.e. n  k, the size of such factor of p=qq^mathrmT on mathcal M = mathcal S(nk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.retract-Tuple{Spectrahedron,Any,Any,ProjectionRetraction}","page":"Spectrahedron","title":"ManifoldsBase.retract","text":"retract(M::Spectrahedron, q, Y, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting q+Y back onto the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.vector_transport_to-Tuple{Spectrahedron,Any,Any,Any,ProjectionTransport}","page":"Spectrahedron","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Spectrahedron, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.zero_tangent_vector-Tuple{Spectrahedron,Vararg{Any,N} where N}","page":"Spectrahedron","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Spectrahedron,p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the Spectrahedron manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#Literature","page":"Spectrahedron","title":"Literature","text":"","category":"section"},{"location":"manifolds/choleskyspace.html#Cholesky-space","page":"Cholesky space","title":"Cholesky space","text":"","category":"section"},{"location":"manifolds/choleskyspace.html","page":"Cholesky space","title":"Cholesky space","text":"The Cholesky space is a Riemannian manifold on the lower triangular matrices. Its metric is based on the cholesky decomposition. The CholeskySpace is used to define the LogCholeskyMetric on the manifold of  SymmetricPositiveDefinite matrices.","category":"page"},{"location":"manifolds/choleskyspace.html","page":"Cholesky space","title":"Cholesky space","text":"Modules = [Manifolds]\nPages = [\"manifolds/CholeskySpace.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/choleskyspace.html#Manifolds.CholeskySpace","page":"Cholesky space","title":"Manifolds.CholeskySpace","text":"CholeskySpace{N} <: Manifold{ℝ}\n\nThe manifold of lower triangular matrices with positive diagonal and a metric based on the cholesky decomposition. The formulae for this manifold are for example summarized in Table 1 of [Lin2019].\n\nConstructor\n\nCholeskySpace(n)\n\nGenerate the manifold of n n lower triangular matrices with positive diagonal.\n\n[Lin2019]: Lin, Zenhua: \"Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition\", arXiv: 1908.09326.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/choleskyspace.html","page":"Cholesky space","title":"Cholesky space","text":"Modules = [Manifolds]\nPages = [\"manifolds/CholeskySpace.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/choleskyspace.html#Base.exp-Tuple{CholeskySpace,Vararg{Any,N} where N}","page":"Cholesky space","title":"Base.exp","text":"exp(M::CholeskySpace, p, X)\n\nCompute the exponential map on the CholeskySpace M emanating from the lower triangular matrix with positive diagonal p towards the lower triangular matrix X The formula reads\n\nexp_p X =  p  +  X  + operatornamediag(p)\noperatornamediag(p)expbigl( operatornamediag(X)operatornamediag(p)^-1bigr)\n\nwhere cdot denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#Base.log-Tuple{LinearAlgebra.Cholesky,Vararg{Any,N} where N}","page":"Cholesky space","title":"Base.log","text":"log(M::CholeskySpace, X, p, q)\n\nCompute the logarithmic map on the CholeskySpace M for the geodesic emanating from the lower triangular matrix with positive diagonal p towards q. The formula reads\n\nlog_p q =  p  -  q  + operatornamediag(p)logbigl(operatornamediag(q)operatornamediag(p)^-1bigr)\n\nwhere cdot denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.check_manifold_point-Tuple{CholeskySpace,Any}","page":"Cholesky space","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::CholeskySpace, p; kwargs...)\n\nCheck whether the matrix p lies on the CholeskySpace M, i.e. it's size fits the manifold, it is a lower triangular matrix and has positive entries on the diagonal. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.check_tangent_vector-Tuple{CholeskySpace,Any,Any}","page":"Cholesky space","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::CholeskySpace, p, X; check_base_point = true, kwargs... )\n\nCheck whether v is a tangent vector to p on the CholeskySpace M, i.e. after check_manifold_point(M,p), X has to have the same dimension as x and a symmetric matrix. The optional parameter check_base_point indicates whether to call check_manifold_point  for p. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.distance-Tuple{CholeskySpace,Any,Any}","page":"Cholesky space","title":"ManifoldsBase.distance","text":"distance(M::CholeskySpace, p, q)\n\nCompute the Riemannian distance on the CholeskySpace M between two matrices p, q that are lower triangular with positive diagonal. The formula reads\n\nd_mathcal M(pq) = sqrtsum_ij (p_ij-q_ij)^2 +\nsum_j=1^m (log p_jj - log q_jj)^2\n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.inner-Tuple{CholeskySpace,Any,Any,Any}","page":"Cholesky space","title":"ManifoldsBase.inner","text":"inner(M::CholeskySpace, p, X, Y)\n\nCompute the inner product on the CholeskySpace M at the lower triangular matric with positive diagonal p and the two tangent vectors X,Y, i.e they are both lower triangular matrices with arbitrary diagonal. The formula reads\n\ng_p(XY) = sum_ij X_ijY_ij + sum_j=1^m X_iiY_iip_ii^-2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.manifold_dimension-Union{Tuple{CholeskySpace{N}}, Tuple{N}} where N","page":"Cholesky space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::CholeskySpace)\n\nReturn the manifold dimension for the CholeskySpace M, i.e.\n\n    dim(mathcal M) = fracN(N+1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.representation_size-Union{Tuple{CholeskySpace{N}}, Tuple{N}} where N","page":"Cholesky space","title":"ManifoldsBase.representation_size","text":"reporesentation_size(M::CholeskySpace)\n\nReturn the representation size for the CholeskySpace{N} M, i.e. (N,N).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.vector_transport_to-Tuple{CholeskySpace,Any,Any,Any,ParallelTransport}","page":"Cholesky space","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::CholeskySpace, p, X, q, ::ParallelTransport)\n\nParallely transport the tangent vector X at p along the geodesic to q on the CholeskySpace manifold M. The formula reads\n\nmathcal P_qp(X) =  X \n+ operatornamediag(q)operatornamediag(p)^-1operatornamediag(X)\n\nwhere cdot denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.zero_tangent_vector-Tuple{CholeskySpace,Vararg{Any,N} where N}","page":"Cholesky space","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::CholeskySpace, p)\n\nReturn the zero tangent vector on the CholeskySpace M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#Literature","page":"Cholesky space","title":"Literature","text":"","category":"section"},{"location":"features/utilities.html#Public-documentation","page":"Utilities","title":"Public documentation","text":"","category":"section"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"Documentation for Manifolds.jl's public interface. It mainly covers functions that are of interest for extending and using the ProductManifold.","category":"page"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"Manifolds.ShapeSpecification\nsubmanifold_component\nsubmanifold_components\nManifolds.ProductArray\nProductRepr\nManifolds.prod_point\nManifolds.StaticReshaper\nManifolds.ArrayReshaper\nManifolds.make_reshape","category":"page"},{"location":"features/utilities.html#Manifolds.ShapeSpecification","page":"Utilities","title":"Manifolds.ShapeSpecification","text":"ShapeSpecification(reshapers, manifolds::Manifold...)\n\nA structure for specifying array size and offset information for linear storage of points and tangent vectors on the product manifold of manifolds.\n\nThe first argument, reshapers, indicates how a view representing a point in the ProductArray will be reshaped. It can either be an object of type AbstractReshaper that will be applied to all views or a tuple of such objects that will be applied to subsequent manifolds.\n\nTwo main reshaping methods are provided by types StaticReshaper that is faster for manifolds represented by small arrays (up to about 100 elements) and ArrayReshaper that is faster for larger arrays.\n\nFor example, consider the shape specification for the product of a sphere and group of rotations:\n\njulia> M1 = Sphere(2)\nSphere{2}()\n\njulia> M2 = Manifolds.Rotations(2)\nManifolds.Rotations{2}()\n\njulia> reshaper = Manifolds.StaticReshaper()\nManifolds.StaticReshaper()\n\njulia> shape = Manifolds.ShapeSpecification(reshaper, M1, M2)\nManifolds.ShapeSpecification{(1:3, 4:7),Tuple{Tuple{3},Tuple{2,2}},\n  Tuple{Manifolds.StaticReshaper,Manifolds.StaticReshaper}}(\n  (Manifolds.StaticReshaper(), Manifolds.StaticReshaper()))\n\nTRanges contains ranges in the linear storage that correspond to a specific manifold. Sphere(2) needs three numbers and is first, so it is allocated the first three elements of the linear storage (1:3). Rotations(2) needs four numbers and is second, so the next four numbers are allocated to it (4:7). TSizes describe how the linear storage must be reshaped to correctly represent points. In this case, Sphere(2) expects a three-element vector, so the corresponding size is Tuple{3}. On the other hand, Rotations(2) expects two-by-two matrices, so its size specification is Tuple{2,2}.\n\n\n\n\n\n","category":"type"},{"location":"features/utilities.html#Manifolds.submanifold_component","page":"Utilities","title":"Manifolds.submanifold_component","text":"submanifold_component(M::Manifold, p, i::Integer)\nsubmanifold_component(M::Manifold, p, ::Val(i)) where {i}\nsubmanifold_component(p, i::Integer)\nsubmanifold_component(p, ::Val(i)) where {i}\n\nProject the product array p on M to its ith component. A new array is returned.\n\n\n\n\n\n","category":"function"},{"location":"features/utilities.html#Manifolds.submanifold_components","page":"Utilities","title":"Manifolds.submanifold_components","text":"submanifold_components(M::Manifold, p)\nsubmanifold_components(p)\n\nGet the projected components of p on the submanifolds of M. The components are returned in a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"features/utilities.html#Manifolds.ProductArray","page":"Utilities","title":"Manifolds.ProductArray","text":"ProductArray(shape::ShapeSpecification, data)\n\nAn array-based representation for points and tangent vectors on the product manifold. data contains underlying representation of points arranged according to TRanges and TSizes from shape. Internal views for each specific sub-point are created and stored in parts.\n\n\n\n\n\n","category":"type"},{"location":"features/utilities.html#Manifolds.ProductRepr","page":"Utilities","title":"Manifolds.ProductRepr","text":"ProductRepr(parts)\n\nA more general but slower representation of points and tangent vectors on a product manifold.\n\nExample:\n\nA product point on a product manifold Sphere(2) × Euclidean(2) might be created as\n\nProductRepr([1.0, 0.0, 0.0], [2.0, 3.0])\n\nwhere [1.0, 0.0, 0.0] is the part corresponding to the sphere factor and [2.0, 3.0] is the part corresponding to the euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"features/utilities.html#Manifolds.prod_point","page":"Utilities","title":"Manifolds.prod_point","text":"prod_point(M::ShapeSpecification, pts...)\n\nConstruct a product point from product manifold M based on point pts represented by ProductArray.\n\nExample\n\nTo construct a point on the product manifold S^2  ℝ^2 from points on the sphere and in the euclidean space represented by, respectively, [1.0, 0.0, 0.0] and [-3.0, 2.0] you need to construct shape specification first. It describes how linear storage of ProductArray corresponds to array representations expected by Sphere(2) and Euclidean(2).\n\nM1 = Sphere(2)\nM2 = Euclidean(2)\nreshaper = Manifolds.StaticReshaper()\nMshape = Manifolds.ShapeSpecification(reshaper, M1, M2)\n\nNext, the desired point on the product manifold can be obtained by calling Manifolds.prod_point(Mshape, [1.0, 0.0, 0.0], [-3.0, 2.0]).\n\n\n\n\n\n","category":"function"},{"location":"features/utilities.html#Manifolds.StaticReshaper","page":"Utilities","title":"Manifolds.StaticReshaper","text":"StaticReshaper()\n\nReshaper that constructs SizedAbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"features/utilities.html#Manifolds.ArrayReshaper","page":"Utilities","title":"Manifolds.ArrayReshaper","text":"ArrayReshaper()\n\nReshaper that constructs Base.ReshapedArray.\n\n\n\n\n\n","category":"type"},{"location":"features/utilities.html#Manifolds.make_reshape","page":"Utilities","title":"Manifolds.make_reshape","text":"make_reshape(reshaper::AbstractReshaper, ::Type{Size}, data) where Size\n\nReshape array data to size Size using method provided by reshaper.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/oblique.html#Oblique-manifold","page":"Oblique manifold","title":"Oblique manifold","text":"","category":"section"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"The oblique manifold mathcalOB(nm) is modeled as an AbstractPowerManifold of the (real-valued) Sphere and uses ArrayPowerRepresentation. Points on the torus are hence matrices, x  ℝ^nm.","category":"page"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/Oblique.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/oblique.html#Manifolds.Oblique","page":"Oblique manifold","title":"Manifolds.Oblique","text":"Oblique{N,M,𝔽} <: AbstractPowerManifold{𝔽}\n\nThe oblique manifold mathcalOB(nm) is the set of 𝔽-valued matrices with unit norm column endowed with the metric from the embedding. This yields exactly the same metric as considering the product metric of the unit norm vectors, i.e. PowerManifold of the (n-1)-dimensional Sphere.\n\nThe Sphere is stored internally within M.manifold, such that all functions of AbstractPowerManifold can be used directly.\n\nConstructor\n\nOblique(n,m)\n\nGenerate the manifold of matrices mathbb R^n  m such that the m columns are unit vectors, i.e. from the Sphere(n-1).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/oblique.html#Functions","page":"Oblique manifold","title":"Functions","text":"","category":"section"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"Most functions are directly implemented for an AbstractPowerManifold with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/Oblique.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/oblique.html#ManifoldsBase.check_manifold_point-Tuple{Oblique,Any}","page":"Oblique manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Oblique{n,m},p)\n\nChecks whether p is a valid point on the Oblique{m,n} M, i.e. is a matrix of m unit columns from mathbb R^n, i.e. each column is a point from Sphere(n-1).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/oblique.html#ManifoldsBase.check_tangent_vector-Union{Tuple{m}, Tuple{n}, Tuple{Oblique{n,m,𝔽,S} where S where 𝔽,Any,Any}} where m where n","page":"Oblique manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Oblique p, X; check_base_point = true, kwargs...)\n\nChecks whether X is a valid tangent vector to p on the Oblique M. This means, that p is valid, that X is of correct dimension and columnswise a tangent vector to the columns of p on the Sphere. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#Multinomial-doubly-stochastic-matrices","page":"Multinomial doubly stochastic matrices","title":"Multinomial doubly stochastic matrices","text":"","category":"section"},{"location":"manifolds/multinomialdoublystochastic.html","page":"Multinomial doubly stochastic matrices","title":"Multinomial doubly stochastic matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/MultinomialDoublyStochastic.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/multinomialdoublystochastic.html#Manifolds.AbstractMultinomialDoublyStochastic","page":"Multinomial doubly stochastic matrices","title":"Manifolds.AbstractMultinomialDoublyStochastic","text":"AbstractMultinomialDoublyStochastic{N} <: AbstractEmbeddedManifold{ℝ, DefaultIsometricEmbeddingType}\n\nA common type for manifolds that are doubly stochastic, for example by direct constraint MultinomialDoublyStochastic or by symmetry MultionialSymmetric, as long as they are also modeled as DefaultIsometricEmbeddingType AbstractEmbeddedManifolds.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialdoublystochastic.html#Manifolds.MultinomialDoubleStochasticMatrices","page":"Multinomial doubly stochastic matrices","title":"Manifolds.MultinomialDoubleStochasticMatrices","text":"MultinomialDoublyStochastic{n} <: AbstractMultinomialDoublyStochastic{N}\n\nThe set of doubly stochastic multinomial matrices consists of all nn matrices with stochastic columns and rows, i.e.\n\nbeginaligned\nmathcalDP(n) coloneqq biglp  ℝ^nn big p_ij  0 text for all  i=1n j=1m\n pmathbf1_n = p^mathrmTmathbf1_n = mathbf1_n\nbigr\nendaligned\n\nwhere mathbf1_n is the vector of length n containing ones.\n\nThe tangent space can be written as\n\nT_pmathcalDP(n) coloneqq bigl\nX  ℝ^nn big X = X^mathrmT text and \nXmathbf1_n = X^mathrmTmathbf1_n = mathbf0_n\nbigr\n\nwhere mathbf0_n is the vector of length n containing zeros.\n\nMore details can be found in Section III[DouikHassibi2019].\n\nConstructor\n\nMultinomialDoubleStochasticMatrices(n)\n\nGenerate the manifold of matrices mathbb R^nn that are doubly stochastic and symmetric.\n\n[DouikHassibi2019]: A. Douik, B. Hassibi: Manifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry, IEEE Transactions on Signal Processing 67(22), pp. 5761–5774, 2019. doi: 10.1109/tsp.2019.2946024, arXiv: 1802.02628.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.check_manifold_point-Union{Tuple{n}, Tuple{MultinomialDoubleStochasticMatrices{n},Any}} where n","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::MultinomialDoubleStochasticMatrices, p)\n\nChecks whether p is a valid point on the MultinomialDoubleStochasticMatrices(n) M, i.e. is a  matrix with positive entries whose rows and columns sum to one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.check_tangent_vector-Union{Tuple{n}, Tuple{MultinomialDoubleStochasticMatrices{n},Any,Any}} where n","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::MultinomialDoubleStochasticMatrices p, X; check_base_point = true, kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialDoubleStochasticMatrices M. This means, that p is valid, that X is of correct dimension and sums to zero along any column or row.\n\nThe optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.manifold_dimension-Union{Tuple{MultinomialDoubleStochasticMatrices{n}}, Tuple{n}} where n","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::MultinomialDoubleStochasticMatrices{n}) where {n}\n\nreturns the dimension of the MultinomialDoubleStochasticMatrices manifold namely\n\noperatornamedim_mathcalDP(n) = (n-1)^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.project-Tuple{Manifolds.AbstractMultinomialDoublyStochastic,Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.project","text":"project(\n    M::AbstractMultinomialDoublyStochastic,\n    p;\n    maxiter = 100,\n    tolerance = eps(eltype(p))\n)\n\nproject a matrix p with positive entries applying Sinkhorn's algorithm. Note that this projct method – different from the usual case, accepts keywords.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.project-Tuple{MultinomialDoubleStochasticMatrices,Any,Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.project","text":"project(M::MultinomialDoubleStochasticMatrices{n}, p, Y) where {n}\n\nProject Y onto the tangent space at p on the MultinomialDoubleStochasticMatrices M, return the result in X. The formula reads\n\n    operatornameproj_p(Y) = Y - (αmathbf1_n^mathrmT + mathbf1_nβ^mathrmT)  p\n\nwhere  denotes the Hadamard or elementwise product and mathbb1_n is the vector of length n containing ones. The two vectors αβ  ℝ^nn are computed as a solution (typically using the left pseudo inverse) of\n\n    beginpmatrix I_n  pp^mathrmT  I_n endpmatrix\n    beginpmatrix α βendpmatrix\n    =\n    beginpmatrix Ymathbf1Y^mathrmTmathbf1endpmatrix\n\nwhere I_n is the nn unit matrix and mathbf1_n is the vector of length n containing ones.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.retract-Tuple{MultinomialDoubleStochasticMatrices,Any,Any,ProjectionRetraction}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.retract","text":"retract(M::MultinomialDoubleStochasticMatrices, p, X, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting podotexp(Xp) back onto the manifold, where  are elementwise multiplication and division, respectively. Similarly, exp refers to the elementwise exponentiation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.vector_transport_to-Tuple{MultinomialDoubleStochasticMatrices,Any,Any,Any,ProjectionTransport}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::MultinomialDoubleStochasticMatrices, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#Literature","page":"Multinomial doubly stochastic matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/product.html#Product-manifold","page":"Product manifold","title":"Product manifold","text":"","category":"section"},{"location":"manifolds/product.html","page":"Product manifold","title":"Product manifold","text":"Product manifold mathcal M = mathcalM_1  mathcalM_2    mathcalM_n of manifolds mathcalM_1 mathcalM_2  mathcalM_n. Points on the product manifold can be constructed using ProductRepr with canonical projections Π_i  mathcalM  mathcalM_i for i  1 2  n provided by submanifold_component.","category":"page"},{"location":"manifolds/product.html","page":"Product manifold","title":"Product manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/ProductManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/product.html#Manifolds.InverseProductRetraction","page":"Product manifold","title":"Manifolds.InverseProductRetraction","text":"InverseProductRetraction(retractions::AbstractInverseRetractionMethod...)\n\nProduct inverse retraction of inverse retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductBasisData","page":"Product manifold","title":"Manifolds.ProductBasisData","text":"ProductBasisData\n\nA typed tuple to store tuples of data of stored/precomputed bases for a ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductFVectorDistribution","page":"Product manifold","title":"Manifolds.ProductFVectorDistribution","text":"ProductFVectorDistribution([type::VectorBundleFibers], [x], distrs...)\n\nGenerates a random vector at point x from vector space (a fiber of a tangent bundle) of type type using the product distribution of given distributions.\n\nVector space type and x can be automatically inferred from distributions distrs.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductManifold","page":"Product manifold","title":"Manifolds.ProductManifold","text":"ProductManifold{𝔽,TM<:Tuple} <: Manifold{𝔽}\n\nProduct manifold M_1  M_2     M_n with product geometry.\n\nConstructor\n\nProductManifold(M_1, M_2, ..., M_n)\n\ngenerates the product manifold M_1  M_2    M_n. Alternatively, the same manifold can be contructed using the × operator: M_1 × M_2 × M_3.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductMetric","page":"Product manifold","title":"Manifolds.ProductMetric","text":"ProductMetric <: Metric\n\nA type to represent the product of metrics for a ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductPointDistribution","page":"Product manifold","title":"Manifolds.ProductPointDistribution","text":"ProductPointDistribution(M::ProductManifold, distributions)\n\nProduct distribution on manifold M, combined from distributions.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductRetraction","page":"Product manifold","title":"Manifolds.ProductRetraction","text":"ProductRetraction(retractions::AbstractRetractionMethod...)\n\nProduct retraction of retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductVectorTransport","page":"Product manifold","title":"Manifolds.ProductVectorTransport","text":"ProductVectorTransport(methods::AbstractVectorTransportMethod...)\n\nProduct vector transport type of methods. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Base.exp-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Base.exp","text":"exp(M::ProductManifold, p, X)\n\ncompute the exponential map from p in the direction of X on the ProductManifold M, which is the elementwise exponential map on the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.getindex-Tuple{ProductRepr,ProductManifold,Union{Colon, Integer, Val, AbstractArray{T,1} where T}}","page":"Product manifold","title":"Base.getindex","text":"getindex(p, M::ProductManifold, i::Union{Integer,Colon,AbstractVector})\np[M::ProductManifold, i]\n\nAccess the element(s) at index i of a point p on a ProductManifold M by linear indexing. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.log-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Base.log","text":"log(M::ProductManifold, p, q)\n\nCompute the logarithmic map from p to q on the ProductManifold M, which can be computed using the logarithmic maps of the manifolds elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.setindex!-Tuple{Union{Manifolds.ProductArray, ProductRepr},Any,ProductManifold,Union{Colon, Integer, Val, AbstractArray{T,1} where T}}","page":"Product manifold","title":"Base.setindex!","text":"setindex!(q, p, M::ProductManifold, i::Union{Integer,Colon,AbstractVector})\nq[M::ProductManifold,i...] = p\n\nset the element [i...] of a point q on a ProductManifold by linear indexing to q. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#LinearAlgebra.cross-Tuple{Vararg{Manifold,N} where N}","page":"Product manifold","title":"LinearAlgebra.cross","text":"cross(M,N)\ncross(M1, M2, M3,...)\n\nReturn the ProductManifold For two Manifolds M and N, where for the case that one of them is a ProductManifold itself, the other is either prepended (if N is a product) or appenden (if M) is. If both are product manifold, they are combined into one product manifold, keeping the order.\n\nFor the case that more than one is a product manifold of these is build with the same approach as above\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#LinearAlgebra.norm-Tuple{ProductManifold,Any,Any}","page":"Product manifold","title":"LinearAlgebra.norm","text":"norm(M::ProductManifold, p, X)\n\nCompute the norm of X from the tangent space of p on the ProductManifold, i.e. from the element wise norms the 2-norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.flat-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Manifolds.flat","text":"flat(M::ProductManifold, p, X::FVector{TangentSpaceType})\n\nuse the musical isomorphism to transform the tangent vector X from the tangent space at p on the ProductManifold M to a cotangent vector. This can be done elementwise for every entry of X (with respect to the corresponding entry in p) separately.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.get_component-Tuple{ProductManifold,Any,Any}","page":"Product manifold","title":"Manifolds.get_component","text":"get_component(M::ProductManifold, p, i)\n\nGet the ith component of a point p on a ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.number_of_components-Union{Tuple{ProductManifold{𝔽,#s69} where #s69<:Tuple{Vararg{Any,N}}}, Tuple{N}, Tuple{𝔽}} where N where 𝔽","page":"Product manifold","title":"Manifolds.number_of_components","text":"number_of_components(M::ProductManifold{<:NTuple{N,Any}}) where {N}\n\nCalculate the number of manifolds multiplied in the given ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.set_component!-Tuple{ProductManifold,Any,Any,Any}","page":"Product manifold","title":"Manifolds.set_component!","text":"set_component!(M::ProductManifold, q, p, i)\n\nSet the ith component of a point q on a ProductManifold M to p, where p is a point on the Manifold this factor of the product manifold consists of.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.sharp-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Manifolds.sharp","text":"sharp(M::ProductManifold, p, ξ::FVector{CotangentSpaceType})\n\nUse the musical isomorphism to transform the cotangent vector ξ from the tangent space at p on the ProductManifold M to a tangent vector. This can be done elementwise for every entry of ξ (and p) separately\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Integer}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Integer)\n\nExtract the ith factor of the product manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Val}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Val)\nsubmanifold(M::ProductManifold, i::AbstractVector)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to Val((1, 3)) the product manifold constructed from the first and the third factor is returned.\n\nThe version with AbstractVector is not type-stable, for better preformance use Val.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_manifold_point-Tuple{ProductManifold,Union{Manifolds.ProductArray, ProductRepr}}","page":"Product manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::ProductManifold, p; kwargs...)\n\nCheck whether p is a valid point on the ProductManifold M. If p is not a point on M a CompositeException consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_tangent_vector-Tuple{ProductManifold,Union{Manifolds.ProductArray, ProductRepr},Union{Manifolds.ProductArray, ProductRepr}}","page":"Product manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::ProductManifold, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to p on the ProductManifold M, i.e. after check_manifold_point(M, p), and all projections to base manifolds must be respective tangent vectors. If X is not a tangent vector to p on M a CompositeException consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.distance-Tuple{ProductManifold,Any,Any}","page":"Product manifold","title":"ManifoldsBase.distance","text":"distance(M::ProductManifold, p, q)\n\nCompute the distance between two points p and q on the ProductManifold M, which is the 2-norm of the elementwise distances on the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.injectivity_radius-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::ProductManifold)\ninjectivity_radius(M::ProductManifold, x)\n\nCompute the injectivity radius on the ProductManifold, which is the minimum of the factor manifolds.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.inner-Tuple{ProductManifold,Any,Any,Any}","page":"Product manifold","title":"ManifoldsBase.inner","text":"inner(M::ProductManifold, p, X, Y)\n\ncompute the inner product of two tangent vectors X, Y from the tangent space at p on the ProductManifold M, which is just the sum of the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.inverse_retract-Tuple{ProductManifold,Any,Any,Any,Manifolds.InverseProductRetraction}","page":"Product manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProductManifold, p, q, m::InverseProductRetraction)\n\nCompute the inverse retraction from p with respect to q on the ProductManifold M using an InverseProductRetraction, which by default encapsulates a inverse retraction for each manifold of the product. Then this method is performed elementwise, so the encapsulated inverse retraction methods have to be available per factor.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.manifold_dimension-Tuple{ProductManifold}","page":"Product manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::ProductManifold)\n\nReturn the manifold dimension of the ProductManifold, which is the sum of the manifold dimensions the product is made of.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.retract-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"ManifoldsBase.retract","text":"retract(M::ProductManifold, p, X, m::ProductRetraction)\n\nCompute the retraction from p with tangent vector X on the ProductManifold M using an ProductRetraction, which by default encapsulates retractions of the base manifolds. Then this method is performed elementwise, so the encapsulated retractions method has to be one that is available on the manifolds.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.vector_transport_to-Tuple{ProductManifold,Any,Any,Any,ProductVectorTransport}","page":"Product manifold","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::ProductManifold, p, X, q, m::ProductVectorTransport)\n\nCompute the vector transport the tangent vector Xat p to q on the ProductManifold M using an ProductVectorTransport m. This method is performed elementwise, i.e. the method m has to be implemented on the base manifold.\n\n\n\n\n\n","category":"method"},{"location":"features/distributions.html#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"features/distributions.html","page":"Distributions","title":"Distributions","text":"The following functions and types provide support for manifold-valued and tangent space-valued distributions:","category":"page"},{"location":"features/distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [Manifolds]\nPages = [\"distributions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/distributions.html#Manifolds.FVectorDistribution","page":"Distributions","title":"Manifolds.FVectorDistribution","text":"FVectorDistribution{TSpace<:VectorBundleFibers, T}\n\nAn abstract distribution for vector bundle fiber-valued distributions (values from a fiber of a vector bundle at point x from the given manifold). For example used for tangent vector-valued distributions.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.FVectorSupport","page":"Distributions","title":"Manifolds.FVectorSupport","text":"FVectorSupport(space::Manifold, VectorBundleFibers)\n\nValue support for vector bundle fiber-valued distributions (values from a fiber of a vector bundle at a point from the given manifold). For example used for tangent vector-valued distributions.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.FVectorvariate","page":"Distributions","title":"Manifolds.FVectorvariate","text":"FVectorvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a vector from a fiber of a vector bundle.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.MPointDistribution","page":"Distributions","title":"Manifolds.MPointDistribution","text":"MPointDistribution{TM<:Manifold}\n\nAn abstract distribution for points on manifold of type TM.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.MPointSupport","page":"Distributions","title":"Manifolds.MPointSupport","text":"MPointSupport(M::Manifold)\n\nValue support for manifold-valued distributions (values from given Manifold M).\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.MPointvariate","page":"Distributions","title":"Manifolds.MPointvariate","text":"MPointvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a point on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Distributions.support-Union{Tuple{T}, Tuple{T}} where T<:Manifolds.FVectorDistribution","page":"Distributions","title":"Distributions.support","text":"support(d::FVectorDistribution)\n\nGet the object of type FVectorSupport for the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"features/distributions.html","page":"Distributions","title":"Distributions","text":"Manifolds.ProjectedPointDistribution\nManifolds.ProjectedFVectorDistribution","category":"page"},{"location":"features/distributions.html#Manifolds.ProjectedPointDistribution","page":"Distributions","title":"Manifolds.ProjectedPointDistribution","text":"ProjectedPointDistribution(M::Manifold, d, proj!, p)\n\nGenerates a random point in ambient space of M and projects it to M using function proj!. Generated arrays are of type TResult, which can be specified by providing the p argument.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.ProjectedFVectorDistribution","page":"Distributions","title":"Manifolds.ProjectedFVectorDistribution","text":"ProjectedFVectorDistribution(type::VectorBundleFibers, p, d, project!)\n\nGenerates a random vector from ambient space of manifold type.manifold at point p and projects it to vector space of type type using function project!, see project for documentation. Generated arrays are of type TResult.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Fixed-rank-matrices","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"","category":"section"},{"location":"manifolds/fixedrankmatrices.html","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"Modules = [Manifolds]\nPages = [\"FixedRankMatrices.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.FixedRankMatrices","page":"Fixed-rank matrices","title":"Manifolds.FixedRankMatrices","text":"FixedRankMatrices{m,n,k,𝔽} <: Manifold{𝔽}\n\nThe manifold of m  n real-valued or complex-valued matrices of fixed rank k, i.e.\n\nbigl p  𝔽^m  n big operatornamerank(p) = k bigr\n\nwhere 𝔽  ℝℂ and the rank is the number of linearly independent columns of a matrix.\n\nRepresentation with 3 matrix factors\n\nA point p  mathcal M can be stored using unitary matrices U  𝔽^m  k, V  𝔽^n  k as well as the k singular values of p = USV^mathrmH, where cdot^mathrmH denotes the complex conjugate transpose or Hermitian. In other words, U and V are from the manifolds Stiefel(m,k,𝔽) and Stiefel(n,k,𝔽), respectively; see SVDMPoint for details.\n\nThe tangent space T_p mathcal M at a point p  mathcal M with p=USV^mathrmH is given by\n\nT_pmathcal M = bigl UMV^mathrmT + U_pV^mathrmH + UV_p^mathrmH \n    M   𝔽^k  k\n    U_p   𝔽^m  k\n    V_p   𝔽^n  k\n    text st \n    U_p^mathrmHU = 0_k\n    V_p^mathrmHV = 0_k\nbigr\n\nwhere 0_k is the k  k zero matrix. See UMVTVector for details.\n\nThe (default) metric of this manifold is obtained by restricting the metric on ℝ^m  n to the tangent bundle[Vandereycken2013].\n\nConstructor\n\nFixedRankMatrics(m, n, k[, field=ℝ])\n\nGenerate the manifold of m-by-n (field-valued) matrices of rank k.\n\n[Vandereycken2013]: Bart Vandereycken: \"Low-rank matrix completion by Riemannian Optimization, SIAM Journal on Optiomoization, 23(2), pp. 1214–1236, 2013. doi: 10.1137/110845768, arXiv: 1209.3834.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.SVDMPoint","page":"Fixed-rank matrices","title":"Manifolds.SVDMPoint","text":"SVDMPoint <: MPoint\n\nA point on a certain manifold, where the data is stored in a svd like fashion, i.e. in the form USV^mathrmH, where this structure stores U, S and V^mathrmH. The storage might also be shortened to just k singular values and accordingly shortened U (columns) and V^mathrmT (rows).\n\nConstructors\n\nSVDMPoint(A) for a matrix A, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(S) for an SVD object, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(U,S,Vt) for the svd factors to initialize the SVDMPoint` (i.e. implicitly k=minmn)\nSVDMPoint(A,k) for a matrix A, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(S,k) for an SVD object, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(U,S,Vt,k) for the svd factors to initialize the SVDMPoint, stores its svd factors shortened to the best rank k approximation\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.UMVTVector","page":"Fixed-rank matrices","title":"Manifolds.UMVTVector","text":"UMVTVector <: TVector\n\nA tangent vector that can be described as a product UMV^mathrmH, at least together with its base point, see for example FixedRankMatrices. This vector structure stores the additionally (to the point) required fields.\n\nConstructors\n\nUMVTVector(U,M,Vt) store umv factors to initialize the UMVTVector\nUMVTVector(U,M,Vt,k) store the umv factors after shortening them down to inner dimensions k, i.e. in UMV^mathrmH, where M is a k  k matrix.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.check_manifold_point-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m,n,k,𝔽} where 𝔽,Any}} where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::FixedRankMatrices{m,n,k}, p; kwargs...)\n\nCheck whether the matrix or SVDMPoint x ids a valid point on the FixedRankMatrices{m,n,k,𝔽} M, i.e. is an m-byn matrix of rank k. For the SVDMPoint the internal representation also has to have the right shape, i.e. p.U and p.Vt have to be unitary. The keyword arguments are passed to the rank function that verifies the rank of p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.check_tangent_vector-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m,n,k,𝔽} where 𝔽,SVDMPoint,UMVTVector}} where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M:FixedRankMatrices{m,n,k}, p, X; check_base_point = true, kwargs...)\n\nCheck whether the tangent UMVTVector X is from the tangent space of the SVDMPoint p on the FixedRankMatrices M, i.e. that v.U and v.Vt are (columnwise) orthogonal to x.U and x.Vt, respectively, and its dimensions are consistent with p and X.M, i.e. correspond to m-by-n matrices of rank k. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.inner-Tuple{FixedRankMatrices,SVDMPoint,UMVTVector,UMVTVector}","page":"Fixed-rank matrices","title":"ManifoldsBase.inner","text":"inner(M::FixedRankMatrices, p::SVDMPoint, X::UMVTVector, Y::UMVTVector)\n\nCompute the inner product of X and Y in the tangent space of p on the FixedRankMatrices M, which is inherited from the embedding, i.e. can be computed using dot on the elements (U, Vt, M) of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.manifold_dimension-Union{Tuple{FixedRankMatrices{m,n,k,𝔽}}, Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{m}} where 𝔽 where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::FixedRankMatrices{m,n,k,𝔽})\n\nReturn the manifold dimension for the 𝔽-valued FixedRankMatrices M of dimension mxn of rank k, namely\n\ndim(mathcal M) = k(m + n - k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.project-Tuple{FixedRankMatrices,Any,Any}","page":"Fixed-rank matrices","title":"ManifoldsBase.project","text":"project(M, p, A)\nproject(M, p, X)\n\nProject the matrix A  ℝ^mn or a UMVTVector X from the embedding or another tangent space onto the tangent space at p on the FixedRankMatrices M, further decomposing the result into X=UMV, i.e. a UMVTVector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.representation_size-Union{Tuple{FixedRankMatrices{m,n,K,𝔽} where 𝔽 where K}, Tuple{n}, Tuple{m}} where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.representation_size","text":"representation_size(M::FixedRankMatrices{m,n,k})\n\nReturn the element size of a point on the FixedRankMatrices M, i.e. the size of matrices on this manifold (mn).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.retract-Tuple{FixedRankMatrices,Any,Any,PolarRetraction}","page":"Fixed-rank matrices","title":"ManifoldsBase.retract","text":"retract(M, p, X, ::PolarRetraction)\n\nCompute an SVD-based retraction on the FixedRankMatrices M by computing\n\n    q = U_kS_kV_k^mathrmH\n\nwhere U_k S_k V_k^mathrmH is the shortened singular value decomposition USV=p+X, in the sense that S_k is the diagonal matrix of size k  k with the k largest singular values and U and V are shortened accordingly.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.zero_tangent_vector-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m,n,k,𝔽} where 𝔽,SVDMPoint}} where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::FixedRankMatrices, p::SVDMPoint)\n\nReturn a UMVTVector representing the zero tangent vector in the tangent space of p on the FixedRankMatrices M, for example all three elements of the resulting structure are zero matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#Literature","page":"Fixed-rank matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/stiefel.html#Stiefel","page":"Stiefel","title":"Stiefel","text":"","category":"section"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/Stiefel.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/stiefel.html#Manifolds.Stiefel","page":"Stiefel","title":"Manifolds.Stiefel","text":"Stiefel{n,k,𝔽} <: AbstractEmbeddedManifold{𝔽,DefaultIsometricEmbeddingType}\n\nThe Stiefel manifold consists of all n  k, n  k unitary matrices, i.e.\n\noperatornameSt(nk) = bigl p  𝔽^n  k big p^mathrmHp = I_k bigr\n\nwhere 𝔽  ℝ ℂ, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k  ℝ^k  k denotes the k  k identity matrix.\n\nThe tangent space at a point p  mathcal M is given by\n\nT_p mathcal M =  X  𝔽^n  k  p^mathrmHX + X^mathrmHp = 0_k\n\nwhere 0_k is the k  k zero matrix.\n\nThis manifold is modeled as an embedded manifold to the Euclidean, i.e. several functions like the inner product and the zero_tangent_vector are inherited from the embedding.\n\nThe manifold is named after Eduard L. Stiefel (1909–1978).\n\nConstructor\n\nStiefel(n, k, field = ℝ)\n\nGenerate the (real-valued) Stiefel manifold of n  k dimensional orthonormal matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel.html#Base.exp-Tuple{Stiefel,Vararg{Any,N} where N}","page":"Stiefel","title":"Base.exp","text":"exp(M::Stiefel, p, X)\n\nCompute the exponential map on the Stiefel{n,k,𝔽}() manifold M emanating from p in tangent direction X.\n\nexp_p X = beginpmatrix\n   pX\n endpmatrix\n operatornameExp\n left(\n beginpmatrix p^mathrmHX  - X^mathrmHX\n I_n  p^mathrmHXendpmatrix\n right)\nbeginpmatrix  exp( -p^mathrmHX)  0_nendpmatrix\n\nwhere operatornameExp denotes matrix exponential, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k and 0_k are the identity matrix and the zero matrix of dimension k  k, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#Manifolds.uniform_distribution-Union{Tuple{k}, Tuple{n}, Tuple{Stiefel{n,k,ℝ},Any}} where k where n","page":"Stiefel","title":"Manifolds.uniform_distribution","text":"uniform_distribution(M::Stiefel{n,k,ℝ}, p)\n\nUniform distribution on given (real-valued) Stiefel M. Specifically, this is the normalized Haar and Hausdorff measure on M. Generated points will be of similar type as p.\n\nThe implementation is based on Section 2.5.1 in [Chikuse2003]; see also Theorem 2.2.1(iii) in [Chikuse2003].\n\n[Chikuse2003]: Y. Chikuse: \"Statistics on Special Manifolds\", Springer New York, 2003, doi: 10.1007/978-0-387-21540-2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{Stiefel{n,k,𝔽},Any}} where 𝔽 where k where n","page":"Stiefel","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Stiefel, p; kwargs...)\n\nCheck whether p is a valid point on the Stiefel M=operatornameSt(nk), i.e. that it has the right AbstractNumbers type and p^mathrmHp is (approximately) the identity, where cdot^mathrmH is the complex conjugate transpose. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{Stiefel{n,k,𝔽},Any,Any}} where 𝔽 where k where n","page":"Stiefel","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Stiefel, p, X; check_base_point = true, kwargs...)\n\nChecks whether X is a valid tangent vector at p on the Stiefel M=operatornameSt(nk), i.e. the AbstractNumbers fits and it (approximately) holds that p^mathrmHX + X^mathrmHp = 0. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inverse_retract-Tuple{Stiefel,Any,Any,PolarInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, p, q, ::PolarInverseRetraction)\n\nCompute the inverse retraction based on a singular value decomposition for two points p, q on the Stiefel manifold M. This follows the folloing approach: From the Polar retraction we know that\n\noperatornameretr_p^-1q = qs - t\n\nif such a symmetric positive definite k  k matrix exists. Since qs - t is also a tangent vector at p we obtain\n\np^mathrmHqs + s(p^mathrmHq)^mathrmH + 2I_k = 0\n\nwhich can either be solved by a Lyapunov approach or a continuous-time algebraic Riccati equation.\n\nThis implementation follows the Lyapunov approach.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inverse_retract-Tuple{Stiefel,Any,Any,QRInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, p, q, ::QRInverseRetraction)\n\nCompute the inverse retraction based on a qr decomposition for two points p, q on the Stiefel manifold M and return the resulting tangent vector in X. The computation follows Algorithm 1 in [KanekoFioriTanaka2013].\n\n[KanekoFioriTanaka2013]: T. Kaneko, S. Fiori, T. Tanaka: \"Empirical Arithmetic Averaging over the Compact Stiefel Manifold\", IEEE Transactions on Signal Processing, 2013, doi: 10.1109/TSP.2012.2226167.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.manifold_dimension-Union{Tuple{Stiefel{n,k,ℝ}}, Tuple{k}, Tuple{n}} where k where n","page":"Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Stiefel)\n\nReturn the dimension of the Stiefel manifold M=operatornameSt(nk𝔽). The dimension is given by\n\nbeginaligned\ndim mathrmSt(n k ℝ) = nk - frac12k(k+1)\ndim mathrmSt(n k ℂ) = 2nk - k^2\ndim mathrmSt(n k ℍ) = 4nk - k(2k-1)\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.project-Tuple{Stiefel,Any,Any}","page":"Stiefel","title":"ManifoldsBase.project","text":"project(M::Stiefel,p)\n\nProjects p from the embedding onto the Stiefel M, i.e. compute q as the polar decomposition of p such that q^mathrmHq is the identity, where cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.project-Tuple{Stiefel,Vararg{Any,N} where N}","page":"Stiefel","title":"ManifoldsBase.project","text":"project(M::Stiefel, p, X)\n\nProject X onto the tangent space of p to the Stiefel manifold M. The formula reads\n\noperatornameproj_mathcal M(p X) = X - p operatornameSym(p^mathrmHX)\n\nwhere operatornameSym(q) is the symmetrization of q, e.g. by operatornameSym(q) = fracq^mathrmH+q2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.representation_size-Union{Tuple{Stiefel{n,k,𝔽} where 𝔽}, Tuple{k}, Tuple{n}} where k where n","page":"Stiefel","title":"ManifoldsBase.representation_size","text":"representation_size(M::Stiefel)\n\nReturns the representation size of the Stiefel M=operatornameSt(nk), i.e. (n,k), which is the matrix dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.retract-Tuple{Stiefel,Any,Any,PolarRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Stiefel manifold M. With USV = p + X the retraction reads\n\noperatornameretr_p X = UbarV^mathrmH\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.retract-Tuple{Stiefel,Any,Any,QRRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::QRRetraction )\n\nCompute the QR-based retraction QRRetraction on the Stiefel manifold M. With QR = p + X the retraction reads\n\noperatornameretr_p X = QD\n\nwhere D is a n  k matrix with\n\nD = operatornamediagbigl(operatornamesgn(R_ii+05)_i=1^k bigr)\n\nwhere operatornamesgn(p) = begincases 1  text for  p  0\n0  text for  p = 0\n-1 text for  p  0 endcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#Literature","page":"Stiefel","title":"Literature","text":"","category":"section"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"<ul>\n<li id=\"SatoTawi2013\">\nH. Sato and T. Iawi, “A complex singular value decomposition algorithm based on\nthe Riemannian Newton method”, in: <emph>IEEE 52nd Annual Conference on Decision and\nControl (CDC)</emph>, 2013, p. 2972--2978,\ndoi: <a href=\"https://doi.org/10.1109/CDC.2013.6760335\">10.1109/CDC.2013.6760335</a>\n</li>\n<li>\nH. Sato: “Riemannian conjugate gradient method for complex singular value\ndecomposition problem”, in: <emph>IEEE 53rd Annual COnference on Decision and Control\n(CDC)</emph>, 2014, p. 5849–5854,\ndoi: <a href=\"https://doi.org/10.1109/CDC.2014.7040305\">10.1109/CDC.2014.7040305</a>\n</li>","category":"page"},{"location":"manifolds/circle.html#Circle","page":"Circle","title":"Circle","text":"","category":"section"},{"location":"manifolds/circle.html","page":"Circle","title":"Circle","text":"Modules = [Manifolds]\nPages = [\"manifolds/Circle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/circle.html#Manifolds.Circle","page":"Circle","title":"Manifolds.Circle","text":"Circle{𝔽} <: Manifold{𝔽}\n\nThe circle 𝕊^1 is a manifold here represented by real-valued points in -ππ) or complex-valued points z  ℂ of absolute value lvert zrvert = 1.\n\nConstructor\n\nCircle(𝔽=ℝ)\n\nGenerate the ℝ-valued Circle represented by angles, which alternatively can be set to use the AbstractNumbers 𝔽=ℂ to obtain the circle represented by ℂ-valued circle of unit numbers.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/circle.html#Base.exp-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"Base.exp","text":"exp(M::Circle, p, X)\n\nCompute the exponential map on the Circle.\n\nexp_p X = (p+X)_2π\n\nwhere (cdot)_2π is the (symmetric) remainder with respect to division by 2π, i.e. in -ππ).\n\nFor the complex-valued case, the same formula as for the Sphere 𝕊^1 is applied to values in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Base.log-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"Base.log","text":"log(M::Circle, p, q)\n\nCompute the logarithmic map on the Circle M.\n\nlog_p q = (q-p)_2π\n\nwhere (cdot)_2π is the (symmetric) remainder with respect to division by 2π, i.e. in -ππ).\n\nFor the complex-valued case, the same formula as for the Sphere 𝕊^1 is applied to values in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.complex_dot-Tuple{Any,Any}","page":"Circle","title":"Manifolds.complex_dot","text":"complex_dot(a, b)\n\nCompute the inner product of two (complex) numbers with in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.sym_rem-Union{Tuple{N}, Tuple{N}, Tuple{N,Any}} where N<:Number","page":"Circle","title":"Manifolds.sym_rem","text":"sym_rem(x,[T=π])\n\nCompute symmetric remainder of x with respect to the interall 2*T, i.e. (x+T)%2T, where the default for T is π\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.check_manifold_point-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Circle, p)\n\nCheck whether p is a point on the Circle M. For the real-valued case, x is an angle and hence it checks that p   -ππ). for the complex-valued case, it is a unit number, p  ℂ with lvert p rvert = 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.check_tangent_vector-Tuple{Circle{ℝ},Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Circle, p, X; check_base_point, kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the Circle M. For the real-valued case represented by angles, all X are valid, since the tangent space is the whole real line. For the complex-valued case X has to lie on the line parallel to the tangent line at p in the complex plane, i.e. their inner product has to be zero. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.distance-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.distance","text":"distance(M::Circle, p, q)\n\nCompute the distance on the Circle M, which is the absolute value of the symmetric remainder of p and q for the real-valued case and the angle between both complex numbers in the Gaussian plane for the complex-valued case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.get_coordinates-Tuple{Circle{ℂ},Any,Any,DefaultOrthonormalBasis}","page":"Circle","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Circle{ℂ}, p, X, B::DefaultOrthonormalBasis)\n\nReturn tangent vector coordinates in the Lie algebra of the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.get_vector-Tuple{Circle{ℂ},Any,Any,AbstractBasis}","page":"Circle","title":"ManifoldsBase.get_vector","text":"get_vector(M::Circle{ℂ}, p, X, B::DefaultOrthonormalBasis)\n\nReturn tangent vector from the coordinates in the Lie algebra of the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.injectivity_radius-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Circle[, p])\n\nReturn the injectivity radius on the Circle M, i.e. π.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.inner-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.inner","text":"inner(M::Circle, p, X, Y)\n\nCompute the inner product of the two tangent vectors X,Y from the tangent plane at p on the Circle M using the restriction of the metric from the embedding, i.e.\n\ng_p(XY) = X*Y\n\nfor the real case and\n\ng_p(XY) = Y^mathrmTX\n\nfor the complex case interpreting complex numbers in the Gaussian plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.manifold_dimension-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Circle)\n\nReturn the dimension of the Circle M, i.e. dim(𝕊^1) = 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.project-Tuple{Circle,Any,Any}","page":"Circle","title":"ManifoldsBase.project","text":"project(M::Circle, p, X)\n\nProject a value X onto the tangent space of the point p on the Circle M.\n\nFor the real-valued case this is just the identity. For the complex valued case X is projected onto the line in the complex plane that is parallel to the tangent to p on the unit circle and contains 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.project-Tuple{Circle,Any}","page":"Circle","title":"ManifoldsBase.project","text":"project(M::Circle, p)\n\nProject a point p onto the Circle M. For the real-valued case this is the remainder with respect to modulus 2π. For the complex-valued case the result is the projection of p onto the unit circle in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.vector_transport_to-Tuple{Circle,Any,Any,Any,ParallelTransport}","page":"Circle","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Circle, p, X, q, ::ParallelTransport)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the Circle M. For the real-valued case this results in the identity. For the complex-valud case, the formula is the same as for the Sphere(1) in the complex plane.\n\nmathcal P_qp X = X - fraclog_p qX_pd^2_ℂ(pq)\nbigl(log_p q + log_q p bigr)\n\nwhere log denotes the logarithmic map on M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Statistics.mean-Tuple{Circle{ℂ},Any}","page":"Circle","title":"Statistics.mean","text":"mean(M::Circle{ℂ}, x::AbstractVector[, w::AbstractWeights])\n\nCompute the Riemannian mean of x of points on the Circle 𝕊^1, reprsented by complex numbers, i.e. embedded in the complex plade. Comuting the sum\n\ns = sum_i=1^n x_i\n\nthe mean is the angle of the complex number s, so represented in the complex plane as fracslvert s rvert, whenever s neq 0.\n\nIf the sum s=0, the mean is not unique. For example for opposite points or equally spaced angles.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Statistics.mean-Tuple{Circle{ℝ},Any}","page":"Circle","title":"Statistics.mean","text":"mean(M::Circle{ℝ}, x::AbstractVector[, w::AbstractWeights])\n\nCompute the Riemannian mean of x of points on the Circle 𝕊^1, reprsented by real numbers, i.e. the angular mean\n\noperatornameatanBigl( sum_i=1^n w_isin(x_i)  sum_i=1^n w_isin(x_i) Bigr)\n\n\n\n\n\n","category":"method"},{"location":"misc/about.html#About-Manifolds.jl","page":"About","title":"About Manifolds.jl","text":"","category":"section"},{"location":"misc/about.html#License","page":"About","title":"License","text":"","category":"section"},{"location":"misc/about.html","page":"About","title":"About","text":"MIT License","category":"page"},{"location":"misc/about.html#Core-Developers","page":"About","title":"Core Developers","text":"","category":"section"},{"location":"misc/about.html","page":"About","title":"About","text":"Seth Axen\nMateusz Baran\nRonny Bergmann","category":"page"},{"location":"misc/about.html#Contributors","page":"About","title":"Contributors","text":"","category":"section"},{"location":"misc/about.html","page":"About","title":"About","text":"See the GitHub contributors page.","category":"page"},{"location":"misc/about.html","page":"About","title":"About","text":"Contributions are welcome!","category":"page"},{"location":"features/testing.html#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"features/testing.html","page":"Testing","title":"Testing","text":"Documentation for testing utilities for Manifolds.jl. The function test_manifold can be used to verify that your manifold correctly implements the Manifolds.jl interface.","category":"page"},{"location":"features/testing.html","page":"Testing","title":"Testing","text":"Modules = [Manifolds, Manifolds.ManifoldTests]\nPages = [\"tests/ManifoldTests.jl\", \"tests/tests_general.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/testing.html#Manifolds.ManifoldTests.test_manifold-Tuple{Manifold,AbstractArray{T,1} where T}","page":"Testing","title":"Manifolds.ManifoldTests.test_manifold","text":"test_manifold(\n    M::Manifold,\n    pts::AbstractVector;\n    args,\n)\n\nTest general properties of manifold M, given at least three different points that lie on it (contained in pts).\n\nArguments\n\nbasis_has_specialized_diagonalizing_get = false: if true, assumes that   DiagonalizingOrthonormalBasis given in basis_types has   get_coordinates and get_vector that work without caching.\nbasis_types_to_from = (): basis types that will be tested based on   get_coordinates and get_vector.\nbasis_types_vecs = () : basis types that will be tested based on get_vectors.\ndefault_inverse_retraction_method = ManifoldsBase.LogarithmicInverseRetraction():   default method for inverse retractions (log).\ndefault_retraction_method = ManifoldsBase.ExponentialRetraction(): default method for   retractions (exp).\nexp_log_atol_multiplier = 0: change absolute tolerance of exp/log tests   (0 use default, i.e. deactivate atol and use rtol).\nexp_log_rtol_multiplier = 1: change the relative tolerance of exp/log tests   (1 use default). This is deactivated if the exp_log_atol_multiplier is nonzero.\nexpected_dimension_type = Integer: expected type of value returned by   manifold_dimension.\ninverse_retraction_methods = []: inverse retraction methods that will be tested.\nis_mutating = true: whether mutating variants of functions should be tested.\nis_point_atol_multiplier = 0: determines atol of is_manifold_point checks.\nis_tangent_atol_multiplier = 0: determines atol of is_tangent_vector checks.\nmid_point12 = test_exp_log ? shortest_geodesic(M, pts[1], pts[2], 0.5) : nothing: if not nothing, then check   that mid_point(M, pts[1], pts[2]) is approximately equal to mid_point12. This is   by default set to nothing if text_exp_log is set to false.\npoint_distributions = [] : point distributions to test.\nrand_tvector_atol_multiplier = 0 : chage absolute tolerance in testing random vectors   (0 use default, i.e. deactivate atol and use rtol) random tangent vectors are tangent   vectors.\nretraction_atol_multiplier = 0: change absolute tolerance of (inverse) retraction tests   (0 use default, i.e. deactivate atol and use rtol).\nretraction_rtol_multiplier = 1: change the relative tolerance of (inverse) retraction   tests (1 use default). This is deactivated if the exp_log_atol_multiplier is nonzero.\nretraction_methods = []: retraction methods that will be tested.\ntest_exp_log = true: if true, checkthat exp is the inverse of log.\ntest_forward_diff = true: if true, automatic differentiation using   ForwardDiff is tested.\ntest_injectivity_radius = true: whether implementation of injectivity_radius   should be tested.\ntest_is_tangent: if true check that the default_inverse_retraction_method   actually returns valid tangent vectors.\ntest_musical_isomorphisms = false : test musical isomorphisms.\ntest_mutating_rand = false : test the mutating random function for points on manifolds.\ntest_project_point = false: test projections onto the manifold.\ntest_project_tangent = false : test projections on tangent spaces.\ntest_representation_size = true : test repersentation size of points/tvectprs.\ntest_reverse_diff = true: if true, automatic differentiation using   ReverseDiff is tested.\ntest_tangent_vector_broadcasting = true : test boradcasting operators on TangentSpace.\ntest_vector_spaces = true : test Vector bundle of this manifold.\ntest_default_vector_transport = false : test the default vector transport (usually   parallel transport).\ntest_vee_hat = false: test vee and hat functions.\ntvector_distributions = [] : tangent vector distributions to test.\nvector_transport_methods = []: vector transport methods that should be tested.\n\n\n\n\n\n","category":"method"},{"location":"features/testing.html#Manifolds.ManifoldTests.find_eps-Tuple","page":"Testing","title":"Manifolds.ManifoldTests.find_eps","text":"find_eps(x...)\n\nFind an appropriate tolerance for given points or tangent vectors, or their types.\n\n\n\n\n\n","category":"method"},{"location":"misc/notation.html#Notation-overview","page":"Notation","title":"Notation overview","text":"","category":"section"},{"location":"misc/notation.html","page":"Notation","title":"Notation","text":"Since manifolds include a reasonable amount of elements and functions, the following list tries to keep an overview of used notation throughout Manifolds.jl. The order is alphabetical by name. They might be used in a plain form within the code or when referring to that code. This is for example the case with the calligraphic symbols.","category":"page"},{"location":"misc/notation.html","page":"Notation","title":"Notation","text":"Within the documented functions, the utf8 symbols are used whenever possible, as long as that renders correctly in TeX within this documentation.","category":"page"},{"location":"misc/notation.html","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\ntau_p action map by group element p mathrmL_p, mathrmR_p either left or right\ntimes Cartesian product of two manifolds  see ProductManifold\n^wedge (n-ary) Cartesian power of a manifold  see PowerManifold\nT^*_p mathcal M the cotangent space at p  \nxi a cotangent vector from T^*_p mathcal M xi_1 xi_2ldotsetazeta sometimes written with base point xi_p.\nmathrmdphi_p(q) Differential of a map phi mathcal M to mathcal N with respect to p at a point q. For functions of multiple variables, for example phi(p p_1) where p in mathcal M and p_1 in mathcal M_1, variable p is explicitly stated to specify with respect to which argument the differential is calculated. mathrmdphi_q, (mathrmdphi)_q, (phi_*)_q, D_pphi(q) pushes tangent vectors X in T_q mathcal M forward to mathrmdphi_p(q)X in T_phi(q) mathcal N\nn dimension (of a manifold) n_1n_2ldotsm dim(mathcal M) for the real dimension sometimes also dim_mathbb R(mathcal M)\nd(cdotcdot) (Riemannian) distance d_mathcal M(cdotcdot) \nexp_p X exponential map at p in mathcal M of a vector X in T_p mathcal M exp_p(X) \nF a fiber  see VectorBundleFibers\nmathbb F a field  field a manifold or a basis is based on, usually mathbb F in mathbb Rmathbb C\ngamma a geodesic gamma_pq, gamma_pX connecting two points pq or starting in p with velocity X.\nnabla f(p) gradient of function f colon mathcalM to mathbbR at p in mathcalM  \ncirc a group operation  \ncdot^mathrmH Hermitian or conjugate transposed  \ne identity element of a group  \nI_k identity matrix of size ktimes k  \nk indices ij \nlanglecdotcdotrangle inner product (in T_p mathcal M) langlecdotcdotrangle_p g_p(cdotcdot) \nmathfrak g a Lie algebra  \nmathcalG a (Lie) group  \nlog_p q logarithmic map at p in mathcal M of a point q in mathcal M log_p(q) \nmathcal M a manifold mathcal M_1 mathcal M_2ldotsmathcal N \noperatornameExp the matrix exponential  \noperatornameLog the matrix logarithm  \nmathcal P_qgets pX parallel transport  of the vector X from T_pmathcal M to T_qmathcal M\np a point on mathcal M p_1 p_2 ldotsq for 3 points one might use xyz\nXi a set of tangent vectors X_1ldotsX_n \nT_p mathcal M the tangent space at p  \nX a tangent vector from T_p mathcal M X_1X_2ldotsYZ sometimes written with base point X_p\noperatornametr trace (of a matrix)  \ncdot^mathrmT transposed  \nB a vector bundle  \n0_k the ktimes k zero matrix.  ","category":"page"},{"location":"manifolds/symmetricpsdfixedrank.html#Symmetric-Positive-Semidefinite-Matrices-of-Fixed-Rank","page":"Symmetric positive semidefinite fixed rank","title":"Symmetric Positive Semidefinite Matrices of Fixed Rank","text":"","category":"section"},{"location":"manifolds/symmetricpsdfixedrank.html","page":"Symmetric positive semidefinite fixed rank","title":"Symmetric positive semidefinite fixed rank","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveSemidefiniteFixedRank.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpsdfixedrank.html#Manifolds.SymmetricPositiveSemidefiniteFixedRank","page":"Symmetric positive semidefinite fixed rank","title":"Manifolds.SymmetricPositiveSemidefiniteFixedRank","text":"SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽} <: AbstractEmbeddedManifold{𝔽,DefaultIsometricEmbeddingType}\n\nThe Manifold $ \\operatorname{SPS}_k(n)$ consisting of the real- or complex-valued symmetric positive semidefinite matrices of size n  n and rank k, i.e. the set\n\noperatornameSPS_k(n) = bigl\np   𝔽^n  n big p^mathrmH = p\napa^mathrmH geq 0 text for all  a  𝔽\ntext and  operatornamerank(p) = kbigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ. We sometimes operatornameSPS_k𝔽(n), when distinguishing the real- and complex-valued manifold is important.\n\nAn element is represented by q  𝔽^n  k from the factorization p = qq^mathrmH. Note that since for any unitary (orthogonal) A  𝔽^n  n we have (Aq)(Aq)^mathrmH = qq^mathrmH = p, the representation is not unique, or in other words, the manifold is a quotient manifold of 𝔽^n  k.\n\nThe tangent space at p, T_poperatornameSPS_k(n), is also represented by matrices Y  𝔽^n  k and reads as\n\nT_poperatornameSPS_k(n) = bigl\nX  𝔽^n  nX = qY^mathrmH + Yq^mathrmH\ntext ie  X = X^mathrmH\nbigr\n\nNote that the metric used yields a non-complete manifold. The metric was used in[JourneeBachAbsilSepulchre2010][MassartAbsil2020].\n\nConstructor\n\nSymmetricPositiveSemidefiniteFixedRank(n::Int, k::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of n  n symmetric positive semidefinite matrices of rank k over the field of real numbers ℝ or complex numbers ℂ.\n\n[JourneeBachAbsilSepulchre2010]: Journée, M., Bach, F., Absil, P.-A., and Sepulchre, R.: “Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”, SIAM Journal on Optimization (20)5, pp. 2327–2351, 2010. doi: 10.1137/080731359, arXiv: 0807.4423.\n\n[MassartAbsil2020]: Massart, E., Absil, P.-A.: \"Quotient Geometry with Simple Geodesics for the Manifold of Fixed-Rank Positive-Semidefinite Matrices\", SIAM Journal on Matrix Analysis and Applications (41)1, pp. 171–198, 2020. doi: 10.1137/18m1231389, preprint: sites.uclouvain.be/absil/2018.06.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpsdfixedrank.html#Base.exp-Tuple{SymmetricPositiveSemidefiniteFixedRank,Any,Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.exp","text":"exp(M::SymmetricPositiveSemidefiniteFixedRank, q, Y)\n\nCompute the exponential map on the SymmetricPositiveSemidefiniteFixedRank, which just reads\n\n    exp_q Y = q+Y\n\nnote: Note\nSince the manifold is represented in the embedding and is a quotient manifold, the exponential and logarithmic map are a bijection only with respect to the equivalence classes. Computing    q_2 = exp_p(log_pq)might yield a matrix q_2neq q, but they represent the same point on the quotient manifold, i.e. d_operatornameSPS_k(n)(q_2q) = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#Base.isapprox-Tuple{SymmetricPositiveSemidefiniteFixedRank,Any,Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.isapprox","text":"isapprox(M::SymmetricPositiveSemidefiniteFixedRank, p, q; kwargs...)\n\ntest, whether two points p, q are (approximately) nearly the same. Since this is a quotient manifold in the embedding, the test is performed by checking their distance, if they are not the same, i.e. that d_mathcal M(pq) approx 0, where the comparison is performed with the classical isapprox. The kwargs... are passed on to this accordingly.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#Base.log-Tuple{SymmetricPositiveSemidefiniteFixedRank,Any,Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.log","text":"log(M::SymmetricPositiveSemidefiniteFixedRank, q, p)\n\nCompute the logarithmic map on the SymmetricPositiveSemidefiniteFixedRank manifold by minimizing lVert p - qYrVert with respect to Y.\n\nnote: Note\nSince the manifold is represented in the embedding and is a quotient manifold, the exponential and logarithmic map are a bijection only with respect to the equivalence classes. Computing    q_2 = exp_p(log_pq)might yield a matrix q_2neq q, but they represent the same point on the quotient manifold, i.e. d_operatornameSPS_k(n)(q_2q) = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽},Any}} where 𝔽 where k where n","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SymmetricPositiveSemidefiniteFixedRank{n,𝔽}, q; kwargs...)\n\nCheck whether q is a valid manifold point on the SymmetricPositiveSemidefiniteFixedRank M, i.e. whether p=q*q' is a symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽. The symmetry of p is not explicitly checked since by using q p is symmetric by construction. The tolerance for the symmetry of p can and the rank of q*q' be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽},Any,Any}} where 𝔽 where k where n","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽}, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SymmetricPositiveSemidefiniteFixedRank M, i.e. X has to be a symmetric matrix of size (n,n) and its values have to be from the correct AbstractNumbers. The optional parameter check_base_point indicates, whether to call  check_manifold_point  for p. The tolerance for the symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.distance-Tuple{SymmetricPositiveSemidefiniteFixedRank,Any,Any}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.distance","text":"distance(M::SymmetricPositiveSemidefiniteFixedRank, p, q)\n\nCompute the distance between two points p, q on the SymmetricPositiveSemidefiniteFixedRank, which is the Frobenius norm of Y which minimizes lVert p - qYrVert with respect to Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.manifold_dimension-Tuple{SymmetricPositiveSemidefiniteFixedRank}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽})\n\nReturn the dimension of the SymmetricPositiveSemidefiniteFixedRank matrix M over the number system 𝔽, i.e.\n\nbeginaligned\ndim operatornameSPS_kℝ(n) = kn - frack(k-1)2\ndim operatornameSPS_kℂ(n) = 2kn - k^2\nendaligned\n\nwhere the last k^2 is due to the zero imaginary part for Hermitian matrices diagonal\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.vector_transport_to-Tuple{SymmetricPositiveSemidefiniteFixedRank,Any,Any,Any,ProjectionTransport}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::SymmetricPositiveSemidefiniteFixedRank, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.zero_tangent_vector-Tuple{SymmetricPositiveSemidefiniteFixedRank,Vararg{Any,N} where N}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.zero_tangent_vector","text":" zero_tangent_vector(M::SymmetricPositiveSemidefiniteFixedRank, p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the SymmetricPositiveSemidefiniteFixedRank manifold M.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Differentiation","page":"Differentiation","title":"Differentiation","text":"","category":"section"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Documentation for Manifolds.jl's methods and types for finite differences and automatic differentiation.","category":"page"},{"location":"features/differentiation.html#Differentiation-backends","page":"Differentiation","title":"Differentiation backends","text":"","category":"section"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Modules = [Manifolds]\nPages = [\"differentiation.jl\"]\nOrder = [:type, :function, :constant]","category":"page"},{"location":"features/differentiation.html#Manifolds.AbstractDiffBackend","page":"Differentiation","title":"Manifolds.AbstractDiffBackend","text":"AbstractDiffBackend\n\nAn abstract type for diff backends. See FiniteDifferencesBackend for an example.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.CurrentDiffBackend","page":"Differentiation","title":"Manifolds.CurrentDiffBackend","text":"CurrentDiffBackend(backend::AbstractDiffBackend)\n\nA mutable struct for storing the current differentiation backend in a global constant _current_diff_backend.\n\nSee also\n\nAbstractDiffBackend, diff_backend, diff_backend!\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.FiniteDifferencesBackend","page":"Differentiation","title":"Manifolds.FiniteDifferencesBackend","text":"FiniteDifferencesBackend(method::FiniteDifferenceMethod = central_fdm(5, 1))\n\nDifferentiation backend based on the FiniteDifferences package.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds._derivative","page":"Differentiation","title":"Manifolds._derivative","text":"_derivative(f, t[, backend::AbstractDiffBackend])\n\nCompute the derivative of a callable f at time t computed using the given backend, an object of type Manifolds.AbstractDiffBackend. If the backend is not explicitly specified, it is obtained using the function Manifolds.diff_backend.\n\nThis function calculates plain Euclidean derivatives, for Riemannian differentiation see for example differential.\n\nnote: Note\nNot specifying the backend explicitly will usually result in a type instability and decreased performance.\n\n\n\n\n\n","category":"function"},{"location":"features/differentiation.html#Manifolds._gradient","page":"Differentiation","title":"Manifolds._gradient","text":"_gradient(f, p[, backend::AbstractDiffBackend])\n\nCompute the gradient of a callable f at point p computed using the given backend, an object of type AbstractDiffBackend. If the backend is not explicitly specified, it is obtained using the function diff_backend.\n\nThis function calculates plain Euclidean gradients, for Riemannian gradient calculation see for example gradient.\n\nnote: Note\nNot specifying the backend explicitly will usually result in a type instability and decreased performance.\n\n\n\n\n\n","category":"function"},{"location":"features/differentiation.html#Manifolds.diff_backend!-Tuple{AbstractDiffBackend}","page":"Differentiation","title":"Manifolds.diff_backend!","text":"diff_backend!(backend::AbstractDiffBackend)\n\nSet current backend for differentiation to backend.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.diff_backend-Tuple{}","page":"Differentiation","title":"Manifolds.diff_backend","text":"diff_backend() -> AbstractDiffBackend\n\nGet the current differentiation backend.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.diff_backends-Tuple{}","page":"Differentiation","title":"Manifolds.diff_backends","text":"diff_backends() -> Vector{AbstractDiffBackend}\n\nGet vector of currently valid differentiation backends.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds._current_diff_backend","page":"Differentiation","title":"Manifolds._current_diff_backend","text":"_current_diff_backend\n\nThe instance of Manifolds.CurrentDiffBackend that stores the globally default differentiation backend.\n\n\n\n\n\n","category":"constant"},{"location":"features/differentiation.html#Manifolds._diff_backends","page":"Differentiation","title":"Manifolds._diff_backends","text":"_diff_backends\n\nA vector of valid Manifolds.AbstractDiffBackend.\n\n\n\n\n\n","category":"constant"},{"location":"features/differentiation.html#Riemannian-differentiation-backends","page":"Differentiation","title":"Riemannian differentiation backends","text":"","category":"section"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Modules = [Manifolds]\nPages = [\"riemannian_diff.jl\"]\nOrder = [:type, :function, :constant]","category":"page"},{"location":"features/differentiation.html#Manifolds.AbstractRiemannianDiffBackend","page":"Differentiation","title":"Manifolds.AbstractRiemannianDiffBackend","text":"AbstractRiemannianDiffBackend\n\nAn abstract type for diff backends. See RiemannianONBDiffBackend for an example.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.CurrentRiemannianDiffBackend","page":"Differentiation","title":"Manifolds.CurrentRiemannianDiffBackend","text":"CurrentRiemannianDiffBackend(backend::AbstractRiemannianDiffBackend)\n\nA mutable struct for storing the current Riemannian differentiation backend in global constants Manifolds._current_rgradient_backend and Manifolds._current_rdifferential_backend.\n\nSee also\n\nAbstractRiemannianDiffBackend, rdifferential_backend, rdifferential_backend!\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.RiemannianONBDiffBackend","page":"Differentiation","title":"Manifolds.RiemannianONBDiffBackend","text":"RiemannianONBDiffBackend(\n    diff_backend::AbstractDiffBackend\n    retraction::AbstractRetractionMethod\n    inverse_retraction::AbstractInverseRetractionMethod\n    basis::Union{AbstractOrthonormalBasis,CachedBasis{<:AbstractOrthonormalBasis}},\n) <: AbstractRiemannianDiffBackend\n\nRiemannian differentiation based on differentiation in an AbstractOrthonormalBasis basis using specified retraction, inverse_retraction and using backend diff_backend.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.RiemannianProjectionGradientBackend","page":"Differentiation","title":"Manifolds.RiemannianProjectionGradientBackend","text":"RiemannianProjectionGradientBackend(\n    diff_backend::AbstractDiffBackend\n) <: AbstractRiemannianDiffBackend\n\nRiemannian differentiation based on differentiation in the ambient space and projection to the given manifold. Differentiation in the ambient space is performed using the backend diff_backend.\n\nOnly valid for manifolds that are embedded in a special way in the Euclidean space. See [Absil2008], Section 3.6.1 for details.\n\n[Absil2008]: Absil, P. A., et al. Optimization Algorithms on Matrix Manifolds. 2008.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.differential-Tuple{Manifold,Any,Real,AbstractRiemannianDiffBackend}","page":"Differentiation","title":"Manifolds.differential","text":"differential(M::Manifold, f, t::Real, backend::AbstractDiffBackend = rdifferential_backend())\n\nCompute the Riemannian differential of a curve f ℝto M on a manifold M represented by function f at time t using the given backend. It is calculated as the tangent vector equal to mathrmdf_t(t)1.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.gradient-Tuple{Manifold,Any,Any,AbstractRiemannianDiffBackend}","page":"Differentiation","title":"Manifolds.gradient","text":"gradient(M::Manifold, f, p, backend::AbstractRiemannianDiffBackend = rgradient_backend())\n\nCompute the Riemannian gradient f(p) of a real field on manifold M represented by function f at point p using the given backend.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.rdifferential_backend!-Tuple{AbstractRiemannianDiffBackend}","page":"Differentiation","title":"Manifolds.rdifferential_backend!","text":"rdifferential_backend!(backend::AbstractRiemannianDiffBackend)\n\nSet current Riemannian differential backend for differentiation to backend.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.rdifferential_backend-Tuple{}","page":"Differentiation","title":"Manifolds.rdifferential_backend","text":"rdifferential_backend() -> AbstractRiemannianDiffBackend\n\nGet the current differentiation backend for Riemannian differentials.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.rgradient_backend!-Tuple{AbstractRiemannianDiffBackend}","page":"Differentiation","title":"Manifolds.rgradient_backend!","text":"rgradient_backend!(backend::AbstractRiemannianDiffBackend)\n\nSet current Riemannian gradient backend for differentiation to backend.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.rgradient_backend-Tuple{}","page":"Differentiation","title":"Manifolds.rgradient_backend","text":"rgradient_backend() -> AbstractRiemannianDiffBackend\n\nGet the current differentiation backend for Riemannian gradients.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds._current_rdifferential_backend","page":"Differentiation","title":"Manifolds._current_rdifferential_backend","text":"_current_rdifferential_backend\n\nThe instance of Manifolds.CurrentRiemannianDiffBackend that stores the globally default differentiation backend for calculating differentials.\n\nSee also\n\nManifolds.differential\n\n\n\n\n\n","category":"constant"},{"location":"features/differentiation.html#Manifolds._current_rgradient_backend","page":"Differentiation","title":"Manifolds._current_rgradient_backend","text":"_current_rgradient_backend\n\nThe instance of Manifolds.CurrentRiemannianDiffBackend that stores the globally default differentiation backend for calculating gradients.\n\nSee also\n\nManifolds.gradient(::Manifold, ::Any, ::Any, ::AbstractRiemannianDiffBackend)\n\n\n\n\n\n","category":"constant"},{"location":"manifolds/skewsymmetric.html#Skew-symmetric-matrices","page":"Skew-symmetric matrices","title":"Skew-symmetric matrices","text":"","category":"section"},{"location":"manifolds/skewsymmetric.html","page":"Skew-symmetric matrices","title":"Skew-symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/SkewSymmetric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/skewsymmetric.html#Manifolds.SkewSymmetricMatrices","page":"Skew-symmetric matrices","title":"Manifolds.SkewSymmetricMatrices","text":"SkewSymmetricMatrices{n,𝔽} <: AbstractEmbeddedManifold{𝔽,TransparentIsometricEmbedding}\n\nThe Manifold $ \\operatorname{SkewSym}(n)$ consisting of the real- or complex-valued skew-symmetric matrices of size n  n, i.e. the set\n\noperatornameSkewSym(n) = biglp   𝔽^n  n big p^mathrmH = -p bigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ.\n\nThough it is slightly redundant, usually the matrices are stored as n  n arrays.\n\nNote that in this representation, the (real-valued part of) the diagonal has to be zero, which is also reflected in the manifold_dimension.\n\nConstructor\n\nSkewSymmetricMatrices(n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of n  n symmetric matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/skewsymmetric.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{SkewSymmetricMatrices{n,𝔽},Any}} where 𝔽 where n","page":"Skew-symmetric matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SkewSymmetricMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether p is a valid manifold point on the SkewSymmetricMatrices M, i.e. whether p is a skew-symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽.\n\nThe tolerance for the skew-symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewsymmetric.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{n}, Tuple{SkewSymmetricMatrices{n,𝔽},Any,Any}} where 𝔽 where n","page":"Skew-symmetric matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SkewSymmetricMatrices{n,𝔽}, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SkewSymmetricMatrices M, i.e. X has to be a skew-symmetric matrix of size (n,n) and its values have to be from the correct AbstractNumbers. The optional parameter check_base_point indicates, whether to call  check_manifold_point  for p. The tolerance for the skew-symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewsymmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{SkewSymmetricMatrices{N,𝔽}}, Tuple{𝔽}, Tuple{N}} where 𝔽 where N","page":"Skew-symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SkewSymmetricMatrices{n,𝔽})\n\nReturn the dimension of the SkewSymmetricMatrices matrix M over the number system 𝔽, i.e.\n\nbeginaligned\ndim mathrmSkewSym(nℝ) = fracn(n-1)2\ndim mathrmSkewSym(nℂ) = 2*fracn(n-1)2 + n = n^2\nendaligned\n\nwhere the last n is due to an imaginary diagonal that is allowed dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewsymmetric.html#ManifoldsBase.project-Tuple{SkewSymmetricMatrices,Any,Any}","page":"Skew-symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SkewSymmetricMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SkewSymmetricMatrices M,\n\noperatornameproj_p(X) = frac12 bigl( X - X^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewsymmetric.html#ManifoldsBase.project-Tuple{SkewSymmetricMatrices,Any}","page":"Skew-symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SkewSymmetricMatrices, p)\n\nProjects p from the embedding onto the SkewSymmetricMatrices M, i.e.\n\noperatornameproj_operatornameSkewSym(n)(p) = frac12 bigl( p - p^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Hyperbolic-space","page":"Hyperbolic space","title":"Hyperbolic space","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Modules = [Manifolds]\nPages = [\"manifolds/Hyperbolic.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/hyperbolic.html#Manifolds.Hyperbolic","page":"Hyperbolic space","title":"Manifolds.Hyperbolic","text":"Hyperbolic{N} <: AbstractEmbeddedManifold{ℝ,DefaultIsometricEmbeddingType}\n\nThe hyperbolic space ℍ^n represented by n+1-Tuples, i.e. embedded in the Lorentzian manifold equipped with the MinkowskiMetric cdotcdot_mathrmM. The space is defined as\n\nℍ^n = Biglp  ℝ^n+1 Big pp_mathrmM= -p_n+1^2\n  + displaystylesum_k=1^n p_k^2 = -1 p_n+1  0Bigr\n\nThe tangent space T_p ℍ^n is given by\n\nT_p ℍ^n = bigl\nX  ℝ^n+1  pX_mathrmM = 0\nbigr\n\nNote that while the MinkowskiMetric renders the Lorentz manifold (only) pseudo-Riemannian, on the tangent bundle of the Hyperbolic space it induces a Riemannian metric. The corresponding sectional curvature is -1.\n\nConstructor\n\nHyperbolic(n)\n\nGenerate the ℍ^n  ℝ^n+1\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Base.exp-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"Base.exp","text":"exp(M::Hyperbolic, p, X)\n\nCompute the exponential map on the Hyperbolic space ℍ^n emanating from p towards X. The formula reads\n\nexp_p X = cosh(sqrtXX_mathrmM)p\n+ sinh(sqrtXX_mathrmM)fracXsqrtXX_mathrmM\n\nwhere cdotcdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.log-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"Base.log","text":"log(M::Hyperbolic, p, q)\n\nCompute the logarithmic map on the Hyperbolic space ℍ^n, the tangent vector representing the geodesic starting from p reaches q after time 1. The formula reads for p  q\n\nlog_p q = d_ℍ^n(pq)\nfracq-pq_mathrmM plVert q-pq_mathrmM p rVert_2\n\nwhere cdotcdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold. For p=q the logarihmic map is equal to the zero vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.check_manifold_point-Tuple{Hyperbolic,Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Hyperbolic, p; kwargs...)\n\nCheck whether p is a valid point on the Hyperbolic M, i.e. is a p vector with inner product in the embedding of -1, see MinkowskiMetric. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.check_tangent_vector-Tuple{Hyperbolic,Any,Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Hyperbolic, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to p on the Hyperbolic M, i.e. after check_manifold_point(M,p), X has to be of the same dimension as p and orthogonal to p with respect to the inner product from the embedding, see MinkowskiMetric. The optional parameter check_base_point indicates whether to call check_manifold_point  for p. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.distance-Tuple{Hyperbolic,Any,Any}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(M::Hyperbolic, p, q)\n\nCompute the distance on the Hyperbolic M, which reads\n\nd_ℍ^n(pq) = operatornameacosh( - p q_mathrmM)\n\nwhere cdotcdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.injectivity_radius-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Hyperbolic)\ninjectivity_radius(M::Hyperbolic, p)\n\nReturn the injectivity radius on the Hyperbolic, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.manifold_dimension-Union{Tuple{Hyperbolic{N}}, Tuple{N}} where N","page":"Hyperbolic space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(H::Hyperbolic)\n\nReturn the dimension of the hyperbolic space manifold ℍ^n, i.e. dim(ℍ^n) = n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.project-Tuple{Hyperbolic,Any,Any}","page":"Hyperbolic space","title":"ManifoldsBase.project","text":"project(M::Hyperbolic, p, X)\n\nPerform an orthogonal projection with respect to the Minkowski inner product of X onto the tangent space at p of the Hyperbolic space M.\n\nThe formula reads\n\nY = X + pX_mathrmM p\n\nwhere cdot cdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.vector_transport_to-Tuple{Hyperbolic,Any,Any,Any,ParallelTransport}","page":"Hyperbolic space","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Hyperbolic, p, X, q, ::ParallelTransport)\n\nCompute the paralllel transport of the X from the tangent space at p on the Hyperbolic space ℍ^n to the tangent at q along the geodesic connecting p and q. The formula reads\n\nmathcal P_qpX = X - fraclog_p qX_pd^2_ℍ^n(pq)\nbigl(log_p q + log_qp bigr)\n\nwhere cdotcdot_p denotes the inner product in the tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Statistics.mean-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"Statistics.mean","text":"mean(\n    M::Hyperbolic,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = CyclicProximalPointEstimation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x on the Hyperbolic space using CyclicProximalPointEstimation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Vector-bundles","page":"Vector bundle","title":"Vector bundles","text":"","category":"section"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Vector bundle E is a manifold that is built on top of another manifold mathcal M (base space). It is characterized by a continuous function Π  E  mathcal M, such that for each point p  mathcal M the preimage of p by Π, Π^-1(p), has a structure of a vector space. These vector spaces are called fibers. Bundle projection can be performed using function bundle_projection.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Tangent bundle is a simple example of a vector bundle, where each fiber is the tangent space at the specified point x. An object representing a tangent bundle can be obtained using the constructor called TangentBundle.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Fibers of a vector bundle are represented by the type VectorBundleFibers. The important difference between functions operating on VectorBundle and VectorBundleFibers is that in the first case both a point on the underlying manifold and the vector are represented together (by a single argument) while in the second case only the vector part is present, while the point is supplied in a different argument where needed.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"VectorBundleFibers refers to the whole set of fibers of a vector bundle. There is also another type, VectorSpaceAtPoint, that represents a specific fiber at a given point. This distinction is made to reduce the need to repeatedly construct objects of type VectorSpaceAtPoint in certain usage scenarios.","category":"page"},{"location":"manifolds/vector_bundle.html#FVector","page":"Vector bundle","title":"FVector","text":"","category":"section"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"For cases where confusion between different types of vectors is possible, the type FVector can be used to express which type of vector space the vector belongs to. It is used for example in musical isomorphisms (the flat and sharp functions) that are used to go from a tangent space to cotangent space and vice versa.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/VectorBundle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/vector_bundle.html#Manifolds.CotangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.CotangentSpaceAtPoint","text":"CotangentSpaceAtPoint(M::Manifold, p)\n\nReturn an object of type VectorSpaceAtPoint representing cotangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.FVector","page":"Vector bundle","title":"Manifolds.FVector","text":"FVector(type::VectorSpaceType, data)\n\nDecorator indicating that the vector data is from a fiber of a vector bundle of type type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.TangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.TangentSpaceAtPoint","text":"TangentSpaceAtPoint(M::Manifold, p)\n\nReturn an object of type VectorSpaceAtPoint representing tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TensorProductType","page":"Vector bundle","title":"Manifolds.TensorProductType","text":"TensorProductType(spaces::VectorSpaceType...)\n\nVector space type corresponding to the tensor product of given vector space types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundle","page":"Vector bundle","title":"Manifolds.VectorBundle","text":"VectorBundle{𝔽,TVS<:VectorSpaceType,TM<:Manifold{𝔽}} <: Manifold{𝔽}\n\nVector bundle on a Manifold M of type VectorSpaceType.\n\nConstructor\n\nVectorBundle(M::Manifold, type::VectorSpaceType)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundleFibers","page":"Vector bundle","title":"Manifolds.VectorBundleFibers","text":"VectorBundleFibers(fiber::VectorSpaceType, M::Manifold)\n\nType representing a family of vector spaces (fibers) of a vector bundle over M with vector spaces of type fiber. In contrast with VectorBundle, operations on VectorBundleFibers expect point-like and vector-like parts to be passed separately instead of being bundled together. It can be thought of as a representation of vector spaces from a vector bundle but without storing the point at which a vector space is attached (which is specified separately in various functions).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundleVectorTransport","page":"Vector bundle","title":"Manifolds.VectorBundleVectorTransport","text":"VectorBundleVectorTransport(\n    method_point::AbstractVectorTransportMethod,\n    method_vector::AbstractVectorTransportMethod,\n)\n\nVector transport type on VectorBundle. method_point is used for vector transport of the point part and method_vector is used for transport of the vector part\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceAtPoint","page":"Vector bundle","title":"Manifolds.VectorSpaceAtPoint","text":"VectorSpaceAtPoint(fiber::VectorBundleFibers, p)\n\nA vector space (fiber type fiber of a vector bundle) at point p from the manifold fiber.manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceType","page":"Vector bundle","title":"Manifolds.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space fiber is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector!(fiber, X, p) to construct zero vectors at point p,\nallocate(X) and allocate(X, T) for vector X and type T,\ncopyto!(X, Y) for vectors X and Y,\nnumber_eltype(v) for vector v,\nvector_space_dimension(::VectorBundleFibers{<:typeof(fiber)}) where fiber.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat and sharp,\nnorm (by default uses inner),\nproject (for embedded vector spaces),\nrepresentation_size (if support for ProductArray is desired),\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Base.exp-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"Base.exp","text":"exp(B::VectorBundle, p, X)\n\nExponential map of tangent vector X at point p from vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe tangent vector X = (V_XM V_XF)  T_pB where V_XM is a tangent vector from the tangent space T_x_pmathcal M and V_XF is a tangent vector from the tangent space T_V_pF (isomorphic to F).\n\nThe exponential map is calculated as\n\nexp_p(X) = (exp_x_p(V_XM) V_exp)\n\nwhere V_exp is the result of vector transport of V_p + V_XF to the point exp_x_p(V_XM). The sum V_p + V_XF corresponds to the exponential map in the vector space F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.log-Tuple{VectorBundle,Vararg{Any,N} where N}","page":"Vector bundle","title":"Base.log","text":"log(B::VectorBundle, p, q)\n\nLogarithmic map of the point y at point p from vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B. Similarly, q = (x_q V_q).\n\nThe logarithmic map is calculated as\n\nlog_p q = (log_x_p(x_q) V_log - V_p)\n\nwhere V_log is the result of vector transport of V_q to the point x_p. The difference V_log - V_p corresponds to the logarithmic map in the vector space F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#LinearAlgebra.norm-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"LinearAlgebra.norm","text":"norm(B::VectorBundleFibers, p, q)\n\nNorm of the vector X from the vector space of type B.fiber at point p from manifold B.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.bundle_projection-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"Manifolds.bundle_projection","text":"bundle_projection(B::VectorBundle, x::ProductRepr)\n\nProjection of point p from the bundle M to the base manifold. Returns the point on the base manifold B.manifold at which the vector part of p is attached.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.flat-Tuple{Manifold,Any,FVector}","page":"Vector bundle","title":"Manifolds.flat","text":"flat(M::Manifold, p, X::FVector)\n\nCompute the flat isomorphism (one of the musical isomorphisms) of tangent vector X from the vector space of type M at point p from the underlying Manifold.\n\nThe function can be used for example to transform vectors from the tangent bundle to vectors from the cotangent bundle   Tmathcal M  T^*mathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.sharp-Tuple{Manifold,Any,FVector}","page":"Vector bundle","title":"Manifolds.sharp","text":"sharp(M::Manifold, p, ξ::FVector)\n\nCompute the sharp isomorphism (one of the musical isomorphisms) of vector ξ from the vector space M at point p from the underlying Manifold.\n\nThe function can be used for example to transform vectors from the cotangent bundle to vectors from the tangent bundle   T^*mathcal M  Tmathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.vector_bundle_transport-Tuple{VectorSpaceType,Manifold}","page":"Vector bundle","title":"Manifolds.vector_bundle_transport","text":"vector_bundle_transport(fiber::VectorSpaceType, M::Manifold)\n\nDetermine the vector tranport used for exp and log maps on a vector bundle with vector space type fiber and manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.vector_space_dimension-Tuple{VectorBundleFibers}","page":"Vector bundle","title":"Manifolds.vector_space_dimension","text":"vector_space_dimension(B::VectorBundleFibers)\n\nDimension of the vector space of type B.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector!-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"Manifolds.zero_vector!","text":"zero_vector!(B::VectorBundleFibers, X, p)\n\nSave the zero vector from the vector space of type B.fiber at point p from manifold B.manifold to X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector-Tuple{VectorBundleFibers,Any}","page":"Vector bundle","title":"Manifolds.zero_vector","text":"zero_vector(B::VectorBundleFibers, p)\n\nCompute the zero vector from the vector space of type B.fiber at point p from manifold B.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.allocate_result-Tuple{VectorBundleFibers,Any,Vararg{Any,N} where N}","page":"Vector bundle","title":"ManifoldsBase.allocate_result","text":"allocate_result(B::VectorBundleFibers, f, x...)\n\nAllocates an array for the result of function f that is an element of the vector space of type B.fiber on manifold B.manifold and arguments x... for implementing the non-modifying operation using the modifying operation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{VectorBundleFibers,Any,Tuple{Vararg{Any,N}}}} where N","page":"Vector bundle","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(B::VectorBundleFibers, f, args::NTuple{N,Any}) where N\n\nReturns type of element of the array that will represent the result of function f for representing an operation with result in the vector space fiber for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundle,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundle, p, q)\n\nDistance between points x and y from the vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p   mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B. Similarly, q = (x_q V_q).\n\nThe distance is calculated as\n\nd_B(x y) = sqrtd_M(x_p x_q)^2 + d_F(V_p V_qp)^2\n\nwhere d_mathcal M is the distance on manifold mathcal M, d_F is the distance between two vectors from the fiber F and V_qp is the result of parallel transport of vector V_q to point x_p. The default behavior of vector_transport_to is used to compute the vector transport.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundleFibers, p, X, Y)\n\nDistance between vectors X and Y from the vector space at point p from the manifold B.manifold, that is the base manifold of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundle,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundle, p, X, Y)\n\nInner product of tangent vectors X and Y at point p from the vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe tangent vector v = (V_XM V_XF)  T_xB where V_XM is a tangent vector from the tangent space T_x_pmathcal M and V_XF is a tangent vector from the tangent space T_V_pF (isomorphic to F). Similarly for the other tangent vector w = (V_YM V_YF)  T_xB.\n\nThe inner product is calculated as\n\nX Y_p = V_XM V_YM_x_p + V_XF V_YF_V_p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundleFibers, p, X, Y)\n\nInner product of vectors X and Y from the vector space of type B.fiber at point p from manifold B.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{VectorBundle,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundle, p, X)\n\nProject the element X of the ambient space of the tangent space T_p B to the tangent space T_p B.\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe vector x = (V_XM V_XF) where x_p belongs to the ambient space of T_x_pmathcal M and V_XF belongs to the ambient space of the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting V_XM to tangent space T_x_pmathcal M and then projecting the vector V_XF to the fiber F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundle, p)\n\nProject the point p from the ambient space of the vector bundle B over manifold B.fiber (denoted mathcal M) to the vector bundle.\n\nNotation:\n\nThe point p = (x_p V_p) where x_p belongs to the ambient space of mathcal M and V_p belongs to the ambient space of the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting the point x_p to the manifold mathcal M and then projecting the vector V_p to the tangent space T_x_pmathcal M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundleFibers, p, X)\n\nProject vector X from the vector space of type B.fiber at point p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.vector_transport_to-Tuple{VectorBundle,Any,Any,Any,Manifolds.VectorBundleVectorTransport}","page":"Vector bundle","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::VectorBundle, p, X, q, m::VectorBundleVectorTransport)\n\nCompute the vector transport the tangent vector Xat p to q on the VectorBundle M using the VectorBundleVectorTransport m.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.zero_tangent_vector-Tuple{VectorBundle,Vararg{Any,N} where N}","page":"Vector bundle","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(B::VectorBundle, p)\n\nZero tangent vector at point p from the vector bundle B over manifold B.fiber (denoted mathcal M). The zero vector belongs to the space T_pB\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe zero vector is calculated as\n\nmathbf0_p = (mathbf0_x_p mathbf0_F)\n\nwhere mathbf0_x_p is the zero tangent vector from T_x_pmathcal M and mathbf0_F is the zero element of the vector space F.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.jl-–-an-interface-for-manifolds","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl – an interface for manifolds","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The interface for a manifold is provided in the lightweight package ManifoldsBase.jl. You can easily implement your algorithms and even your own manifolds just using the interface. All manifolds from the package here are also based on this interface, so any project based on the interface can benefit from all manifolds, as soon as a certain manifold provides implementations of the functions a project requires.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Pages = [\"interface.md\"]\nDepth = 2","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Additionally the AbstractDecoratorManifold is provided as well as the ValidationManifold as a specific example of such a decorator.","category":"page"},{"location":"interface.html#Types-and-functions","page":"ManifoldsBase.jl","title":"Types and functions","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The following functions are currently available from the interface. If a manifold that you implement for your own package fits this interface, we happily look forward to a Pull Request to add it here.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.AbstractEstimationMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractEstimationMethod","text":"AbstractEstimationMethod\n\nAbstract type for defining statistical estimation methods.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractInverseRetractionMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractInverseRetractionMethod","text":"AbstractInverseRetractionMethod\n\nAbstract type for methods for inverting a retraction (see inverse_retract).\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractRetractionMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractRetractionMethod","text":"AbstractRetractionMethod\n\nAbstract type for methods for retracting a tangent vector to a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.CoTVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.CoTVector","text":"CoTVector\n\nType for a cotangent vector of a manifold. While a Manifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ExponentialRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.ExponentialRetraction","text":"ExponentialRetraction\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.LogarithmicInverseRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.MPoint","page":"ManifoldsBase.jl","title":"ManifoldsBase.MPoint","text":"MPoint\n\nType for a point on a manifold. While a Manifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of points on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.Manifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.Manifold","text":"Manifold{F}\n\nA manifold type. The Manifold is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the exponential and logarithmic maps as well as more general functions that are built on them like the geodesic.\n\nThe manifold is parametrized by an AbstractNumbers to distinguish for example real (ℝ) and complex (ℂ) manifolds.\n\nFor subtypes the preferred order of parameters is: size and simple value parameters, followed by the AbstractNumbers field, followed by data type parameters, which might depend on the abstract number field type.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.OutOfInjectivityRadiusError","page":"ManifoldsBase.jl","title":"ManifoldsBase.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse_retract) is given arguments outside of its injectivity_radius.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.PolarInverseRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.PolarInverseRetraction","text":"PolarInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.PolarRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.PolarRetraction","text":"PolarRetraction <: AbstractRetractionMethod\n\nRetractions that are based on singular value decompositions of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ProjectionInverseRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.ProjectionInverseRetraction","text":"ProjectionInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a projection (or its inversion).\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ProjectionRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.ProjectionRetraction","text":"ProjectionRetraction <: AbstractRetractionMethod\n\nRetractions that are based on projection and usually addition in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.QRInverseRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.QRInverseRetraction","text":"QRInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.QRRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.QRRetraction","text":"QRRetraction <: AbstractRetractionMethod\n\nRetractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.TVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.TVector","text":"TVector\n\nType for a tangent vector of a manifold. While a Manifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#Base.angle-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"Base.angle","text":"angle(M::Manifold, p, X, Y)\n\nCompute the angle between tangent vectors X and Y at point p from the Manifold M with respect to the inner product from inner.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.exp-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.exp","text":"exp(M::Manifold, p, X)\nexp(M::Manifold, p, X, t::Real = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from manifold the Manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"Base.isapprox","text":"isapprox(M::Manifold, p, X, Y; kwargs...)\n\nCheck if vectors X and Y tangent at p from Manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.isapprox-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.isapprox","text":"isapprox(M::Manifold, p, q; kwargs...)\n\nCheck if points p and q from Manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.log-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.log","text":"log(M::Manifold, p, q)\n\nCompute the logarithmic map of point q at base point p on the Manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#LinearAlgebra.norm-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"LinearAlgebra.norm","text":"norm(M::Manifold, p, X)\n\nCompute the norm of tangent vector X at point p from a Manifold M. By default this is computed using inner.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase.allocate","text":"allocate(a)\nallocate(a, dims::Integer...)\nallocate(a, dims::Tuple)\nallocate(a, T::Type)\nallocate(a, T::Type, dims::Integer...)\nallocate(a, T::Type, dims::Tuple)\n\nAllocate an object similar to a. It is similar to function similar, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls similar on the innermost array-like object only. Type T is the new number element type number_eltype, if it is not given the element type of a is retained. The dims argument can be given for non-nested allocation and is forwarded to the function similar.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase.allocate_result","text":"allocate_result(M::Manifold, f, x...)\n\nAllocate an array for the result of function f on Manifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N","page":"ManifoldsBase.jl","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(M::Manifold, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f and the Manifold M on given arguments args (passed as a tuple).\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.base_manifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::Manifold, depth = Val(-1))\n\nReturn the internally stored Manifold for decorated manifold M and the base manifold for vector bundles or power manifolds. The optional parameter depth can be used to remove only the first depth many decorators and return the Manifold from that level, whether its decorated or not. Any negative value deactivates this depth limit.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Manifold, p; kwargs...) -> Union{Nothing,String}\n\nReturn nothing when p is a point on the Manifold M. Otherwise, return an error with description why the point does not belong to manifold M.\n\nBy default, check_manifold_point returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the MPoint type.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Manifold, p, X; kwargs...) -> Union{Nothing,String}\n\nCheck whether X is a valid tangent vector in the tangent space of p on the Manifold M. An implementation should first call check_manifold_point(M, p; kwargs...) and then validate X. If it is not a tangent vector, an error string should be returned.\n\nBy default, check_tangent_vector returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the TVector type.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.distance","text":"distance(M::Manifold, p, q)\n\nShortest distance between the points p and q on the Manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.embed!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.embed!","text":"embed!(M::Manifold, Y, p, X)\n\nEmbed a tangent vector X at a point p on the Manifold M into the ambient space and return the result in Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.embed!-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.embed!","text":"embed!(M::Manifold, q, p)\n\nEmbed point p from the Manifold M into the ambient space and return the result in q. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed includes changing data representation, if applicable, i.e. if the points on M are not represented in the same way as points on the embedding, the representation is changed accordingly.\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.embed-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.embed","text":"embed(M::Manifold, p, X)\n\nEmbed a tangent vector X at a point p on the Manifold M into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.embed-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.embed","text":"embed(M::Manifold, p)\n\nEmbed point p from the Manifold M into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed includes changing data representation, if applicable, i.e. if the points on M are not represented in the same way as points on the embedding, the representation is changed accordingly.\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.exp!","text":"exp!(M::Manifold, q, p, X)\nexp!(M::Manifold, q, p, X, t::Real = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from manifold the Manifold M. The result is saved to q.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.geodesic","text":"geodesic(M::Manifold, p, X) -> Function\n\nGet the geodesic with initial point p and velocity X on the Manifold M.  The geodesic is the curve of constant velocity that is locally distance-minimizing.  This function returns a function of (time) t.\n\ngeodesic(M::Manifold, x, v, t::Real)\ngeodesic(M::Manifold, x, v, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Manifold, p)\n\nReturn the distance d such that exp(M, p, X) is injective for all tangent vectors shorter than d (i.e. has an inverse).\n\ninjectivity_radius(M::Manifold)\n\nInfimum of the injectivity radius of all manifold points.\n\ninjectivity_radius(M::Manifold[, x], method::AbstractRetractionMethod)\ninjectivity_radius(M::Manifold, x, method::AbstractRetractionMethod)\n\nDistance d such that retract(M, p, X, method) is injective for all tangent vectors shorter than d (i.e. has an inverse) for point p if provided or all manifold points otherwise.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inner","text":"inner(M::Manifold, p, X, Y)\n\nCompute the inner product of tangent vectors X and Y at point p from the Manifold M.\n\nSee also: MetricManifold\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::Manifold, X, p, q[, method::AbstractInverseRetractionMethod])\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the Manifold M. Result is saved to X.\n\nInverse retraction method can be specified by the last argument, defaulting to LogarithmicInverseRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Manifold, x, y)\ninverse_retract(M::Manifold, x, y, method::AbstractInverseRetractionMethod\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the Manifold M.\n\nInverse retraction method can be specified by the last argument, defaulting to LogarithmicInverseRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.is_manifold_point","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_manifold_point","text":"is_manifold_point(M::Manifold, p, throw_error = false; kwargs...)\n\nReturn whether p is a valid point on the Manifold M.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_manifold_point(M, p; kwargs...) and checks whether the returned value is nothing or an error.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.is_tangent_vector","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_tangent_vector","text":"is_tangent_vector(M::Manifold, p, X, throw_error = false; kwargs...)\n\nReturn whether X is a valid tangent vector at point p on the Manifold M. Returns either true or false.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_tangent_vector(M, p, X; kwargs...) and checks whether the returned value is nothing or an error.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.log!","text":"log!(M::Manifold, X, p, q)\n\nCompute the logarithmic map of point q at base point p on the Manifold M. The result is saved to X.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Manifold)\n\nThe dimension n=dim_mathcal M of real space mathbb R^n to which the neighborhood of each point of the Manifold M is homeomorphic.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.mid_point!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.mid_point!","text":"mid_point!(M::Manifold, q, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp!. Saves the result in q.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.mid_point-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.mid_point","text":"mid_point(M::Manifold, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.number_eltype-Tuple{Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.number_eltype","text":"number_eltype(x)\n\nNumeric element type of the a nested representation of a point or a vector. To be used in conjuntion with allocate or allocate_result.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project!","text":"project!(M::Manifold, Y, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the Manifold M. The result is saved in vector Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project!-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project!","text":"project!(M::Manifold, q, p)\n\nProject point p from the ambient space onto the Manifold M. The result is storedin q. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project","text":"project(M::Manifold, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the Manifold M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project","text":"project(M::Manifold, p)\n\nProject point p from the ambient space of the Manifold M to M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.representation_size-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.representation_size","text":"representation_size(M::Manifold)\n\nThe size of an array representing a point on Manifold M. Returns nothing by default indicating that points are not represented using an AbstractArray.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.retract!","text":"retract!(M::Manifold, q, p, X)\nretract!(M::Manifold, q, p, X, t::Real=1)\nretract!(M::Manifold, q, p, X, method::AbstractRetractionMethod)\nretract!(M::Manifold, q, p, X, t::Real=1, method::AbstractRetractionMethod)\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the Manifold manifold M. Result is saved to q.\n\nRetraction method can be specified by the last argument, defaulting to ExponentialRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.retract","text":"retract(M::Manifold, p, X)\nretract(M::Manifold, p, X, t::Real=1)\nretract(M::Manifold, p, X, method::AbstractRetractionMethod)\nretract(M::Manifold, p, X, t::Real=1, method::AbstractRetractionMethod)\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the Manifold M.\n\nRetraction method can be specified by the last argument, defaulting to ExponentialRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::Manifold, p, q) -> Function\n\nGet a geodesic gamma_pq(t) whose length is the shortest path between the points pand q, where gamma_pq(0)=p and gamma_pq(1)=q. When there are multiple shortest geodesics, there is no guarantee which will be returned.\n\nThis function returns a function of time, which may be a Real or an AbstractVector.\n\nshortest_geodesic(M::Manifold, p, q, t::Real)\nshortest_geodesic(M::Manifold, p, q, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the shortest geodesic.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.zero_tangent_vector!","text":"zero_tangent_vector!(M::Manifold, X, p)\n\nSave to X a vector such that retracting X to the Manifold M at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Manifold, p)\n\nReturn the tangent vector from the tangent space at p on the Manifold M, that represents the zero vector, i.e. such that a retraction at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Number-systems","page":"ManifoldsBase.jl","title":"Number systems","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"numbers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.AbstractNumbers","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractNumbers","text":"AbstractNumbers\n\nAn abstract type to represent the number system on which a manifold is built.\n\nThis provides concrete number types for dispatch. The two most common number types are the fields RealNumbers (ℝ for short) and ComplexNumbers (ℂ).\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ComplexNumbers","page":"ManifoldsBase.jl","title":"ManifoldsBase.ComplexNumbers","text":"ComplexNumbers <: AbstractNumbers\nℂ = ComplexNumbers()\n\nThe field of complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.QuaternionNumbers","page":"ManifoldsBase.jl","title":"ManifoldsBase.QuaternionNumbers","text":"QuaternionNumbers <: AbstractNumbers\nℍ = QuaternionNumbers()\n\nThe division algebra of quaternions.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.RealNumbers","page":"ManifoldsBase.jl","title":"ManifoldsBase.RealNumbers","text":"RealNumbers <: AbstractNumbers\nℝ = RealNumbers()\n\nThe field of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase._unify_number_systems-Tuple{AbstractNumbers,Vararg{AbstractNumbers,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase._unify_number_systems","text":"_unify_number_systems(𝔽s::AbstractNumbers...)\n\nCompute a number system that includes all given number systems (as sub-systems) and is closed under addition and multiplication.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.number_system-Union{Tuple{Manifold{𝔽}}, Tuple{𝔽}} where 𝔽","page":"ManifoldsBase.jl","title":"ManifoldsBase.number_system","text":"number_system(M::Manifold{𝔽})\n\nReturn the number system the manifold M is based on, i.e. the parameter 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.real_dimension-Tuple{AbstractNumbers}","page":"ManifoldsBase.jl","title":"ManifoldsBase.real_dimension","text":"real_dimension(𝔽::AbstractNumbers)\n\nReturn the real dimension dim_ℝ 𝔽 of the AbstractNumbers system 𝔽. The real dimension is the dimension of a real vector space with which a number in 𝔽 can be identified. For example, ComplexNumbers have a real dimension of 2, and QuaternionNumbers have a real dimension of 4.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Allocation","page":"ManifoldsBase.jl","title":"Allocation","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Non-mutating functions in ManifoldsBase.jl are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"allocate that allocates a new point or vector similar to the given one. This function behaves like similar for simple representations of points and vectors (for example Array{Float64}). For more complex types, such as nested representations of PowerManifold (see NestedPowerRepresentation), FVector types, checked types like ValidationMPoint and more it operates differently. While similar only concerns itself with the higher level of nested structures, allocate maps itself through all levels of nesting until a simple array of numbers is reached and then calls similar. The difference can be most easily seen in the following example:","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"julia> x = similar([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n #undef\n #undef\n\njulia> y = Manifolds.allocate([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n [6.90031725726027e-310]\n [6.9003678131654e-310]\n\njulia> x[1]\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744\n [2] top-level scope at REPL[12]:1\n\njulia> y[1]\n1-element Array{Float64,1}:\n 6.90031725726027e-310","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"allocate_result allocates a result of a particular function (for example [exp], [flat], etc.) on a particular manifold with particular arguments. It takes into account the possibility that different arguments may have different numeric number_eltype types thorough the ManifoldsBase.allocate_result_type function.","category":"page"},{"location":"interface.html#Bases","page":"ManifoldsBase.jl","title":"Bases","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The following functions and types provide support for bases of the tangent space of different manifolds. An orthonormal basis of the tangent space T_p mathcal M of (real) dimension n has a real-coefficient basis e_1 e_2  e_n if mathrmRe(g_p(e_i e_j)) = δ_ij for each ij  1 2  n where g_p is the Riemannian metric at point p. A vector X from the tangent space T_p mathcal M can be expressed in Einstein notation as a sum X = X^i e_i, where (real) coefficients X^i are calculated as X^i = mathrmRe(g_p(X e_i)).","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The main types are:","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"DefaultOrthonormalBasis, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make get_coordinates and get_vector fast.\nDiagonalizingOrthonormalBasis, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.\nProjectedOrthonormalBasis, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.\nCachedBasis, which stores (explicitly or implicitly) a precomputed basis at a certain point.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The main functions are:","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"get_basis precomputes a basis at a certain point.\nget_coordinates returns coordinates of a tangent vector.\nget_vector returns a vector for the specified coordinates.\nget_vectors returns a vector of basis vectors. Calling it should be avoided for high-dimensional manifolds.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [ManifoldsBase,Manifolds]\nPages = [\"bases.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.AbstractBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractBasis","text":"AbstractBasis{𝔽}\n\nAbstract type that represents a basis on a manifold or a subset of it.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractOrthogonalBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractOrthogonalBasis","text":"AbstractOrthogonalBasis{𝔽}\n\nAbstract type that represents an orthonormal basis on a manifold or a subset of it.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractOrthonormalBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractOrthonormalBasis","text":"AbstractOrthonormalBasis{𝔽}\n\nAbstract type that represents an orthonormal basis on a manifold or a subset of it.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.CachedBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.CachedBasis","text":"CachedBasis{𝔽,V,<:AbstractBasis{𝔽}} <: AbstractBasis{𝔽}\n\nA cached version of the given basis with precomputed basis vectors. The basis vectors are stored in data, either explicitly (like in cached variants of ProjectedOrthonormalBasis) or implicitly.\n\nConstructor\n\nCachedBasis(basis::AbstractBasis, data)\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.DefaultBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.DefaultBasis","text":"DefaultBasis{𝔽}\n\nAn arbitrary basis on a manifold. This will usually be the fastest basis available for a manifold.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.DefaultOrthogonalBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.DefaultOrthogonalBasis","text":"DefaultOrthogonalBasis{𝔽}\n\nAn arbitrary orthogonal basis on a manifold. This will usually be the fastest orthogonal basis available for a manifold.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.DefaultOrthonormalBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.DefaultOrthonormalBasis","text":"DefaultOrthonormalBasis(𝔽::AbstractNumbers = ℝ)\n\nAn arbitrary orthonormal basis on a manifold. This will usually be the fastest orthonormal basis available for a manifold.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.DiagonalizingOrthonormalBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.DiagonalizingOrthonormalBasis","text":"DiagonalizingOrthonormalBasis{𝔽,TV} <: AbstractOrthonormalBasis{𝔽}\n\nAn orthonormal basis Ξ as a vector of tangent vectors (of length determined by manifold_dimension) in the tangent space that diagonalizes the curvature tensor R(uv)w and where the direction frame_direction v has curvature 0.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nConstructor\n\nDiagonalizingOrthonormalBasis(frame_direction, 𝔽::AbstractNumbers = ℝ)\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ProjectedOrthonormalBasis","page":"ManifoldsBase.jl","title":"ManifoldsBase.ProjectedOrthonormalBasis","text":"ProjectedOrthonormalBasis(method::Symbol, 𝔽::AbstractNumbers = ℝ)\n\nAn orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nAvailable methods:\n\n:gram_schmidt uses a modified Gram-Schmidt orthonormalization.\n:svd uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.allocation_promotion_function-Tuple{Manifold,Any,Tuple}","page":"ManifoldsBase.jl","title":"ManifoldsBase.allocation_promotion_function","text":"allocation_promotion_function(M::Manifold, f, args::Tuple)\n\nDetermine the function that must be used to ensure that the allocated representation is of the right type. This is needed for get_vector when a point on a complex manifold is represented by a real-valued vectors with a real-coefficient basis, so that a complex-valued vector representation is allocated.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.get_basis-Tuple{Manifold,Any,AbstractBasis}","page":"ManifoldsBase.jl","title":"ManifoldsBase.get_basis","text":"get_basis(M::Manifold, p, B::AbstractBasis) -> CachedBasis\n\nCompute the basis vectors of the tangent space at a point on manifold M represented by p.\n\nReturned object derives from AbstractBasis and may have a field .vectors that stores tangent vectors or it may store them implicitly, in which case the function get_vectors needs to be used to retrieve the basis vectors.\n\nSee also: get_coordinates, get_vector\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}","page":"ManifoldsBase.jl","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Manifold, p, X, B::AbstractBasis)\nget_coordinates(M::Manifold, p, X, B::CachedBasis)\n\nCompute a one-dimensional vector of coefficients of the tangent vector X at point denoted by p on manifold M in basis B.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve. If a CachedBasis is provided, their stored vectors are used, otherwise the user has to provide a method to compute the coordinates.\n\nFor the CachedBasis keep in mind that the reconstruction with get_vector requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_vector, get_basis\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}","page":"ManifoldsBase.jl","title":"ManifoldsBase.get_vector","text":"get_vector(M::Manifold, p, X, B::AbstractBasis)\n\nConvert a one-dimensional vector of coefficients in a basis B of the tangent space at p on manifold M to a tangent vector X at p.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve.\n\nFor the CachedBasis keep in mind that the reconstruction from get_coordinates requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_coordinates, get_basis\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.get_vectors-Tuple{Manifold,Any,AbstractBasis}","page":"ManifoldsBase.jl","title":"ManifoldsBase.get_vectors","text":"get_vectors(M::Manifold, p, B::AbstractBasis)\n\nGet the basis vectors of basis B of the tangent space at point p.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.hat-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.hat","text":"hat(M::Manifold, p, Xⁱ)\n\nGiven a basis e_i on the tangent space at a point p and tangent component vector X^i, compute the equivalent vector representation X=X^i e_i, where Einstein summation notation is used:\n\n  X^i  X^i e_i\n\nFor array manifolds, this converts a vector representation of the tangent vector to an array representation. The vee map is the hat map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.number_of_coordinates-Union{Tuple{𝔾}, Tuple{𝔽}, Tuple{Manifold{𝔽},AbstractBasis{𝔾}}} where 𝔾 where 𝔽","page":"ManifoldsBase.jl","title":"ManifoldsBase.number_of_coordinates","text":"number_of_coordinates(M::Manifold, B::AbstractBasis)\n\nCompute the number of coordinates in basis B of manifold M. This also corresponds to the number of vectors represented by B, or stored within B in case of a CachedBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.number_system-Union{Tuple{AbstractBasis{𝔽}}, Tuple{𝔽}} where 𝔽","page":"ManifoldsBase.jl","title":"ManifoldsBase.number_system","text":"number_system(::AbstractBasis)\n\nThe number system for the vectors of the given basis.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vee-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vee","text":"vee(M::Manifold, p, X)\n\nGiven a basis e_i on the tangent space at a point p and tangent vector X, compute the vector components X^i, such that X = X^i e_i, where Einstein summation notation is used:\n\nvee  X^i e_i  X^i\n\nFor array manifolds, this converts an array representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Vector-transport","page":"ManifoldsBase.jl","title":"Vector transport","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"There are three main functions for vector transport:","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"vector_transport_along\nvector_transport_direction\nvector_transport_to","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Different types of vector transport are implemented using subtypes of AbstractVectorTransportMethod:","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"ParallelTransport\nPoleLadderTransport\nProjectionTransport\nSchildsLadderTransport","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [ManifoldsBase,Manifolds]\nPages = [\"vector_transport.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.AbstractVectorTransportMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractVectorTransportMethod","text":"AbstractVectorTransportMethod\n\nAbstract type for methods for transporting vectors.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ParallelTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.ParallelTransport","text":"ParallelTransport <: AbstractVectorTransportMethod\n\nSpecify to use parallel transport as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.PoleLadderTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.PoleLadderTransport","text":"PoleLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use pole_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet Xin T_pmathcal M be a tangent vector at pinmathcal M and qinmathcal M the point to transport to. Then x = exp_pX is used to call y =pole_ladder(M, p, x, q) and the resulting vector is obtained by computing Y = -log_qy.\n\nThe PoleLadderTransport posesses two advantages compared to SchildsLadderTransport:\n\nit is cheaper to evaluate, if you want to transport several vectors, since the mid point c then stays unchanged.\nwhile both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds[Pennec2018]\n\nThe pole ladder was was proposed in [LorenziPennec2014]. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.\n\nConstructor\n\nPoleLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical pole ladder that employs exp and log, i.e. as proposed in[LorenziPennec2014]. For an even cheaper transport the inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[LorenziPennec2014]: Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild’s to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5–17 doi 10.1007/s10851-013-0470-3, hal: hal-00870489\n\n[Pennec2018]: Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: 1805.11436\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ProjectionTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.ProjectionTransport","text":"ProjectionTransport <: AbstractVectorTransportMethod\n\nSpecify to use projection onto tangent space as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along. See project for details.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.SchildsLadderTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.SchildsLadderTransport","text":"SchildsLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use schilds_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet Xin T_pmathcal M be a tangent vector at pinmathcal M and qinmathcal M the point to transport to. Then\n\nP^mathrmS_qgets p(X) =\n    log_qbigl( operatornameretr_p ( 2operatornameretr_p^-1c ) bigr)\n\nwhere c is the mid point between q and d=exp_pX.\n\nThis method employs the internal function schilds_ladder(M, p, d, q) that avoids leaving the manifold.\n\nThe name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in [EhlersPiraniSchild1972].\n\nConstructor\n\nSchildsLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical Schilds ladder that employs exp and log, i.e. as proposed in[EhlersPiraniSchild1972]. For an even cheaper transport these inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[EhlersPiraniSchild1972]: Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O’Raifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63–84. Clarendon Press, Oxford (1972). reprint doi: 10.1007/s10714-012-1353-4\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.pole_ladder","page":"ManifoldsBase.jl","title":"ManifoldsBase.pole_ladder","text":"pole_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q);\n    retraction=ExponentialRetraction(),\n    inverse_retraction=LogarithmicInverseRetraction()\n)\n\nCompute an inner step of the pole ladder, that can be used as a vector_transport_to. Let c = gamma_pq(frac12) mid point between p and q, then the pole ladder is given by\n\n    operatornamePl(pdq) = operatornameretr_d (2operatornameretr_d^-1c)\n\nWhere the classical pole ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nWhen you have X=log_pd and Y = -log_q operatornamePl(pdq), you will obtain the PoleLadderTransport. When performing multiple steps, this method avoidsd the switching to the tangent space. Keep in mind that after n successive steps the tangent vector reads Y_n = (-1)^nlog_q operatornamePl(p_n-1d_n-1p_n).\n\nIt is cheaper to evaluate than schilds_ladder, sinc if you want to form multiple ladder steps between p and q, but with different d, there is just one evaluation of a geodesic each., since the center c can be reused.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.pole_ladder!","page":"ManifoldsBase.jl","title":"ManifoldsBase.pole_ladder!","text":"pole_ladder(\n    M,\n    pl,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q),\n    X = allocate_result_type(M, log, d, c);\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction()\n)\n\nCompute the pole_ladder, i.e. the result is saved in pl. X is used for storing intermediate inverse retraction.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.schilds_ladder","page":"ManifoldsBase.jl","title":"ManifoldsBase.schilds_ladder","text":"schilds_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d);\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nPerform an inner step of schilds ladder, which can be used as a vector_transport_to, see SchildsLadderTransport. Let c = gamma_qd(frac12) denote the mid point on the shortest geodesic connecting q and the point d. Then Schild's ladder reads as\n\noperatornameSl(pdq) = operatornameretr_x( 2operatornameretr_p^-1 c)\n\nWhere the classical Schilds ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nIn consistency with pole_ladder you can change the way the mid point is computed using the optional parameter c, but note that here it's the mid point between q and d.\n\nWhen you have X=log_pd and Y = log_q operatornameSl(pdq), you will obtain the PoleLadderTransport. Then the approximation to the transported vector is given by log_qoperatornameSl(pdq).\n\nWhen performing multiple steps, this method avoidsd the switching to the tangent space. Hence after n successive steps the tangent vector reads Y_n = log_q operatornamePl(p_n-1d_n-1p_n).\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.schilds_ladder!","page":"ManifoldsBase.jl","title":"ManifoldsBase.schilds_ladder!","text":"schilds_ladder!(\n    M,\n    sl\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d),\n    X = allocate_result_type(M, log, d, c);\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction()\n)\n\nCompute schilds_ladder and return the value in the parameter sl. If the required mid point c was computed before, it can be passed using c, and the allocation of new memory can be avoided providing a tangent vector X for the interims result.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,AbstractVectorTransportMethod}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(\n    M::Manifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::AbstractVectorTransportMethod\n) where {T}\n\nCompute the vector transport along a discretized curve c using an AbstractVectorTransportMethod method succesively along the sampled curve.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,PoleLadderTransport}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along!","text":"function vector_transport_along!(\n    M::Manifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::PoleLadderTransport\n)\n\nCompute the vector transport along a discretized curve using PoleLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,SchildsLadderTransport}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(\n    M::Manifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::SchildsLadderTransport\n)\n\nCompute the vector transport along a discretized curve using SchildsLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(M::Manifold, Y, p, X, c)\nvector_transport_along!(M::Manifold, Y, p, X, c, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the Manifold M along the curve represented by c using the method, which defaults to ParallelTransport. The result is saved to Y.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along","text":"vector_transport_along(M::Manifold, p, X, c)\nvector_transport_along(M::Manifold, p, X, c, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the Manifold M along the curve represented by c using the method, which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_direction!","text":"vector_transport_direction!(M::Manifold, Y, p, X, d)\nvector_transport_direction!(M::Manifold, Y, p, X, d, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the Manifold M in the direction indicated by the tangent vector d at p. By default, exp and vector_transport_to! are used with the method, which defaults to ParallelTransport. The result is saved to Y.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::Manifold, p, X, d)\nvector_transport_direction(M::Manifold, p, X, d, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the Manifold M in the direction indicated by the tangent vector d at p. By default, exp and vector_transport_to! are used with the method, which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,PoleLadderTransport}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, Y, p, X, q, method::PoleLadderTransport)\n\nPerform a vector transport by using PoleLadderTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, Y, p, X, q, method::ProjectionTransport)\n\nTransport a vector X from the tangent space at p on the Manifold M by interpreting it as an element of the embedding and then projecting it onto the tangent space at q. This function needs to be separately implemented for each manifold because projection project may also change vector representation (if it's different than in the embedding) and it is assumed that the vector X already has the correct representation for M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,SchildsLadderTransport}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, Y, p, X, q, method::SchildsLadderTransport)\n\nPerform a vector transport by using SchildsLadderTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, Y, p, X, q)\nvector_transport_to!(M::Manifold, Y, p, X, q, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the Manifold M along the shortest_geodesic to the tangent space at another point q. By default, the AbstractVectorTransportMethod method is ParallelTransport. The result is saved to Y.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Manifold, p, X, q)\nvector_transport_to(M::Manifold, p, X, q, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the Manifold M along the shortest_geodesic to the tangent space at another point q. By default, the AbstractVectorTransportMethod method is ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#A-Decorator-for-manifolds","page":"ManifoldsBase.jl","title":"A Decorator for manifolds","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"A decorator manifold extends the functionality of a Manifold in a semi-transparent way. It internally stores the Manifold it extends and by default for functions defined in the ManifoldsBase it acts transparently in the sense that it passes all functions through to the base except those that it actually affects. For example, because the ValidationManifold affects nearly all functions, it overwrites nearly all functions, except a few like manifold_dimension. On the other hand, the MetricManifold only affects functions that involve metrics, especially exp and log but not the manifold_dimension. Contrary to the previous decorator, the MetricManifold does not overwrite functions. The decorator sets functions like exp and log to be implemented anew but required to be implemented when specifying a new metric. An exception is not issued if a metric is additionally set to be the default metric (see is_default_metric, since this makes all functions act transparently. this last case assumes that the newly specified metric type is actually the one already implemented on a manifold initially.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"By default, i.e. for a plain new decorator, all functions are passed down. To implement a method for a decorator that behaves differently from the method of the same function for the internal manifold, two steps are required. Let's assume the function is called f(M, arg1, arg2), and our decorator manifold DM of type OurDecoratorManifold decorates M. Then","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"set decorator_transparent_dispatch(f, M::OurDecoratorManifold, args...) = Val(:intransparent)\nimplement f(DM::OurDecoratorManifold, arg1, arg2)","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"This makes it possible to extend a manifold or all manifolds with a feature or replace a feature of the original manifold. The MetricManifold is the best example of the second case, since the default metric indicates for which metric the manifold was originally implemented, such that those functions are just passed through. This can best be seen in the SymmetricPositiveDefinite manifold with its LinearAffineMetric.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"DecoratorManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.@decorator_transparent_fallback","text":"@decorator_transparent_fallback(ex)\n@decorator_transparent_fallback(fallback_case = :intransparent, ex)\n\nThis macro introduces an additional implementation for a certain additional case. This can especially be used if for an already transparent function and an abstract intermediate type a change in the default is required. For implementing a concrete type, neither this nor any other trick is necessary. One just implements the function as before. Note that a decorator that is_default_decorator still dispatches to the transparent case.\n\n:transparent states, that the function is transparently passed on to the manifold that is decorated by the AbstractDecoratorManifold M, which is determined using the function decorated_manifold.\n:intransparent states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.\n:parent states, that this function passes on to the supertype instead of to the decorated manifold.\n\nInline definitions are not supported. The function signature however may contain keyword arguments and a where clause. It does not allow for parameters with default values.\n\nExamples\n\n@decorator_transparent_fallback function log!(M::AbstractGroupManifold, X, p, q)\n    log!(decorated_manifold(M), X, p, Q)\nend\n@decorator_transparent_fallback :transparent function log!(M::AbstractGroupManifold, X, p, q)\n    log!(decorated_manifold(M), X, p, Q)\nend\n\n\n\n\n\n","category":"macro"},{"location":"interface.html#ManifoldsBase.@decorator_transparent_function-Tuple{Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.@decorator_transparent_function","text":"@decorator_transparent_function(ex)\n@decorator_transparent_function(fallback_case = :intransparent, ex)\n\nIntroduce the function specified by ex to act transparently with respect to AbstractDecoratorManifolds. This introduces the possibility to modify the kind of transparency the implementation is done for. This optional first argument, the Symbol within fallback_case. This macro can be used to define a function and introduce it as transparent to other decorators. Note that a decorator that is_default_decorator still dispatches to the transparent case.\n\nThe cases of transparency are\n\n:transparent states, that the function is transparently passed on to the manifold that is decorated by the AbstractDecoratorManifold M, which is determined using the function decorated_manifold.\n:intransparent states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.\n:parent states, that this function passes on to the supertype instead of to the decorated manifold. Passing is performed using the invoke function where the type of manifold is replaced by its supertype.\n\nInnkoline-definitions are not yet covered – the function signature however may contain keyword arguments and a where clause.\n\nExamples\n\n@decorator_transparent_function log!(M::AbstractDecoratorManifold, X, p, q)\n    log!(decorated_manifold(M), X, p, Q)\nend\n@decorator_transparent_function :parent log!(M::AbstractDecoratorManifold, X, p, q)\n    log!(decorated_manifold(M), X, p, Q)\nend\n\n\n\n\n\n","category":"macro"},{"location":"interface.html#ManifoldsBase.@decorator_transparent_signature-Tuple{Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.@decorator_transparent_signature","text":"@decorator_transparent_signature(ex)\n\nIntroduces a given function to be transparent with respect to all decorators. The function is adressed by its signature in ex.\n\nSupports standard, keyword arguments and where clauses. Doesn't support parameters with default values. It introduces a dispatch on several transparency modes\n\nThe cases of transparency are\n\n:transparent states, that the function is transparently passed on to the manifold that is decorated by the AbstractDecoratorManifold M, which is determined using the function decorated_manifold. This is the default.\n:intransparent states that an implementation for this decorator is required, and if none of the types provides one, an error is issued.\n:parent states, that this function passes on to the supertype instead of to the decorated manifold.\n\nInline definitions are not supported. The function signature however may contain keyword arguments and a where clause.\n\nThe dispatch kind can later still be set to something different, see decorator_transparent_dispatch\n\nExamples:\n\n@decorator_transparent_signature log!(M::AbstractDecoratorManifold, X, p, q)\n@decorator_transparent_signature log!(M::TD, X, p, q) where {TD<:AbstractDecoratorManifold}\n@decorator_transparent_signature isapprox(M::AbstractDecoratorManifold, p, q; kwargs...)\n\n\n\n\n\n","category":"macro"},{"location":"interface.html#ManifoldsBase.AbstractDecoratorManifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractDecoratorManifold","text":"AbstractDecoratorManifold{𝔽} <: Manifold{𝔽}\n\nAn AbstractDecoratorManifold indicates that to some extent a manifold subtype decorates another Manifold in the sense that it either\n\nit extends the functionality of a manifold with further features\nit defines a new manifold that internally uses functions from the decorated manifold\n\nwith the main intent that several or most functions of Manifold are transparently passed through to the manifold that is decorated. This way a function implemented for a decorator acts transparent on all other decorators, i.e. they just pass them through. If the decorator the function is implemented for is not among the decorators, an error is issued. By default all base manifold functions, for example exp and log are transparent for all decorators.\n\nTransparency of functions with respect to decorators can be specified using the macros @decorator_transparent_fallback, @decorator_transparent_function and @decorator_transparent_signature.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.decorated_manifold-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::AbstractDecoratorManifold)\n\nReturn the manifold decorated by the decorator M. Defaults to M.manifold.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any,Manifold,Vararg{Any,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase.decorator_transparent_dispatch","text":"decorator_transparent_dispatch(f, M::Manifold, args...) -> Val\n\nGiven a Manifold M and a function f(M,args...), indicate, whether a function is Val(:transparent) or Val(:intransparent) for the (decorated) Manifold M. Another possibility is, that for M and given args... the function f should invoke Ms Val(:parent) implementation, see @decorator_transparent_function for details.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.default_decorator_dispatch-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.default_decorator_dispatch","text":"default_decorator_dispatch(M) -> Val\n\nReturn whether by default to dispatch the the inner manifold of a decorator (Val(true)) or not (Val(false). For more details see is_decorator_transparent.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.is_decorator_transparent-Tuple{Any,Manifold,Vararg{Any,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_decorator_transparent","text":"is_decorator_transparent(f, M::Manifold, args...) -> Bool\n\nGiven a Manifold M and a function f(M, args...), indicate, whether an AbstractDecoratorManifold acts transparently for f. This means, it just passes through down to the internally stored manifold. Transparency is only defined for decorator manifolds and by default all decorators are transparent. A function that is affected by the decorator indicates this by returning false. To change this behaviour, see decorator_transparent_dispatch.\n\nIf a decorator manifold is not in general transparent, it might still pass down for the case that a decorator is the default decorator, see is_default_decorator.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.is_default_decorator-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_default_decorator","text":"is_default_decorator(M) -> Bool\n\nFor any manifold that is a subtype of AbstractDecoratorManifold, this function indicates whether a certain manifold M acts as a default decorator.\n\nThis yields that all functions are passed through to the decorated Manifold if M is indicated as default. This overwrites all is_decorator_transparent values.\n\nThis yields the following advantange: For a manifold one usually implicitly assumes for example a metric. To avoid reimplementation of this metric when introducing a second metric, the first metric can be set to be the default, i.e. its implementaion is already given by the undecorated case.\n\nValue returned by this function is determined by default_decorator_dispatch, which returns a Val-wrapped boolean for type stability of certain functions.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ValidationManifold","page":"ManifoldsBase.jl","title":"ValidationManifold","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"ValidationManifold is a simple decorator that “decorates” a manifold with tests that all involved arrays are correct. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling is_manifold_point or is_tangent_vector whenever applicable.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"ValidationManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.ValidationCoTVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.ValidationCoTVector","text":"ValidationCoTVector <: CoTVector\n\nRepresent a cotangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints and ValidationTVectors.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ValidationMPoint","page":"ManifoldsBase.jl","title":"ManifoldsBase.ValidationMPoint","text":"ValidationMPoint <: MPoint\n\nRepresent a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationTVectors and ValidationCoTVectors.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ValidationManifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.ValidationManifold","text":"ValidationManifold{𝔽,M<:Manifold{𝔽}} <: AbstractDecoratorManifold{𝔽}\n\nA manifold to encapsulate manifolds working on array representations of MPoints and TVectors in a transparent way, such that for these manifolds it's not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.\n\nThis manifold is a decorator for a manifold, i.e. it decorates a Manifold M with types points, vectors, and covectors.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ValidationTVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.ValidationTVector","text":"ValidationTVector <: TVector\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints and ValidationCoTVectors.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.array_value-Tuple{AbstractArray}","page":"ManifoldsBase.jl","title":"ManifoldsBase.array_value","text":"array_value(p)\n\nReturn the internal array value of an ValidationMPoint, ValidationTVector, or ValidationCoTVector if the value p is encapsulated as such. Return p if it is already an array.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#EmbeddedManifold","page":"ManifoldsBase.jl","title":"EmbeddedManifold","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Some manifolds can easily be defined by using a certain embedding. For example the Sphere(n) is embedded in Euclidean(n+1). Similar to the metric and MetricManifold, an embedding is often implicitly assumed. We introduce the embedded manifolds hence as an AbstractDecoratorManifold.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"This decorator enables to use such an embedding in an transparent way. Different types of embeddings can be distinguished using the AbstractEmbeddingType.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The embedding also covers representation of tangent vectors. For both points and tangent vectors the function embed returns their representation in the embedding. For any point or vector in the embedding the functions project can be used to obtain the closest point on the manifold and tangent vector in the tangent space. Note that both embed and project may also be implemented on a Manifold already, assuming that the default implementation of that manifold has an (implicitly assumed) embedding. If there exists more than one embedding or to foster using functions from the embedding, like inner, this decorator can be employed. The different embeddings might also refer to different representations or parametrisations of an embedding. A specific example where embed and project actually do change the representation are Lie groups. Here, tangent vectors are often represented in the Lie algebra, i.e. in the tangent space of the identity element. Then, projection first projects onto a tangent space but also takes care to return the correct representation, i.e. the element from the Lie algebra corresponding to the projected tangent vector. Similarly, before embedding a tangent vector that is represented by an element from the Lie algebra, the group opration is applied.","category":"page"},{"location":"interface.html#Isometric-Embeddings","page":"ManifoldsBase.jl","title":"Isometric Embeddings","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"For isometric embeddings the type AbstractIsometricEmbeddingType can be used to avoid reimplementing the metric. See Sphere or Hyperbolic for example. Here, the exponential map, the logarithmic map, the retraction and its inverse are set to :intransparent, i.e. they have to be implemented.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Furthermore, the TransparentIsometricEmbedding type even states that the exponential and logarithmic maps as well as retractions and vector transports of the embedding can be used for the embedded manifold as well. See SymmetricMatrices for an example.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"In both cases of course check_manifold_point and check_tangent_vector have to be implemented.","category":"page"},{"location":"interface.html#Technical-Details","page":"ManifoldsBase.jl","title":"Technical Details","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Semantically we use the idea of the embedding to efficiently implement a manifold by not having to implement those functions that are already given by its embedding. Hence we decorate in some sense the manifold we implement. Still, technically base_manifold returns the embedding as long as EmbeddedManifold is used. For the abstract case, AbstractEmbeddedManifold the base manfiold might differ. Note that internally base_manifold uses decorated_manifold for one step of removing multiple decorators.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Clearly get_embedding always returns the embedding.","category":"page"},{"location":"interface.html#Types","page":"ManifoldsBase.jl","title":"Types","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [ManifoldsBase, Manifolds]\nPages = [\"EmbeddedManifold.jl\"]\nOrder = [:type]","category":"page"},{"location":"interface.html#ManifoldsBase.AbstractEmbeddedManifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractEmbeddedManifold","text":"AbstractEmbeddedManifold{𝔽,T<:AbstractEmbeddingType,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nAn abstract type for embedded manifolds, which acts as an AbstractDecoratorManifold. The functions of the manifold that is embedded can hence be just passed on to the embedding. The embedding is further specified by an AbstractEmbeddingType.\n\nThis means, that technically an embedded manifold is a decorator for the embedding, i.e. functions of this type get, in the semi-transparent way of the AbstractDecoratorManifold, passed on to the embedding.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractEmbeddingType","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractEmbeddingType","text":"AbstractEmbeddingType\n\nA type used to specify properties of an AbstractEmbeddedManifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractIsometricEmbeddingType","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractIsometricEmbeddingType","text":"AbstractIsometricEmbeddingType <: AbstractEmbeddingType\n\nCharacterizes an embedding as isometric. For this case the inner product is passed from the embedded manifold to the embedding.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.DefaultEmbeddingType","page":"ManifoldsBase.jl","title":"ManifoldsBase.DefaultEmbeddingType","text":"DefaultEmbeddingType <: AbstractEmbeddingType\n\nA type of default embedding that does not have any special properties.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.DefaultIsometricEmbeddingType","page":"ManifoldsBase.jl","title":"ManifoldsBase.DefaultIsometricEmbeddingType","text":"DefaultIsometricEmbeddingType <: AbstractIsometricEmbeddingType\n\nAn isometric embedding type that acts as a default, i.e. it has no specifig properties beyond its isometric property.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.EmbeddedManifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.EmbeddedManifold","text":"EmbeddedManifold{𝔽, MT <: Manifold, NT <: Manifold, ET} <: AbstractEmbeddedManifold{𝔽, ET}\n\nA type to represent that a Manifold M of type MT is indeed an emebedded manifold and embedded into the manifold N of type NT. Based on the AbstractEmbeddingType ET, this introduces methods for M by passing them through to embedding N.\n\nFields\n\nmanifold the manifold that is an embedded manifold\nembedding a second manifold, the first one is embedded into\n\nConstructor\n\nEmbeddedManifold(M, N, e=TransparentIsometricEmbedding())\n\nGenerate the EmbeddedManifold of the Manifold M into the Manifold N with AbstractEmbeddingType e that by default is the most transparent TransparentIsometricEmbedding\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.TransparentIsometricEmbedding","page":"ManifoldsBase.jl","title":"ManifoldsBase.TransparentIsometricEmbedding","text":"TransparentIsometricEmbedding <: AbstractIsometricEmbeddingType\n\nSpecify that an embedding is the default isometric embedding. This even inherits logarithmic and exponential map as well as retraction and inverse retractions from the embedding.\n\nFor an example, see SymmetricMatrices which are isometrically embedded in the Euclidean space of matrices but also inherit exponential and logarithmic maps.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#Functions","page":"ManifoldsBase.jl","title":"Functions","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [ManifoldsBase, Manifolds]\nPages = [\"EmbeddedManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface.html#ManifoldsBase.base_manifold-Union{Tuple{AbstractEmbeddedManifold}, Tuple{N}, Tuple{AbstractEmbeddedManifold,Val{N}}} where N","page":"ManifoldsBase.jl","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::AbstractEmbeddedManifold, d::Val{N} = Val(-1))\n\nReturn the base manifold of M that is enhanced with its embedding. While functions like inner might be overwritten to use the (decorated) manifold representing the embedding, the basemanifold is the manifold itself in the sense that detemining e.g. the [`isdefault_metric](@ref) does not fall back to check with the embedding but with the manifold itself. For this abstract case, justM` is returned.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.base_manifold-Union{Tuple{EmbeddedManifold}, Tuple{N}, Tuple{EmbeddedManifold,Val{N}}} where N","page":"ManifoldsBase.jl","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))\n\nReturn the base manifold of M that is enhanced with its embedding. For this specific type the internally stored enhanced manifold M.manifold is returned.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.check_manifold_point-Tuple{AbstractEmbeddedManifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::AbstractEmbeddedManifold, p; kwargs)\n\ncheck whether a point p is a valid point on the AbstractEmbeddedManifold, i.e. that embed(M, p) is a valid point on the embedded manifold.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.check_tangent_vector-Tuple{AbstractEmbeddedManifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::AbstractEmbeddedManifold, p, X; check_base_point = true, kwargs...)\n\ncheck that embed(M,p,X) is a valid tangent to embed(p,X), where check_base_point determines whether the validity of p is checked, too.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.default_embedding_dispatch-Tuple{AbstractEmbeddedManifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.default_embedding_dispatch","text":"default_embedding_dispatch(M::AbstractEmbeddedManifold)\n\nThis method indicates that an AbstractEmbeddedManifold is the default and hence acts completely transparently and passes all functions transparently onwards. This is used by the AbstractDecoratorManifold within default_decorator_dispatch. By default this is set to Val(false).\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.get_embedding-Tuple{AbstractEmbeddedManifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::AbstractEmbeddedManifold)\n\nReturn the Manifold N an AbstractEmbeddedManifold is embedded into.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#DefaultManifold","page":"ManifoldsBase.jl","title":"DefaultManifold","text":"","category":"section"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"DefaultManifold is a simplified version of Euclidean and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using Manifolds.jl the Euclidean is available, the DefaultManifold itself is not exported.","category":"page"},{"location":"interface.html","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"ManifoldsBase.DefaultManifold","category":"page"},{"location":"interface.html#ManifoldsBase.DefaultManifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.DefaultManifold","text":"DefaultManifold <: Manifold\n\nThis default manifold illustrates the main features of the interface and provides a skeleton to build one's own manifold. It is a simplified/shortened variant of Euclidean from Manifolds.jl.\n\nThis manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spheresymmetricmatrices.html#Unit-norm-symmetric-matrices","page":"Unit-norm symmetric matrices","title":"Unit-norm symmetric matrices","text":"","category":"section"},{"location":"manifolds/spheresymmetricmatrices.html","page":"Unit-norm symmetric matrices","title":"Unit-norm symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/SphereSymmetricMatrices.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/spheresymmetricmatrices.html#Manifolds.SphereSymmetricMatrices","page":"Unit-norm symmetric matrices","title":"Manifolds.SphereSymmetricMatrices","text":"SphereSymmetricMatrices{n,𝔽} <: AbstractEmbeddedManifold{ℝ,TransparentIsometricEmbedding}\n\nThe Manifold consisting of the n  n symmetric matrices  of unit Frobenius norm, i.e. \n\nmathcalS_textsym =biglp   𝔽^n  n big p^mathrmH = p lVert p rVert = 1 bigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ.\n\nConstructor\n\nSphereSymmetricMatrices(n[, field=ℝ])\n\nGenerate the manifold of n-by-n symmetric matrices of unit Frobenius norm.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{SphereSymmetricMatrices{n,𝔽},Any}} where 𝔽 where n","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SphereSymmetricMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether the matrix is a valid point on the SphereSymmetricMatrices M,  i.e. is an n-by-n symmetric matrix of unit Frobenius norm.\n\nThe tolerance for the symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{n}, Tuple{SphereSymmetricMatrices{n,𝔽},Any,Any}} where 𝔽 where n","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SphereSymmetricMatrices{n,𝔽}, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SphereSymmetricMatrices M, i.e. X has to be a symmetric matrix of size (n,n) of unit Frobenius norm. The optional parameter check_base_point indicates, whether to call  check_manifold_point  for p.\n\nThe tolerance for the symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.manifold_dimension-Union{Tuple{SphereSymmetricMatrices{n,𝔽}}, Tuple{𝔽}, Tuple{n}} where 𝔽 where n","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SphereSymmetricMatrices{n,𝔽})\n\nReturn the manifold dimension of the SphereSymmetricMatrices n-by-n symmetric matrix M of unit Frobenius norm over the number system 𝔽, i.e.\n\nbeginaligned\ndim(mathcalS_textsym)(nℝ) = fracn(n+1)2 - 1\ndim(mathcalS_textsym)(nℂ) = 2fracn(n+1)2 - n -1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.project-Tuple{SphereSymmetricMatrices,Any,Any}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SphereSymmetricMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SphereSymmetricMatrices M, i.e.\n\noperatornameproj_p(X) = fracX + X^mathrmH2 - p fracX + X^mathrmH2p\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.project-Tuple{SphereSymmetricMatrices,Any}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SphereSymmetricMatrices, p)\n\nProjects p from the embedding onto the SphereSymmetricMatrices M, i.e.\n\noperatornameproj_mathcalS_textsym(p) = frac12 bigl( p + p^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus.html#Torus","page":"Torus","title":"Torus","text":"","category":"section"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"The torus 𝕋^d  -ππ)^d is modeled as an AbstractPowerManifold of the (real-valued) Circle and uses ArrayPowerRepresentation. Points on the torus are hence row vectors, x  ℝ^d.","category":"page"},{"location":"manifolds/torus.html#Example","page":"Torus","title":"Example","text":"","category":"section"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"The following code can be used to make a three-dimensional torus 𝕋^3 and compute a tangent vector:","category":"page"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"using Manifolds\nM = Torus(3)\np = [0.5, 0.0, 0.0]\nq = [0.0, 0.5, 1.0]\nX = log(M, p, q)","category":"page"},{"location":"manifolds/torus.html#Types-and-functions","page":"Torus","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"Most functions are directly implemented for an AbstractPowerManifold with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"Modules = [Manifolds]\nPages = [\"manifolds/Torus.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/torus.html#Manifolds.Torus","page":"Torus","title":"Manifolds.Torus","text":"Torus{N} <: AbstractPowerManifold\n\nThe n-dimensional torus is the n-dimensional product of the Circle.\n\nThe Circle is stored internally within M.manifold, such that all functions of AbstractPowerManifold can be used directly.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/torus.html#ManifoldsBase.check_manifold_point-Tuple{Torus,Any}","page":"Torus","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Torus{n},p)\n\nChecks whether p is a valid point on the Torus M, i.e. each of its entries is a valid point on the Circle and the length of x is n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Torus{N},Any,Any}} where N","page":"Torus","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Torus{n}, p, X; check_base_point = true, kwargs...)\n\nChecks whether X is a valid tangent vector to p on the Torus M. This means, that p is valid, that X is of correct dimension and elementwise a tangent vector to the elements of p on the Circle. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#The-probability-simplex","page":"Probability simplex","title":"The probability simplex","text":"","category":"section"},{"location":"manifolds/probabilitysimplex.html","page":"Probability simplex","title":"Probability simplex","text":"Modules = [Manifolds]\nPages = [\"manifolds/ProbabilitySimplex.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/probabilitysimplex.html#Manifolds.FisherRaoMetric","page":"Probability simplex","title":"Manifolds.FisherRaoMetric","text":"FisherRaoMetric <: Metric\n\nThe Fisher-Rao metric or Fisher information metric is a particular Riemannian metric which can be defined on a smooth statistical manifold, i.e., a smooth manifold whose points are probability measures defined on a common probability space.\n\nSee for example the ProbabilitySimplex.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex.html#Manifolds.ProbabilitySimplex","page":"Probability simplex","title":"Manifolds.ProbabilitySimplex","text":"ProbabilitySimplex{n} <: AbstractEmbeddedManifold{ℝ,DefaultEmbeddingType}\n\nThe (relative interior of) the probability simplex is the set\n\nΔ^n = biggl p  ℝ^n+1 big p_i  0 text for all  i=1n+1\ntext and  mathbb1p = sum_i=1^n+1 p_i = 1biggr\n\nwhere mathbb1=(11)^mathrmT ℝ^n+1 denotes the vector containing only ones.\n\nThis set is also called the unit simplex or standard simplex.\n\nThe tangent space is given by\n\nT_pΔ^n = biggl X  ℝ^n+1 big mathbb1X = sum_i=1^n+1 X_i = 0 biggr\n\nThe manifold is implemented assuming the Fisher-Rao metric for the multinomial distribution, which is equivalent to the induced metric from isometrically embedding the probability simplex in the n-sphere of radius 2. The corresponding diffeomorphism varphi mathbb Δ^n  mathcal N, where mathcal N subset 2𝕊^n is given by varphi(p) = 2sqrtp.\n\nThis implementation follows the notation in [ÅströmPetraSchmitzerSchnörr2017].\n\n[ÅströmPetraSchmitzerSchnörr2017]: F. Åström, S. Petra, B. Schmitzer, C. Schnörr: “Image Labeling by Assignment”, Journal of Mathematical Imaging and Vision, 58(2), pp. 221–238, 2017. doi: 10.1007/s10851-016-0702-4 arxiv: 1603.05285.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex.html#Manifolds.SoftmaxInverseRetraction","page":"Probability simplex","title":"Manifolds.SoftmaxInverseRetraction","text":"SoftmaxInverseRetraction <: AbstractInverseRetractionMethod\n\nDescribes an inverse retraction that is based on the softmax function.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex.html#Manifolds.SoftmaxRetraction","page":"Probability simplex","title":"Manifolds.SoftmaxRetraction","text":"SoftmaxRetraction <: AbstractRetractionMethod\n\nDescribes a retraction that is based on the softmax function.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex.html#Base.exp-Tuple{ProbabilitySimplex,Vararg{Any,N} where N}","page":"Probability simplex","title":"Base.exp","text":"exp(M::ProbabilitySimplex,p,X)\n\nCompute the exponential map on the probability simplex.\n\nexp_pX = frac12Bigl(p+fracX_p^2lVert X_p rVert^2Bigr)\n+ frac12Bigl(p - fracX_p^2lVert X_p rVert^2Bigr)cos(lVert X_prVert)\n+ frac1lVert X_p rVertsqrtpsin(lVert X_prVert)\n\nwhere X_p = fracXsqrtp, with its division meant elementwise, as well as for the operations X_p^2 and sqrtp.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Base.log-Tuple{ProbabilitySimplex,Vararg{Any,N} where N}","page":"Probability simplex","title":"Base.log","text":"log(M::ProbabilitySimplex, p, q)\n\nCompute the logarithmic map of p and q on the ProbabilitySimplex M.\n\nlog_pq = fracd_Δ^n(pq)sqrt1-sqrtpsqrtq(sqrtpq - sqrtpsqrtqp)\n\nwhere pq and sqrtp is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.check_manifold_point-Tuple{ProbabilitySimplex,Any}","page":"Probability simplex","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::ProbabilitySimplex, p; kwargs...)\n\nCheck whether p is a valid point on the ProbabilitySimplex M, i.e. is a point in the embedding with positive entries that sum to one The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.check_tangent_vector-Tuple{ProbabilitySimplex,Any,Any}","page":"Probability simplex","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::ProbabilitySimplex, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to p on the ProbabilitySimplex M, i.e. after check_manifold_point(M,p), X has to be of same dimension as p and its elements have to sum to one. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p or not. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.distance-Tuple{ProbabilitySimplex,Any,Any}","page":"Probability simplex","title":"ManifoldsBase.distance","text":"distance(M,p,q)\n\nCompute the distance between two points on the ProbabilitySimplex M. The formula reads\n\nd_Δ^n(pq) = 2arccos biggl( sum_i=1^n+1 sqrtp_i q_i biggr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.injectivity_radius-Union{Tuple{n}, Tuple{ProbabilitySimplex{n},Any}} where n","page":"Probability simplex","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M,p)\n\ncompute the injectivity radius on the ProbabilitySimplex M at the point p, i.e. the distanceradius to a point near/on the boundary, that could be reached by following the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.inner-Tuple{ProbabilitySimplex,Any,Any,Any}","page":"Probability simplex","title":"ManifoldsBase.inner","text":"inner(M::ProbabilitySimplex,p,X,Y)\n\nCompute the inner product of two tangent vectors X, Y from the tangent space T_pΔ^n at p. The formula reads\n\ng_p(XY) = sum_i=1^n+1fracX_iY_ip_i\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.inverse_retract-Tuple{ProbabilitySimplex,Any,Any,SoftmaxInverseRetraction}","page":"Probability simplex","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProbabilitySimplex, p, q, ::SoftmaxInverseRetraction)\n\nCompute a first order approximation by projection. The formula reads\n\noperatornameretr^-1_p q = bigl( I_n+1 - frac1nmathbb1^n+1n+1 bigr)(log(q)-log(p))\n\nwhere mathbb1^mn is the size (m,n) matrix containing ones, and log is applied elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.manifold_dimension-Union{Tuple{ProbabilitySimplex{n}}, Tuple{n}} where n","page":"Probability simplex","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::ProbabilitySimplex{n})\n\nReturns the manifold dimension of the probability simplex in ℝ^n+1, i.e.\n\n    dim_Δ^n = n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.project-Tuple{ProbabilitySimplex,Any,Any}","page":"Probability simplex","title":"ManifoldsBase.project","text":"project(M::ProbabilitySimplex, p, Y)\n\nproject Y from the embedding onto the tangent space at p on the ProbabilitySimplex M. The formula reads\n\noperatornameproj_Δ^n(pY) = Y - pYp\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.representation_size-Union{Tuple{ProbabilitySimplex{n}}, Tuple{n}} where n","page":"Probability simplex","title":"ManifoldsBase.representation_size","text":"representation_size(::ProbabilitySimplex{n})\n\nreturn the representation size of points in the n-dimensional probability simplex, i.e. an array size of (n+1,).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.retract-Tuple{ProbabilitySimplex,Any,Any,SoftmaxRetraction}","page":"Probability simplex","title":"ManifoldsBase.retract","text":"retract(M::ProbabilitySimplex, p, X, ::SoftmaxRetraction)\n\nCompute a first order approximation by applying the softmax function. The formula reads\n\noperatornameretr_p X = fracpmathrme^Xpmathrme^X\n\nwhere multiplication, exponentiation and division are meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.zero_tangent_vector-Tuple{ProbabilitySimplex,Any}","page":"Probability simplex","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::ProbabilitySimplex,p)\n\nreturns the zero tangent vector in the tangent space of the point p  from the ProbabilitySimplex M, i.e. its representation by the zero vector in the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Statistics.mean-Tuple{ProbabilitySimplex,Vararg{Any,N} where N}","page":"Probability simplex","title":"Statistics.mean","text":"mean(\n    M::ProbabilitySimplex,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Literature","page":"Probability simplex","title":"Literature","text":"","category":"section"},{"location":"manifolds/generalizedstiefel.html#Generalized-Stiefel","page":"Generalized Stiefel","title":"Generalized Stiefel","text":"","category":"section"},{"location":"manifolds/generalizedstiefel.html","page":"Generalized Stiefel","title":"Generalized Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/GeneralizedStiefel.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/generalizedstiefel.html#Manifolds.GeneralizedStiefel","page":"Generalized Stiefel","title":"Manifolds.GeneralizedStiefel","text":"GeneralizedStiefel{n,k,𝔽,B} <: AbstractEmbeddedManifold{𝔽,DefaultEmbeddingType}\n\nThe Generalized Stiefel manifold consists of all ntimes k, ngeq k orthonormal matrices w.r.t. an arbitrary scalar product with symmetric positive definite matrix Bin R^n  n, i.e.\n\noperatornameSt(nkB) = bigl p in mathbb F^n  k big p^mathrmH B p = I_k bigr\n\nwhere 𝔽  ℝ ℂ, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k in mathbb R^k  k denotes the k  k identity matrix.\n\nIn the case B=I_k one gets the usual Stiefel manifold.\n\nThe tangent space at a point pinmathcal M=operatornameSt(nkB) is given by\n\nT_pmathcal M =  X in 𝔽^n  k  p^mathrmHBX + X^mathrmHBp=0_n\n\nwhere 0_k is the k  k zero matrix.\n\nThis manifold is modeled as an embedded manifold to the Euclidean, i.e. several functions like the zero_tangent_vector are inherited from the embedding.\n\nThe manifold is named after Eduard L. Stiefel (1909–1978).\n\nConstructor\n\nGeneralizedStiefel(n, k, B=I_n, F=ℝ)\n\nGenerate the (real-valued) Generalized Stiefel manifold of ntimes k dimensional orthonormal matrices with scalar product B.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{GeneralizedStiefel{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T),Any}} where 𝔽 where k where n","page":"Generalized Stiefel","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::GeneralizedStiefel, p; kwargs...)\n\nCheck whether p is a valid point on the GeneralizedStiefel M=operatornameSt(nkB), i.e. that it has the right AbstractNumbers type and x^mathrmHBx is (approximately) the identity, where cdot^mathrmH is the complex conjugate transpose. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{B}, Tuple{k}, Tuple{n}, Tuple{GeneralizedStiefel{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T),Any,Any}} where 𝔽 where B where k where n","page":"Generalized Stiefel","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::GeneralizedStiefel, p, X; kwargs...)\n\nCheck whether X is a valid tangent vector at p on the GeneralizedStiefel M=operatornameSt(nkB), i.e. the AbstractNumbers fits, p is a valid point on M and it (approximately) holds that p^mathrmHBX + X^mathrmHBp = 0, where kwargs... is passed to the isapprox.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.inner-Tuple{GeneralizedStiefel,Any,Any,Any}","page":"Generalized Stiefel","title":"ManifoldsBase.inner","text":"inner(M::GeneralizedStiefel, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the GeneralizedStiefel manifold M. The formula reads\n\n(X Y)_p = operatornametrace(v^mathrmHBw)\n\ni.e. the metric induced by the scalar product B from the embedding, restricted to the tangent space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.manifold_dimension-Union{Tuple{GeneralizedStiefel{n,k,ℝ,TB} where TB<:(AbstractArray{T,2} where T)}, Tuple{k}, Tuple{n}} where k where n","page":"Generalized Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::GeneralizedStiefel)\n\nReturn the dimension of the GeneralizedStiefel manifold M=operatornameSt(nkB𝔽). The dimension is given by\n\nbeginaligned\ndim mathrmSt(n k B ℝ) = nk - frac12k(k+1) \ndim mathrmSt(n k B ℂ) = 2nk - k^2\ndim mathrmSt(n k B ℍ) = 4nk - k(2k-1)\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.project-Tuple{GeneralizedStiefel,Any,Any}","page":"Generalized Stiefel","title":"ManifoldsBase.project","text":"project(M:GeneralizedStiefel, p, X)\n\nProject X onto the tangent space of p to the GeneralizedStiefel manifold M. The formula reads\n\noperatornameproj_operatornameSt(nk)(pX) = X - poperatornameSym(p^mathrmHBX)\n\nwhere operatornameSym(y) is the symmetrization of y, e.g. by operatornameSym(y) = fracy^mathrmH+y2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.project-Tuple{GeneralizedStiefel,Any}","page":"Generalized Stiefel","title":"ManifoldsBase.project","text":"project(M::GeneralizedStiefel,p)\n\nProject p from the embedding onto the GeneralizedStiefel M, i.e. compute q as the polar decomposition of p such that q^mathrmHBq is the identity, where cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.retract-Tuple{GeneralizedStiefel,Vararg{Any,N} where N}","page":"Generalized Stiefel","title":"ManifoldsBase.retract","text":"retract(M::GeneralizedStiefel, p, X)\nretract(M::GeneralizedStiefel, p, X, ::PolarRetraction)\nretract(M::GeneralizedStiefel, p, X, ::ProjectionRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the GeneralizedStiefel manifold M, which in this case is the same as the projection based retraction employing the exponential map in the embedding and projecting the result back to the manifold.\n\nThe default retraction for this manifold is the ProjectionRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.vector_transport_to-Tuple{GeneralizedStiefel,Any,Any,Any,ProjectionTransport}","page":"Generalized Stiefel","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::GeneralizedStiefel, p, X, q, ::ProjectionTransport)\n\nCompute the vector transport of the tangent vector X at p to q, using the project of X to q.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds","page":"Home","title":"Manifolds","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package Manifolds aims to provide a library of manifolds to be used within your project. The implemented manifolds are accompanied by their mathematical formulae.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The manifolds are implemented using the interface for manifolds given in ManifoldsBase.jl. You can use that interface to implement your own software on manifolds, such that all manifolds based on that interface can be used within your code.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For more information, see the About section.","category":"page"},{"location":"index.html#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To install the package just type","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add Manifolds","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then you can directly start, for example to stop half way from the north pole on the Sphere to a point on the the equator, you can generate the shortest_geodesic. It internally employs log and exp.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Manifolds\nM = Sphere(2)\nγ = shortest_geodesic(M, [0., 0., 1.], [0., 1., 0.])\nγ(0.5)","category":"page"},{"location":"manifolds/lorentz.html#Lorentzian-Manifold","page":"Lorentzian manifold","title":"Lorentzian Manifold","text":"","category":"section"},{"location":"manifolds/lorentz.html","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"The Lorentz manifold is a pseudo-Riemannian manifold. It is named after the Dutch physicist Hendrik Lorentz (1853–1928). The default LorentzMetric is the MinkowskiMetric named after the German mathematician Hermann Minkowski (1864–1909).","category":"page"},{"location":"manifolds/lorentz.html","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"Within Manifolds.jl it is used as the embedding of the Hyperbolic space.","category":"page"},{"location":"manifolds/lorentz.html","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"Modules = [Manifolds]\nPages = [\"Lorentz.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/lorentz.html#Manifolds.Lorentz","page":"Lorentzian manifold","title":"Manifolds.Lorentz","text":"Lorentz{N} = MetricManifold{Euclidean{N,ℝ},LorentzMetric}\n\nThe Lorentz manifold (or Lorentzian) is a pseudo-Riemannian manifold.\n\nConstructor\n\nLorentz(n[, metric=MinkowskiMetric()])\n\nGenerate the Lorentz manifold of dimension n with the LorentzMetric m, which is by default set to the MinkowskiMetric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz.html#Manifolds.LorentzMetric","page":"Lorentzian manifold","title":"Manifolds.LorentzMetric","text":"LorentzMetric <: Metric\n\nAbstract type for Lorentz metrics, which have a single time dimension. These metrics assume the spacelike convention with the time dimension being last, giving the signature (+++-).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz.html#Manifolds.MinkowskiMetric","page":"Lorentzian manifold","title":"Manifolds.MinkowskiMetric","text":"MinkowskiMetric <: LorentzMetric\n\nAs a special metric of signature  (+++-), i.e. a LorentzMetric, see minkowski_metric for the formula.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz.html#Manifolds.minkowski_metric-Tuple{Any,Any}","page":"Lorentzian manifold","title":"Manifolds.minkowski_metric","text":"minkowski_metric(a,b)\n\nCompute the minkowski metric on mathbb R^n is given by\n\nab_mathrmM = -a_nb_n +\ndisplaystylesum_k=1^n-1 a_kb_k\n\n\n\n\n\n","category":"method"},{"location":"misc/internals.html#Internal-documentation","page":"Internals","title":"Internal documentation","text":"","category":"section"},{"location":"misc/internals.html","page":"Internals","title":"Internals","text":"This page documents the internal types and methods of Manifolds.jl's that might be of use for writing your own manifold.","category":"page"},{"location":"misc/internals.html#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"misc/internals.html","page":"Internals","title":"Internals","text":"Manifolds.SizedAbstractArray","category":"page"},{"location":"misc/internals.html#Manifolds.SizedAbstractArray","page":"Internals","title":"Manifolds.SizedAbstractArray","text":"SizedAbstractArray{Tuple{dims...}}(array)\n\nWraps an AbstractArray with a static size, so to take advantage of the (faster) methods defined by the static array package. The size is checked once upon construction to determine if the number of elements (length) match, but the array may be reshaped.\n\n\n\n\n\n","category":"type"},{"location":"misc/internals.html#Functions","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"misc/internals.html","page":"Internals","title":"Internals","text":"Manifolds.eigen_safe\nManifolds.find_pv\nManifolds.log_safe\nManifolds.size_to_tuple\nManifolds.select_from_tuple\nManifolds.usinc\nManifolds.usinc_from_cos\nManifolds.ziptuples","category":"page"},{"location":"misc/internals.html#Manifolds.eigen_safe","page":"Internals","title":"Manifolds.eigen_safe","text":"eigen_safe(x)\n\nCompute the eigendecomposition of x. If x is a StaticMatrix, it is converted to a Matrix before the decomposition.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.find_pv","page":"Internals","title":"Manifolds.find_pv","text":"find_pv(x...)\n\nA = find_pv(x...) returns the first ProductArray among the arguments.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.log_safe","page":"Internals","title":"Manifolds.log_safe","text":"log_safe(x)\n\nCompute the matrix logarithm of x. If x is a StaticMatrix, it is converted to a Matrix before computing the log.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.size_to_tuple","page":"Internals","title":"Manifolds.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.select_from_tuple","page":"Internals","title":"Manifolds.select_from_tuple","text":"select_from_tuple(t::NTuple{N, Any}, positions::Val{P})\n\nSelects elements of tuple t at positions specified by the second argument. For example select_from_tuple((\"a\", \"b\", \"c\"), Val((3, 1, 1))) returns (\"c\", \"a\", \"a\").\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.usinc","page":"Internals","title":"Manifolds.usinc","text":"usinc(θ::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(θ) = fracsin(θ)θ. This is equivalent to sinc(θ/π).\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.usinc_from_cos","page":"Internals","title":"Manifolds.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(θ) = fracsin(θ)θ, computed from x = cos(θ).\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.ziptuples","page":"Internals","title":"Manifolds.ziptuples","text":"ziptuples(a, b[, c[, d[, e]]])\n\nZips tuples a, b, and remaining in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/sphere.html#Sphere-and-unit-norm-arrays","page":"Sphere","title":"Sphere and unit norm arrays","text":"","category":"section"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"AbstractSphere","category":"page"},{"location":"manifolds/sphere.html#Manifolds.AbstractSphere","page":"Sphere","title":"Manifolds.AbstractSphere","text":"AbstractSphere{𝔽} <: AbstractEmbeddedManifold{𝔽,DefaultIsometricEmbeddingType}\n\nAn abstract type to represent a unit sphere that is represented isometrically in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"The classical sphere, i.e. unit norm (real- or complex-valued) vectors can be generated as usual: to create the 2-dimensional sphere (in ℝ^3), use Sphere(2) and Sphere(2,ℂ), respectively.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"Sphere","category":"page"},{"location":"manifolds/sphere.html#Manifolds.Sphere","page":"Sphere","title":"Manifolds.Sphere","text":"Sphere{n,𝔽} <: AbstractSphere{𝔽}\n\nThe (unit) sphere manifold 𝕊^n is the set of all unit norm vectors in 𝔽^N, 𝔽 elements. The sphere is represented in the embedding, i.e.\n\n𝕊^n = bigl p in 𝔽^n+1 big lVert p rVert = 1 bigr\n\nwhere 𝔽inℝℂ. Note that compared to the ArraySphere, here the argument n of the manifold is the dimension of the manifold, i.e. 𝕊^n  𝔽^n+1, nin ℕ.\n\nThe tangent space at point p is given by\n\nT_p𝕊^n = bigl X  𝔽^n+1  pX = 0 bigr \n\nwhere 𝔽inℝℂ and cdotcdot denotes the inner product in the embedding mathbb 𝔽^n+1.\n\nThis manifold is modeled as a special case of the more general case, i.e. as an embedded manifold to the Euclidean, and several functions like the inner product and the zero_tangent_vector are inherited from the embedding.\n\nConstructor\n\nSphere(n[, field=ℝ])\n\nGenerate the (real-valued) sphere 𝕊^n  ℝ^n+1, where field can also be used to generate the complex-valued sphere.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"For the higher-dimensional arrays, for example unit (Frobenius) norm matrices, the manifold is generated using the size of the matrix. To create the unit sphere of 32 real-valued matrices, write ArraySphere(3,2) and the complex case is done – as for the Euclidean case – with an keyword argument ArraySphere(3,2; field = ℂ). This case also covers the classical sphere as a special case, but you specify the size of the vectors/embedding instead: The 2-sphere can here be generated ArraySphere(3).","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"ArraySphere","category":"page"},{"location":"manifolds/sphere.html#Manifolds.ArraySphere","page":"Sphere","title":"Manifolds.ArraySphere","text":"ArraySphere{T<:Tuple,𝔽} <: AbstractSphere{𝔽}\n\nThe (unit) sphere manifold 𝕊^n₁n₂nᵢ is the set of all unit (Frobenius) norm elements of 𝔽^n₁n₂nᵢ, where 𝔽\\in{ℝ,ℂ}. The generalized sphere is represented in the embedding, and supports arbitrary sized arrays or in other words arbitrary tensors of unit norm. The set formally reads\n\n𝕊^n_1 n_2  n_i = bigl p in 𝔽^n_1 n_2  n_i big lVert p rVert = 1 bigr\n\nwhere 𝔽inℝℂ. Setting i=1 and 𝔽=ℝ  this  simplifies to unit vectors in ℝ^n, see Sphere for this special case. Note that compared to this classical case, the argument for the generalized case here is given by the dimension of the embedding. This means that Sphere(2) and ArraySphere(3) are the same manifold.\n\nThe tangent space at point p is given by\n\nT_p𝕊^n_1 n_2  n_i = bigl X  𝔽^n_1 n_2  n_i  pX = 0 bigr \n\nwhere 𝔽inℝℂ and cdotcdot denotes the inner product in the embedding mathbb 𝔽^n_1 n_2  n_i.\n\nThis manifold is modeled as an embedded manifold to the Euclidean, i.e. several functions like the inner product and the zero_tangent_vector are inherited from the embedding.\n\nConstructor\n\nArraySphere(n₁,n₂,...,nᵢ; field=ℝ)\n\nGenerate sphere in 𝔽^n_1 n_2  n_i, where 𝔽 defaults to the real-valued case ℝ.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html#Functions-on-unit-spheres","page":"Sphere","title":"Functions on unit spheres","text":"","category":"section"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"Modules = [Manifolds]\nPages = [\"manifolds/Sphere.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/sphere.html#Base.exp-Tuple{AbstractSphere,Vararg{Any,N} where N}","page":"Sphere","title":"Base.exp","text":"exp(M::AbstractSphere, p, X)\n\nCompute the exponential map from p in the tangent direction X on the AbstractSphere M by following the great arc eminating from p in direction X.\n\nexp_p X = cos(lVert X rVert_p)p + sin(lVert X rVert_p)fracXlVert X rVert_p\n\nwhere lVert X rVert_p is the norm on the tangent space at p of the AbstractSphere M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Base.log-Tuple{AbstractSphere,Vararg{Any,N} where N}","page":"Sphere","title":"Base.log","text":"log(M::AbstractSphere, p, q)\n\nCompute the logarithmic map on the AbstractSphere M, i.e. the tangent vector, whose geodesic starting from p reaches q after time 1. The formula reads for x  -y\n\nlog_p q = d_𝕊(pq) fracq-pq plVert q-pq p rVert_2\n\nand a deterministic choice from the set of tangent vectors is returned if x=-y, i.e. for opposite points.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.normal_tvector_distribution-Union{Tuple{n}, Tuple{Sphere{n,ℝ},Any,Any}} where n","page":"Sphere","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(S::Sphere{n,ℝ}, p, σ)\n\nGenerate a distribution in the tangent space at p by generating a normal distribution in ambient space with standard deviation σ projected to the tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.uniform_distribution-Tuple{AbstractSphere,Any}","page":"Sphere","title":"Manifolds.uniform_distribution","text":"uniform_distribution(M::AbstractSphere, p)\n\nUniform distribution on given AbstractSphere M. Generated points will be of similar type as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_manifold_point-Tuple{AbstractSphere,Any}","page":"Sphere","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::AbstractSphere, p; kwargs...)\n\nCheck whether p is a valid point on the AbstractSphere M, i.e. is a point in the embedding of unit length. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_tangent_vector-Tuple{AbstractSphere,Any,Any}","page":"Sphere","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::AbstractSphere, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to p on the AbstractSphere M, i.e. after check_manifold_point(M,p), X has to be of same dimension as p and orthogonal to p. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p or not. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.distance-Tuple{AbstractSphere,Any,Any}","page":"Sphere","title":"ManifoldsBase.distance","text":"distance(M::AbstractSphere, p, q)\n\nCompute the geodesic distance betweeen p and q on the AbstractSphere M. The formula is given by the (shorter) great arc length on the (or a) great circle both p and q lie on.\n\nd_𝕊(pq) = arccos(pq)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.get_coordinates-Union{Tuple{n}, Tuple{Sphere{n,ℝ},Any,Any,DefaultOrthonormalBasis}} where n","page":"Sphere","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Sphere, p, X, B::DefaultOrthonormalBasis)\n\nRepresent the tangent vector X at point p from the Sphere M in an orthonormal basis by rotating the vector X using the rotation matrix 2fracq q^mathrmTq^mathrmT q - I where q = p + (1 0  0).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.injectivity_radius-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractSphere[, p])\n\nReturn the injectivity radius for the AbstractSphere M, which is globally π.\n\ninjectivity_radius(M::Sphere, x, ::ProjectionRetraction)\n\nReturn the injectivity radius for the ProjectionRetraction on the AbstractSphere, which is globally fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.inverse_retract-Tuple{AbstractSphere,Any,Any,ProjectionInverseRetraction}","page":"Sphere","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractSphere, p, q, ::ProjectionInverseRetraction)\n\nCompute the inverse of the projection based retraction on the AbstractSphere M, i.e. rearranging p+X = qlVert p+XrVert_2 yields since pX = 0 and when d_𝕊^2(pq)  fracπ2 that\n\noperatornameretr_p^-1(q) = fracqp q - p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.manifold_dimension-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractSphere)\n\nReturn the dimension of the AbstractSphere M, respectively i.e. the dimension of the embedding -1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.project-Tuple{AbstractSphere,Any,Any}","page":"Sphere","title":"ManifoldsBase.project","text":"project(M::AbstractSphere, p, X)\n\nProject the point X onto the tangent space at p on the Sphere M.\n\noperatornameproj_p(X) = X - p Xp\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.project-Tuple{AbstractSphere,Any}","page":"Sphere","title":"ManifoldsBase.project","text":"project(M::AbstractSphere, p)\n\nProject the point p from the embedding onto the Sphere M.\n\n    operatornameproj(p) = fracplVert p rVert\n\nwhere lVertcdotrVert denotes the usual 2-norm for vectors if m=1 and the Frobenius norm for the case m1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.representation_size-Union{Tuple{ArraySphere{N,𝔽} where 𝔽}, Tuple{N}} where N","page":"Sphere","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractSphere)\n\nReturn the size points on the AbstractSphere M are represented as, i.e., the representation size of the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.retract-Tuple{AbstractSphere,Any,Any,ProjectionRetraction}","page":"Sphere","title":"ManifoldsBase.retract","text":"retract(M::AbstractSphere, p, X, ::ProjectionRetraction)\n\nCompute the retraction that is based on projection, i.e.\n\noperatornameretr_p(X) = fracp+XlVert p+X rVert_2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.vector_transport_to-Tuple{AbstractSphere,Any,Any,Any,Any,ParallelTransport}","page":"Sphere","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractSphere, p, X, q, ::ParallelTransport)\n\nCompute the parallel transport on the Sphere of the tangent vector X at p to q, provided, the geodesic between p and q is unique. The formula reads\n\nP_pq(X) = X - fraclangle log_p qXrangle_pd^2_𝕊(pq)\nbigl(log_xy + log_yx bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Statistics.mean-Tuple{AbstractSphere,Vararg{Any,N} where N}","page":"Sphere","title":"Statistics.mean","text":"mean(\n    S::AbstractSphere,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#Graph-manifold","page":"Graph manifold","title":"Graph manifold","text":"","category":"section"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"For a given graph G(VE) implemented using LightGraphs.jl, the GraphManifold models a PowerManifold either on the nodes or edges of the graph, depending on the GraphManifoldType. i.e., it's either a mathcal M^lvert V rvert for the case of a vertex manifold or a mathcal M^lvert E rvert for the case of a edge manifold.","category":"page"},{"location":"manifolds/graph.html#Example","page":"Graph manifold","title":"Example","text":"","category":"section"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"To make a graph manifold over ℝ^2 with three vertices and two edges, one can use","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"using Manifolds\nusing LightGraphs\nM = Euclidean(2)\np = [[1., 4.], [2., 5.], [3., 6.]]\nq = [[4., 5.], [6., 7.], [8., 9.]]\nx = [[6., 5.], [4., 3.], [2., 8.]]\nG = SimpleGraph(3)\nadd_edge!(G, 1, 2)\nadd_edge!(G, 2, 3)\nN = GraphManifold(G, M, VertexManifold())","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"It supports all AbstractPowerManifold operations (it is based on NestedPowerRepresentation) and furthermore it is possible to compute a graph logarithm:","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"using Manifolds\nusing LightGraphs\nM = Euclidean(2)\np = [[1., 4.], [2., 5.], [3., 6.]]\nq = [[4., 5.], [6., 7.], [8., 9.]]\nx = [[6., 5.], [4., 3.], [2., 8.]]\nG = SimpleGraph(3)\nadd_edge!(G, 1, 2)\nadd_edge!(G, 2, 3)\nN = GraphManifold(G, M, VertexManifold())","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"incident_log(N, p)","category":"page"},{"location":"manifolds/graph.html#Types-and-functions","page":"Graph manifold","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/GraphManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/graph.html#Manifolds.EdgeManifold","page":"Graph manifold","title":"Manifolds.EdgeManifold","text":"EdgeManifoldManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the edges.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.GraphManifold","page":"Graph manifold","title":"Manifolds.GraphManifold","text":"GraphManifold{G,𝔽,M,T} <: AbstractPowerManifold{𝔽,M,NestedPowerRepresentation}\n\nBuild a manifold, that is a PowerManifold of the Manifold M either on the edges or vertices of a graph G depending on the GraphManifoldType T.\n\nFields\n\nG is an AbstractSimpleGraph\nM is a Manifold\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.GraphManifoldType","page":"Graph manifold","title":"Manifolds.GraphManifoldType","text":"GraphManifoldType\n\nThis type represents the type of data on the graph that the GraphManifold represents.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.VertexManifold","page":"Graph manifold","title":"Manifolds.VertexManifold","text":"VectexGraphManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the vertices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.incident_log-Tuple{GraphManifold{#s80,𝔽,#s69,VertexManifold} where #s69<:Manifold{𝔽} where #s80<:LightGraphs.AbstractGraph where 𝔽,Any}","page":"Graph manifold","title":"Manifolds.incident_log","text":"incident_log(M::GraphManifold, x)\n\nReturn the tangent vector on the (vertex) GraphManifold, where at each node the sum of the logs to incident nodes is computed. For a SimpleGraph, an egde is interpreted as double edge in the corresponding SimpleDiGraph\n\nIf the internal graph is a SimpleWeightedGraph the weighted sum of the tangent vectors is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.check_manifold_point-Tuple{GraphManifold,Vararg{Any,N} where N}","page":"Graph manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::GraphManifold, p)\n\nCheck whether p is a valid point on the GraphManifold, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of p passes the check_manifold_point test for the base manifold M.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.check_tangent_vector-Tuple{GraphManifold,Vararg{Any,N} where N}","page":"Graph manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::GraphManifold, p, X; check_base_point = true, kwargs...)\n\nCheck whether p is a valid point on the GraphManifold, and X it from its tangent space, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of X together with its corresponding entry of p passes the check_tangent_vector test for the base manifold M.manifold. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{#s80,𝔽,#s69,EdgeManifold} where #s69<:Manifold{𝔽} where #s80<:LightGraphs.AbstractGraph where 𝔽}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,𝔽,M,EdgeManifold})\n\nreturns the manifold dimension of the GraphManifold N on the edges of a graph G=(VE), i.e.\n\ndim(mathcal N) = lvert E rvert dim(mathcal M)\n\nwhere mathcal M is the manifold of the data on the edges.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{#s80,𝔽,#s69,VertexManifold} where #s69<:Manifold{𝔽} where #s80<:LightGraphs.AbstractGraph where 𝔽}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,𝔽,M,VertexManifold})\n\nreturns the manifold dimension of the GraphManifold N on the vertices of a graph G=(VE), i.e.\n\ndim(mathcal N) = lvert V rvert dim(mathcal M)\n\nwhere mathcal M is the manifold of the data on the nodes.\n\n\n\n\n\n","category":"method"},{"location":"examples/manifold.html#manifold-tutorial","page":"How to implement a Manifold","title":"How to implement your own manifold","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"CurrentModule = ManifoldsBase\nDocTestSetup  = quote\n    using Manifolds\nend","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"This tutorial demonstrates how to easily set your own manifold up within Manifolds.jl.","category":"page"},{"location":"examples/manifold.html#Introduction","page":"How to implement a Manifold","title":"Introduction","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"If you looked around a little and saw the interface, the amount of functions and possibilities, it might seem that a manifold might take some time to implement. This tutorial demonstrates that you can get your first own manifold quite fast and you only have to implement the functions you actually need. For this tutorial it would be helpful if you take a look at our notation. This tutorial assumes that you heard of the exponential map, tangent vectors and the dimension of a manifold. If not, please read for example [do Carmo, 1992], Chapter 3, first.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"In general you need just a datatype (struct) that inherits from Manifold to define a manifold. No function is per se required to be implemented. However, it is a good idea to provide functions that might be useful to others, for example check_manifold_point and check_tangent_vector, as we do in this tutorial.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"We start with two technical preliminaries. If you want to start directly, you can skip this paragraph and revisit it for two of the implementation details.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"After that, we will","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"model the manifold\nimplement two tests, so that points and tangent vectors can be checked for validity, for example also within ValidationManifold,\nimplement two functions, the exponential map and the manifold dimension.","category":"page"},{"location":"examples/manifold.html#manifold-tutorial-prel","page":"How to implement a Manifold","title":"Technical preliminaries","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"There are only two small technical things we need to explain at this point. First of all our Manifold{𝔽} has a parameter 𝔽. This parameter indicates the number_system the manifold is based on, for example ℝ for real manifolds. It is important primarily for defining bases of tangent spaces. See SymmetricMatrices as an example of defining both a real-valued and a complex-valued symmetric manifolds using one type.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Second, a main design decision of Manifold.jl is that most functions are implemented as mutating functions, i.e. as in-place-computations. There usually exists a non-mutating version that falls back to allocating memory and calling the mutating one. This means you only have to implement the mutating version, unless there is a good reason to provide a special case for the non-mutating one, i.e. because in that case you know a far better performing implementation.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Let's look at an example. The exponential map exp_pcolon T_pmathcal M to mathcal M that maps a tangent vector Xin T_pmathcal M from the tangent space at pin mathcal M to the manifold. The function exp has to know the manifold M, the point p and the tangent vector X as input, so to compute the resulting point q you need to call","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"q = exp(M, p, X)","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"If you already have allocated memory for the variable that should store the result, it is better to perform the computations directly in that memory and avoid reallocations. For example","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"q = similar(p)\nexp!(M, q, p, X)","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"calls exp!, which modifies its input q and returns the resulting point in there. Actually these two lines are (almost) the default implementation for exp. allocate_result that is actually used there just calls similar for simple Arrays. Note that for a unified interface, the manifold M is always the first parameter, and the variable the result will be stored to in the mutating variants is always the second parameter.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Long story short: if possible, implement the mutating version exp!, you get the exp for free. Many functions that build upon basic functions employ the mutating variant, too, to avoid reallocations.","category":"page"},{"location":"examples/manifold.html#manifold-tutorial-startup","page":"How to implement a Manifold","title":"Startup","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"As a start, let's load ManifoldsBase.jl and import the functions we consider throughout this tutorial. For implementing a manifold, loading the interface should suffice for quite some time.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"using ManifoldsBase, LinearAlgebra, Test\nimport ManifoldsBase: check_manifold_point, check_tangent_vector, manifold_dimension, exp!","category":"page"},{"location":"examples/manifold.html#manifold-tutorial-task","page":"How to implement a Manifold","title":"Goal","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"As an example, let's implement the sphere, but with a radius r. Since this radius is a property inherent to the manifold, it will become a field of the manifold. The second information, we want to store is the dimension of the sphere, for example whether it's the 1-sphere, i.e. the circle, represented by vectors pinmathbb R^2 or the 2-sphere in mathbb R^3. Since the latter might be something we want to dispatch on, we model it as a parameter of the type.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"In general the struct of a manifold should provide information about the manifold, which are inherent to the manifold or has to be available without a specific point or tangent vector present. This is – most prominently – a way to determine the manifold dimension.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"For our example we define","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"\"\"\"\n    MySphere{N} <: Manifold{ℝ}\n\nDefine an `n`-sphere of radius `r`. Construct by `MySphere(radius,n)`\n\"\"\"\nstruct MySphere{N} <: Manifold{ManifoldsBase.ℝ} where {N}\n    radius::Float64\nend\nMySphere(radius, n) = MySphere{n}(radius)\nBase.show(io::IO, M::MySphere{n}) where {n} = print(io, \"MySphere($(M.radius),$n)\")\nnothing #hide","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Here, the last line just provides a nicer print of a variable of that type Now we can already initialize our manifold that we will use later, the 2-sphere of radius 15.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"S = MySphere(1.5, 2)","category":"page"},{"location":"examples/manifold.html#manifold-tutorial-checks","page":"How to implement a Manifold","title":"Checking points and tangents","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"If we have now a point, represented as an array, we would first like to check, that it is a valid point on the manifold. For this one can use the easy interface is_manifold_point. This internally uses check_manifold_point. This is what we want to implement. We have to return the error if p is not on M and nothing otherwise.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"We have to check two things: that a point p is a vector with N+1 entries and it's norm is the desired radius. To spare a few lines, we can use short-circuit evaluation instead of if statements. If something has to only hold up to precision, we can pass that down, too using the kwargs....","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"function check_manifold_point(M::MySphere{N}, p; kwargs...) where {N}\n    (size(p)) == (N+1,) || return DomainError(size(p),\"The size of $p is not $((N+1,)).\")\n    if !isapprox(norm(p), M.radius; kwargs...)\n        return DomainError(norm(p), \"The norm of $p is not $(M.radius).\")\n    end\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Similarly, we can verify, whether a tangent vector X is valid. It has to fulfill the same size requirements and it has to be orthogonal to p. We can again use the kwargs, but also provide a way to check p, too.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"function check_tangent_vector(M::MySphere, p, X, check_base_point = true, kwargs...)\n    if check_base_point\n        mpe = check_manifold_point(M, p; kwargs...)\n        mpe === nothing || return mpe\n    end\n    size(X) != size(p) && return DomainError(size(X), \"The size of $X is not $(size(p)).\")\n    if !isapprox(dot(p,X), 0.0; kwargs...)\n        return DomainError(dot(p,X), \"The tangent $X is not orthogonal to $p.\")\n    end\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"to test points we can now use","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"is_manifold_point(S, [1.0,0.0,0.0]) # norm 1, so not on S, returns false\n@test_throws DomainError is_manifold_point(S, [1.5,0.0], true) # only on R^2, throws an error.\np = [1.5,0.0,0.0]\nX = [0.0,1.0,0.0]\n# The following two tests return true\n[ is_manifold_point(S, p); is_tangent_vector(S,p,X) ]","category":"page"},{"location":"examples/manifold.html#manifold-tutorial-fn","page":"How to implement a Manifold","title":"Functions on the manifold","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"For the manifold_dimension we have to just return the N parameter","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"manifold_dimension(::MySphere{N}) where {N} = N\nmanifold_dimension(S)","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Note that we can even omit the variable name in the first line since we do not have to access any field or use the variable otherwise.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"To implement the exponential map, we have to implement the formula for great arcs, given a start point p and a direction X on the n-sphere of radius r the formula reads","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"exp_p X = cos(frac1rlVert X rVert)p + sin(frac1rlVert X rVert)fracrlVert X rVertX","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Note that with this choice we for example implicitly assume a certain metric. This is completely fine. We only have to think about specifying a metric explicitly, when we have (at least) two different metrics on the same manifold.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"An implementation of the mutation version, see the technical note, reads","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"function exp!(M::MySphere{N}, q, p, X) where {N}\n    nX = norm(X)\n    if nX == 0\n        q .= p\n    else\n        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (X./nX)\n    end\n    return q\nend\nnothing #hide","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"A first easy check can be done taking p from above and any vector X of length 1.5π from its tangent space. The resulting point is opposite of p, i.e. -p","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"q = exp(S,p, [0.0,1.5π,0.0])\n[isapprox(p,-q); is_manifold_point(S,q)]","category":"page"},{"location":"examples/manifold.html#manifold-tutorial-outlook","page":"How to implement a Manifold","title":"Conclusion","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"You can now just continue implementing further functions from the interface, but with just exp! you for example already have","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"geodesic the (not necessarily shortest) geodesic emanating from p in direction X.\nthe ExponentialRetraction, that the retract function uses by default.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"For the shortest_geodesic the implementation of a logarithm log, again better a log! is necessary.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"Sometimes a default implementation is provided; for example if you implemented inner, the norm is defined. You should overwrite it, if you can provide a more efficient version. For a start the default should suffice. With log! and inner you get the distance, and so.","category":"page"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"In summary with just these few functions you can already explore the first things on your own manifold. Whenever a function from Manifolds.jl requires another function to be specifically implemented, you get a reasonable error message.","category":"page"},{"location":"examples/manifold.html#Literature","page":"How to implement a Manifold","title":"Literature","text":"","category":"section"},{"location":"examples/manifold.html","page":"How to implement a Manifold","title":"How to implement a Manifold","text":"<ul>\n<li id=\"doCarmo1992\">\n    [<a>doCarmo, 1992</a>]\n    M. P. do Carmo,\n    <emph>Riemannian Geometry</emph>,\n    Birkhäuser Boston, 1992,\n    ISBN: 0-8176-3490-8.\n</li>\n</ul>","category":"page"},{"location":"manifolds/euclidean.html#Euclidean-space","page":"Euclidean","title":"Euclidean space","text":"","category":"section"},{"location":"manifolds/euclidean.html","page":"Euclidean","title":"Euclidean","text":"The Euclidean space ℝ^n is a simple model space, since it has curvature constantly zero everywhere; hence, nearly all operations simplify. The easiest way to generate an Euclidean space is to use a field, i.e. AbstractNumbers, e.g. to create the ℝ^n or ℝ^ntimes n you can simply type M = ℝ^n or ℝ^(n,n), respectively.","category":"page"},{"location":"manifolds/euclidean.html","page":"Euclidean","title":"Euclidean","text":"Modules = [Manifolds]\nPages = [\"manifolds/Euclidean.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/euclidean.html#Manifolds.Euclidean","page":"Euclidean","title":"Manifolds.Euclidean","text":"Euclidean{T<:Tuple,𝔽} <: Manifold{𝔽}\n\nEuclidean vector space.\n\nConstructor\n\nEuclidean(n)\n\nGenerate the n-dimensional vector space ℝ^n.\n\nEuclidean(n₁,n₂,...,nᵢ; field=ℝ)\n𝔽^(n₁,n₂,...,nᵢ) = Euclidean(n₁,n₂,...,nᵢ; field=𝔽)\n\nGenerate the vector space of k = n_1 cdot n_2 cdot  cdot n_i values, i.e. the manifold 𝔽^n_1 n_2  n_i, 𝔽inℝℂ, whose elements are interpreted as n_1  n_2    n_i arrays. For i=2 we obtain a matrix space. The default field=ℝ can also be set to field=ℂ. The dimension of this space is k dim_ℝ 𝔽, where dim_ℝ 𝔽 is the real_dimension of the field 𝔽.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Manifolds.EuclideanMetric","page":"Euclidean","title":"Manifolds.EuclideanMetric","text":"EuclideanMetric <: RiemannianMetric\n\nA general type for any manifold that employs the Euclidean Metric, for example the Euclidean manifold itself, or the Sphere, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).\n\nSince the metric is independent of the field type, this metric is also used for the Hermitian metrics, i.e. metrics that are analogous to the EuclideanMetric but where the field type of the manifold is ℂ.\n\nThis metric is the default metric for example for the Euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Base.exp-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Base.exp","text":"exp(M::Euclidean, p, X)\n\nCompute the exponential map on the Euclidean manifold M from p in direction X, which in this case is just\n\nexp_p X = p + X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Base.log-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Base.log","text":"log(M::Euclidean, p, q)\n\nCompute the logarithmic map on the Euclidean M from p to q, which in this case is just\n\nlog_p q = q-p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#LinearAlgebra.norm-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"LinearAlgebra.norm","text":"norm(M::Euclidean, p, X)\n\nCompute the norm of a tangent vector X at p on the Euclidean M, i.e. since every tangent space can be identified with M itself in this case, just the (Frobenius) norm of X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.flat-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Manifolds.flat","text":"flat(M::Euclidean, p, X)\n\nTransform a tangent vector X into a cotangent. Since they can directly be identified in the Euclidean case, this yields just the identity for a tangent vector w in the tangent space of p on M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.normal_tvector_distribution-Union{Tuple{N}, Tuple{Euclidean{Tuple{N},𝔽} where 𝔽,Any,Any}} where N","page":"Euclidean","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::Euclidean, p, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.projected_distribution-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"Manifolds.projected_distribution","text":"projected_distribution(M::Euclidean, d, [p])\n\nWrap the standard distribution d into a manifold-valued distribution. Generated points will be of similar type to p. By default, the type is not changed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.sharp-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Manifolds.sharp","text":"sharp(M::Euclidean, p, ξ)\n\nTransform the cotangent vector ξ at p on the Euclidean M to a tangent vector X. Since cotangent and tangent vectors can directly be identified in the Euclidean case, this yields just the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.distance-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"ManifoldsBase.distance","text":"distance(M::Euclidean, p, q)\n\nCompute the Euclidean distance between two points on the Euclidean manifold M, i.e. for vectors it's just the norm of the difference, for matrices and higher order arrays, the matrix and ternsor Frobenius norm, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.injectivity_radius-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Euclidean)\n\nReturn the injectivity radius on the Euclidean M, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.inner-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"ManifoldsBase.inner","text":"inner(M::Euclidean, p, X, Y)\n\nCompute the inner product on the Euclidean M, which is just the inner product on the real-valued or complex valued vector space of arrays (or tensors) of size n_1  n_2       n_i, i.e.\n\ng_p(XY) = sum_k  I overlineX_k Y_k\n\nwhere I is the set of vectors k  ℕ^i, such that for all 1  j  i it holds 1  k_j  n_j and overlinecdot denotes the complex conjugate.\n\nFor the special case of i  2, i.e. matrices and vectors, this simplifies to\n\ng_p(XY) = X^mathrmHY\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.manifold_dimension-Union{Tuple{Euclidean{N,𝔽}}, Tuple{𝔽}, Tuple{N}} where 𝔽 where N","page":"Euclidean","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Euclidean)\n\nReturn the manifold dimension of the Euclidean M, i.e. the product of all array dimensions and the real_dimension of the underlying number system.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"ManifoldsBase.project","text":"project(M::Euclidean, p, X)\n\nProject an arbitrary vector X into the tangent space of a point p on the Euclidean M, which is just the identity, since any tangent space of M can be identified with all of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project-Tuple{Euclidean,Any}","page":"Euclidean","title":"ManifoldsBase.project","text":"project(M::Euclidean, p)\n\nProject an arbitrary point p onto the Euclidean manifold M, which is of course just the identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.representation_size-Union{Tuple{Euclidean{N,𝔽} where 𝔽}, Tuple{N}} where N","page":"Euclidean","title":"ManifoldsBase.representation_size","text":"representation_size(M::Euclidean)\n\nReturn the array dimensions required to represent an element on the Euclidean M, i.e. the vector of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.vector_transport_to-Tuple{Euclidean,Any,Any,Any,AbstractVectorTransportMethod}","page":"Euclidean","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Euclidean, p, X, q, ::AbstractVectorTransportMethod)\n\nTransport the vector X from the tangent space at p to the tangent space at q on the Euclidean M, which simplifies to the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.zero_tangent_vector-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Euclidean, x)\n\nReturn the zero vector in the tangent space of x on the Euclidean M, which here is just a zero filled array the same size as x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#Multinomial-symmetric-matrices","page":"Multinomial symmetric matrices","title":"Multinomial symmetric matrices","text":"","category":"section"},{"location":"manifolds/multinomialsymmetric.html","page":"Multinomial symmetric matrices","title":"Multinomial symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/MultinomialSymmetric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/multinomialsymmetric.html#Manifolds.MultinomialSymmetric","page":"Multinomial symmetric matrices","title":"Manifolds.MultinomialSymmetric","text":"MultinomialSymmetric{n} <: AbstractMultinomialDoublyStochastic{N}\n\nThe multinomial symmetric matrices manifold consists of all symmetric nn matrices with positive entries such that each column sums to one, i.e.\n\nbeginaligned\nmathcalSP(n) coloneqq biglp  ℝ^nn big p_ij  0 text for all  i=1n j=1m\n p^mathrmT = p\n pmathbf1_n = mathbf1_n\nbigr\nendaligned\n\nwhere mathbf1_n is the vector of length n containing ones.\n\nIt is modeled as an DefaultIsometricEmbeddingType, AbstractEmbeddedManifold via the AbstractMultinomialDoublyStochastic type, since it shares a few functions also with AbstractMultinomialDoublyStochastic, most and foremost projection of a point from the embedding onto the manifold.\n\nThe tangent space can be written as\n\nT_pmathcalSP(n) coloneqq bigl\nX  ℝ^nn big X = X^mathrmT text and \nXmathbf1_n = mathbf0_n\nbigr\n\nwhere mathbf0_n is the vector of length n containing zeros.\n\nMore details can be found in Section IV[DouikHassibi2019].\n\nConstructor\n\nMultinomialSymmetric(n)\n\nGenerate the manifold of matrices mathbb R^nn that are doubly stochastic and symmetric.\n\n[DouikHassibi2019]: A. Douik, B. Hassibi: Manifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry, IEEE Transactions on Signal Processing 67(22), pp. 5761–5774, 2019. doi: 10.1109/tsp.2019.2946024, arXiv: 1802.02628.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.check_manifold_point-Union{Tuple{n}, Tuple{MultinomialSymmetric{n},Any}} where n","page":"Multinomial symmetric matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::MultinomialSymmetric, p)\n\nChecks whether p is a valid point on the MultinomialSymmetric(m,n) M, i.e. is a symmetric matrix with positive entries whose rows sum to one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.check_tangent_vector-Union{Tuple{n}, Tuple{MultinomialSymmetric{n},Any,Any}} where n","page":"Multinomial symmetric matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::MultinomialSymmetric p, X; check_base_point = true, kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialSymmetric M. This means, that p is valid, that X is of correct dimension, symmetric, and sums to zero along any row.\n\nThe optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{MultinomialSymmetric{n}}, Tuple{n}} where n","page":"Multinomial symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::MultinomialSymmetric{n}) where {n}\n\nreturns the dimension of the MultinomialSymmetric manifold namely\n\noperatornamedim_mathcalSP(n) = fracn(n-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.project-Tuple{MultinomialSymmetric,Any,Any}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.project","text":"project(M::MultinomialSymmetric{n}, p, Y) where {n}\n\nProject Y onto the tangent space at p on the MultinomialSymmetric M, return the result in X. The formula reads\n\n    operatornameproj_p(Y) = Y - (αmathbf1_n^mathrmT + mathbf1_n α^mathrmT)  p\n\nwhere  denotes the Hadamard or elementwise product and mathbb1_n is the vector of length n containing ones. The two vector α  ℝ^nn is given by solving\n\n    (I_n+p)α =  Ymathbf1\n\nwhere I_n is teh nn unit matrix and mathbf1_n is the vector of length n containing ones.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.retract-Tuple{MultinomialSymmetric,Any,Any,ProjectionRetraction}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.retract","text":"retract(M::MultinomialSymmetric, p, X, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting podotexp(Xp) back onto the manifold, where  are elementwise multiplication and division, respectively. Similarly, exp refers to the elementwise exponentiation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.vector_transport_to-Tuple{MultinomialSymmetric,Any,Any,Any,ProjectionTransport}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::MultinomialSymmetric, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#Literature","page":"Multinomial symmetric matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/centeredmatrices.html#Centered-matrices","page":"Centered matrices","title":"Centered matrices","text":"","category":"section"},{"location":"manifolds/centeredmatrices.html","page":"Centered matrices","title":"Centered matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/CenteredMatrices.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/centeredmatrices.html#Manifolds.CenteredMatrices","page":"Centered matrices","title":"Manifolds.CenteredMatrices","text":"CenteredMatrices{m,n,𝔽} <: AbstractEmbeddedManifold{𝔽,TransparentIsometricEmbedding}\n\nThe manifold of m  n real-valued or complex-valued matrices whose columns sum to zero, i.e.\n\nbigl p  𝔽^m  n big 1  1 * p = 0  0 bigr\n\nwhere 𝔽  ℝℂ.\n\nConstructor\n\nCenteredMatrices(m, n[, field=ℝ])\n\nGenerate the manifold of m-by-n (field-valued) matrices whose columns sum to zero.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{m}, Tuple{CenteredMatrices{m,n,𝔽},Any}} where 𝔽 where n where m","page":"Centered matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::CenteredMatrices{m,n,𝔽}, p; kwargs...)\n\nCheck whether the matrix is a valid point on the CenteredMatrices M, i.e. is an m-by-n matrix whose columns sum to  zero.\n\nThe tolerance for the column sums of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{n}, Tuple{m}, Tuple{CenteredMatrices{m,n,𝔽},Any,Any}} where 𝔽 where n where m","page":"Centered matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::CenteredMatrices{m,n,𝔽}, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the CenteredMatrices M, i.e. that X is a matrix of size (m,n) whose columns sum to zero and its values are from the correct AbstractNumbers. The optional parameter check_base_point indicates, whether to call  check_manifold_point  for p. The tolerance for the column sums of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.manifold_dimension-Union{Tuple{CenteredMatrices{m,n,𝔽}}, Tuple{𝔽}, Tuple{n}, Tuple{m}} where 𝔽 where n where m","page":"Centered matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::CenteredMatrices{m,n,𝔽})\n\nReturn the manifold dimension of the CenteredMatrices m-by-n matrix M over the number system 𝔽, i.e.\n\ndim(mathcal M) = (m*n - n) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.project-Tuple{CenteredMatrices,Any,Any}","page":"Centered matrices","title":"ManifoldsBase.project","text":"project(M::CenteredMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the CenteredMatrices M, i.e.\n\noperatornameproj_p(X) = X - beginbmatrix \n1\n\n1\nendbmatrix * c_1 dots c_n\n\nwhere c_i = frac1msum_j=1^m x_ji  for i = 1 dots n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.project-Tuple{CenteredMatrices,Any}","page":"Centered matrices","title":"ManifoldsBase.project","text":"project(M::CenteredMatrices, p)\n\nProjects p from the embedding onto the CenteredMatrices M, i.e.\n\noperatornameproj_mathcal M(p) = p - beginbmatrix \n1\n\n1\nendbmatrix * c_1 dots c_n\n\nwhere c_i = frac1msum_j=1^m p_ji for i = 1 dots n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Group-manifolds-and-actions","page":"Group manifold","title":"Group manifolds and actions","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Lie groups, groups that are Manifolds with a smooth binary group operation AbstractGroupOperation, are implemented as subtypes of AbstractGroupManifold or by decorating an existing manifold with a group operation using GroupManifold.","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"The common addition and multiplication group operations of AdditionOperation and MultiplicationOperation are provided, though their behavior may be customized for a specific group.","category":"page"},{"location":"manifolds/group.html#Contents","page":"Group manifold","title":"Contents","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Pages = [\"group.md\"]\nDepth = 3","category":"page"},{"location":"manifolds/group.html#Groups","page":"Group manifold","title":"Groups","text":"","category":"section"},{"location":"manifolds/group.html#Group-manifold","page":"Group manifold","title":"Group manifold","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AbstractGroupManifold","page":"Group manifold","title":"Manifolds.AbstractGroupManifold","text":"AbstractGroupManifold{𝔽,O<:AbstractGroupOperation} <: AbstractDecoratorManifold{𝔽}\n\nAbstract type for a Lie group, a group that is also a smooth manifold with an AbstractGroupOperation, a smooth binary operation. AbstractGroupManifolds must implement at least inv, identity, compose, and translate_diff.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.AbstractGroupOperation","page":"Group manifold","title":"Manifolds.AbstractGroupOperation","text":"AbstractGroupOperation\n\nAbstract type for smooth binary operations  on elements of a Lie group mathcalG:\n\n  mathcalG  mathcalG  mathcalG\n\nAn operation can be either defined for a specific AbstractGroupManifold over number system 𝔽 or in general, by defining for an operation Op the following methods:\n\nidentity!(::AbstractGroupManifold{𝔽,Op}, q, q)\nidentity(::AbstractGroupManifold{𝔽,Op}, p)\ninv!(::AbstractGroupManifold{𝔽,Op}, q, p)\ninv(::AbstractGroupManifold{𝔽,Op}, p)\ncompose(::AbstractGroupManifold{𝔽,Op}, p, q)\ncompose!(::AbstractGroupManifold{𝔽,Op}, x, p, q)\n\nNote that a manifold is connected with an operation by wrapping it with a decorator, AbstractGroupManifold. In typical cases the concrete wrapper GroupManifold can be used.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.ActionDirection","page":"Group manifold","title":"Manifolds.ActionDirection","text":"ActionDirection\n\nDirection of action on a manifold, either LeftAction or RightAction.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.AdditionOperation","page":"Group manifold","title":"Manifolds.AdditionOperation","text":"AdditionOperation <: AbstractGroupOperation\n\nGroup operation that consists of simple addition.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.GroupExponentialRetraction","page":"Group manifold","title":"Manifolds.GroupExponentialRetraction","text":"GroupExponentialRetraction{D<:ActionDirection} <: AbstractRetractionMethod\n\nRetraction using the group exponential group_exp \"translated\" to any point on the manifold.\n\nFor more details, see retract.\n\nConstructor\n\nGroupExponentialRetraction(conv::ActionDirection = LeftAction())\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.GroupLogarithmicInverseRetraction","page":"Group manifold","title":"Manifolds.GroupLogarithmicInverseRetraction","text":"GroupLogarithmicInverseRetraction{D<:ActionDirection} <: AbstractInverseRetractionMethod\n\nRetraction using the group logarithm group_log \"translated\" to any point on the manifold.\n\nFor more details, see inverse_retract.\n\nConstructor\n\nGroupLogarithmicInverseRetraction(conv::ActionDirection = LeftAction())\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.GroupManifold","page":"Group manifold","title":"Manifolds.GroupManifold","text":"GroupManifold{𝔽,M<:Manifold{𝔽},O<:AbstractGroupOperation} <: AbstractGroupManifold{𝔽,O}\n\nDecorator for a smooth manifold that equips the manifold with a group operation, thus making it a Lie group. See AbstractGroupManifold for more details.\n\nGroup manifolds by default forward metric-related operations to the wrapped manifold.\n\nConstructor\n\nGroupManifold(manifold, op)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.Identity","page":"Group manifold","title":"Manifolds.Identity","text":"Identity(G::AbstractGroupManifold, p)\n\nThe group identity element e  mathcalG represented by point p.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.LeftAction","page":"Group manifold","title":"Manifolds.LeftAction","text":"LeftAction()\n\nLeft action of a group on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.MultiplicationOperation","page":"Group manifold","title":"Manifolds.MultiplicationOperation","text":"MultiplicationOperation <: AbstractGroupOperation\n\nGroup operation that consists of multiplication.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.RightAction","page":"Group manifold","title":"Manifolds.RightAction","text":"RightAction()\n\nRight action of a group on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Base.identity-Tuple{AbstractGroupManifold,Any}","page":"Group manifold","title":"Base.identity","text":"identity(G::AbstractGroupManifold, p)\n\nIdentity element e  mathcalG, such that for any element p  mathcalG, p circ e = e circ p = p. The returned element is of a similar type to p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Base.inv-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Base.inv","text":"inv(G::AbstractGroupManifold, p)\n\nInverse p^-1  mathcalG of an element p  mathcalG, such that p circ p^-1 = p^-1 circ p = e  mathcalG, where e is the identity element of mathcalG.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.base_group-Tuple{AbstractDecoratorManifold}","page":"Group manifold","title":"Manifolds.base_group","text":"base_group(M::Manifold) -> AbstractGroupManifold\n\nUn-decorate M until an AbstractGroupManifold is encountered. Return an error if the base_manifold is reached without encountering a group.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.compose-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Manifolds.compose","text":"compose(G::AbstractGroupManifold, p, q)\n\nCompose elements pq  mathcalG using the group operation p circ q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_exp-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Manifolds.group_exp","text":"group_exp(G::AbstractGroupManifold, X)\n\nCompute the group exponential of the Lie algebra element X.\n\nGiven an element X  𝔤 = T_e mathcalG, where e is the identity element of the group mathcalG, and 𝔤 is its Lie algebra, the group exponential is the map\n\nexp  𝔤  mathcalG\n\nsuch that for ts  ℝ, γ(t) = exp (t X) defines a one-parameter subgroup with the following properties:\n\nbeginaligned\nγ(t) = γ(-t)^-1\nγ(t + s) = γ(t) circ γ(s) = γ(s) circ γ(t)\nγ(0) = e\nlim_t  0 fracddt γ(t) = X\nendaligned\n\nnote: Note\nIn general, the group exponential map is distinct from the Riemannian exponential map exp.\n\ngroup_exp(G::AbstractGroupManifold{𝔽,AdditionOperation}, X) where {𝔽}\n\nCompute q = X.\n\ngroup_exp(G::AbstractGroupManifold{𝔽,MultiplicationOperation}, X) where {𝔽}\n\nFor Number and AbstractMatrix types of X, compute the usual numeric/matrix exponential,\n\nexp X = operatornameExp X = sum_n=0^ frac1n X^n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_log-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Manifolds.group_log","text":"group_log(G::AbstractGroupManifold, q)\n\nCompute the group logarithm of the group element q.\n\nGiven an element q  mathcalG, compute the right inverse of the group exponential map group_exp, that is, the element log q = X  𝔤 = T_e mathcalG, such that q = exp X\n\nnote: Note\nIn general, the group logarithm map is distinct from the Riemannian logarithm map log.\n\ngroup_log(G::AbstractGroupManifold{𝔽,AdditionOperation}, q) where {𝔽}\n\nCompute X = q.\n\ngroup_log(G::AbstractGroupManifold{𝔽,MultiplicationOperation}, q) where {𝔽}\n\nFor Number and AbstractMatrix types of q, compute the usual numeric/matrix logarithm:\n\nlog q = operatornameLog q = sum_n=1^ frac(-1)^n+1n (q - e)^n\n\nwhere e here is the identity element, that is, 1 for numeric q or the identity matrix I_m for matrix q  ℝ^m  m.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_translate-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Manifolds.inverse_translate","text":"inverse_translate(G::AbstractGroupManifold, p, q)\ninverse_translate(G::AbstractGroupManifold, p, q, conv::ActionDirection=LeftAction())\n\nInverse translate group element q by p with the inverse translation τ_p^-1 with the specified convention, either left (L_p^-1) or right (R_p^-1), defined as\n\nbeginaligned\nL_p^-1  q  p^-1 circ q\nR_p^-1  q  q circ p^-1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_translate_diff-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Manifolds.inverse_translate_diff","text":"inverse_translate_diff(G::AbstractGroupManifold, p, q, X)\ninverse_translate_diff(G::AbstractGroupManifold, p, q, X, conv::ActionDirection=LeftAction())\n\nFor group elements p q  mathcalG and tangent vector X  T_q mathcalG, compute the action on X of the differential of the inverse translation τ_p by p, with the specified left or right convention. The differential transports vectors:\n\n(mathrmdτ_p^-1)_q  T_q mathcalG  T_τ_p^-1 q mathcalG\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.switch_direction-Tuple{ActionDirection}","page":"Group manifold","title":"Manifolds.switch_direction","text":"switch_direction(::ActionDirection)\n\nReturns a RightAction when given a LeftAction and vice versa.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Manifolds.translate","text":"translate(G::AbstractGroupManifold, p, q)\ntranslate(G::AbstractGroupManifold, p, q, conv::ActionDirection=LeftAction()])\n\nTranslate group element q by p with the translation τ_p with the specified convention, either left (L_p) or right (R_p), defined as\n\nbeginaligned\nL_p  q  p circ q\nR_p  q  q circ p\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate_diff-Tuple{AbstractGroupManifold,Vararg{Any,N} where N}","page":"Group manifold","title":"Manifolds.translate_diff","text":"translate_diff(G::AbstractGroupManifold, p, q, X)\ntranslate_diff(G::AbstractGroupManifold, p, q, X, conv::ActionDirection=LeftAction())\n\nFor group elements p q  mathcalG and tangent vector X  T_q mathcalG, compute the action of the differential of the translation τ_p by p on X, with the specified left or right convention. The differential transports vectors:\n\n(mathrmdτ_p)_q  T_q mathcalG  T_τ_p q mathcalG\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.inverse_retract-Tuple{GroupManifold,Any,Any,Manifolds.GroupLogarithmicInverseRetraction}","page":"Group manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(\n    G::AbstractGroupManifold,\n    p,\n    X,\n    method::GroupLogarithmicInverseRetraction{<:ActionDirection},\n)\n\nCompute the inverse retraction using the group logarithm group_log \"translated\" to any point on the manifold. With a group translation (translate) τ_p in a specified direction, the retraction is\n\noperatornameretr_p^-1 = (mathrmdτ_p)_e circ log circ τ_p^-1\n\nwhere log is the group logarithm (group_log), and (mathrmdτ_p)_e is the action of the differential of translation τ_p evaluated at the identity element e (see translate_diff).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.retract-Tuple{AbstractGroupManifold,Any,Any,Manifolds.GroupExponentialRetraction}","page":"Group manifold","title":"ManifoldsBase.retract","text":"retract(\n    G::AbstractGroupManifold,\n    p,\n    X,\n    method::GroupExponentialRetraction{<:ActionDirection},\n)\n\nCompute the retraction using the group exponential group_exp \"translated\" to any point on the manifold. With a group translation (translate) τ_p in a specified direction, the retraction is\n\noperatornameretr_p = τ_p circ exp circ (mathrmdτ_p^-1)_p\n\nwhere exp is the group exponential (group_exp), and (mathrmdτ_p^-1)_p is the action of the differential of inverse translation τ_p^-1 evaluated at p (see inverse_translate_diff).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Product-group","page":"Group manifold","title":"Product group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.ProductGroup-Union{Tuple{ProductManifold{𝔽,TM} where TM<:Tuple}, Tuple{𝔽}} where 𝔽","page":"Group manifold","title":"Manifolds.ProductGroup","text":"ProductGroup{𝔽,T} <: GroupManifold{𝔽,ProductManifold{T},ProductOperation}\n\nDecorate a product manifold with a ProductOperation.\n\nEach submanifold must also be an AbstractGroupManifold or a decorated instance of one. This type is mostly useful for equipping the direct product of group manifolds with an Identity element.\n\nConstructor\n\nProductGroup(manifold::ProductManifold)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.ProductOperation","page":"Group manifold","title":"Manifolds.ProductOperation","text":"ProductOperation <: AbstractGroupOperation\n\nDirect product group operation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Semidirect-product-group","page":"Group manifold","title":"Semidirect product group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/semidirect_product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SemidirectProductGroup-Union{Tuple{𝔽}, Tuple{GroupManifold{𝔽,M,O} where O<:AbstractGroupOperation where M<:Manifold{𝔽},GroupManifold{𝔽,M,O} where O<:AbstractGroupOperation where M<:Manifold{𝔽},AbstractGroupAction}} where 𝔽","page":"Group manifold","title":"Manifolds.SemidirectProductGroup","text":"SemidirectProductGroup(N::GroupManifold, H::GroupManifold, A::AbstractGroupAction)\n\nA group that is the semidirect product of a normal group mathcalN and a subgroup mathcalH, written mathcalG = mathcalN _θ mathcalH, where θ mathcalH  mathcalN  mathcalN is an automorphism action of mathcalH on mathcalN. The group mathcalG has the composition rule\n\ng circ g = (n h) circ (n h) = (n circ θ_h(n) h circ h)\n\nand the inverse\n\ng^-1 = (n h)^-1 = (θ_h^-1(n^-1) h^-1)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.SemidirectProductOperation","page":"Group manifold","title":"Manifolds.SemidirectProductOperation","text":"SemidirectProductOperation(action::AbstractGroupAction)\n\nGroup operation of a semidirect product group. The operation consists of the operation opN on a normal subgroup N, the operation opH on a subgroup H, and an automorphism action of elements of H on N. Only the action is stored.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Circle-group","page":"Group manifold","title":"Circle group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/circle_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.CircleGroup","page":"Group manifold","title":"Manifolds.CircleGroup","text":"CircleGroup <: GroupManifold{Circle{ℂ},MultiplicationOperation}\n\nThe circle group is the complex circle (Circle(ℂ)) equipped with the group operation of complex multiplication (MultiplicationOperation).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Special-orthogonal-group","page":"Group manifold","title":"Special orthogonal group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/special_orthogonal.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SpecialOrthogonal","page":"Group manifold","title":"Manifolds.SpecialOrthogonal","text":"SpecialOrthogonal{n} <: GroupManifold{ℝ,Rotations{n},MultiplicationOperation}\n\nSpecial orthogonal group mathrmSO(n) represented by rotation matrices.\n\nConstructor\n\nSpecialOrthogonal(n)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Translation-group","page":"Group manifold","title":"Translation group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/translation_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.TranslationGroup","page":"Group manifold","title":"Manifolds.TranslationGroup","text":"TranslationGroup{T<:Tuple,𝔽} <: GroupManifold{Euclidean{T,𝔽},AdditionOperation}\n\nTranslation group mathrmT(n) represented by translation arrays.\n\nConstructor\n\nTranslationGroup(n₁,...,nᵢ; field = 𝔽)\n\nGenerate the translation group on 𝔽^n₁nᵢ = Euclidean(n₁,...,nᵢ; field = 𝔽), which is isomorphic to the group itself.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Special-Euclidean-group","page":"Group manifold","title":"Special Euclidean group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/special_euclidean.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SpecialEuclidean","page":"Group manifold","title":"Manifolds.SpecialEuclidean","text":"SpecialEuclidean(n)\n\nSpecial Euclidean group mathrmSE(n), the group of rigid motions.\n\nmathrmSE(n) is the semidirect product of the TranslationGroup on ℝ^n and SpecialOrthogonal(n)\n\nmathrmSE(n)  mathrmT(n) _θ mathrmSO(n)\n\nwhere θ is the canonical action of mathrmSO(n) on mathrmT(n) by vector rotation.\n\nThis constructor is equivalent to calling\n\nTn = TranslationGroup(n)\nSOn = SpecialOrthogonal(n)\nSemidirectProductGroup(Tn, SOn, RotationAction(Tn, SOn))\n\nPoints on mathrmSE(n) may be represented as points on the underlying product manifold mathrmT(n)  mathrmSO(n). For group-specific functions, they may also be represented as affine matrices with size (n + 1, n + 1) (see affine_matrix), for which the group operation is MultiplicationOperation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.affine_matrix-Union{Tuple{n}, Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{n},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{n},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{n},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{n},MultiplicationOperation},LeftAction}}},Any}} where n","page":"Group manifold","title":"Manifolds.affine_matrix","text":"affine_matrix(G::SpecialEuclidean, p) -> AbstractMatrix\n\nRepresent the point p  mathrmSE(n) as an affine matrix. For p = (t R)  mathrmSE(n), where t  mathrmT(n) R  mathrmSO(n), the affine representation is the n + 1  n + 1 matrix\n\nbeginpmatrix\nR  t \n0^mathrmT  1\nendpmatrix\n\nSee also screw_matrix for matrix representations of the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_exp-Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{2},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{2},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{2},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{2},MultiplicationOperation},LeftAction}}},Any}","page":"Group manifold","title":"Manifolds.group_exp","text":"group_exp(G::SpecialEuclidean{2}, X)\n\nCompute the group exponential of X = (b Ω)  𝔰𝔢(2), where b  𝔱(2) and Ω  𝔰𝔬(2):\n\nexp X = (t R) = (U(θ) b exp Ω)\n\nwhere t  mathrmT(2), R = exp Ω is the group exponential on mathrmSO(2),\n\nU(θ) = fracsin θθ I_2 + frac1 - cos θθ^2 Ω\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_exp-Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{3},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{3},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{3},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{3},MultiplicationOperation},LeftAction}}},Any}","page":"Group manifold","title":"Manifolds.group_exp","text":"group_exp(G::SpecialEuclidean{3}, X)\n\nCompute the group exponential of X = (b Ω)  𝔰𝔢(3), where b  𝔱(3) and Ω  𝔰𝔬(3):\n\nexp X = (t R) = (U(θ) b exp Ω)\n\nwhere t  mathrmT(3), R = exp Ω is the group exponential on mathrmSO(3),\n\nU(θ) = I_3 + frac1 - cos θθ^2 Ω + fracθ - sin θθ^3 Ω^2\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_exp-Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{N},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{N},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{N},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{N},MultiplicationOperation},LeftAction}}} where N,Any}","page":"Group manifold","title":"Manifolds.group_exp","text":"group_exp(G::SpecialEuclidean{n}, X)\n\nCompute the group exponential of X = (b Ω)  𝔰𝔢(n), where b  𝔱(n) and Ω  𝔰𝔬(n):\n\nexp X = (t R)\n\nwhere t  mathrmT(n) and R = exp Ω is the group exponential on mathrmSO(n).\n\nIn the screw_matrix representation, the group exponential is the matrix exponential (see group_exp).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_log-Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{2},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{2},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{2},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{2},MultiplicationOperation},LeftAction}}},Any}","page":"Group manifold","title":"Manifolds.group_log","text":"group_log(G::SpecialEuclidean{2}, p)\n\nCompute the group logarithm of p = (t R)  mathrmSE(2), where t  mathrmT(2) and R  mathrmSO(2):\n\nlog p = (b Ω) = (U(θ)^-1 t log R)\n\nwhere b  𝔱(2), Ω = log R  𝔰𝔬(2) is the group logarithm on mathrmSO(2),\n\nU(θ) = fracsin θθ I_2 + frac1 - cos θθ^2 Ω\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_log-Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{3},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{3},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{3},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{3},MultiplicationOperation},LeftAction}}},Any}","page":"Group manifold","title":"Manifolds.group_log","text":"group_log(G::SpecialEuclidean{3}, p)\n\nCompute the group logarithm of p = (t R)  mathrmSE(3), where t  mathrmT(3) and R  mathrmSO(3):\n\nlog p = (b Ω) = (U(θ)^-1 t log R)\n\nwhere b  𝔱(3), Ω = log R  𝔰𝔬(3) is the group logarithm on mathrmSO(3),\n\nU(θ) = I_3 + frac1 - cos θθ^2 Ω + fracθ - sin θθ^3 Ω^2\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_log-Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{N},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{N},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{N},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{N},MultiplicationOperation},LeftAction}}} where N,Any}","page":"Group manifold","title":"Manifolds.group_log","text":"group_log(G::SpecialEuclidean{n}, p) where {n}\n\nCompute the group logarithm of p = (t R)  mathrmSE(n), where t  mathrmT(n) and R  mathrmSO(n):\n\nlog p = (b Ω)\n\nwhere b  𝔱(n) and Ω = log R  𝔰𝔬(n) is the group logarithm on mathrmSO(n).\n\nIn the affine_matrix representation, the group logarithm is the matrix logarithm (see group_log):\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.screw_matrix-Union{Tuple{n}, Tuple{GroupManifold{ℝ,ProductManifold{ℝ,Tuple{GroupManifold{ℝ,Euclidean{Tuple{n},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{n},MultiplicationOperation}}},Manifolds.SemidirectProductOperation{RotationAction{GroupManifold{ℝ,Euclidean{Tuple{n},ℝ},AdditionOperation},GroupManifold{ℝ,Rotations{n},MultiplicationOperation},LeftAction}}},Any}} where n","page":"Group manifold","title":"Manifolds.screw_matrix","text":"screw_matrix(G::SpecialEuclidean, X) -> AbstractMatrix\n\nRepresent the Lie algebra element X  𝔰𝔢(n) = T_e mathrmSE(n) as a screw matrix. For X = (b Ω)  𝔰𝔢(n), where Ω  𝔰𝔬(n) = T_e mathrmSO(n), the screw representation is the n + 1  n + 1 matrix\n\nbeginpmatrix\nΩ  b \n0^mathrmT  0\nendpmatrix\n\nSee also affine_matrix for matrix representations of the Lie group.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Group-actions","page":"Group manifold","title":"Group actions","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AbstractGroupAction","page":"Group manifold","title":"Manifolds.AbstractGroupAction","text":"AbstractGroupAction\n\nAn abstract group action on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.apply!-Tuple{AbstractGroupAction{LeftAction},Any,Any,Any}","page":"Group manifold","title":"Manifolds.apply!","text":"apply!(A::AbstractGroupAction, q, a, p)\n\nApply action a to the point p with the rule specified by A. The result is saved in q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.apply-Tuple{AbstractGroupAction,Any,Any}","page":"Group manifold","title":"Manifolds.apply","text":"apply(A::AbstractGroupAction, a, p)\n\nApply action a to the point p using map τ_a, specified by A. Unless otherwise specified, the right action is defined in terms of the left action:\n\nmathrmR_a = mathrmL_a^-1\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.apply_diff-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.apply_diff","text":"apply_diff(A::AbstractGroupAction, a, p, X)\n\nFor group point p  mathcal M and tangent vector X  T_p mathcal M, compute the action on X of the differential of the action of a  mathcalG, specified by rule A. Written as (mathrmdτ_a)_p, with the specified left or right convention, the differential transports vectors\n\n(mathrmdτ_a)_p  T_p mathcal M  T_τ_a p mathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.base_group-Tuple{AbstractGroupAction}","page":"Group manifold","title":"Manifolds.base_group","text":"base_group(A::AbstractGroupAction)\n\nThe group that acts in action A.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.center_of_orbit","page":"Group manifold","title":"Manifolds.center_of_orbit","text":"center_of_orbit(\n    A::AbstractGroupAction,\n    pts,\n    p,\n    mean_method::AbstractEstimationMethod = GradientDescentEstimation(),\n)\n\nCalculate an action element a of action A that is the mean element of the orbit of p with respect to given set of points pts. The mean is calculated using the method mean_method.\n\nThe orbit of p with respect to the action of a group mathcalG is the set\n\nO =  τ_a p  a  mathcalG \n\nThis function is useful for computing means on quotients of manifolds by a Lie group action.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/group.html#Manifolds.direction-Union{Tuple{AbstractGroupAction{AD}}, Tuple{AD}} where AD","page":"Group manifold","title":"Manifolds.direction","text":"direction(::AbstractGroupAction{AD}) -> AD\n\nGet the direction of the action\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.g_manifold-Tuple{AbstractGroupAction}","page":"Group manifold","title":"Manifolds.g_manifold","text":"g_manifold(A::AbstractGroupAction)\n\nThe manifold the action A acts upon.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply!-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_apply!","text":"inverse_apply!(A::AbstractGroupAction, q, a, p)\n\nApply inverse of action a to the point p with the rule specified by A. The result is saved in q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply-Tuple{AbstractGroupAction,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_apply","text":"inverse_apply(A::AbstractGroupAction, a, p)\n\nApply inverse of action a to the point p. The action is specified by A.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply_diff-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_apply_diff","text":"inverse_apply_diff(A::AbstractGroupAction, a, p, X)\n\nFor group point p  mathcal M and tangent vector X  T_p mathcal M, compute the action on X of the differential of the inverse action of a  mathcalG, specified by rule A. Written as (mathrmdτ_a^-1)_p, with the specified left or right convention, the differential transports vectors\n\n(mathrmdτ_a^-1)_p  T_p mathcal M  T_τ_a^-1 p mathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.optimal_alignment!-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.optimal_alignment!","text":"optimal_alignment!(A::AbstractGroupAction, x, p, q)\n\nCalculate an action element of action A that acts upon p to produce the element closest to q. The result is written to x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.optimal_alignment-Tuple{AbstractGroupAction,Any,Any}","page":"Group manifold","title":"Manifolds.optimal_alignment","text":"optimal_alignment(A::AbstractGroupAction, p, q)\n\nCalculate an action element a of action A that acts upon p to produce the element closest to q in the metric of the G-manifold:\n\nargmin_a  mathcalG d_mathcal M(τ_a p q)\n\nwhere mathcalG is the group that acts on the G-manifold mathcal M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Group-operation-action","page":"Group manifold","title":"Group operation action","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group_operation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.GroupOperationAction","page":"Group manifold","title":"Manifolds.GroupOperationAction","text":"GroupOperationAction(group::AbstractGroupManifold, AD::ActionDirection = LeftAction())\n\nAction of a group upon itself via left or right translation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Rotation-action","page":"Group manifold","title":"Rotation action","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/rotation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.RotationAction","page":"Group manifold","title":"Manifolds.RotationAction","text":"RotationAction(\n    M::Manifold,\n    SOn::SpecialOrthogonal,\n    AD::ActionDirection = LeftAction(),\n)\n\nSpace of actions of the SpecialOrthogonal group mathrmSO(n) on a Euclidean-like manifold M of dimension n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Translation-action","page":"Group manifold","title":"Translation action","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/translation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.TranslationAction","page":"Group manifold","title":"Manifolds.TranslationAction","text":"TranslationAction(\n    M::Manifold,\n    Rn::TranslationGroup,\n    AD::ActionDirection = LeftAction(),\n)\n\nSpace of actions of the TranslationGroup mathrmT(n) on a Euclidean-like manifold M.\n\nThe left and right actions are equivalent.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Invariant-metrics","page":"Group manifold","title":"Invariant metrics","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/metric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.InvariantMetric","page":"Group manifold","title":"Manifolds.InvariantMetric","text":"InvariantMetric{G<:Metric,D<:ActionDirection} <: Metric\n\nExtend a metric on the Lie algebra of an AbstractGroupManifold to the whole group via translation in the specified direction.\n\nGiven a group mathcalG and a left- or right group translation map τ on the group, a metric g is τ-invariant if it has the inner product\n\ng_p(X Y) = g_τ_q p((mathrmdτ_q)_p X (mathrmdτ_q)_p Y)\n\nfor all pq  mathcalG and XY  T_p mathcalG, where (mathrmdτ_q)_p is the differential of translation by q evaluated at p (see translate_diff).\n\nInvariantMetric constructs an (assumed) τ-invariant metric by extending the inner product of a metric h_e on the Lie algebra to the whole group:\n\ng_p(X Y) = h_e((mathrmdτ_p^-1)_p X (mathrmdτ_p^-1)_p Y)\n\nwarning: Warning\nThe invariance condition is not checked and must be verified for the entire group. To verify the condition for a set of points numerically, use has_approx_invariant_metric.\n\nThe convenient aliases LeftInvariantMetric and RightInvariantMetric are provided.\n\nConstructor\n\nInvariantMetric(metric::Metric, conv::ActionDirection = LeftAction())\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.LeftInvariantMetric-Tuple{Any}","page":"Group manifold","title":"Manifolds.LeftInvariantMetric","text":"LeftInvariantMetric(metric::Metric)\n\nAlias for a left-InvariantMetric.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.RightInvariantMetric-Tuple{Any}","page":"Group manifold","title":"Manifolds.RightInvariantMetric","text":"RightInvariantMetric(metric::Metric)\n\nAlias for a right-InvariantMetric.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.biinvariant_metric_dispatch-Tuple{Manifold}","page":"Group manifold","title":"Manifolds.biinvariant_metric_dispatch","text":"biinvariant_metric_dispatch(G::AbstractGroupManifold) -> Val\n\nReturn Val(true) if the metric on the manifold is bi-invariant, that is, if the metric is both left- and right-invariant (see invariant_metric_dispatch).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.has_approx_invariant_metric-Tuple{AbstractGroupManifold,Any,Any,Any,Any,ActionDirection}","page":"Group manifold","title":"Manifolds.has_approx_invariant_metric","text":"has_approx_invariant_metric(\n    G::AbstractGroupManifold,\n    p,\n    X,\n    Y,\n    qs::AbstractVector,\n    conv::ActionDirection = LeftAction();\n    kwargs...,\n) -> Bool\n\nCheck whether the metric on the group mathcalG is (approximately) invariant using a set of predefined points. Namely, for p  mathcalG, XY  T_p mathcalG, a metric g, and a translation map τ_q in the specified direction, check for each q  mathcalG that the following condition holds:\n\ng_p(X Y)  g_τ_q p((mathrmdτ_q)_p X (mathrmdτ_q)_p Y)\n\nThis is necessary but not sufficient for invariance.\n\nOptionally, kwargs passed to isapprox may be provided.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.invariant_metric_dispatch-Tuple{MetricManifold,ActionDirection}","page":"Group manifold","title":"Manifolds.invariant_metric_dispatch","text":"invariant_metric_dispatch(G::AbstractGroupManifold, conv::ActionDirection) -> Val\n\nReturn Val(true) if the metric on the group mathcalG is invariant under translations by the specified direction, that is, given a group mathcalG, a left- or right group translation map τ, and a metric g_e on the Lie algebra, a τ-invariant metric at any point p  mathcalG is defined as a metric with the inner product\n\ng_p(X Y) = g_τ_q p((mathrmdτ_q)_p X (mathrmdτ_q)_p Y)\n\nfor XY  T_q mathcalG and all q  mathcalG, where (mathrmdτ_q)_p is the differential of translation by q evaluated at p (see translate_diff).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Metric-manifold","page":"Metric manifold","title":"Metric manifold","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"A Riemannian manifold always consists of a topological manifold together with a smoothly varying metric g.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"However, often there is an implicitly assumed (default) metric, like the usual inner product on Euclidean space. This decorator takes this into account. It is not necessary to use this decorator if you implement just one (or the first) metric. If you later introduce a second, the old (first) metric can be used with the (non MetricManifold) Manifold, i.e. without an explicitly stated metric.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"This manifold decorator serves two purposes:","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"to implement different metrics (e.g. in closed form) for one Manifold\nto provide a way to compute geodesics on manifolds, where this Metric does not yield closed formula.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Let's first look at the provided types.","category":"page"},{"location":"manifolds/metric.html#Types","page":"Metric manifold","title":"Types","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/MetricManifold.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/metric.html#Manifolds.Metric","page":"Metric manifold","title":"Manifolds.Metric","text":"Metric\n\nAbstract type for the pseudo-Riemannian metric tensor g, a family of smoothly varying inner products on the tangent space. See inner.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.MetricManifold","page":"Metric manifold","title":"Manifolds.MetricManifold","text":"MetricManifold{𝔽,M<:Manifold{𝔽},G<:Metric} <: AbstractDecoratorManifold{𝔽}\n\nEquip a Manifold explicitly with a Metric G.\n\nFor a Metric Manifold, by default, assumes, that you implement the linear form from local_metric in order to evaluate the exponential map.\n\nIf the corresponding Metric G yields closed form formulae for e.g. the exponential map and this is implemented directly (without solving the ode), you can of course still implement that directly.\n\nConstructor\n\nMetricManifold(M, G)\n\nGenerate the Manifold M as a manifold with the Metric G.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.RiemannianMetric","page":"Metric manifold","title":"Manifolds.RiemannianMetric","text":"RiemannianMetric <: Metric\n\nAbstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for X   T_p mathcal M, the inner product g(X X)  0 whenever X is not the zero vector.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Implement-Different-Metrics-on-the-same-Manifold","page":"Metric manifold","title":"Implement Different Metrics on the same Manifold","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"In order to distinguish different metrics on one manifold, one can introduce two Metrics and use this type to dispatch on the metric, see SymmetricPositiveDefinite. To avoid overhead, one Metric can then be marked as being the default, i.e. the one that is used, when no MetricManifold decorator is present. This avoids reimplementation of the first existing metric, access to the metric-dependent functions that were implemented using the undecorated manifold, as well as the transparent fallback of the corresponding MetricManifold with default metric to the undecorated implementations. This does not cause any runtime overhead. Introducing a default Metric serves a better readability of the code when working with different metrics.","category":"page"},{"location":"manifolds/metric.html#Implementation-of-Metrics","page":"Metric manifold","title":"Implementation of Metrics","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"For the case that a local_metric is implemented as a bilinear form that is positive definite, the following further functions are provided, unless the corresponding Metric is marked as default – then the fallbacks mentioned in the last section are used for e.g. the exp!onential map.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/MetricManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/metric.html#Base.exp-Tuple{MetricManifold,Vararg{Any,N} where N}","page":"Metric manifold","title":"Base.exp","text":"exp(N::MetricManifold{M,G}, p, X)\n\nCopute the exponential map on the Manifold M equipped with the Metric G.\n\nIf the metric was declared the default metric using is_default_metric, this method falls back to exp(M,p,X).\n\nOtherwise it numerically integrates the underlying ODE, see solve_exp_ode. Currently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Base.log-Tuple{MetricManifold,Vararg{Any,N} where N}","page":"Metric manifold","title":"Base.log","text":"log(N::MetricManifold{M,G}, p, q)\n\nCopute the logarithmic map on the Manifold M equipped with the Metric G.\n\nIf the metric was declared the default metric using is_default_metric, this method falls back to log(M,p,q). Otherwise, you have to provide an implementation for the non-default Metric G metric within its MetricManifold{M,G}.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_first-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_first","text":"christoffel_symbols_first(\n    M::MetricManifold,\n    p;\n    backend::AbstractDiffBackend = diff_backend(),\n)\n\nCompute the Christoffel symbols of the first kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nΓ_ijk = frac12 Biglg_kji + g_ikj - g_ijkBigr\n\nwhere g_ijk=frac p^k g_ij is the coordinate derivative of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_second-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_second","text":"christoffel_symbols_second(\n    M::MetricManifold,\n    x;\n    backend::AbstractDiffBackend = diff_backend(),\n)\n\nCompute the Christoffel symbols of the second kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nΓ^l_ij = g^kl Γ_ijk\n\nwhere Γ_ijk are the Christoffel symbols of the first kind, and g^kl is the inverse of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (lij).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_second_jacobian-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_second_jacobian","text":"christoffel_symbols_second_jacobian(\n    M::MetricManifold,\n    p;\n    backend::AbstractDiffBackend = diff_backend(),\n)\n\nGet partial derivatives of the Christoffel symbols of the second kind for manifold M at p with respect to the coordinates of p, frac p^l Γ^k_ij = Γ^k_ijl The dimensions of the resulting multi-dimensional array are ordered (ijkl).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.det_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.det_local_metric","text":"det_local_metric(M::MetricManifold, p)\n\nReturn the determinant of local matrix representation of the metric tensor g.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.einstein_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.einstein_tensor","text":"einstein_tensor(M::MetricManifold, p; backend::AbstractDiffBackend = diff_backend())\n\nCompute the Einstein tensor of the manifold M at the point p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.flat-Tuple{MetricManifold,Vararg{Any,N} where N}","page":"Metric manifold","title":"Manifolds.flat","text":"flat(N::MetricManifold{M,G}, p, X::FVector{TangentSpaceType})\n\nCompute the musical isomorphism to transform the tangent vector X from the Manifold M equipped with Metric G to a cotangent by computing\n\nX^= G_p X\n\nwhere G_p is the local matrix representation of G, see local_metric\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.gaussian_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.gaussian_curvature","text":"gaussian_curvature(M::MetricManifold, x; backend::AbstractDiffBackend = diff_backend())\n\nCompute the Gaussian curvature of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.inverse_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.inverse_local_metric","text":"inverse_local_metric(M::MetricManifold, p)\n\nReturn the local matrix representation of the inverse metric (cometric) tensor, usually written g^ij.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.is_default_metric-Tuple{Manifold,Metric}","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(M,G)\n\nIndicate whether the Metric G is the default metric for the Manifold M. This means that any occurence of MetricManifold(M,G) where typeof(is_default_metric(M,G)) = true falls back to just be called with M such that the Manifold M implicitly has this metric, for example if this was the first one implemented or is the one most commonly assumed to be used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.is_default_metric-Tuple{MetricManifold}","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(MM::MetricManifold)\n\nIndicate whether the Metric MM.G is the default metric for the Manifold MM.manifold, within the MetricManifold MM. This means that any occurence of MetricManifold(MM.manifold, MM.G) where is_default_metric(MM.manifold, MM.G)) = true falls back to just be called with MM.manifold, such that the Manifold MM.manifold implicitly has the metric MM.G, for example if this was the first one implemented or is the one most commonly assumed to be used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.local_metric","text":"local_metric(M::MetricManifold, p)\n\nReturn the local matrix representation at the point p of the metric tensor g on the Manifold M, usually written g_ij. The matrix has the property that g(X Y)=X^mathrmT g_ij Y = g_ij X^i Y^j, where the latter expression uses Einstein summation convention.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric_jacobian-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.local_metric_jacobian","text":"local_metric_jacobian(\n    M::MetricManifold,\n    p;\n    backend::AbstractDiffBackend = diff_backend(),\n)\n\nGet partial derivatives of the local metric of M at p with respect to the coordinates of p, frac p^k g_ij = g_ijk. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.log_local_metric_density-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.log_local_metric_density","text":"log_local_metric_density(M::MetricManifold, p)\n\nReturn the natural logarithm of the metric density ρ of M at p, which is given by ρ = log sqrtdet g_ij.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.metric-Tuple{MetricManifold}","page":"Metric manifold","title":"Manifolds.metric","text":"metric(M::MetricManifold)\n\nGet the metric g of the manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_curvature","text":"ricci_curvature(M::MetricManifold, p; backend::AbstractDiffBackend = diff_backend())\n\nCompute the Ricci scalar curvature of the manifold M at the point p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_tensor","text":"ricci_tensor(M::MetricManifold, p; backend::AbstractDiffBackend = diff_backend())\n\nCompute the Ricci tensor, also known as the Ricci curvature tensor, of the manifold M at the point p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.riemann_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.riemann_tensor","text":"riemann_tensor(M::MetricManifold, p; backend::AbstractDiffBackend = diff_backend())\n\nCompute the Riemann tensor R^l_ijk, also known as the Riemann curvature tensor, at the point p. The dimensions of the resulting multi-dimensional array are ordered (lijk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.sharp-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.sharp","text":"sharp(N::MetricManifold{M,G}, p, ξ::FVector{CotangentSpaceType})\n\nCompute the musical isomorphism to transform the cotangent vector ξ from the Manifold M equipped with Metric G to a tangent by computing\n\nξ^ = G_p^-1 ξ\n\nwhere G_p is the local matrix representation of G, i.e. one employs inverse_local_metric here to obtain G_p^-1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.solve_exp_ode-NTuple{4,Any}","page":"Metric manifold","title":"Manifolds.solve_exp_ode","text":"solve_exp_ode(\n    M::MetricManifold,\n    p,\n    X,\n    tspan;\n    backend::AbstractDiffBackend = diff_backend(),\n    solver = AutoVern9(Rodas5()),\n    kwargs...,\n)\n\nApproximate the exponential map on the manifold over the provided timespan assuming the Levi-Civita connection by solving the ordinary differential equation\n\nfracd^2dt^2 p^k + Γ^k_ij fracddt p_i fracddt p_j = 0\n\nwhere Γ^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed. The arguments tspan and solver follow the OrdinaryDiffEq conventions. kwargs... specify keyword arguments that will be passed to OrdinaryDiffEq.solve.\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\nnote: Note\nThis function only works for Julia 1.1 or greater, when OrdinaryDiffEq.jl is loaded withusing OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#ManifoldsBase.inner-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"ManifoldsBase.inner","text":"inner(N::MetricManifold{M,G}, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on the Manifold M using the Metric G. If G is the default metric (see is_default_metric) this is done using inner(M, p, X, Y), otherwise the local_metric(M, p) is employed as\n\ng_p(X Y) = X G_p Y\n\nwhere G_p is the loal matrix representation of the Metric G.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#Symmetric-matrices","page":"Symmetric matrices","title":"Symmetric matrices","text":"","category":"section"},{"location":"manifolds/symmetric.html","page":"Symmetric matrices","title":"Symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/Symmetric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetric.html#Manifolds.SymmetricMatrices","page":"Symmetric matrices","title":"Manifolds.SymmetricMatrices","text":"SymmetricMatrices{n,𝔽} <: AbstractEmbeddedManifold{𝔽,TransparentIsometricEmbedding}\n\nThe Manifold $ \\operatorname{Sym}(n)$ consisting of the real- or complex-valued symmetric matrices of size n  n, i.e. the set\n\noperatornameSym(n) = biglp   𝔽^n  n big p^mathrmH = p bigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ.\n\nThough it is slightly redundant, usually the matrices are stored as n  n arrays.\n\nNote that in this representation, the complex valued case has to have a real-valued diagonal, which is also reflected in the manifold_dimension.\n\nConstructor\n\nSymmetricMatrices(n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of n  n symmetric matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{SymmetricMatrices{n,𝔽},Any}} where 𝔽 where n","page":"Symmetric matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SymmetricMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether p is a valid manifold point on the SymmetricMatrices M, i.e. whether p is a symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽.\n\nThe tolerance for the symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{n}, Tuple{SymmetricMatrices{n,𝔽},Any,Any}} where 𝔽 where n","page":"Symmetric matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SymmetricMatrices{n,𝔽}, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SymmetricMatrices M, i.e. X has to be a symmetric matrix of size (n,n) and its values have to be from the correct AbstractNumbers. The optional parameter check_base_point indicates, whether to call  check_manifold_point  for p. The tolerance for the symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricMatrices{N,𝔽}}, Tuple{𝔽}, Tuple{N}} where 𝔽 where N","page":"Symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricMatrices{n,𝔽})\n\nReturn the dimension of the SymmetricMatrices matrix M over the number system 𝔽, i.e.\n\nbeginaligned\ndim mathrmSym(nℝ) = fracn(n+1)2\ndim mathrmSym(nℂ) = 2fracn(n+1)2 - n = n^2\nendaligned\n\nwhere the last -n is due to the zero imaginary part for Hermitian matrices\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project-Tuple{SymmetricMatrices,Any,Any}","page":"Symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SymmetricMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SymmetricMatrices M,\n\noperatornameproj_p(X) = frac12 bigl( X + X^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project-Tuple{SymmetricMatrices,Any}","page":"Symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SymmetricMatrices, p)\n\nProjects p from the embedding onto the SymmetricMatrices M, i.e.\n\noperatornameproj_operatornameSym(n)(p) = frac12 bigl( p + p^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Grassmannian-manifold","page":"Grassmann","title":"Grassmannian manifold","text":"","category":"section"},{"location":"manifolds/grassmann.html","page":"Grassmann","title":"Grassmann","text":"Modules = [Manifolds]\nPages = [\"manifolds/Grassmann.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/grassmann.html#Manifolds.Grassmann","page":"Grassmann","title":"Manifolds.Grassmann","text":"Grassmann{n,k,𝔽} <: AbstractEmbeddedManifold{𝔽,DefaultIsometricEmbeddingType}\n\nThe Grassmann manifold operatornameGr(nk) consists of all subspaces spanned by k linear independent vectors 𝔽^n, where 𝔽   ℝ ℂ is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of ℝ^n for the real-valued case and all 2k-dimensional subspaces of ℂ^n for the second.\n\nThe manifold can be represented as\n\noperatornameGr(nk) = bigl operatornamespan(p)  p  𝔽^n  k p^mathrmHp = I_k\n\nwhere cdot^mathrmH denotes the complex conjugate transpose or Hermitian and I_k is the k  k identity matrix. This means, that the columns of p form an unitary basis of the subspace, that is a point on operatornameGr(nk), and hence the subspace can actually be represented by a whole equivalence class of representers. Another interpretation is, that\n\noperatornameGr(nk) = operatornameSt(nk)  operatornameO(k)\n\ni.e the Grassmann manifold is the quotient of the Stiefel manifold and the orthogonal group operatornameO(k) of orthogonal k  k matrices.\n\nThe tangent space at a point (subspace) x is given by\n\nT_xmathrmGr(nk) = bigl\nX  𝔽^n  k \nX^mathrmHp + p^mathrmHX = 0_k bigr\n\nwhere 0_k denotes the k  k zero matrix.\n\nNote that a point p  operatornameGr(nk) might be represented by different matrices (i.e. matrices with unitary column vectors that span the same subspace). Different representations of p also lead to different representation matrices for the tangent space T_pmathrmGr(nk)\n\nThe manifold is named after Hermann G. Graßmann (1809-1877).\n\nConstructor\n\nGrassmann(n,k,field=ℝ)\n\nGenerate the Grassmann manifold operatornameGr(nk), where the real-valued case field = ℝ is the default.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann.html#Base.exp-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmann","title":"Base.exp","text":"exp(M::Grassmann, p, X)\n\nCompute the exponential map on the Grassmann M= mathrmGr(nk) starting in p with tangent vector (direction) X. Let X = USV denote the SVD decomposition of X. Then the exponential map is written using\n\nz = p Vcos(S)V^mathrmH + Usin(S)V^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian and the cosine and sine are applied element wise to the diagonal entries of S. A final QR decomposition z=QR is performed for numerical stability reasons, yielding the result as\n\nexp_p X = Q\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Base.log-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmann","title":"Base.log","text":"log(M::Grassmann, p, q)\n\nCompute the logarithmic map on the Grassmann M$ = \\mathcal M=\\mathrm{Gr}(n,k)$, i.e. the tangent vector X whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = Vcdot operatornameatan(S) cdot U^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian. The matrices U and V are the unitary matrices, and S is the diagonal matrix containing the singular values of the SVD-decomposition\n\nUSV = (q^mathrmHp)^-1 ( q^mathrmH - q^mathrmHpp^mathrmH)\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Manifolds.uniform_distribution-Union{Tuple{k}, Tuple{n}, Tuple{Grassmann{n,k,ℝ},Any}} where k where n","page":"Grassmann","title":"Manifolds.uniform_distribution","text":"uniform_distribution(M::Grassmann{n,k,ℝ}, p)\n\nUniform distribution on given (real-valued) Grassmann M. Specifically, this is the normalized Haar measure on M. Generated points will be of similar type as p.\n\nThe implementation is based on Section 2.5.1 in [Chikuse2003]; see also Theorem 2.2.2(iii) in [Chikuse2003].\n\n[Chikuse2003]: Y. Chikuse: \"Statistics on Special Manifolds\", Springer New York, 2003, doi: 10.1007/978-0-387-21540-2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{Grassmann{n,k,𝔽},Any}} where 𝔽 where k where n","page":"Grassmann","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Grassmann{n,k,𝔽}, p)\n\nCheck whether p is representing a point on the Grassmann M, i.e. its a n-by-k matrix of unitary column vectors and of correct eltype with respect to 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{Grassmann{n,k,𝔽},Any,Any}} where 𝔽 where k where n","page":"Grassmann","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Grassmann{n,k,𝔽}, p, X; check_base_point = true, kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the Grassmann M, i.e. that X is of size and type as well as that\n\n    p^mathrmHX + X^mathrmHp = 0_k\n\nwhere cdot^mathrmH denotes the complex conjugate transpose or Hermitian and 0_k denotes the k  k zero natrix. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.distance-Tuple{Grassmann,Any,Any}","page":"Grassmann","title":"ManifoldsBase.distance","text":"distance(M::Grassmann, p, q)\n\nCompute the Riemannian distance on Grassmann manifold M= mathrmGr(nk).\n\nLet USV = p^mathrmHq denote the SVD decomposition of p^mathrmHq, where cdot^mathrmH denotes the complex conjugate transposed or Hermitian. Then the distance is given by\n\nd_mathrmGr(nk)(pq) = operatornamenorm(operatornameRe(b))\n\nwhere\n\nb_i=begincases\n0  textif  S_i  1\narccos(S_i)   textif  S_i1\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.injectivity_radius-Tuple{Grassmann}","page":"Grassmann","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Grassmann)\ninjectivity_radius(M::Grassmann, p)\n\nReturn the injectivity radius on the Grassmann M, which is fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inner-Tuple{Grassmann,Any,Any,Any}","page":"Grassmann","title":"ManifoldsBase.inner","text":"inner(M::Grassmann, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the Grassmann manifold M. The formula reads\n\ng_p(XY) = operatornametr(X^mathrmHY)\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract-Tuple{Grassmann,Any,Any,PolarInverseRetraction}","page":"Grassmann","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Grassmann, p, q, ::PolarInverseRetraction)\n\nCompute the inverse retraction for the PolarRetraction, on the Grassmann manifold M, i.e.,\n\noperatornameretr_p^-1q = q*(p^mathrmHq)^-1 - p\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract-Tuple{Grassmann,Any,Any,QRInverseRetraction}","page":"Grassmann","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, p, q, ::QRInverseRetraction)\n\nCompute the inverse retraction for the QRRetraction, on the Grassmann manifold M, i.e.,\n\noperatornameretr_p^-1q = q(p^mathrmHq)^-1 - p\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.manifold_dimension-Union{Tuple{Grassmann{n,k,𝔽}}, Tuple{𝔽}, Tuple{k}, Tuple{n}} where 𝔽 where k where n","page":"Grassmann","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Grassmann)\n\nReturn the dimension of the Grassmann(n,k,𝔽) manifold M, i.e.\n\ndim operatornameGr(nk) = k(n-k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.project-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmann","title":"ManifoldsBase.project","text":"project(M::Grassmann, p, X)\n\nProject the n-by-k X onto the tangent space of p on the Grassmann M, which is computed by\n\noperatornameproj_p(X) = X - pp^mathrmHX\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.representation_size-Union{Tuple{Grassmann{n,k,𝔽} where 𝔽}, Tuple{k}, Tuple{n}} where k where n","page":"Grassmann","title":"ManifoldsBase.representation_size","text":"representation_size(M::Grassmann{n,k})\n\nReturn the represenation size or matrix dimension of a point on the Grassmann M, i.e. (nk) for both the real-valued and the complex value case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.retract-Tuple{Grassmann,Any,Any,PolarRetraction}","page":"Grassmann","title":"ManifoldsBase.retract","text":"retract(M::Grassmann, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Grassmann M. With USV = p + X the retraction reads\n\noperatornameretr_p X = UV^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.retract-Tuple{Grassmann,Any,Any,QRRetraction}","page":"Grassmann","title":"ManifoldsBase.retract","text":"retract(M::Grassmann, p, X, ::QRRetraction )\n\nCompute the QR-based retraction QRRetraction on the Grassmann M. With QR = p + X the retraction reads\n\noperatornameretr_p X = QD\n\nwhere D is a m  n matrix with\n\nD = operatornamediag( operatornamesgn(R_ii+05)_i=1^n )\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.vector_transport_to-Tuple{Grassmann,Any,Any,Any,ProjectionTransport}","page":"Grassmann","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Grassmann,p,X,q,::ProjectionTransport)\n\ncompute the projection based transport on the Grassmann M by interpreting X from the tangent space at p as a point in the embedding and projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.zero_tangent_vector-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmann","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Grassmann, p)\n\nReturn the zero tangent vector from the tangent space at p on the Grassmann M, which is given by a zero matrix the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Statistics.mean-Tuple{Grassmann{n,k,𝔽} where 𝔽 where k where n,Vararg{Any,N} where N}","page":"Grassmann","title":"Statistics.mean","text":"mean(\n    M::Grassmann,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Power-manifold","page":"Power manifold","title":"Power manifold","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"A power manifold is based on a Manifold mathcal M to build a mathcal M^n_1 times n_2 times cdots times n_m. In the case where m=1 we can represent a manifold-valued vector of data of length n_1, for example a time series. The case where m=2 is useful for representing manifold-valued matrices of data of size n_1 times n_2, for example certain types of images.","category":"page"},{"location":"manifolds/power.html#Example","page":"Power manifold","title":"Example","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"There are two ways to store the data: in a multidimensional array or in a nested array.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"Let's look at an example for both. Let mathcal M be Sphere(2) the 2-sphere and we want to look at vectors of length 4.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"For the default, the ArrayPowerRepresentation, we store the data in a multidimensional array,","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), 4)\np = cat([1.0, 0.0, 0.0],\n        [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n        [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n        [0.0, 1.0, 0.0]\n    ,dims=2)","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"which is a valid point i.e.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"is_manifold_point(M, p)","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"This can also be used in combination with HybridArrays.jl and StaticArrays.jl, by setting","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using HybridArrays, StaticArrays\nq = HybridArray{Tuple{3,StaticArrays.Dynamic()},Float64,2}(p)","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"which is still a valid point on M and PowerManifold works with these, too.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"An advantage of this representation is that it is quite efficient, especially when a HybridArray (from the HybridArrays.jl package) is used to represent a point on the power manifold. A disadvantage is not being able to easily identify parts of the multidimensional array that correspond to a single point on the base manifold. Another problem is, that accessing a single point is p[:, 1] which might be unintuitive.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"For the NestedPowerRepresentation we can now do","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), NestedPowerRepresentation(), 4)\np = [ [1.0, 0.0, 0.0],\n      [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n      [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n      [0.0, 1.0, 0.0],\n    ]","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"which is again a valid point so is_manifold_point(M, p) here also yields true. A disadvantage might be that with nested arrays one loses a little bit of performance. The data however is nicely encapsulated. Accessing the first data item is just p[1].","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"For accessing points on power manifolds in both representations you can use get_component and set_component! functions. They work work both point representations.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), NestedPowerRepresentation(), 4)\np = [ [1.0, 0.0, 0.0],\n      [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n      [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n      [0.0, 1.0, 0.0],\n    ]\nset_component!(M, p, [0.0, 0.0, 1.0], 4)\nget_component(M, p, 4)","category":"page"},{"location":"manifolds/power.html#Types-and-Functions","page":"Power manifold","title":"Types and Functions","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/PowerManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/power.html#Manifolds.AbstractPowerManifold","page":"Power manifold","title":"Manifolds.AbstractPowerManifold","text":"AbstractPowerManifold{𝔽,M,TPR} <: Manifold{𝔽}\n\nAn abstract Manifold to represent manifolds that are build as powers of another Manifold M with representation type TPR, a subtype of AbstractPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.AbstractPowerRepresentation","page":"Power manifold","title":"Manifolds.AbstractPowerRepresentation","text":"AbstractPowerRepresentation\n\nAn abstract representation type of points and tangent vectors on a power manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.ArrayPowerRepresentation","page":"Power manifold","title":"Manifolds.ArrayPowerRepresentation","text":"ArrayPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using multidimensional arrays where first dimensions are equal to representation_size of the wrapped manifold and the following ones are equal to the number of elements in each direction.\n\nTorus uses this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.InversePowerRetraction","page":"Power manifold","title":"Manifolds.InversePowerRetraction","text":"InversePowerRetraction(inverse_retractions::AbstractInverseRetractionMethod...)\n\nPower inverse retraction of inverse_retractions. Works on AbstractPowerManifolds.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.NestedPowerRepresentation","page":"Power manifold","title":"Manifolds.NestedPowerRepresentation","text":"NestedPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nGraphManifold uses this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerBasisData","page":"Power manifold","title":"Manifolds.PowerBasisData","text":"PowerBasisData{TB<:AbstractArray}\n\nData storage for an array of basis data.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerFVectorDistribution","page":"Power manifold","title":"Manifolds.PowerFVectorDistribution","text":"PowerFVectorDistribution([type::VectorBundleFibers], [x], distr)\n\nGenerates a random vector at a point from vector space (a fiber of a tangent bundle) of type type using the power distribution of distr.\n\nVector space type and point can be automatically inferred from distribution distr.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerManifold","page":"Power manifold","title":"Manifolds.PowerManifold","text":"PowerManifold{𝔽,TM<:Manifold,TSize<:Tuple,TPR<:AbstractPowerRepresentation} <: AbstractPowerManifold{𝔽,TM}\n\nThe power manifold mathcal M^n_1 n_2    n_d with power geometry  TSize statically defines the number of elements along each axis.\n\nFor example, a manifold-valued time series would be represented by a power manifold with d equal to 1 and n_1 equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (d=2) with n_1 and n_2 equal to width and height of the image.\n\nWhile the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays. Operations on small power manifolds might be faster if they are represented as ProductManifold.\n\nConstructor\n\nPowerManifold(M, N_1, N_2, ..., N_d)\nPowerManifold(M, NestedPowerRepresentation(), N_1, N_2, ..., N_d)\nM^(N_1, N_2, ..., N_d)\n\nGenerate the power manifold M^N_1  N_2    N_d. By default, the ArrayPowerRepresentation of points and tangent vectors is used, although a different one, for example NestedPowerRepresentation, can be given as the second argument to the constructor. When M is a PowerManifold (not any AbstractPowerManifold) itself, given dimensions will be appended to the dimensions already present, for example PowerManifold(PowerManifold(Sphere(2), 2), 3) is equivalent to PowerManifold(Sphere(2), 2, 3). This feature preserves the representation of the inner power manifold (unless it's explicitly overridden).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerMetric","page":"Power manifold","title":"Manifolds.PowerMetric","text":"PowerMetric <: Metric\n\nRepresent the Metric on an AbstractPowerManifold, i.e. the inner product on the tangent space is the sum of the inner product of each elements tangent space of the power manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerPointDistribution","page":"Power manifold","title":"Manifolds.PowerPointDistribution","text":"PowerPointDistribution(M::AbstractPowerManifold, distribution)\n\nPower distribution on manifold M, based on distribution.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerRetraction","page":"Power manifold","title":"Manifolds.PowerRetraction","text":"PowerRetraction(retraction::AbstractRetractionMethod)\n\nPower retraction based on retraction. Works on AbstractPowerManifolds.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerVectorTransport","page":"Power manifold","title":"Manifolds.PowerVectorTransport","text":"PowerVectorTransport(method::AbstractVectorTransportMethod)\n\nPower vector transport method based on method. Works on AbstractPowerManifolds.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Base.exp-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Base.exp","text":"exp(M::AbstractPowerManifold, p, X)\n\nCompute the exponential map from p in direction X on the AbstractPowerManifold M, which can be computed using the base manifolds exponential map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Base.getindex-Tuple{AbstractArray,AbstractPowerManifold,Vararg{Union{Colon, Integer, AbstractArray{T,1} where T},N} where N}","page":"Power manifold","title":"Base.getindex","text":"getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\np[M::AbstractPowerManifold, i...]\n\nAccess the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Base.log-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Base.log","text":"log(M::AbstractPowerManifold, p, q)\n\nCompute the logarithmic map from p to q on the AbstractPowerManifold M, which can be computed using the base manifolds logarithmic map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Base.setindex!-Tuple{AbstractArray,Any,AbstractPowerManifold,Vararg{Union{Colon, Integer, AbstractArray{T,1} where T},N} where N}","page":"Power manifold","title":"Base.setindex!","text":"setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\nq[M::AbstractPowerManifold, i...] = p\n\nSet the element(s) at index [i...] of a point q on an AbstractPowerManifold M by linear or multidimensional indexing to q. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Base.view-Tuple{AbstractArray,AbstractPowerManifold,Vararg{Union{Colon, Integer, AbstractArray{T,1} where T},N} where N}","page":"Power manifold","title":"Base.view","text":"view(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\n\nGet the view of the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#LinearAlgebra.norm-Tuple{AbstractPowerManifold,Any,Any}","page":"Power manifold","title":"LinearAlgebra.norm","text":"norm(M::AbstractPowerManifold, p, X)\n\nCompute the norm of X from the tangent space of p on an AbstractPowerManifold M, i.e. from the element wise norms the Frobenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.flat-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Manifolds.flat","text":"flat(M::AbstractPowerManifold, p, X::FVector{TangentSpaceType})\n\nuse the musical isomorphism to transform the tangent vector X from the tangent space at p on an AbstractPowerManifold M to a cotangent vector. This can be done elementwise for each entry of X (and p).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.get_component-Tuple{AbstractPowerManifold,Any,Vararg{Any,N} where N}","page":"Power manifold","title":"Manifolds.get_component","text":"get_component(M::AbstractPowerManifold, p, idx...)\n\nGet the component of a point p on an AbstractPowerManifold M at index idx.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.power_dimensions-Union{Tuple{PowerManifold{𝔽,#s69,TSize,TPR} where TPR<:AbstractPowerRepresentation where #s69<:Manifold}, Tuple{TSize}, Tuple{𝔽}} where TSize where 𝔽","page":"Power manifold","title":"Manifolds.power_dimensions","text":"power_dimensions(M::PowerManifold)\n\nreturn the power of M,\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.set_component!-Tuple{AbstractPowerManifold,Any,Any,Vararg{Any,N} where N}","page":"Power manifold","title":"Manifolds.set_component!","text":"set_component!(M::AbstractPowerManifold, q, p, idx...)\n\nSet the component of a point q on an AbstractPowerManifold M at index idx to p, which itself is a point on the Manifold the power manifold is build on.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.sharp-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Manifolds.sharp","text":"sharp(M::AbstractPowerManifold, p, ξ::FVector{CotangentSpaceType})\n\nUse the musical isomorphism to transform the cotangent vector ξ from the tangent space at p on an AbstractPowerManifold M to a tangent vector. This can be done elementwise for every entry of ξ (and p).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.check_manifold_point-Tuple{AbstractPowerManifold,Any}","page":"Power manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::AbstractProductManifold, p; kwargs...)\n\nCheck whether p is a valid point on an AbstractPowerManifold M, i.e. each element of p has to be a valid point on the base manifold. If p is not a point on M a CompositeException consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.check_tangent_vector-Tuple{AbstractPowerManifold,Any,Any}","page":"Power manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::AbstractPowerManifold, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to p an the AbstractPowerManifold M, i.e. atfer check_manifold_point(M, p), and all projections to base manifolds must be respective tangent vectors. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p. If X is not a tangent vector to p on M a CompositeException consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.distance-Tuple{AbstractPowerManifold,Any,Any}","page":"Power manifold","title":"ManifoldsBase.distance","text":"distance(M::AbstractPowerManifold, p, q)\n\nCompute the distance between q and p on an AbstractPowerManifold, i.e. from the element wise distances the Forbenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold,Any}","page":"Power manifold","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractPowerManifold[, p])\n\nthe injectivity radius on an AbstractPowerManifold is for the global case equal to the one of its base manifold. For a given point p it's equal to the minimum of all radii in the array entries.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.inner-Tuple{AbstractPowerManifold,Any,Any,Any}","page":"Power manifold","title":"ManifoldsBase.inner","text":"inner(M::AbstractPowerManifold, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on an AbstractPowerManifold M, i.e. for each arrays entry the tangent vector entries from X and Y are in the tangent space of the corresponding element from p. The inner product is then the sum of the elementwise inner products.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractPowerManifold, p, q, m::InversePowerRetraction)\n\nCompute the inverse retraction from p with respect to q on an AbstractPowerManifold M using an InversePowerRetraction, which by default encapsulates a inverse retraction of the base manifold. Then this method is performed elementwise, so the encapsulated inverse retraction method has to be one that is available on the base Manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{𝔽,#s69,TSize,TPR} where TPR<:AbstractPowerRepresentation where #s69<:Manifold}, Tuple{TSize}, Tuple{𝔽}} where TSize where 𝔽","page":"Power manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PowerManifold)\n\nReturns the manifold-dimension of an PowerManifold M =mathcal N = (mathcal M)^n_1n_d, i.e. with n=(n_1n_d) the array size of the power manifold and d_mathcal M the dimension of the base manifold mathcal M, the manifold is of dimension\n\ndim(mathcal N) = dim(mathcal M)prod_i=1^d n_i = n_1n_2cdotcdot n_d dim(mathcal M)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"ManifoldsBase.retract","text":"retract(M::AbstractPowerManifold, p, X, method::PowerRetraction)\n\nCompute the retraction from p with tangent vector X on an AbstractPowerManifold M using a PowerRetraction, which by default encapsulates a retraction of the base manifold. Then this method is performed elementwise, so the encapsulated retraction method has to be one that is available on the base Manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold,Any,Any,Any,PowerVectorTransport}","page":"Power manifold","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractPowerManifold, p, X, q, method::PowerVectorTransport)\n\nCompute the vector transport the tangent vector Xat p to q on the PowerManifold M using an PowerVectorTransport m. This method is performed elementwise, i.e. the method m has to be implemented on the base manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Rotations","page":"Rotations","title":"Rotations","text":"","category":"section"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"The manifold mathrmSO(n) of orthogonal matrices with determinant +1 in ℝ^n  n, i.e.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"mathrmSO(n) = biglR  ℝ^n  n big R R^mathrmT =\nR^mathrmTR = I_n det(R) = 1 bigr","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"The Lie group mathrmSO(n) is a subgroup of the orthogonal group mathrmO(n) and also known as the special orthogonal group or the set of rotations group. See also SpecialOrthogonal, which is this manifold equipped with the group operation.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"Tangent vectors are represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"Let L_R mathrmSO(n)  mathrmSO(n) where R  mathrmSO(n) be the left-multiplication by R, that is L_R(S) = RS. The tangent space at rotation R, T_R mathrmSO(n), is related to the tangent space at the identity rotation I_n by the differential of L_R at identity, (mathrmdL_R)_I_n  T_I_n mathrmSO(n)  T_R mathrmSO(n). For a tangent vector at the identity rotation X  T_I_n mathrmSO(n) the matrix representation of the corresponding tangent vector Y at a rotation R can be obtained by matrix multiplication: Y = RX  T_R mathrmSO(n). You can compare the functions log and exp to see how it works in practice.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"Modules = [Manifolds]\nPages = [\"manifolds/Rotations.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/rotations.html#Manifolds.NormalRotationDistribution","page":"Rotations","title":"Manifolds.NormalRotationDistribution","text":"NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)\n\nDistribution that returns a random point on the manifold Rotations M. Random point is generated using base distribution d and the type of the result is adjusted to TResult.\n\nSee normal_rotation_distribution for details.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.Rotations","page":"Rotations","title":"Manifolds.Rotations","text":"Rotations{N} <: Manifold{ℝ}\n\nThe special orthogonal manifold mathrmSO(n) represented by n  n real-valued orthogonal matrices with determinant +1 is the manifold of Rotations, since these matrices represent all rotations of points in ℝ^n.\n\nConstructor\n\nRotations(n)\n\nGenerate the mathrmSO(n) subset ℝ^n  n\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Base.exp-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"Base.exp","text":"exp(M::Rotations, p, X)\n\nCompute the exponential map on the Rotations from p into direction X, i.e.\n\nexp_p X = p operatornameExp(X)\n\nwhere operatornameExp(X)  denotes the matrix exponential of X.\n\nexp(M::Rotations{4}, p, X)\n\nCompute the exponential map of tangent vector X at point p from mathrmSO(4) manifold M.\n\nThe algorithm used is a more numerically stable form of those proposed in [Gallier2002] and [Andrica2013].\n\n[Gallier2002]: Gallier J.; Xu D.; Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation (2002), 17(4), pp. 1-11. pdf.\n\n[Andrica2013]: Andrica D.; Rohan R.-A.; Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications (2013), 18(2), pp. 1-2. pdf.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Base.log-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"Base.log","text":"log(M::Rotations, p, q)\n\nCompute the logarithmic map on the Rotations manifold M=mathrmSO(n), which is given by\n\nlog_p q =\n  frac12 bigl(operatornameLog(p^mathrmTq)\n  - (operatornameLog(p^mathrmTq)^mathrmT)\n\nwhere operatornameLog denotes the matrix logarithm.\n\nFor antipodal rotations the function returns deterministically one of the tangent vectors that point at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#LinearAlgebra.norm-Tuple{Rotations,Any,Any}","page":"Rotations","title":"LinearAlgebra.norm","text":"norm(M::Rotations, p, X)\n\nCompute the norm of a tangent vector X from the tangent space at p on the Rotations M. The formula reads\n\nlVert X rVert_p = lVert X rVert\n\ni.e. the Frobenius norm of X, where tangent vectors are represented by elements from the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra of Rotations(4) in ℝ^4  4, 𝔰𝔬(4), consists of 4  4 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order (corresponding to the same ordering of angles as cos_angles_4d_rotation_matrix).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles αβ of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned\ncos α + cos β = frac12 operatornametr(R)\ncos α + cos β = frac18 operatornametr(R)^2\n                 - frac116 operatornametr((R - R^T)^2) - 1\nendaligned\n\nBy convention, the returned values are sorted in increasing order. See angles_4d_skew_sym_matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N},Any,Real}} where N","page":"Rotations","title":"Manifolds.normal_rotation_distribution","text":"normal_rotation_distribution(M::Rotations, p, σ::Real)\n\nReturn a random point on the manifold Rotations M by generating a (Gaussian) random orthogonal matrix with determinant +1. Let\n\nQR = A\n\nbe the QR decomposition of a random matrix A, then the formula reads\n\np = QD\n\nwhere D is a diagonal matrix with the signs of the diagonal entries of R, i.e.\n\nD_ij=begincases operatornamesgn(R_ij)  textif  i=j  0   textotherwise endcases\n\nIt can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.\n\nThe argument p is used to determine the type of returned points.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_tvector_distribution-Tuple{Rotations,Any,Any}","page":"Rotations","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::Rotations, p, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{Rotations{N},Any}} where N","page":"Rotations","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M, p; kwargs...)\n\nCheck whether p is a valid point on the Rotations M, i.e. is an array of size manifold_dimension(M) and represents a valid rotation. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Rotations{N},Any,Any}} where N","page":"Rotations","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to p on the Rotations space M, i.e. after check_manifold_point(M,p), X has to be of same dimension and orthogonal to p. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.get_coordinates-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Rotations, p, X)\n\nExtract the unique tangent vector components X^i at point p on Rotations mathrmSO(n) from the matrix representation X of the tangent vector.\n\nThe basis on the Lie algebra 𝔰𝔬(n) is chosen such that for mathrmSO(2), X^1 = θ = X_21 is the angle of rotation, and for mathrmSO(3), (X^1 X^2 X^3) = (X_32 X_13 X_21) = θ u is the angular velocity and axis-angle representation, where u is the unit vector along the axis of rotation.\n\nFor mathrmSO(n) where n  4, the additional elements of X^i are X^j (j - 3)2 + k + 1 = X_jk, for j  4n k  1j).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.get_vector-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"ManifoldsBase.get_vector","text":"get_vector(M::Rotations, p, Xⁱ, B:: DefaultOrthogonalBasis)\n\nConvert the unique tangent vector components Xⁱ at point p on Rotations group mathrmSO(n) to the matrix representation X of the tangent vector. See get_coordinates for the conventions used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.injectivity_radius-Tuple{Rotations}","page":"Rotations","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Rotations)\ninjectivity_radius(M::Rotations, p)\n\nReturn the injectivity radius on the Rotations M, which is globally\n\n    operatornameinj_mathrmSO(n)(p) = πsqrt2\n\ninjectivity_radius(M::Rotations, p, ::PolarRetraction)\n\nReturn the radius of injectivity for the PolarRetraction on the Rotations M which is fracπsqrt2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inner-Tuple{Rotations,Any,Any,Any}","page":"Rotations","title":"ManifoldsBase.inner","text":"inner(M::Rotations, p, X, Y)\n\nCompute the inner product of the two tangent vectors X, Y from the tangent plane at p on the special orthogonal space M=mathrmSO(n) using the restriction of the metric from the embedding, i.e.\n\ng_p(X Y) = operatornametr(X^mathrmT Y)\n\nTangent vectors are represented by matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inverse_retract-Tuple{Rotations,Any,Any,PolarInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, p, q, ::PolarInverseRetraction)\n\nCompute a vector from the tangent space T_pmathrmSO(n) of the point p on the Rotations manifold M with which the point q can be reached by the PolarRetraction from the point p after time 1.\n\nThe formula reads\n\noperatornameretr^-1_p(q)\n= -frac12(p^mathrmTqs - (p^mathrmTqs)^mathrmT)\n\nwhere s is the solution to the Sylvester equation\n\np^mathrmTqs + s(p^mathrmTq)^mathrmT + 2I_n = 0\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inverse_retract-Tuple{Rotations,Any,Any,QRInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Rotations, p, q, ::QRInverseRetraction)\n\nCompute a vector from the tangent space T_pmathrmSO(n) of the point p on the Rotations manifold M with which the point q can be reached by the QRRetraction from the point q after time 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Rotations)\n\nReturn the dimension of the manifold mathrmSO(n), i.e.\n\ndim_mathrmSO(n) = fracn(n-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.project-Tuple{Rotations,Any,Any}","page":"Rotations","title":"ManifoldsBase.project","text":"project(M::Rotations, p, X)\n\nProject the matrix X onto the tangent space by making X skew symmetric,\n\noperatornameproj_p(X) = fracX-X^mathrmT2\n\nwhere tangent vectors are represented by elements from the Lie group\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.project-Tuple{Rotations,Any}","page":"Rotations","title":"ManifoldsBase.project","text":"project(M::Rotations, p; check_det = true)\n\nProject p to the nearest point on manifold M.\n\nGiven the singular value decomposition p = U Σ V^mathrmT, with the singular values sorted in descending order, the projection is\n\noperatornameproj_mathrmSO(n)(p) =\nUoperatornamediagleft11det(U V^mathrmT)right V^mathrmT\n\nThe diagonal matrix ensures that the determinant of the result is +1. If p is expected to be almost special orthogonal, then you may avoid this check with check_det = false.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.representation_size-Union{Tuple{Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"ManifoldsBase.representation_size","text":"representation_size(M::Rotations)\n\nReturn the size() of a point on the Rotations M, i.e. for the mathrmSO(n) it's (n,n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.retract-Tuple{Rotations,Any,Any,PolarRetraction}","page":"Rotations","title":"ManifoldsBase.retract","text":"retract(M::Rotations, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction on the Rotations M from p in direction X (as an element of the Lie group) and is a second-order approximation of the exponential map. Let\n\nUSV = p + pX\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_p X = UV^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.retract-Tuple{Rotations,Any,Any,QRRetraction}","page":"Rotations","title":"ManifoldsBase.retract","text":"retract(M, p, X, ::QRRetraction)\n\nCompute the QR-based retraction on the Rotations M from p in direction X (as an element of the Lie group), which is a first-order approximation of the exponential map.\n\nThis is also the default retraction on the Rotations\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.zero_tangent_vector-Tuple{Rotations,Any}","page":"Rotations","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Rotations, p)\n\nReturn the zero tangent vector from the tangent space art p on the Rotations as an element of the Lie group, i.e. the zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Statistics.mean-Tuple{Rotations,Any}","page":"Rotations","title":"Statistics.mean","text":"mean(\n    M::Rotations,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2/√2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Literature","page":"Rotations","title":"Literature","text":"","category":"section"},{"location":"manifolds/generalizedgrassmann.html#Generalized-Grassmann","page":"Generalized Grassmann","title":"Generalized Grassmann","text":"","category":"section"},{"location":"manifolds/generalizedgrassmann.html","page":"Generalized Grassmann","title":"Generalized Grassmann","text":"Modules = [Manifolds]\nPages = [\"manifolds/GeneralizedGrassmann.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/generalizedgrassmann.html#Manifolds.GeneralizedGrassmann","page":"Generalized Grassmann","title":"Manifolds.GeneralizedGrassmann","text":"GeneralizedGrassmann{n,k,𝔽} <: AbstractEmbeddedManifold{𝔽,DefaultEmbeddingType}\n\nThe generalized Grassmann manifold operatornameGr(nkB) consists of all subspaces spanned by k linear independent vectors 𝔽^n, where 𝔽   ℝ ℂ is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of ℝ^n for the real-valued case and all 2k-dimensional subspaces of ℂ^n for the second.\n\nThe manifold can be represented as\n\noperatornameGr(n k B) = bigl operatornamespan(p) big p  𝔽^n  k p^mathrmHBp = I_k\n\nwhere cdot^mathrmH denotes the complex conjugate (or Hermitian) transpose and I_k is the k  k identity matrix. This means, that the columns of p form an unitary basis of the subspace with respect to the scaled inner product, that is a point on operatornameGr(nkB), and hence the subspace can actually be represented by a whole equivalence class of representers. For B=I_n this simplifies to the Grassmann manifold.\n\nThe tangent space at a point (subspace) p is given by\n\nT_xmathrmGr(nkB) = bigl\nX  𝔽^n  k \nX^mathrmHBp + p^mathrmHBX = 0_k bigr\n\nwhere 0_k denotes the k  k zero matrix.\n\nNote that a point p  operatornameGr(nkB) might be represented by different matrices (i.e. matrices with B-unitary column vectors that span the same subspace). Different representations of p also lead to different representation matrices for the tangent space T_pmathrmGr(nkB)\n\nThe manifold is named after Hermann G. Graßmann (1809-1877).\n\nConstructor\n\nGeneralizedGrassmann(n, k, B=I_n, field=ℝ)\n\nGenerate the (real-valued) Generalized Grassmann manifold of ntimes k dimensional orthonormal matrices with scalar product B.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalizedgrassmann.html#Base.exp-Tuple{GeneralizedGrassmann,Vararg{Any,N} where N}","page":"Generalized Grassmann","title":"Base.exp","text":"exp(M::GeneralizedGrassmann, p, X)\n\nCompute the exponential map on the GeneralizedGrassmann M= mathrmGr(nkB) starting in p with tangent vector (direction) X. Let X^mathrmHBX = USV denote the SVD decomposition of X^mathrmHBX. Then the exponential map is written using\n\nexp_p X = p Vcos(S)V^mathrmH + Usin(S)V^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian and the cosine and sine are applied element wise to the diagonal entries of S.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#Base.log-Tuple{GeneralizedGrassmann,Vararg{Any,N} where N}","page":"Generalized Grassmann","title":"Base.log","text":"log(M::GeneralizedGrassmann, p, q)\n\nCompute the logarithmic map on the GeneralizedGrassmann M$ = \\mathcal M=\\mathrm{Gr}(n,k,B)$, i.e. the tangent vector X whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = Vcdot operatornameatan(S) cdot U^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian. The matrices U and V are the unitary matrices, and S is the diagonal matrix containing the singular values of the SVD-decomposition\n\nUSV = (q^mathrmHBp)^-1 ( q^mathrmH - q^mathrmHBpp^mathrmH)\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.check_manifold_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{GeneralizedGrassmann{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T),Any}} where 𝔽 where k where n","page":"Generalized Grassmann","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::GeneralizedGrassmann{n,k,𝔽}, p)\n\nCheck whether p is representing a point on the GeneralizedGrassmann M, i.e. its a n-by-k matrix of unitary column vectors with respect to the B inner prudct and of correct eltype with respect to 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.check_tangent_vector-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{GeneralizedGrassmann{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T),Any,Any}} where 𝔽 where k where n","page":"Generalized Grassmann","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::GeneralizedGrassmann{n,k,𝔽}, p, X; check_base_point = true, kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the GeneralizedGrassmann M, i.e. that X is of size and type as well as that\n\n    p^mathrmHBX + X^mathrmHBp = 0_k\n\nwhere cdot^mathrmH denotes the complex conjugate transpose or Hermitian and 0_k denotes the k  k zero natrix. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.distance-Tuple{GeneralizedGrassmann,Any,Any}","page":"Generalized Grassmann","title":"ManifoldsBase.distance","text":"distance(M::GeneralizedGrassmann, p, q)\n\nCompute the Riemannian distance on GeneralizedGrassmann manifold M= mathrmGr(nkB).\n\nLet USV = p^mathrmHBq denote the SVD decomposition of p^mathrmHBq, where cdot^mathrmH denotes the complex conjugate transposed or Hermitian. Then the distance is given by\n\nd_mathrmGr(nkB)(pq) = operatornamenorm(operatornameRe(b))\n\nwhere\n\nb_i=begincases\n0  textif  S_i  1\narccos(S_i)   textif  S_i1\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.injectivity_radius-Tuple{GeneralizedGrassmann}","page":"Generalized Grassmann","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::GeneralizedGrassmann)\ninjectivity_radius(M::GeneralizedGrassmann, p)\n\nReturn the injectivity radius on the GeneralizedGrassmann M, which is fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.inner-Union{Tuple{k}, Tuple{n}, Tuple{GeneralizedGrassmann{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T) where 𝔽,Any,Any,Any}} where k where n","page":"Generalized Grassmann","title":"ManifoldsBase.inner","text":"inner(M::GeneralizedGrassmann, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the GeneralizedGrassmann manifold M. The formula reads\n\ng_p(XY) = operatornametr(X^mathrmHBY)\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.manifold_dimension-Union{Tuple{GeneralizedGrassmann{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T)}, Tuple{𝔽}, Tuple{k}, Tuple{n}} where 𝔽 where k where n","page":"Generalized Grassmann","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::GeneralizedGrassmann)\n\nReturn the dimension of the GeneralizedGrassmann(n,k,𝔽) manifold M, i.e.\n\ndim operatornameGr(nkB) = k(n-k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.project-Tuple{GeneralizedGrassmann,Any,Any}","page":"Generalized Grassmann","title":"ManifoldsBase.project","text":"project(M::GeneralizedGrassmann, p, X)\n\nProject the n-by-k X onto the tangent space of p on the GeneralizedGrassmann M, which is computed by\n\noperatornameproj_p(X) = X - pp^mathrmHB^mathrmTX\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian and cdot^mathrmT the transpose.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.project-Tuple{GeneralizedGrassmann,Any}","page":"Generalized Grassmann","title":"ManifoldsBase.project","text":"project(M::GeneralizedGrassmann, p)\n\nProject p from the embedding onto the GeneralizedGrassmann M, i.e. compute q as the polar decomposition of p such that q^mathrmHBq is the identity, where cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.representation_size-Union{Tuple{GeneralizedGrassmann{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T) where 𝔽}, Tuple{k}, Tuple{n}} where k where n","page":"Generalized Grassmann","title":"ManifoldsBase.representation_size","text":"representation_size(M::GeneralizedGrassmann{n,k})\n\nReturn the represenation size or matrix dimension of a point on the GeneralizedGrassmann M, i.e. (nk) for both the real-valued and the complex value case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.retract-Tuple{GeneralizedGrassmann,Any,Any,PolarRetraction}","page":"Generalized Grassmann","title":"ManifoldsBase.retract","text":"retract(M::GeneralizedGrassmann, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the GeneralizedGrassmann M, by projecting p + X onto M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.vector_transport_to-Tuple{GeneralizedGrassmann,Any,Any,Any,ProjectionTransport}","page":"Generalized Grassmann","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::GeneralizedGrassmann, p, X, q, ::ProjectionTransport)\n\nCompute the vector transport of the tangent vector X at p to q, using the project of X to q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.zero_tangent_vector-Tuple{GeneralizedGrassmann,Vararg{Any,N} where N}","page":"Generalized Grassmann","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::GeneralizedGrassmann, p)\n\nReturn the zero tangent vector from the tangent space at p on the GeneralizedGrassmann M, which is given by a zero matrix the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#Statistics.mean-Tuple{GeneralizedGrassmann{n,k,𝔽,TB} where TB<:(AbstractArray{T,2} where T) where 𝔽 where k where n,Vararg{Any,N} where N}","page":"Generalized Grassmann","title":"Statistics.mean","text":"mean(\n    M::GeneralizedGrassmann,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#Elliptope","page":"Elliptope","title":"Elliptope","text":"","category":"section"},{"location":"manifolds/elliptope.html","page":"Elliptope","title":"Elliptope","text":"Modules = [Manifolds]\nPages = [\"manifolds/Elliptope.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/elliptope.html#Manifolds.Elliptope","page":"Elliptope","title":"Manifolds.Elliptope","text":"Elliptope{N,K} <: AbstractEmbeddedManifold{ℝ,DefaultIsometricEmbeddingType}\n\nThe Elliptope manifold, also known as the set of correlation matrices, consists of all symmetric positive semidefinite matrices of rank k with unit diagonal, i.e.,\n\nbeginaligned\nmathcal E(nk) =\nbiglp  ℝ^n  n big a^mathrmTpa geq 0 text for all  a  ℝ^n\np_ii = 1 text for all  i=1ldotsn\ntextand  p = qq^mathrmT text for  q in  ℝ^n  k text with  operatornamerank(p) = operatornamerank(q) = k\nbigr\nendaligned\n\nAnd this manifold is working solely on the matrices q. Note that this q is not unique, indeed for any orthogonal matrix A we have (qA)(qA)^mathrmT = qq^mathrmT = p, so the manifold implemented here is the quotient manifold. The unit diagonal translates to unit norm columns of q.\n\nThe tangent space at p, denoted T_pmathcal E(nk), is also represented by matrices Yin ℝ^n  k and reads as\n\nT_pmathcal E(nk) = bigl\nX  ℝ^n  nX = qY^mathrmT + Yq^mathrmT text with  X_ii = 0 text for  i=1ldotsn\nbigr\n\nendowed with the Euclidean metric from the embedding, i.e. from the ℝ^n  k\n\nThis manifold was for example investigated in[JourneeBachAbsilSepulchre2010].\n\nConstructor\n\nElliptope(n,k)\n\ngenerates the manifold mathcal E(nk) subset ℝ^n  n.\n\n[JourneeBachAbsilSepulchre2010]: Journée, M., Bach, F., Absil, P.-A., and Sepulchre, R.: “Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”, SIAM Journal on Optimization (20)5, pp. 2327–2351, 2010. doi: 10.1137/080731359, arXiv: 0807.4423.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/elliptope.html#ManifoldsBase.check_manifold_point-Union{Tuple{K}, Tuple{N}, Tuple{Elliptope{N,K},Any}} where K where N","page":"Elliptope","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Elliptope, q; kwargs...)\n\nchecks, whether q is a valid reprsentation of a point p=qq^mathrmT on the Elliptope M, i.e. is a matrix of size (N,K), such that p is symmetric positive semidefinite and has unit trace. Since by construction p is symmetric, this is not explicitly checked. Since p is by construction positive semidefinite, this is not checked. The tolerances for positive semidefiniteness and unit trace can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.check_tangent_vector-Union{Tuple{K}, Tuple{N}, Tuple{Elliptope{N,K},Any,Any}} where K where N","page":"Elliptope","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Elliptope, q, Y; check_base_point = true, kwargs... )\n\nCheck whether X = qY^mathrmT + Yq^mathrmT is a tangent vector to p=qq^mathrmT on the Elliptope M, i.e. atfer check_manifold_point of q, Y has to be of same dimension as q and a X has to be a symmetric matrix with zero diagonal. The optional parameter check_base_point indicates, whether to call check_manifold_point  for q. The tolerance for the base point check and zero diagonal can be set using the kwargs.... Note that symmetric of X holds by construction an is not explicitly checked.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.manifold_dimension-Union{Tuple{Elliptope{N,K}}, Tuple{K}, Tuple{N}} where K where N","page":"Elliptope","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Elliptope)\n\nreturns the dimension of Elliptope M=mathcal E(nk) nk  ℕ, i.e.\n\ndim mathcal E(nk) = n(k-1) - frack(k-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.project-Tuple{Elliptope,Any}","page":"Elliptope","title":"ManifoldsBase.project","text":"project(M::Elliptope, q)\n\nproject q onto the manifold Elliptope M, by normalizing the rows of q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.project-Tuple{Elliptope,Vararg{Any,N} where N}","page":"Elliptope","title":"ManifoldsBase.project","text":"project(M::Elliptope, q, Y)\n\nProject Y onto the tangent space at q, i.e. row-wise onto the oblique manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.representation_size-Union{Tuple{Elliptope{N,K}}, Tuple{K}, Tuple{N}} where K where N","page":"Elliptope","title":"ManifoldsBase.representation_size","text":"representation_size(M::Elliptope)\n\nReturn the size of an array representing an element on the Elliptope manifold M, i.e. n  k, the size of such factor of p=qq^mathrmT on mathcal M = mathcal E(nk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.retract-Tuple{Elliptope,Any,Any,ProjectionRetraction}","page":"Elliptope","title":"ManifoldsBase.retract","text":"retract(M::Elliptope, q, Y, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting q+Y back onto the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.vector_transport_to-Tuple{Elliptope,Any,Any,Any,ProjectionTransport}","page":"Elliptope","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Elliptope, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.zero_tangent_vector-Tuple{Elliptope,Vararg{Any,N} where N}","page":"Elliptope","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Elliptope,p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the Elliptope manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#Literature","page":"Elliptope","title":"Literature","text":"","category":"section"},{"location":"manifolds/multinomial.html#Multinomial-matrices","page":"Multinomial matrices","title":"Multinomial matrices","text":"","category":"section"},{"location":"manifolds/multinomial.html","page":"Multinomial matrices","title":"Multinomial matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/Multinomial.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/multinomial.html#Manifolds.MultinomialMatrices","page":"Multinomial matrices","title":"Manifolds.MultinomialMatrices","text":"MultinomialMatrices{n,m} <: AbstractPowerManifold{ℝ}\n\nThe multinomial manifold consists of m column vectors, where each column is of length n and unit norm, i.e.\n\nmathcalMN(nm) coloneqq bigl p  ℝ^nm big p_ij  0 text for all  i=1n j=1m text and  p^mathrmTmathbb1_m = mathbb1_nbigr\n\nwhere mathbb1_k is the vector of length k containing ones.\n\nThis yields exactly the same metric as considering the product metric of the probablity vectors, i.e. PowerManifold of the (n-1)-dimensional ProbabilitySimplex.\n\nThe ProbabilitySimplex is stored internally within M.manifold, such that all functions of AbstractPowerManifold can be used directly.\n\nConstructor\n\nMultinomialMatrices(n, m)\n\nGenerate the manifold of matrices mathbb R^nm such that the m columns are discrete probability distributions, i.e. sum up to one.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomial.html#Functions","page":"Multinomial matrices","title":"Functions","text":"","category":"section"},{"location":"manifolds/multinomial.html","page":"Multinomial matrices","title":"Multinomial matrices","text":"Most functions are directly implemented for an AbstractPowerManifold with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/multinomial.html","page":"Multinomial matrices","title":"Multinomial matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/Multinomial.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/multinomial.html#ManifoldsBase.check_manifold_point-Tuple{MultinomialMatrices,Any}","page":"Multinomial matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::MultinomialMatrices, p)\n\nChecks whether p is a valid point on the MultinomialMatrices(m,n) M, i.e. is a matrix of m discrete probability distributions as columns from mathbb R^n, i.e. each column is a point from ProbabilitySimplex(n-1).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomial.html#ManifoldsBase.check_tangent_vector-Union{Tuple{m}, Tuple{n}, Tuple{MultinomialMatrices{n,m,S} where S,Any,Any}} where m where n","page":"Multinomial matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::MultinomialMatrices p, X; check_base_point = true, kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialMatrices M. This means, that p is valid, that X is of correct dimension and columnswise a tangent vector to the columns of p on the ProbabilitySimplex. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Symmetric-positive-definite-matrices","page":"Symmetric positive definite","title":"Symmetric positive definite matrices","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"SymmetricPositiveDefinite","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite","page":"Symmetric positive definite","title":"Manifolds.SymmetricPositiveDefinite","text":"SymmetricPositiveDefinite{N} <: AbstractEmbeddedManifold{ℝ,DefaultEmbeddingType}\n\nThe manifold of symmetric positive definite matrices, i.e.\n\nmathcal P(n) =\nbigl\np  ℝ^n  n big a^mathrmTpa  0 text for all  a  ℝ^nbackslash0\nbigr\n\nConstructor\n\nSymmetricPositiveDefinite(n)\n\ngenerates the manifold mathcal P(n) subset ℝ^n  n\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"This manifold can – for example – be illustrated as ellipsoids:  since the eigenvalues are all positive they can be taken as lengths of the axes of an ellipsoids while the directions are given by the eigenvectors.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"(Image: An example set of data)","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"The manifold can be equipped with different metrics","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Common-and-metric-independent-functions","page":"Symmetric positive definite","title":"Common and metric independent functions","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefinite.jl\"]\nOrder = [:function]\n Filter = t -> t !== mean","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SymmetricPositiveDefinite, p; kwargs...)\n\nchecks, whether p is a valid point on the SymmetricPositiveDefinite M, i.e. is a matrix of size (N,N), symmetric and positive definite. The tolerance for the second to last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SymmetricPositiveDefinite, p, X; check_base_point = true, kwargs... )\n\nCheck whether X is a tangent vector to p on the SymmetricPositiveDefinite M, i.e. atfer check_manifold_point(M,p), X has to be of same dimension as p and a symmetric matrix, i.e. this stores tangent vetors as elements of the corresponding Lie group. The optional parameter check_base_point indicates, whether to call check_manifold_point  for p. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.injectivity_radius-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::SymmetricPositiveDefinite[, p])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}[, p])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}[, p])\n\nReturn the injectivity radius of the SymmetricPositiveDefinite. Since M is a Hadamard manifold with respect to the LinearAffineMetric and the LogCholeskyMetric, the injectivity radius is globally .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricPositiveDefinite)\n\nreturns the dimension of SymmetricPositiveDefinite M=mathcal P(n) n  ℕ, i.e.\n\ndim mathcal P(n) = fracn(n+1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.representation_size-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.representation_size","text":"representation_size(M::SymmetricPositiveDefinite)\n\nReturn the size of an array representing an element on the SymmetricPositiveDefinite manifold M, i.e. n  n, the size of such a symmetric positive definite matrix on mathcal M = mathcal P(n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.zero_tangent_vector-Tuple{SymmetricPositiveDefinite,Any}","page":"Symmetric positive definite","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::SymmetricPositiveDefinite,x)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix x on the SymmetricPositiveDefinite manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Default-metric:-the-linear-affine-metric","page":"Symmetric positive definite","title":"Default metric: the linear affine metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLinearAffine.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LinearAffineMetric","page":"Symmetric positive definite","title":"Manifolds.LinearAffineMetric","text":"LinearAffineMetric <: Metric\n\nThe linear affine metric is the metric for symmetric positive definite matrices, that employs matrix logarithms and exponentials, which yields a linear and affine metric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"This metric is also the default metric, i.e. any call of the following functions with P=SymmetricPositiveDefinite(3) will result in MetricManifold(P,LinearAffineMetric())and hence yield the formulae described in this seciton.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLinearAffine.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{SymmetricPositiveDefinite,Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::SymmetricPositiveDefinite, p, X)\nexp(M::MetricManifold{SymmetricPositiveDefinite{N},LinearAffineMetric}, p, X)\n\nCompute the exponential map from p with tangent vector X on the SymmetricPositiveDefinite M with its default MetricManifold having the LinearAffineMetric. The formula reads\n\nexp_p X = p^frac12operatornameExp(p^-frac12 X p^-frac12)p^frac12\n\nwhere operatornameExp denotes to the matrix exponential.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{SymmetricPositiveDefinite,Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::SymmetricPositiveDefinite, p, q)\nlog(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, q)\n\nCompute the logarithmic map from p to q on the SymmetricPositiveDefinite as a MetricManifold with LinearAffineMetric. The formula reads\n\nlog_p q =\np^frac12operatornameLog(p^-frac12qp^-frac12)p^frac12\n\nwhere operatornameLog denotes to the matrix logarithm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::SymmetricPositiveDefinite, p, q)\ndistance(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, q)\n\nCompute the distance on the SymmetricPositiveDefinite manifold between p and q, as a MetricManifold with LinearAffineMetric. The formula reads\n\nd_mathcal P(n)(pq)\n= lVert operatornameLog(p^-frac12qp^-frac12)rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.get_basis-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,DiagonalizingOrthonormalBasis}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.get_basis","text":"[Ξ,κ] = get_basis(M::SymmetricPositiveDefinite, p, B::DiagonalizingOrthonormalBasis)\n[Ξ,κ] = get_basis(M::MetricManifold{SymmetricPositiveDefinite{N},LinearAffineMetric}, p, B::DiagonalizingOrthonormalBasis)\n\nReturn a orthonormal basis Ξ as a vector of tangent vectors (of length manifold_dimension of M) in the tangent space of p on the MetricManifold of SymmetricPositiveDefinite manifold M with LinearAffineMetric that diagonalizes the curvature tensor R(uv)w with eigenvalues κ and where the direction B.frame_direction has curvature 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Tuple{SymmetricPositiveDefinite,Any,Any,Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::SymmetricPositiveDefinite, p, X, Y)\ninner(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, X, Y)\n\nCompute the inner product of X, Y in the tangent space of p on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LinearAffineMetric. The formula reads\n\ng_p(XY) = operatornametr(p^-1 X p^-1 Y)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.vector_transport_to-Tuple{SymmetricPositiveDefinite,Any,Any,Any,ParallelTransport}","page":"Symmetric positive definite","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::SymmetricPositiveDefinite, p, X, q, ::ParallelTransport)\nvector_transport_to(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, X, y, ::ParallelTransport)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the SymmetricPositiveDefinite as a MetricManifold with the LinearAffineMetric. The formula reads\n\nmathcal P_qpX = p^frac12\noperatornameExpbigl(\nfrac12p^-frac12log_p(q)p^-frac12\nbigr)\np^-frac12X p^-frac12\noperatornameExpbigl(\nfrac12p^-frac12log_p(q)p^-frac12\nbigr)\np^frac12\n\nwhere operatornameExp denotes the matrix exponential and log the logarithmic map on SymmetricPositiveDefinite (again with respect to the LinearAffineMetric).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#The-log-Euclidean-metric","page":"Symmetric positive definite","title":"The log Euclidean metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLogEuclidean.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogEuclideanMetric","page":"Symmetric positive definite","title":"Manifolds.LogEuclideanMetric","text":"LogEuclideanMetric <: Metric\n\nThe LogEuclidean Metric consists of the Euclidean metric applied to all elements after mapping them into the Lie Algebra, i.e. performing a matrix logarithm beforehand.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{ℝ,SymmetricPositiveDefinite{N},LogEuclideanMetric},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{SymmetricPositiveDefinite{N},LogEuclideanMetric}, p, q)\n\nCompute the distance on the SymmetricPositiveDefinite manifold between p and q as a MetricManifold with LogEuclideanMetric. The formula reads\n\n    d_mathcal P(n)(pq) = lVert operatornameLog p - operatornameLog q rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#log-Cholesky-metric","page":"Symmetric positive definite","title":"log Cholesky metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLogCholesky.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogCholeskyMetric","page":"Symmetric positive definite","title":"Manifolds.LogCholeskyMetric","text":"LogCholeskyMetric <: Metric\n\nThe Log-Cholesky metric imposes a metric based on the Cholesky decomposition as introduced by [Lin2019].\n\n[Lin2019]: Lin, Zenhua: \"Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition\", arXiv: 1908.09326.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{MetricManifold{ℝ,SymmetricPositiveDefinite,LogCholeskyMetric},Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, X)\n\nCompute the exponential map on the SymmetricPositiveDefinite M with LogCholeskyMetric from p into direction X. The formula reads\n\nexp_p X = (exp_y W)(exp_y W)^mathrmT\n\nwhere exp_xW is the exponential map on CholeskySpace, y is the cholesky decomposition of p, W = y(y^-1Xy^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{MetricManifold{ℝ,SymmetricPositiveDefinite,LogCholeskyMetric},Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, q)\n\nCompute the logarithmic map on SymmetricPositiveDefinite M with respect to the LogCholeskyMetric emanating from p to q. The formula can be adapted from the CholeskySpace as\n\nlog_p q = xW^mathrmT + Wx^mathrmT\n\nwhere x is the cholesky factor of p and W=log_x y for y the cholesky factor of q and the just mentioned logarithmic map is the one on CholeskySpace.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{ℝ,SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, q)\n\nCompute the distance on the manifold of SymmetricPositiveDefinite nmatrices, i.e. between two symmetric positive definite matrices p and q with respect to the LogCholeskyMetric. The formula reads\n\nd_mathcal P(n)(pq) = sqrt\n lVert  x  -  y  rVert_mathrmF^2\n + lVert log(operatornamediag(x)) - log(operatornamediag(y))rVert_mathrmF^2   \n\nwhere x and y are the cholesky factors of p and q, respectively, cdot denbotes the strictly lower triangular matrix of its argument, and lVertcdotrVert_mathrmF the Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Union{Tuple{N}, Tuple{MetricManifold{ℝ,SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{LogCholeskyMetric,ℝ,SymmetricPositiveDefinite}, p, X, Y)\n\nCompute the inner product of two matrices X, Y in the tangent space of p on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LogCholeskyMetric. The formula reads\n\n    g_p(XY) = a_z(X)a_z(Y)_z\n\nwhere cdotcdot_x denotes inner product on the CholeskySpace, z is the cholesky factor of p, a_z(W) = z (z^-1Wz^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.vector_transport_to-Tuple{MetricManifold{ℝ,SymmetricPositiveDefinite,LogCholeskyMetric},Any,Any,Any,ParallelTransport}","page":"Symmetric positive definite","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(\n    M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric},\n    p,\n    X,\n    q,\n    ::ParallelTransport,\n)\n\nParallel transport the tangent vector X at p along the geodesic to q with respect to the SymmetricPositiveDefinite manifold M and LogCholeskyMetric. The parallel transport is based on the parallel transport on CholeskySpace: Let x and y denote the cholesky factors of p and q, respectively and W = x(x^-1Xx^-mathrmT)_frac12, where (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12. With V the parallel transport on CholeskySpace from x to y. The formula hear reads\n\nmathcal P_qpX = yV^mathrmT + Vy^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics","page":"Symmetric positive definite","title":"Statistics","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages   = [\"SymmetricPositiveDefinite.jl\"]\nOrder = [:function]\nFilter = t -> t === mean","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics.mean-Tuple{SymmetricPositiveDefinite,Any}","page":"Symmetric positive definite","title":"Statistics.mean","text":"mean(\n    M::SymmetricPositiveDefinite,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Literature","page":"Symmetric positive definite","title":"Literature","text":"","category":"section"},{"location":"misc/contributing.html#Contributing-to-Manifolds.jl","page":"Contributing","title":"Contributing to Manifolds.jl","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"First, thanks for taking the time to contribute. Any contribution is appreciated and welcome.","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"The following is a set of guidelines to Manifolds.jl.","category":"page"},{"location":"misc/contributing.html#Table-of-Contents","page":"Contributing","title":"Table of Contents","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"I just have a question\nHow can I file an issue?\nHow can I contribute?","category":"page"},{"location":"misc/contributing.html#I-just-have-a-question","page":"Contributing","title":"I just have a question","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"The developers can most easily be reached in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"misc/contributing.html#How-can-I-file-an-issue?","page":"Contributing","title":"How can I file an issue?","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"If you found a bug or want to propose a feature, we track our issues within the GitHub repository.","category":"page"},{"location":"misc/contributing.html#How-can-I-contribute?","page":"Contributing","title":"How can I contribute?","text":"","category":"section"},{"location":"misc/contributing.html#Add-a-missing-method","page":"Contributing","title":"Add a missing method","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"Not all methods from our interface ManifoldsBase.jl have been implemented for every manifold. If you notice a method missing and can contribute an implementation, please do so! Even providing a single new method is a good contribution.","category":"page"},{"location":"misc/contributing.html#Provide-a-new-manifold","page":"Contributing","title":"Provide a new manifold","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"A main contribution you can provide is another manifold that is not yet included in the package. A manifold is a concrete type of Manifold from ManifoldsBase.jl. This package also provides the main set of functions a manifold can/should implement. Don't worry if you can only implement some of the functions. If the application you have in mind only requires a subset of these functions, implement those. The ManifoldsBase.jl interface provides concrete error messages for the remaining unimplemented functions.","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"One important detail is that the interface usually provides a mutating as well as a non-mutating variant See for example exp! and exp. The non-mutating one (e.g. exp) always falls back to use the mutating one, so in most cases it should suffice to implement the mutating one (e.g. exp!).","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"Note that since the first argument is always the Manifold, the mutated argument is always the second one in the signature. In the example we have exp(M, x, v) for the exponential map and exp!(M, y, v, x) for the mutating one, that stores the result in y.","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"On the other hand, the user will most likely look for the documentation of the non-mutating version, so we recommend adding the docstring for the non-mutating one, where all different signatures should be collected in one string when reasonable. This can best be achieved by adding a docstring to the method with a general signature with the first argument being your manifold:","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"struct MyManifold <: Manifold end\n\n@doc raw\"\"\"\n    exp(M::MyManifold, x, v)\n\nDescribe the function.\n\"\"\"\nexp(::MyManifold, ::Any...)","category":"page"},{"location":"misc/contributing.html#Code-style","page":"Contributing","title":"Code style","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"We try to follow the documentation guidelines from the Julia documentation as well as Blue Style. We run JuliaFormatter.jl on the repo in the following way, which enforces a number of conventions consistent with Blue Style:","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\n\nformat(\n    \".\",\n    short_to_long_function_def = true,\n    always_for_in = true,\n    whitespace_ops_in_indices = true,\n    pipe_to_function_call = true,\n    import_to_using = true,\n    always_use_return = true,\n)","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"We also follow a few internal conventions:","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"It is preferred that the Manifold's struct contain a reference to the general theory.\nAny implemented function should be accompanied by its mathematical formulae if a closed form exists.\nWithin the source code of one manifold, the type of the manifold should be the first element of the file, and an alphabetical order of the functions is preferable.\nThe above implies that the mutating variant of a function follows the non-mutating variant.\nThere should be no dangling = signs.\nAlways add a newline between things of different types (struct/method/const).\nAlways add a newline between methods for different functions (including mutating/nonmutating variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the docstrings.\nAll import/using/include should be in the main module file.","category":"page"}]
}
