<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to implement a Manifold · Manifolds.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manifolds.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../interface.html">ManifoldsBase.jl</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href="manifold.html">How to implement a Manifold</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#manifold-tutorial-prel"><span>Technical preliminaries</span></a></li><li><a class="tocitem" href="#manifold-tutorial-startup"><span>Startup</span></a></li><li><a class="tocitem" href="#manifold-tutorial-task"><span>Goal</span></a></li><li><a class="tocitem" href="#manifold-tutorial-checks"><span>Checking points and tangents</span></a></li><li><a class="tocitem" href="#manifold-tutorial-fn"><span>Functions on the manifold</span></a></li><li><a class="tocitem" href="#manifold-tutorial-outlook"><span>Conclusion</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/centeredmatrices.html">Centered matrices</a></li><li><a class="tocitem" href="../manifolds/choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="../manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="../manifolds/elliptope.html">Elliptope</a></li><li><a class="tocitem" href="../manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="../manifolds/fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="../manifolds/generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="../manifolds/generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="../manifolds/grassmann.html">Grassmann</a></li><li><a class="tocitem" href="../manifolds/hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="../manifolds/lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="../manifolds/multinomialdoublystochastic.html">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="../manifolds/multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="../manifolds/multinomialsymmetric.html">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="../manifolds/oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="../manifolds/probabilitysimplex.html">Probability simplex</a></li><li><a class="tocitem" href="../manifolds/positivenumbers.html">Positive numbers</a></li><li><a class="tocitem" href="../manifolds/projectivespace.html">Projective space</a></li><li><a class="tocitem" href="../manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="../manifolds/skewsymmetric.html">Skew-symmetric matrices</a></li><li><a class="tocitem" href="../manifolds/spectrahedron.html">Spectrahedron</a></li><li><a class="tocitem" href="../manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="../manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="../manifolds/symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="../manifolds/symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="../manifolds/symmetricpsdfixedrank.html">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="../manifolds/torus.html">Torus</a></li><li><a class="tocitem" href="../manifolds/spheresymmetricmatrices.html">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/graph.html">Graph manifold</a></li><li><a class="tocitem" href="../manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="../manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="../manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/metric.html">Metric manifold</a></li><li><a class="tocitem" href="../manifolds/group.html">Group manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="../features/differentiation.html">Differentiation</a></li><li><a class="tocitem" href="../features/distributions.html">Distributions</a></li><li><a class="tocitem" href="../features/statistics.html">Statistics</a></li><li><a class="tocitem" href="../features/testing.html">Testing</a></li><li><a class="tocitem" href="../features/utilities.html">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="../misc/about.html">About</a></li><li><a class="tocitem" href="../misc/contributing.html">Contributing</a></li><li><a class="tocitem" href="../misc/internals.html">Internals</a></li><li><a class="tocitem" href="../misc/notation.html">Notation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="manifold.html">How to implement a Manifold</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="manifold.html">How to implement a Manifold</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/examples/manifold.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="manifold-tutorial"><a class="docs-heading-anchor" href="#manifold-tutorial">How to implement your own manifold</a><a id="manifold-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial" title="Permalink"></a></h1><p>This tutorial demonstrates how to easily set your own manifold up within <code>Manifolds.jl</code>.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>If you looked around a little and saw the <a href="../interface.html">interface</a>, the amount of functions and possibilities, it might seem that a manifold might take some time to implement. This tutorial demonstrates that you can get your first own manifold quite fast and you only have to implement the functions you actually need. For this tutorial it would be helpful if you take a look at our <a href="../misc/notation.html">notation</a>. This tutorial assumes that you heard of the exponential map, tangent vectors and the dimension of a manifold. If not, please read for example [<a href="#doCarmo1992">do Carmo, 1992</a>], Chapter 3, first.</p><p>In general you need just a datatype (<code>struct</code>) that inherits from <a href="../interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> to define a manifold. No function is <em>per se</em> required to be implemented. However, it is a good idea to provide functions that might be useful to others, for example <a href="../interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point</code></a> and <a href="../interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>check_tangent_vector</code></a>, as we do in this tutorial.</p><p>We start with two technical preliminaries. If you want to start directly, you can <a href="manifold.html#manifold-tutorial-task">skip</a> this paragraph and revisit it for two of the implementation details.</p><p>After that, we will</p><ul><li><a href="manifold.html#manifold-tutorial-task">model</a> the manifold</li><li><a href="manifold.html#manifold-tutorial-checks">implement</a> two tests, so that points and tangent vectors can be checked for validity, for example also within <a href="../interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>,</li><li><a href="manifold.html#manifold-tutorial-fn">implement</a> two functions, the exponential map and the manifold dimension.</li></ul><h2 id="manifold-tutorial-prel"><a class="docs-heading-anchor" href="#manifold-tutorial-prel">Technical preliminaries</a><a id="manifold-tutorial-prel-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-prel" title="Permalink"></a></h2><p>There are only two small technical things we need to explain at this point. First of all our <a href="../interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a><code>{𝔽}</code> has a parameter <code>𝔽</code>. This parameter indicates the <a href="../interface.html#ManifoldsBase.number_system-Union{Tuple{Manifold{𝔽}}, Tuple{𝔽}} where 𝔽"><code>number_system</code></a> the manifold is based on, for example <code>ℝ</code> for real manifolds. It is important primarily for defining bases of tangent spaces. See <a href="../manifolds/symmetric.html#Manifolds.SymmetricMatrices"><code>SymmetricMatrices</code></a> as an example of defining both a real-valued and a complex-valued symmetric manifolds using one type.</p><p>Second, a main design decision of <code>Manifold.jl</code> is that most functions are implemented as mutating functions, i.e. as in-place-computations. There usually exists a non-mutating version that falls back to allocating memory and calling the mutating one. This means you only have to implement the mutating version, <em>unless</em> there is a good reason to provide a special case for the non-mutating one, i.e. because in that case you know a far better performing implementation.</p><p>Let&#39;s look at an example. The exponential map <span>$\exp_p\colon T_p\mathcal M \to \mathcal M$</span> that maps a tangent vector <span>$X\in T_p\mathcal M$</span> from the tangent space at <span>$p\in \mathcal M$</span> to the manifold. The function <a href="../interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> has to know the manifold <code>M</code>, the point <code>p</code> and the tangent vector <code>X</code> as input, so to compute the resulting point <code>q</code> you need to call</p><pre><code class="language-julia">q = exp(M, p, X)</code></pre><p>If you already have allocated memory for the variable that should store the result, it is better to perform the computations directly in that memory and avoid reallocations. For example</p><pre><code class="language-julia">q = similar(p)
exp!(M, q, p, X)</code></pre><p>calls <a href="../interface.html#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}"><code>exp!</code></a>, which modifies its input <code>q</code> and returns the resulting point in there. Actually these two lines are (almost) the default implementation for <a href="../interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>. <a href="../interface.html#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>allocate_result</code></a> that is actually used there just calls <code>similar</code> for simple <code>Array</code>s. Note that for a unified interface, the manifold <code>M</code> is <em>always</em> the first parameter, and the variable the result will be stored to in the mutating variants is <em>always</em> the second parameter.</p><p>Long story short: if possible, implement the mutating version <a href="../interface.html#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}"><code>exp!</code></a>, you get the <a href="../interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> for free. Many functions that build upon basic functions employ the mutating variant, too, to avoid reallocations.</p><h2 id="manifold-tutorial-startup"><a class="docs-heading-anchor" href="#manifold-tutorial-startup">Startup</a><a id="manifold-tutorial-startup-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-startup" title="Permalink"></a></h2><p>As a start, let&#39;s load <code>ManifoldsBase.jl</code> and import the functions we consider throughout this tutorial. For implementing a manifold, loading the interface should suffice for quite some time.</p><pre><code class="language-julia">using ManifoldsBase, LinearAlgebra, Test
import ManifoldsBase: check_manifold_point, check_tangent_vector, manifold_dimension, exp!</code></pre><h2 id="manifold-tutorial-task"><a class="docs-heading-anchor" href="#manifold-tutorial-task">Goal</a><a id="manifold-tutorial-task-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-task" title="Permalink"></a></h2><p>As an example, let&#39;s implement the sphere, but with a radius <span>$r$</span>. Since this radius is a property inherent to the manifold, it will become a field of the manifold. The second information, we want to store is the dimension of the sphere, for example whether it&#39;s the 1-sphere, i.e. the circle, represented by vectors <span>$p\in\mathbb R^2$</span> or the 2-sphere in <span>$\mathbb R^3$</span>. Since the latter might be something we want to <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">dispatch</a> on, we model it as a parameter of the type.</p><p>In general the <code>struct</code> of a manifold should provide information about the manifold, which are inherent to the manifold or has to be available without a specific point or tangent vector present. This is – most prominently – a way to determine the manifold dimension.</p><p>For our example we define</p><pre><code class="language-julia">&quot;&quot;&quot;
    MySphere{N} &lt;: Manifold{ℝ}

Define an `n`-sphere of radius `r`. Construct by `MySphere(radius,n)`
&quot;&quot;&quot;
struct MySphere{N} &lt;: Manifold{ManifoldsBase.ℝ} where {N}
    radius::Float64
end
MySphere(radius, n) = MySphere{n}(radius)
Base.show(io::IO, M::MySphere{n}) where {n} = print(io, &quot;MySphere($(M.radius),$n)&quot;)</code></pre><p>Here, the last line just provides a nicer print of a variable of that type Now we can already initialize our manifold that we will use later, the <span>$2$</span>-sphere of radius <span>$1.5$</span>.</p><pre><code class="language-julia">S = MySphere(1.5, 2)</code></pre><pre class="documenter-example-output">MySphere(1.5,2)</pre><h2 id="manifold-tutorial-checks"><a class="docs-heading-anchor" href="#manifold-tutorial-checks">Checking points and tangents</a><a id="manifold-tutorial-checks-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-checks" title="Permalink"></a></h2><p>If we have now a point, represented as an array, we would first like to check, that it is a valid point on the manifold. For this one can use the easy interface <a href="../interface.html#ManifoldsBase.is_manifold_point"><code>is_manifold_point</code></a>. This internally uses <a href="../interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point</code></a>. This is what we want to implement. We have to return the error if <code>p</code> is not on <code>M</code> and <code>nothing</code> otherwise.</p><p>We have to check two things: that a point <code>p</code> is a vector with <code>N+1</code> entries and its norm is the desired radius. To spare a few lines, we can use <a href="https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation-1">short-circuit evaluation</a> instead of <code>if</code> statements. If something has to only hold up to precision, we can pass that down, too using the <code>kwargs...</code>.</p><pre><code class="language-julia">function check_manifold_point(M::MySphere{N}, p; kwargs...) where {N}
    (size(p)) == (N+1,) || return DomainError(size(p),&quot;The size of $p is not $((N+1,)).&quot;)
    if !isapprox(norm(p), M.radius; kwargs...)
        return DomainError(norm(p), &quot;The norm of $p is not $(M.radius).&quot;)
    end
    return nothing
end</code></pre><p>Similarly, we can verify, whether a tangent vector <code>X</code> is valid. It has to fulfill the same size requirements and it has to be orthogonal to <code>p</code>. We can again use the <code>kwargs</code>, but also provide a way to check <code>p</code>, too.</p><pre><code class="language-julia">function check_tangent_vector(M::MySphere, p, X, check_base_point = true, kwargs...)
    if check_base_point
        mpe = check_manifold_point(M, p; kwargs...)
        mpe === nothing || return mpe
    end
    size(X) != size(p) &amp;&amp; return DomainError(size(X), &quot;The size of $X is not $(size(p)).&quot;)
    if !isapprox(dot(p,X), 0.0; kwargs...)
        return DomainError(dot(p,X), &quot;The tangent $X is not orthogonal to $p.&quot;)
    end
    return nothing
end</code></pre><p>to test points we can now use</p><pre><code class="language-julia">is_manifold_point(S, [1.0,0.0,0.0]) # norm 1, so not on S, returns false
@test_throws DomainError is_manifold_point(S, [1.5,0.0], true) # only on R^2, throws an error.
p = [1.5,0.0,0.0]
X = [0.0,1.0,0.0]
# The following two tests return true
[ is_manifold_point(S, p); is_tangent_vector(S,p,X) ]</code></pre><pre class="documenter-example-output">2-element Array{Bool,1}:
 1
 1</pre><h2 id="manifold-tutorial-fn"><a class="docs-heading-anchor" href="#manifold-tutorial-fn">Functions on the manifold</a><a id="manifold-tutorial-fn-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-fn" title="Permalink"></a></h2><p>For the <a href="../interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>manifold_dimension</code></a> we have to just return the <code>N</code> parameter</p><pre><code class="language-julia">manifold_dimension(::MySphere{N}) where {N} = N
manifold_dimension(S)</code></pre><pre class="documenter-example-output">2</pre><p>Note that we can even omit the variable name in the first line since we do not have to access any field or use the variable otherwise.</p><p>To implement the exponential map, we have to implement the formula for great arcs, given a start point <code>p</code> and a direction <code>X</code> on the <span>$n$</span>-sphere of radius <span>$r$</span> the formula reads</p><p class="math-container">\[\exp_p X = \cos(\frac{1}{r}\lVert X \rVert)p + \sin(\frac{1}{r}\lVert X \rVert)\frac{r}{\lVert X \rVert}X.\]</p><p>Note that with this choice we for example implicitly assume a certain metric. This is completely fine. We only have to think about specifying a metric explicitly, when we have (at least) two different metrics on the same manifold.</p><p>An implementation of the mutation version, see the <a href="manifold.html#manifold-tutorial-prel">technical note</a>, reads</p><pre><code class="language-julia">function exp!(M::MySphere{N}, q, p, X) where {N}
    nX = norm(X)
    if nX == 0
        q .= p
    else
        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (X./nX)
    end
    return q
end</code></pre><p>A first easy check can be done taking <code>p</code> from above and any vector <code>X</code> of length <code>1.5π</code> from its tangent space. The resulting point is opposite of <code>p</code>, i.e. <code>-p</code></p><pre><code class="language-julia">q = exp(S,p, [0.0,1.5π,0.0])
[isapprox(p,-q); is_manifold_point(S,q)]</code></pre><pre class="documenter-example-output">2-element Array{Bool,1}:
 1
 1</pre><h2 id="manifold-tutorial-outlook"><a class="docs-heading-anchor" href="#manifold-tutorial-outlook">Conclusion</a><a id="manifold-tutorial-outlook-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-outlook" title="Permalink"></a></h2><p>You can now just continue implementing further functions from the <a href="../interface.html">interface</a>, but with just <a href="../interface.html#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}"><code>exp!</code></a> you for example already have</p><ul><li><a href="../interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>geodesic</code></a> the (not necessarily shortest) geodesic emanating from <code>p</code> in direction <code>X</code>.</li><li>the <a href="../interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>, that the <a href="../interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>retract</code></a> function uses by default.</li></ul><p>For the <a href="../interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>shortest_geodesic</code></a> the implementation of a logarithm <a href="../interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>, again better a <a href="../interface.html#ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}"><code>log!</code></a> is necessary.</p><p>Sometimes a default implementation is provided; for example if you implemented <a href="../interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a>, the <a href="../interface.html#LinearAlgebra.norm-Tuple{Manifold,Any,Any}"><code>norm</code></a> is defined. You should overwrite it, if you can provide a more efficient version. For a start the default should suffice. With <a href="../interface.html#ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}"><code>log!</code></a> and <a href="../interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a> you get the <a href="../interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>distance</code></a>, and so.</p><p>In summary with just these few functions you can already explore the first things on your own manifold. Whenever a function from <code>Manifolds.jl</code> requires another function to be specifically implemented, you get a reasonable error message.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><ul>
<li id="doCarmo1992">
    [<a>doCarmo, 1992</a>]
    M. P. do Carmo,
    <emph>Riemannian Geometry</emph>,
    Birkhäuser Boston, 1992,
    ISBN: 0-8176-3490-8.
</li>
</ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface.html">« ManifoldsBase.jl</a><a class="docs-footer-nextpage" href="../manifolds/centeredmatrices.html">Centered matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 11 December 2020 14:46">Friday 11 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
