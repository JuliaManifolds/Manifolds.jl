<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sphere Â· Manifolds.jl</title><meta name="title" content="Sphere Â· Manifolds.jl"/><meta property="og:title" content="Sphere Â· Manifolds.jl"/><meta property="twitter:title" content="Sphere Â· Manifolds.jl"/><meta name="description" content="Documentation for Manifolds.jl."/><meta property="og:description" content="Documentation for Manifolds.jl."/><meta property="twitter:description" content="Documentation for Manifolds.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manifolds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">ğŸš€ Get Started with <code>Manifolds.jl</code></a></li><li><a class="tocitem" href="../../tutorials/working-in-charts/">work in charts</a></li><li><a class="tocitem" href="../../tutorials/work-with-a-metric-defined-in-a-chart/">work with a metric defined in a chart</a></li><li><a class="tocitem" href="../../tutorials/hand-gestures/">perform Hand gesture analysis</a></li><li><a class="tocitem" href="../../tutorials/integration/">integrate on manifolds and handle probability densities</a></li><li><a class="tocitem" href="../../tutorials/exploring-curvature/">explore curvature without coordinates</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../centeredmatrices/">Centered matrices</a></li><li><a class="tocitem" href="../choleskyspace/">Cholesky space</a></li><li><a class="tocitem" href="../circle/">Circle</a></li><li><a class="tocitem" href="../determinantone/">Determinant one matrices</a></li><li><a class="tocitem" href="../elliptope/">Elliptope</a></li><li><a class="tocitem" href="../essentialmanifold/">Essential manifold</a></li><li><a class="tocitem" href="../euclidean/">Euclidean</a></li><li><a class="tocitem" href="../fixedrankmatrices/">Fixed-rank matrices</a></li><li><a class="tocitem" href="../flag/">Flag</a></li><li><a class="tocitem" href="../generalizedstiefel/">Generalized Stiefel</a></li><li><a class="tocitem" href="../generalizedgrassmann/">Generalized Grassmann</a></li><li><a class="tocitem" href="../grassmann/">Grassmann</a></li><li><a class="tocitem" href="../hamiltonian/">Hamiltonian</a></li><li><a class="tocitem" href="../heisenberg/">Heisenberg matrices</a></li><li><a class="tocitem" href="../hyperbolic/">Hyperbolic space</a></li><li><a class="tocitem" href="../hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../invertible/">Invertible matrices</a></li><li><a class="tocitem" href="../lorentz/">Lorentzian manifold</a></li><li><a class="tocitem" href="../multinomialdoublystochastic/">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="../multinomial/">Multinomial matrices</a></li><li><a class="tocitem" href="../multinomialsymmetric/">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="../multinomialsymmetricpositivedefinite/">Multinomial symmetric positive definite matrices</a></li><li><a class="tocitem" href="../oblique/">Oblique manifold</a></li><li><a class="tocitem" href="../probabilitysimplex/">Probability simplex</a></li><li><a class="tocitem" href="../positivenumbers/">Positive numbers</a></li><li><a class="tocitem" href="../projectivespace/">Projective space</a></li><li><a class="tocitem" href="../generalunitary/">Orthogonal and Unitary Matrices</a></li><li><a class="tocitem" href="../rotations/">Rotations</a></li><li><a class="tocitem" href="../segre/">Segre</a></li><li><a class="tocitem" href="../shapespace/">Shape spaces</a></li><li><a class="tocitem" href="../skewhermitian/">Skew-Hermitian matrices</a></li><li><a class="tocitem" href="../spectrahedron/">Spectrahedron</a></li><li class="is-active"><a class="tocitem" href>Sphere</a><ul class="internal"><li><a class="tocitem" href="#Functions-on-unit-spheres"><span>Functions on unit spheres</span></a></li><li><a class="tocitem" href="#Visualization-on-Sphere{2,â„}"><span>Visualization on <code>Sphere{2,â„}</code></span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../stiefel/">Stiefel</a></li><li><a class="tocitem" href="../symmetric/">Symmetric matrices</a></li><li><a class="tocitem" href="../symmetricpositivedefinite/">Symmetric positive definite</a></li><li><a class="tocitem" href="../spdfixeddeterminant/">SPD, fixed determinant</a></li><li><a class="tocitem" href="../symmetricpsdfixedrank/">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="../symplecticgrassmann/">Symplectic Grassmann</a></li><li><a class="tocitem" href="../symplectic/">Symplectic matrices</a></li><li><a class="tocitem" href="../symplecticstiefel/">Symplectic Stiefel</a></li><li><a class="tocitem" href="../torus/">Torus</a></li><li><a class="tocitem" href="../tucker/">Tucker</a></li><li><a class="tocitem" href="../spheresymmetricmatrices/">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fiber_bundle/">Fiber bundle</a></li><li><a class="tocitem" href="../graph/">Graph manifold</a></li><li><a class="tocitem" href="../power/">Power manifold</a></li><li><a class="tocitem" href="../product/">Product manifold</a></li><li><a class="tocitem" href="../vector_bundle/">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../connection/">Connection manifold</a></li><li><a class="tocitem" href="../metric/">Metric manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="../../features/atlases/">Atlases and charts</a></li><li><a class="tocitem" href="../../features/differentiation/">Differentiation</a></li><li><a class="tocitem" href="../../features/distributions/">Distributions</a></li><li><a class="tocitem" href="../../features/integration/">Integration</a></li><li><a class="tocitem" href="../../features/statistics/">Statistics</a></li><li><a class="tocitem" href="../../features/utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="../../misc/about/">About</a></li><li><a class="tocitem" href="../../misc/NEWS/">Changelog</a></li><li><a class="tocitem" href="../../misc/CONTRIBUTING/">Contributing</a></li><li><a class="tocitem" href="../../misc/internals/">Internals</a></li><li><a class="tocitem" href="../../misc/testsuite/">Test suite</a></li><li><a class="tocitem" href="../../misc/notation/">Notation</a></li><li><a class="tocitem" href="../../misc/references/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manifolds</a></li><li><a class="is-disabled">Basic manifolds</a></li><li class="is-active"><a href>Sphere</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sphere</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/manifolds/sphere.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SphereSection"><a class="docs-heading-anchor" href="#SphereSection">Sphere and unit norm arrays</a><a id="SphereSection-1"></a><a class="docs-heading-anchor-permalink" href="#SphereSection" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="Manifolds.AbstractSphere"><a class="docstring-binding" href="#Manifolds.AbstractSphere"><code>Manifolds.AbstractSphere</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSphere{ğ”½} &lt;: AbstractDecoratorManifold{ğ”½}</code></pre><p>An abstract type to represent a unit sphere that is represented isometrically in the embedding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L1-L5">source</a></section></details></article><p>The classical sphere, i.e. unit norm (real- or complex-valued) vectors can be generated as usual: to create the 2-dimensional sphere (in <span>$â„^3$</span>), use <code>Sphere(2)</code> and <code>Sphere(2,â„‚)</code>, respectively.</p><article><details class="docstring" open="true"><summary id="Manifolds.Sphere"><a class="docstring-binding" href="#Manifolds.Sphere"><code>Manifolds.Sphere</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Sphere{ğ”½, T} &lt;: AbstractSphere{ğ”½}</code></pre><p>The (unit) sphere manifold <span>$ğ•Š^{n}$</span> is the set of all unit norm vectors in <span>$ğ”½^{n+1}$</span>. The sphere is represented in the embedding, i.e.</p><p class="math-container">\[ğ•Š^{n} := \bigl\{ p \in ğ”½^{n+1}\ \big|\ \lVert p \rVert = 1 \bigr\}\]</p><p>where <span>$ğ”½\in\{â„,â„‚,â„\}$</span>. Note that compared to the <a href="#Manifolds.ArraySphere"><code>ArraySphere</code></a>, here the argument <code>n</code> of the manifold is the dimension of the manifold, i.e. <span>$ğ•Š^{n} âŠ‚ ğ”½^{n+1}$</span>, <span>$n\in â„•$</span>.</p><p>The tangent space at point <span>$p$</span> is given by</p><p class="math-container">\[T_pğ•Š^{n} := \bigl\{ X âˆˆ ğ”½^{n+1}\ |\ \Re(âŸ¨p,XâŸ©) = 0 \bigr \},\]</p><p>where <span>$ğ”½\in\{â„,â„‚,â„\}$</span> and <span>$âŸ¨â‹…,â‹…âŸ©$</span> denotes the inner product in the embedding <span>$ğ”½^{n+1}$</span>.</p><p>For <span>$ğ”½=â„‚$</span>, the manifold is the complex sphere, written <span>$â„‚ğ•Š^n$</span>, embedded in <span>$â„‚^{n+1}$</span>. <span>$â„‚ğ•Š^n$</span> is the complexification of the real sphere <span>$ğ•Š^{2n+1}$</span>. Likewise, the quaternionic sphere <span>$â„ğ•Š^n$</span> is the quaternionification of the real sphere <span>$ğ•Š^{4n+3}$</span>. Consequently, <span>$â„‚ğ•Š^0$</span> is equivalent to <span>$ğ•Š^1$</span> and <a href="../circle/#Circle"><code>Circle</code></a>, while <span>$â„‚ğ•Š^1$</span> and <span>$â„ğ•Š^0$</span> are equivalent to <span>$ğ•Š^3$</span>, though with different default representations.</p><p>This manifold is modeled as a special case of the more general case, i.e. as an embedded manifold to the <a href="../euclidean/#Manifolds.Euclidean"><code>Euclidean</code></a>, and several functions like the <a href="../euclidean/#ManifoldsBase.inner-Tuple{Euclidean, Vararg{Any}}"><code>inner</code></a> product and the <a href="../euclidean/#ManifoldsBase.zero_vector-Tuple{Euclidean, Vararg{Any}}"><code>zero_vector</code></a> are inherited from the embedding.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Sphere(n[, field=â„])</code></pre><p>Generate the (real-valued) sphere <span>$ğ•Š^{n} âŠ‚ â„^{n+1}$</span>, where <code>field</code> can also be used to generate the complex- and quaternionic-valued sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L8-L47">source</a></section></details></article><p>For the higher-dimensional arrays, for example unit (Frobenius) norm matrices, the manifold is generated using the size of the matrix. To create the unit sphere of <span>$3Ã—2$</span> real-valued matrices, write <code>ArraySphere(3,2)</code> and the complex case is done â€“ as for the <a href="../euclidean/#Manifolds.Euclidean"><code>Euclidean</code></a> case â€“ with an keyword argument <code>ArraySphere(3,2; field=â„‚)</code>. This case also covers the classical sphere as a special case, but you specify the size of the vectors/embedding instead: The 2-sphere can here be generated <code>ArraySphere(3)</code>.</p><article><details class="docstring" open="true"><summary id="Manifolds.ArraySphere"><a class="docstring-binding" href="#Manifolds.ArraySphere"><code>Manifolds.ArraySphere</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ArraySphere{ğ”½, T} &lt;: AbstractSphere{ğ”½}</code></pre><p>The (unit) sphere manifold <span>$ğ•Š^{nâ‚,nâ‚‚,...,náµ¢}$</span> is the set of all unit (Frobenius) norm elements of <span>$ğ”½^{nâ‚,nâ‚‚,...,náµ¢}$</span>, where ``ğ”½\in{â„,â„‚,â„}. The generalized sphere is represented in the embedding, and supports arbitrary sized arrays or in other words arbitrary tensors of unit norm. The set formally reads</p><p class="math-container">\[ğ•Š^{n_1, n_2, â€¦, n_i} := \bigl\{ p \in ğ”½^{n_1, n_2, â€¦, n_i}\ \big|\ \lVert p \rVert = 1 \bigr\}\]</p><p>where <span>$ğ”½âˆˆ\{â„,â„‚,â„\}$</span>. Setting <span>$i=1$</span> and <span>$ğ”½=â„$</span>  this  simplifies to unit vectors in <span>$â„^n$</span>, see <a href="#Manifolds.Sphere"><code>Sphere</code></a> for this special case. Note that compared to this classical case, the argument for the generalized case here is given by the dimension of the embedding. This means that <code>Sphere(2)</code> and <code>ArraySphere(3)</code> are the same manifold.</p><p>The tangent space at point <span>$p$</span> is given by</p><p class="math-container">\[T_p ğ•Š^{n_1, n_2, â€¦, n_i} := \bigl\{ X âˆˆ ğ”½^{n_1, n_2, â€¦, n_i}\ |\ \Re(âŸ¨p,XâŸ©) = 0 \bigr \},\]</p><p>where <span>$ğ”½âˆˆ\{â„,â„‚,â„\}$</span> and <span>$âŸ¨â‹…,â‹…âŸ©$</span> denotes the (Frobenius) inner product in the embedding <span>$ğ”½^{n_1, n_2, â€¦, n_i}$</span>.</p><p>This manifold is modelled as an embedded manifold to the <a href="../euclidean/#Manifolds.Euclidean"><code>Euclidean</code></a>, i.e. several functions like the <a href="../euclidean/#ManifoldsBase.inner-Tuple{Euclidean, Vararg{Any}}"><code>inner</code></a> product and the <a href="../euclidean/#ManifoldsBase.zero_vector-Tuple{Euclidean, Vararg{Any}}"><code>zero_vector</code></a> are inherited from the embedding.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ArraySphere(nâ‚,nâ‚‚,...,náµ¢; field=â„, parameter::Symbol=:type)</code></pre><p>Generate sphere in <span>$ğ”½^{n_1, n_2, â€¦, n_i}$</span>, where <span>$ğ”½$</span> defaults to the real-valued case <span>$â„$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L56-L91">source</a></section></details></article><p>There is also one atlas available on the sphere.</p><article><details class="docstring" open="true"><summary id="Manifolds.StereographicAtlas"><a class="docstring-binding" href="#Manifolds.StereographicAtlas"><code>Manifolds.StereographicAtlas</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StereographicAtlas()</code></pre><p>The stereographic atlas of <span>$S^n$</span> with two charts: one with the singular point (-1, 0, ..., 0) (called <code>:north</code>) and one with the singular point (1, 0, ..., 0) (called <code>:south</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L655-L661">source</a></section></details></article><h2 id="Functions-on-unit-spheres"><a class="docs-heading-anchor" href="#Functions-on-unit-spheres">Functions on unit spheres</a><a id="Functions-on-unit-spheres-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-unit-spheres" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Base.exp-Tuple{AbstractSphere, Vararg{Any}}"><a class="docstring-binding" href="#Base.exp-Tuple{AbstractSphere, Vararg{Any}}"><code>Base.exp</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">exp(M::AbstractSphere, p, X)</code></pre><p>Compute the exponential map from <code>p</code> in the tangent direction <code>X</code> on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code> by following the great arc emanating from <code>p</code> in direction <code>X</code>.</p><p class="math-container">\[\exp_p X = \cos(\lVert X \rVert_p)p + \sin(\lVert X \rVert_p)\frac{X}{\lVert X \rVert_p},\]</p><p>where <span>$\lVert X \rVert_p$</span> is the <a href="../../features/atlases/#LinearAlgebra.norm-Tuple{AbstractManifold, AbstractAtlas, Any, Any, Any}"><code>norm</code></a> on the tangent space at <code>p</code> of the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L180-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.log-Tuple{AbstractSphere, Vararg{Any}}"><a class="docstring-binding" href="#Base.log-Tuple{AbstractSphere, Vararg{Any}}"><code>Base.log</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log(M::AbstractSphere, p, q)</code></pre><p>Compute the logarithmic map on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>, i.e. the tangent vector, whose geodesic starting from <code>p</code> reaches <code>q</code> after time 1. The formula reads for <span>$x â‰  -y$</span></p><p class="math-container">\[\log_p q = d_{ğ•Š}(p,q) \frac{q-\Re(âŸ¨p,qâŸ©) p}{\lVert q-\Re(âŸ¨p,qâŸ©) p \rVert_2},\]</p><p>and a deterministic choice from the set of tangent vectors is returned if <span>$x=-y$</span>, i.e. for opposite points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L366-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.local_metric-Tuple{Sphere{â„, Tuple{Int64}}, Any, DefaultOrthonormalBasis}"><a class="docstring-binding" href="#Manifolds.local_metric-Tuple{Sphere{â„, Tuple{Int64}}, Any, DefaultOrthonormalBasis}"><code>Manifolds.local_metric</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_metric(M::Sphere{n}, p, ::DefaultOrthonormalBasis)</code></pre><p>return the local representation of the metric in a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.DefaultOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a>, namely the diagonal matrix of size <span>$nÃ—n$</span> with ones on the diagonal, since the metric is obtained from the embedding by restriction to the tangent space <span>$T_p\mathcal M$</span> at <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L347-L353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.manifold_volume-Tuple{AbstractSphere{â„}}"><a class="docstring-binding" href="#Manifolds.manifold_volume-Tuple{AbstractSphere{â„}}"><code>Manifolds.manifold_volume</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">manifold_volume(M::AbstractSphere{â„})</code></pre><p>Volume of the <span>$n$</span>-dimensional <a href="#Manifolds.Sphere"><code>Sphere</code></a> <code>M</code>. The formula reads</p><p class="math-container">\[\operatorname{Vol}(ğ•Š^{n}) = \frac{2\pi^{(n+1)/2}}{Î“((n+1)/2)},\]</p><p>where <span>$Î“$</span> denotes the <a href="https://en.wikipedia.org/wiki/Gamma_function">Gamma function</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L408-L418">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.volume_density-Tuple{AbstractSphere{â„}, Any, Any}"><a class="docstring-binding" href="#Manifolds.volume_density-Tuple{AbstractSphere{â„}, Any, Any}"><code>Manifolds.volume_density</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">volume_density(M::AbstractSphere{â„}, p, X)</code></pre><p>Compute volume density function of a sphere, i.e. determinant of the differential of exponential map <code>exp(M, p, X)</code>. The formula reads <span>$(\sin(\lVert X\rVert)/\lVert X\rVert)^(n-1)$</span> where <code>n</code> is the dimension of <code>M</code>. It is derived from Eq. (4.1) in [<a href="../../misc/references/#ChevallierLiLuDunson_2022">CLLD22</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L622-L628">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.Weingarten-Tuple{Sphere, Any, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.Weingarten-Tuple{Sphere, Any, Any, Any}"><code>ManifoldsBase.Weingarten</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Y = Weingarten(M::Sphere, p, X, V)
Weingarten!(M::Sphere, Y, p, X, V)</code></pre><p>Compute the Weingarten map <span>$\mathcal W_p$</span> at <code>p</code> on the <a href="#Manifolds.Sphere"><code>Sphere</code></a> <code>M</code> with respect to the tangent vector <span>$X \in T_p\mathcal M$</span> and the normal vector <span>$V \in N_p\mathcal M$</span>.</p><p>The formula is due to [<a href="../../misc/references/#AbsilMahonyTrumpf_2013">AMT13</a>] given by</p><p class="math-container">\[\mathcal W_p(X,V) = -Xp^{\mathrm{T}}V\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L635-L647">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.check_point-Tuple{AbstractSphere, Any}"><a class="docstring-binding" href="#ManifoldsBase.check_point-Tuple{AbstractSphere, Any}"><code>ManifoldsBase.check_point</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_point(M::AbstractSphere, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>, i.e. is a point in the embedding of unit length. The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L104-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{AbstractSphere, Any, T}} where T"><a class="docstring-binding" href="#ManifoldsBase.check_vector-Union{Tuple{T}, Tuple{AbstractSphere, Any, T}} where T"><code>ManifoldsBase.check_vector</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractSphere, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>, i.e. after <a href="../centeredmatrices/#ManifoldsBase.check_point-Union{Tuple{T}, Tuple{CenteredMatrices, T}} where T"><code>check_point</code></a><code>(M,p)</code>, <code>X</code> has to be of same dimension as <code>p</code> and orthogonal to <code>p</code>. The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L121-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.default_retraction_method-Tuple{AbstractSphere}"><a class="docstring-binding" href="#ManifoldsBase.default_retraction_method-Tuple{AbstractSphere}"><code>ManifoldsBase.default_retraction_method</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_retraction_method(M::AbstractSphere)</code></pre><p>The default retraction on the sphere is usually the exponential map. Howeverm since that map tends to be very sensitive to also only slight errors in tangent vectors (not being tangent), we use a stabilized version as default that projects onto the sphere afterwards, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.StabilizedRetraction"><code>StabilizedRetraction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L442-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.distance-Tuple{AbstractSphere, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.distance-Tuple{AbstractSphere, Any, Any}"><code>ManifoldsBase.distance</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distance(M::AbstractSphere, p, q)</code></pre><p>Compute the geodesic distance between <code>p</code> and <code>q</code> on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>. The formula is given by the (shorter) great arc length on the (or a) great circle both <code>p</code> and <code>q</code> lie on.</p><p class="math-container">\[d_{ğ•Š}(p,q) = \arccos(\Re(âŸ¨p,qâŸ©)).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L157-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.get_coordinates-Tuple{AbstractSphere{â„}, Any, Any, DefaultOrthonormalBasis}"><a class="docstring-binding" href="#ManifoldsBase.get_coordinates-Tuple{AbstractSphere{â„}, Any, Any, DefaultOrthonormalBasis}"><code>ManifoldsBase.get_coordinates</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_coordinates(M::AbstractSphere{â„}, p, X, B::DefaultOrthonormalBasis)</code></pre><p>Represent the tangent vector <code>X</code> at point <code>p</code> from the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code> in an orthonormal basis by rotating the hyperplane containing <code>X</code> to a hyperplane whose normal is the <span>$x$</span>-axis.</p><p>Given <span>$q = p Î» + x$</span>, where <span>$Î» = \operatorname{sgn}(âŸ¨x, pâŸ©)$</span>, and <span>$âŸ¨â‹…, â‹…âŸ©_{\mathrm{F}}$</span> denotes the Frobenius inner product, the formula for <span>$Y$</span> is</p><p class="math-container">\[\begin{pmatrix}0 \\ Y\end{pmatrix} = X - q\frac{2 âŸ¨q, XâŸ©_{\mathrm{F}}}{âŸ¨q, qâŸ©_{\mathrm{F}}}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L222-L234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.get_vector-Tuple{AbstractSphere{â„}, Any, Any, DefaultOrthonormalBasis}"><a class="docstring-binding" href="#ManifoldsBase.get_vector-Tuple{AbstractSphere{â„}, Any, Any, DefaultOrthonormalBasis}"><code>ManifoldsBase.get_vector</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_vector(M::AbstractSphere{â„}, p, X, B::DefaultOrthonormalBasis)</code></pre><p>Convert a one-dimensional vector of coefficients <code>X</code> in the basis <code>B</code> of the tangent space at <code>p</code> on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code> to a tangent vector <code>Y</code> at <code>p</code> by rotating the hyperplane containing <code>X</code>, whose normal is the <span>$x$</span>-axis, to the hyperplane whose normal is <code>p</code>.</p><p>Given <span>$q = p Î» + x$</span>, where <span>$Î» = \operatorname{sgn}(âŸ¨x, pâŸ©)$</span>, and <span>$âŸ¨â‹…, â‹…âŸ©_{\mathrm{F}}$</span> denotes the Frobenius inner product, the formula for <span>$Y$</span> is</p><p class="math-container">\[Y = X - q\frac{2 \left\langle q, \begin{pmatrix}0 \\ X\end{pmatrix}\right\rangle_{\mathrm{F}}}{âŸ¨q, qâŸ©_{\mathrm{F}}}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L259-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.injectivity_radius-Tuple{AbstractSphere, Any, ProjectionRetraction}"><a class="docstring-binding" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractSphere, Any, ProjectionRetraction}"><code>ManifoldsBase.injectivity_radius</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">injectivity_radius(M::Sphere, ::ProjectionRetraction)
injectivity_radius(M::Sphere, p, ::ProjectionRetraction)</code></pre><p>Return the injectivity radius for the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.ProjectionRetraction"><code>ProjectionRetraction</code></a> on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a>, which is globally <span>$$(_tex(:frac, &quot;Ï€&quot;, &quot;2&quot;))$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L310-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.injectivity_radius-Tuple{AbstractSphere, Any}"><a class="docstring-binding" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractSphere, Any}"><code>ManifoldsBase.injectivity_radius</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractSphere[, p, ::ExponentialRetraction])</code></pre><p>Return the injectivity radius for the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>, which is globally <span>$Ï€$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L295-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.injectivity_radius-Tuple{AbstractSphere, ProjectionRetraction}"><a class="docstring-binding" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractSphere, ProjectionRetraction}"><code>ManifoldsBase.injectivity_radius</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">injectivity_radius(M::Sphere, ::ProjectionRetraction)
injectivity_radius(M::Sphere, p, ::ProjectionRetraction)</code></pre><p>Return the injectivity radius for the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.ProjectionRetraction"><code>ProjectionRetraction</code></a> on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a>, which is globally <span>$$(_tex(:frac, &quot;Ï€&quot;, &quot;2&quot;))$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L307-L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.injectivity_radius-Tuple{AbstractSphere}"><a class="docstring-binding" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractSphere}"><code>ManifoldsBase.injectivity_radius</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractSphere[, p, ::ExponentialRetraction])</code></pre><p>Return the injectivity radius for the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>, which is globally <span>$Ï€$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L293-L297">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.inverse_retract-Tuple{AbstractSphere, Any, Any, ProjectionInverseRetraction}"><a class="docstring-binding" href="#ManifoldsBase.inverse_retract-Tuple{AbstractSphere, Any, Any, ProjectionInverseRetraction}"><code>ManifoldsBase.inverse_retract</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_retract(M::AbstractSphere, p, q, ::ProjectionInverseRetraction)</code></pre><p>Compute the inverse of the projection based retraction on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>, i.e. rearranging <span>$p+X = q\lVert p+X\rVert_2$</span> yields since <span>$\Re(âŸ¨p,XâŸ©) = 0$</span> and when <span>$d_{ğ•Š^2}(p,q) â‰¤ \frac{Ï€}{2}$</span> that</p><p class="math-container">\[\operatorname{retr}_p^{-1}(q) = \frac{q}{\Re(âŸ¨p, qâŸ©)} - p.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L323-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.is_flat-Tuple{AbstractSphere}"><a class="docstring-binding" href="#ManifoldsBase.is_flat-Tuple{AbstractSphere}"><code>ManifoldsBase.is_flat</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_flat(M::AbstractSphere)</code></pre><p>Return true if <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> is of dimension 1 and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L340-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.manifold_dimension-Tuple{AbstractSphere}"><a class="docstring-binding" href="#ManifoldsBase.manifold_dimension-Tuple{AbstractSphere}"><code>ManifoldsBase.manifold_dimension</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">manifold_dimension(M::AbstractSphere)</code></pre><p>Return the dimension of the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>, respectively i.e. the dimension of the embedding -1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L400-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.parallel_transport_to-Tuple{AbstractSphere, Vararg{Any, 4}}"><a class="docstring-binding" href="#ManifoldsBase.parallel_transport_to-Tuple{AbstractSphere, Vararg{Any, 4}}"><code>ManifoldsBase.parallel_transport_to</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parallel_transport_to(M::AbstractSphere, p, X, q)</code></pre><p>Compute the parallel transport on the <a href="#Manifolds.Sphere"><code>Sphere</code></a> of the tangent vector <code>X</code> at <code>p</code> to <code>q</code>, provided, the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.geodesic-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>geodesic</code></a> between <code>p</code> and <code>q</code> is unique. The formula reads</p><p class="math-container">\[P_{pâ†q}(X) = X - \frac{\Re(âŸ¨\log_p q,XâŸ©_p)}{d^2_ğ•Š(p,q)}
\bigl(\log_p q + \log_q p \bigr).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L551-L561">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.project-Tuple{AbstractSphere, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.project-Tuple{AbstractSphere, Any, Any}"><code>ManifoldsBase.project</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">project(M::AbstractSphere, p, X)</code></pre><p>Project the point <code>X</code> onto the tangent space at <code>p</code> on the <a href="#Manifolds.Sphere"><code>Sphere</code></a> <code>M</code>.</p><p class="math-container">\[\operatorname{proj}_{p}(X) = X - \Re(âŸ¨p, XâŸ©)p\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L473-L481">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.project-Tuple{AbstractSphere, Any}"><a class="docstring-binding" href="#ManifoldsBase.project-Tuple{AbstractSphere, Any}"><code>ManifoldsBase.project</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">project(M::AbstractSphere, p)</code></pre><p>Project the point <code>p</code> from the embedding onto the <a href="#Manifolds.Sphere"><code>Sphere</code></a> <code>M</code>.</p><p class="math-container">\[\operatorname{proj}(p) = \frac{p}{\lVert p \rVert},\]</p><p>where <span>$\lVertâ‹…\rVert$</span> denotes the usual 2-norm for vectors if <span>$m=1$</span> and the Frobenius norm for the case <span>$m&gt;1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L458-L468">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.representation_size-Tuple{ArraySphere}"><a class="docstring-binding" href="#ManifoldsBase.representation_size-Tuple{ArraySphere}"><code>ManifoldsBase.representation_size</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">representation_size(M::AbstractSphere)</code></pre><p>Return the size points on the <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code> are represented as, i.e., the representation size of the embedding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L502-L507">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.retract-Tuple{AbstractSphere, Any, Any, ProjectionRetraction}"><a class="docstring-binding" href="#ManifoldsBase.retract-Tuple{AbstractSphere, Any, Any, ProjectionRetraction}"><code>ManifoldsBase.retract</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">retract(M::AbstractSphere, p, X, ::ProjectionRetraction)</code></pre><p>Compute the retraction that is based on projection, i.e.</p><p class="math-container">\[\operatorname{retr}_p(X) = \frac{p+X}{\lVert p+X \rVert_2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L516-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.riemann_tensor-Tuple{AbstractSphere{â„}, Vararg{Any, 4}}"><a class="docstring-binding" href="#ManifoldsBase.riemann_tensor-Tuple{AbstractSphere{â„}, Vararg{Any, 4}}"><code>ManifoldsBase.riemann_tensor</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">riemann_tensor(M::AbstractSphere{â„}, p, X, Y, Z)</code></pre><p>Compute the Riemann tensor <span>$R(X,Y)Z$</span> at point <code>p</code> on <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code>. The formula reads [<a href="../../misc/references/#MuralidharanFlecther_2012">MF12</a>] (though note that a different convention is used in that paper than in Manifolds.jl):</p><p class="math-container">\[R(X,Y)Z = \langle Z, Y \rangle X - \langle Z, X \rangle Y\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L572-L582">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.sectional_curvature-Tuple{AbstractSphere, Any, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.sectional_curvature-Tuple{AbstractSphere, Any, Any, Any}"><code>ManifoldsBase.sectional_curvature</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sectional_curvature(::AbstractSphere, p, X, Y)</code></pre><p>Sectional curvature of <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code> is 1 if dimension is greater than 1 and 0 otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L592-L597">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.sectional_curvature_max-Tuple{AbstractSphere}"><a class="docstring-binding" href="#ManifoldsBase.sectional_curvature_max-Tuple{AbstractSphere}"><code>ManifoldsBase.sectional_curvature_max</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sectional_curvature_max(::AbstractSphere)</code></pre><p>Sectional curvature of <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code> is 1 if dimension is greater than 1 and 0 otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L602-L607">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.sectional_curvature_min-Tuple{AbstractSphere}"><a class="docstring-binding" href="#ManifoldsBase.sectional_curvature_min-Tuple{AbstractSphere}"><code>ManifoldsBase.sectional_curvature_min</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sectional_curvature_min(M::AbstractSphere)</code></pre><p>Sectional curvature of <a href="#Manifolds.AbstractSphere"><code>AbstractSphere</code></a> <code>M</code> is 1 if dimension is greater than 1 and 0 otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L612-L617">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.mean-Tuple{AbstractSphere, Vararg{Any}}"><a class="docstring-binding" href="#Statistics.mean-Tuple{AbstractSphere, Vararg{Any}}"><code>Statistics.mean</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mean(
    S::AbstractSphere,
    x::AbstractVector,
    [w::AbstractWeights,]
    method = GeodesicInterpolationWithinRadius(Ï€/2);
    kwargs...,
)</code></pre><p>Compute the Riemannian <a href="../../features/statistics/#Statistics.mean-Tuple{AbstractManifold, Vararg{Any}}"><code>mean</code></a> of <code>x</code> using <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.GeodesicInterpolationWithinRadius"><code>GeodesicInterpolationWithinRadius</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/b6c7a0ddeb8c5b764aa5d1c56e315343c94fda42/src/manifolds/Sphere.jl#L424-L435">source</a></section></details></article><h2 id="Visualization-on-Sphere{2,â„}"><a class="docs-heading-anchor" href="#Visualization-on-Sphere{2,â„}">Visualization on <code>Sphere{2,â„}</code></a><a id="Visualization-on-Sphere{2,â„}-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-on-Sphere{2,â„}" title="Permalink"></a></h2><p>You can visualize both points and tangent vectors on the sphere.</p><div class="admonition is-info" id="Note-dc635f5728c63c92"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-dc635f5728c63c92" title="Permalink"></a></header><div class="admonition-body"><p>There seems to be no unified way to draw spheres in the backends of <a href="http://docs.juliaplots.org/latest/">Plots.jl</a>. This recipe currently uses the <code>seriestype</code> <code>wireframe</code> and <code>surface</code>, which does not yet work with the default backend <a href="https://github.com/jheinen/GR.jl"><code>GR</code></a>.</p></div></div><p>In general you can plot the surface of the hyperboloid either as wireframe (<code>wireframe=true</code>) additionally specifying <code>wires</code> (or <code>wires_x</code> and <code>wires_y</code>) to change the density of the wires and a <code>wireframe_color</code> for their color. The same holds for the plot as a <code>surface</code> (which is <code>false</code> by default) and its <code>surface_resolution</code> (or <code>surface_resolution_lat</code> or <code>surface_resolution_lon</code>) and a <code>surface_color</code>.</p><pre><code class="language-julia hljs">using Manifolds, Plots
pythonplot()
M = Sphere(2)
pts = [ [1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0] ]
scene = plot(M, pts; wireframe_color=colorant&quot;#CCCCCC&quot;, markersize=10)</code></pre><img src="baadaa84.svg" alt="Example block output"/><p>which scatters our points. We can also draw connecting geodesics, which here is a geodesic triangle. Here we discretize each geodesic with 100 points along the geodesic. The default value is <code>geodesic_interpolation=-1</code> which switches to scatter plot of the data.</p><pre><code class="language-julia hljs">plot!(scene, M, pts; wireframe=false, geodesic_interpolation=100, linewidth=2)</code></pre><img src="52bd1824.svg" alt="Example block output"/><p>And we can also add tangent vectors, for example tangents pointing towards the geometric center of given points.</p><pre><code class="language-julia hljs">pts2 =  [ [1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0] ]
p3 = 1/sqrt(3) .* [1.0, -1.0, 1.0]
vecs = log.(Ref(M), pts2, Ref(p3))
plot!(scene, M, pts2, vecs; wireframe = false, linewidth=1.5)</code></pre><img src="6dd77b0e.svg" alt="Example block output"/><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[AMT13]</dt><dd><div>P.Â -.-A.Â Absil, R.Â Mahony and J.Â Trumpf. <a href="https://doi.org/10.1007/978-3-642-40020-9_39"><em>An Extrinsic Look at the Riemannian Hessian</em></a>. In: <em>Geometric Science of Information</em>, edited by F.Â Nielsen and F.Â Barbaresco (Springer Berlin Heidelberg, 2013); pp.Â 361â€“368.</div></dd><dt>[CLLD22]</dt><dd><div>E.Â Chevallier, D.Â Li, Y.Â Lu and D.Â B.Â Dunson. <a href="https://doi.org/10.48550/arXiv.2009.01983"><em>Exponential-wrapped distributions on symmetric spaces</em></a>. ArXivÂ Preprint (2022).</div></dd><dt>[MF12]</dt><dd><div>P.Â Muralidharan and P.Â T.Â Fletcher. <a href="https://doi.org/10.1109/cvpr.2012.6247780"><em>Sasaki metrics for analysis of longitudinal data on manifolds</em></a>. In: <em>2012 IEEE Conference on Computer Vision and Pattern Recognition</em> (2012).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spectrahedron/">Â« Spectrahedron</a><a class="docs-footer-nextpage" href="../stiefel/">Stiefel Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 16 December 2025 06:37">Tuesday 16 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
