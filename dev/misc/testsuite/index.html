<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Test suite ¬∑ Manifolds.jl</title><meta name="title" content="Test suite ¬∑ Manifolds.jl"/><meta property="og:title" content="Test suite ¬∑ Manifolds.jl"/><meta property="twitter:title" content="Test suite ¬∑ Manifolds.jl"/><meta name="description" content="Documentation for Manifolds.jl."/><meta property="og:description" content="Documentation for Manifolds.jl."/><meta property="twitter:description" content="Documentation for Manifolds.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manifolds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üöÄ Get Started with <code>Manifolds.jl</code></a></li><li><a class="tocitem" href="../../tutorials/working-in-charts/">work in charts</a></li><li><a class="tocitem" href="../../tutorials/work-with-a-metric-defined-in-a-chart/">work with a metric defined in a chart</a></li><li><a class="tocitem" href="../../tutorials/hand-gestures/">perform Hand gesture analysis</a></li><li><a class="tocitem" href="../../tutorials/integration/">integrate on manifolds and handle probability densities</a></li><li><a class="tocitem" href="../../tutorials/exploring-curvature/">explore curvature without coordinates</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manifolds/centeredmatrices/">Centered matrices</a></li><li><a class="tocitem" href="../../manifolds/choleskyspace/">Cholesky space</a></li><li><a class="tocitem" href="../../manifolds/circle/">Circle</a></li><li><a class="tocitem" href="../../manifolds/determinantone/">Determinant one matrices</a></li><li><a class="tocitem" href="../../manifolds/elliptope/">Elliptope</a></li><li><a class="tocitem" href="../../manifolds/essentialmanifold/">Essential manifold</a></li><li><a class="tocitem" href="../../manifolds/euclidean/">Euclidean</a></li><li><a class="tocitem" href="../../manifolds/fixedrankmatrices/">Fixed-rank matrices</a></li><li><a class="tocitem" href="../../manifolds/flag/">Flag</a></li><li><a class="tocitem" href="../../manifolds/generalizedstiefel/">Generalized Stiefel</a></li><li><a class="tocitem" href="../../manifolds/generalizedgrassmann/">Generalized Grassmann</a></li><li><a class="tocitem" href="../../manifolds/grassmann/">Grassmann</a></li><li><a class="tocitem" href="../../manifolds/hamiltonian/">Hamiltonian</a></li><li><a class="tocitem" href="../../manifolds/heisenberg/">Heisenberg matrices</a></li><li><a class="tocitem" href="../../manifolds/hyperbolic/">Hyperbolic space</a></li><li><a class="tocitem" href="../../manifolds/hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../manifolds/invertible/">Invertible matrices</a></li><li><a class="tocitem" href="../../manifolds/lorentz/">Lorentzian manifold</a></li><li><a class="tocitem" href="../../manifolds/multinomialdoublystochastic/">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="../../manifolds/multinomial/">Multinomial matrices</a></li><li><a class="tocitem" href="../../manifolds/multinomialsymmetric/">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="../../manifolds/multinomialsymmetricpositivedefinite/">Multinomial symmetric positive definite matrices</a></li><li><a class="tocitem" href="../../manifolds/oblique/">Oblique manifold</a></li><li><a class="tocitem" href="../../manifolds/probabilitysimplex/">Probability simplex</a></li><li><a class="tocitem" href="../../manifolds/positivenumbers/">Positive numbers</a></li><li><a class="tocitem" href="../../manifolds/projectivespace/">Projective space</a></li><li><a class="tocitem" href="../../manifolds/generalunitary/">Orthogonal and Unitary Matrices</a></li><li><a class="tocitem" href="../../manifolds/rotations/">Rotations</a></li><li><a class="tocitem" href="../../manifolds/segre/">Segre</a></li><li><a class="tocitem" href="../../manifolds/shapespace/">Shape spaces</a></li><li><a class="tocitem" href="../../manifolds/skewhermitian/">Skew-Hermitian matrices</a></li><li><a class="tocitem" href="../../manifolds/spectrahedron/">Spectrahedron</a></li><li><a class="tocitem" href="../../manifolds/sphere/">Sphere</a></li><li><a class="tocitem" href="../../manifolds/stiefel/">Stiefel</a></li><li><a class="tocitem" href="../../manifolds/symmetric/">Symmetric matrices</a></li><li><a class="tocitem" href="../../manifolds/symmetricpositivedefinite/">Symmetric positive definite</a></li><li><a class="tocitem" href="../../manifolds/spdfixeddeterminant/">SPD, fixed determinant</a></li><li><a class="tocitem" href="../../manifolds/symmetricpsdfixedrank/">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="../../manifolds/symplecticgrassmann/">Symplectic Grassmann</a></li><li><a class="tocitem" href="../../manifolds/symplectic/">Symplectic matrices</a></li><li><a class="tocitem" href="../../manifolds/symplecticstiefel/">Symplectic Stiefel</a></li><li><a class="tocitem" href="../../manifolds/torus/">Torus</a></li><li><a class="tocitem" href="../../manifolds/tucker/">Tucker</a></li><li><a class="tocitem" href="../../manifolds/spheresymmetricmatrices/">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manifolds/fiber_bundle/">Fiber bundle</a></li><li><a class="tocitem" href="../../manifolds/graph/">Graph manifold</a></li><li><a class="tocitem" href="../../manifolds/power/">Power manifold</a></li><li><a class="tocitem" href="../../manifolds/product/">Product manifold</a></li><li><a class="tocitem" href="../../manifolds/vector_bundle/">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manifolds/connection/">Connection manifold</a></li><li><a class="tocitem" href="../../manifolds/metric/">Metric manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="../../features/atlases/">Atlases and charts</a></li><li><a class="tocitem" href="../../features/differentiation/">Differentiation</a></li><li><a class="tocitem" href="../../features/distributions/">Distributions</a></li><li><a class="tocitem" href="../../features/integration/">Integration</a></li><li><a class="tocitem" href="../../features/statistics/">Statistics</a></li><li><a class="tocitem" href="../../features/utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="../about/">About</a></li><li><a class="tocitem" href="../NEWS/">Changelog</a></li><li><a class="tocitem" href="../CONTRIBUTING/">Contributing</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li class="is-active"><a class="tocitem" href>Test suite</a><ul class="internal"><li><a class="tocitem" href="#Functions-for-individual-tests"><span>Functions for individual tests</span></a></li><li><a class="tocitem" href="#Internals-to-handle-expectations"><span>Internals to handle expectations</span></a></li><li><a class="tocitem" href="#Former-tests"><span>Former tests</span></a></li></ul></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Miscellanea</a></li><li class="is-active"><a href>Test suite</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Test suite</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/misc/testsuite.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Test-suite"><a class="docs-heading-anchor" href="#A-Test-suite">A Test suite</a><a id="A-Test-suite-1"></a><a class="docs-heading-anchor-permalink" href="#A-Test-suite" title="Permalink"></a></h1><p>The submodule <code>Manifolds.Test</code> provides functions to test mathematical properties of functions defined for a manifold according to the API from <code>ManifoldsBase.jl</code>.</p><article><details class="docstring" open="true"><summary id="Manifolds.Test"><a class="docstring-binding" href="#Manifolds.Test"><code>Manifolds.Test</code></a> ‚Äî <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test</code></pre><p>The module <code>Manifolds.Test</code> contains functions to test functions from <code>Manifolds.jl</code>. Most functionality is provided only when <code>Test.jl</code> is loaded as well, i.e. populated with methods by the extension.</p><p>The test functions provided are mean to verify that the defined functions on a specific manifold behave as expected, for example that an allocating and in-place version of a function give the same result, or that for example the exponential map computes a point on the manifold, and calling the logarithmic map on the result yields the original tangent vector again, for tangent vectors within the injectivity radius.</p><p>In general for every function defined in the API for manifolds, this module shall provide a test function with</p><ul><li>the same name prefixed by <code>test_</code></li><li>the same function arguments as the original function</li><li>keyword arguments to control which tests to perform</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/src/test.jl#L1-L20">source</a></section></details></article><p>The main function is</p><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_manifold"><a class="docstring-binding" href="#Manifolds.Test.test_manifold"><code>Manifolds.Test.test_manifold</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_manifold(G::AbstractManifold, properties::Dict, expectations::Dict)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <span>$\mathcal M$</span> based on a <code>Dict</code> of properties and a <code>Dict</code> of <code>expectations</code>.</p><p>Three functions are expected to be defined (without explicitly being passed in the <code>properties</code>): <code>is_point(M, p)</code>, <code>is_vector(M, p, X)</code>, and <code>isapprox(M, p, q)</code> / <code>isapprox(M, p, X, Y)</code>, since these are essential for verifying results.</p><p>From the following properties, the two often expected to be defined are <code>:Points</code> and <code>:Vectors</code>, which should contain at least two points and two tangent vectors, respectively.</p><p>Possible properties are</p><ul><li><code>:Aliased</code> is a boolean (same as <code>:Mutating</code> by default) whether to test the mutating variants with aliased input</li><li><code>:Bases</code> is a vector of bases, which can be used to test basis related functions, one basis for each entry in <code>:Coordinates</code></li><li><code>:Covectors</code> is a vector of covectors, which should be in the cotangent space of the correspondinig point entry in <code>:Points</code></li><li><code>:Coordinates</code> is a vector of coordinates, which can be used to test coordinate related functions, one coordinate vector for each entry in <code>:Bases</code></li><li><code>:EmbeddedPoints</code> is a vector of points in the embedding space of <code>M</code>, to test <code>project</code></li><li><code>:EmbeddedVectors</code> is a vector of tangent vectors in the embedding space of <code>M</code>, to test <code>project</code></li><li><code>:Functions</code> is a vector of all defined functions for <code>M</code> note a test is activated by the function (like <code>exp</code>), adding the mutating function (like <code>exp!</code>) overwrites the global default (see <code>:Mutating</code>) to true.</li><li><code>:GeodesicMaxTime</code> is a real number indicating the time parameter to use when testing <code>geodesic</code></li><li><code>:GeodesicSamples</code> is an integer indicating the number of samples to use when testing <code>geodesic</code> (defaults to 10)</li><li><code>:InvalidPoints</code> is a vector of points that are not on <code>M</code>, e.g. to test <code>is_point</code></li><li><code>:InvalidVectors</code> is a vector of tangent vectors that are not in the tangent space of the first point from <code>:Points</code></li><li><code>:InverseRetractionMethods</code> is a vector of inverse retraction methods to test on <code>M</code> these should have the same order as <code>:RetractionMethods</code> (use <code>missing</code> for skipping one)</li><li><code>:Mutating</code> is a boolean (<code>true</code> by default) whether to test the mutating variants of functions or not. when setting this to false, you can still activate single functions mutation checks by adding the mutating function to <code>:Functions</code></li><li><code>:Name</code> is a name of the test. If not provided, defaults to <code>&quot;$M&quot;</code></li><li><code>:NormalVectors</code> is a vector of normal vectors, where each should be in the normal space of the corresponding point entries in <code>:Points</code></li><li><code>:Points</code> is a vector of at least 2 points on <code>M</code>, which should not be the same point</li><li><code>:RetractionMethods</code> is a vector of retraction methods to test on <code>M</code> these should have the same order as <code>:InverseRetractionMethods</code> (use <code>missing</code> for skipping one)</li><li><code>:Rng</code> is a random number generator to use for generating random points/vectors if needed</li><li><code>:Seed</code> is a seed to use for generating random points/vectors if needed</li><li><code>:Vectors</code> is a vector of at least 2 tangent vectors, which should be in the tangent space of the correspondinig point entries in <code>:Points</code></li><li><code>:VectorTransportMethods</code> is a vector of vector transport methods to test on <code>M</code></li><li><code>:TestMidpointSymmetry</code> is a boolean (<code>true</code> by default) whether to test the symmetry property of the midpoint function</li><li><code>:TestInfo</code> is a boolean (<code>true</code> by default) whether to test that whether <code>error=:info</code> in verification functions issues info messages.</li><li><code>:TestWarn</code> is a boolean (<code>true</code> by default) whether to test that whether <code>error=:warn</code> in verification functions issues warning.</li></ul><p>Possible entries of the <code>expectations</code> dictionary are</p><ul><li>any function tested to provide their expected resulting value, e.g. <code>exp =&gt; p</code> for the result of <code>exp(M, p, X)</code></li><li>for retractions, inverse retractions, and vector transports, the key is a tuple of the function and the method, e.g. <code>(retract, method) =&gt; q</code></li><li>for <code>embed</code>, and <code>project</code>, the key is a tuple of the function and <code>:Point</code> or <code>:Vector</code>, e.g. `(embed, :Point) of expected (embedded) points or vectors, omitting that symbol is interpreted as the expected point.</li><li>for <code>get_basis</code>, the key is a tuple of the function and the basis, e.g. <code>(get_basis, B) =&gt; ...</code> to the expexted basis</li><li>for <code>get_coordinates</code> the key is a tuple of the function and the basis, e.g. <code>(get_coordinates, B) =&gt; c</code></li><li>for <code>get_vector</code> the key is a tuple of the function, the coordinate vector, and the basis, e.g. <code>(get_vector, c, B) =&gt; X</code></li><li>for <code>get_vectors</code> the key is a tuple of the function and the basis, e.g. <code>(get_vectors, B) =&gt; :Symbol</code> where<ul><li><code>:Orthogonal</code> tests for orthogonality</li><li><code>:Orthonormal</code> tests additionally to the previous for unit length</li></ul>For any basis this test calls <code>get_basis</code> on any provided basis, if that function is available.</li><li>for <code>is_default_metric</code>, the value is the default metric</li><li><code>:atol =&gt; 0.0</code> a global absolute tolerance</li><li><code>:atols -&gt; Dict()</code> a dictionary <code>function -&gt; atol</code> for tolerances of specific function tested.</li><li><code>:Types</code> -&gt; Dict() a dictionary <code>function -&gt; Type</code> for specifying expected types of results of specific functions, for example <code>manifold_dimension =&gt; Int</code>.</li><li><code>:IsPointErrors</code> is a vector of expected error types for each invalid point provided in <code>:InvalidPoints</code>, use <code>missing</code> to skip testing for errors for a specific point.</li><li><code>:IsVectorErrors</code> is a vector of expected error types for each invalid vector provided in <code>:InvalidVectors</code>, use <code>missing</code> to skip testing for errors for a specific vector.</li><li><code>:IsVectorBasepointError</code> is an expected error type when the base point is invalid e.g. for <code>is_vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L10-L76">source</a></section></details></article><h2 id="Functions-for-individual-tests"><a class="docs-heading-anchor" href="#Functions-for-individual-tests">Functions for individual tests</a><a id="Functions-for-individual-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-individual-tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_copy"><a class="docstring-binding" href="#Manifolds.Test.test_copy"><code>Manifolds.Test.test_copy</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_copy(M, p, X;
    name = &quot;copying on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test <code>copy(M, p)</code> and <code>copy(M, p, X)</code> on a manifold <code>M</code>.</p><ul><li>that the copied point/vector is a valid point/vector on the manifold / tangent space</li><li>that the copied point/vector matches the original point/vector but is new memory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L594-L604">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_copyto"><a class="docstring-binding" href="#Manifolds.Test.test_copyto"><code>Manifolds.Test.test_copyto</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_copyto(M, p, X;
    name = &quot;copying on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test <code>copyto!(M, q, p)</code> and <code>copyto!(M, Y, p, X)</code> on a manifold <code>M</code>.</p><ul><li>that the copied point/vector is a valid point/vector on the manifold / tangent space</li><li>that the copied point/vector matches the original point/vector and is the same memory</li></ul><p>Note that since this function does not modify its input, is is called <code>test_copyto</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L624-L636">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_default_retraction"><a class="docstring-binding" href="#Manifolds.Test.test_default_retraction"><code>Manifolds.Test.test_default_retraction</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_default_retraction_method(
    M, T=missing;
    expected_value = NoExpectation(),
    expected_type = isexpected(expected_value) ? Expect(typeof(expect(expected_value))) : NoExpectation(),
    name = &quot;default_retraction_method on $M $(ismissing(T) ? &quot;&quot; : &quot;for type $T&quot;)&quot;,
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a> on manifold <code>M</code>.</p><ul><li>that it returns an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a></li><li>that the result matches <code>expected_value</code>, if given</li><li>that the result is of type <code>expected_type</code>, if given, defaults to the type of the value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L684-L696">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_default_inverse_retraction"><a class="docstring-binding" href="#Manifolds.Test.test_default_inverse_retraction"><code>Manifolds.Test.test_default_inverse_retraction</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_default_inverse_retraction_method(
    M, T=missing;
    expected_value = NoExpectation(),
    expected_type = !isexpected(expected_value) ? NoExpectation() : typeof(expected_value),
    name = &quot;default_inverse_retraction_method on $M $(ismissing(T) ? &quot;&quot; : &quot;for type $T&quot;)&quot;,
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_inverse_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_inverse_retraction_method</code></a> on manifold <code>M</code>.</p><ul><li>that it returns an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a></li><li>that the result matches <code>expected_value</code>, if given</li><li>that the result is of type <code>expected_type</code>, if given, defaults to the type of the value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L656-L668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_default_vector_transport_method"><a class="docstring-binding" href="#Manifolds.Test.test_default_vector_transport_method"><code>Manifolds.Test.test_default_vector_transport_method</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_default_vector_transport_method(
    M, T=missing;
    expected_value = NoExpectation(),
    expected_type = isexpected(expected_value) ? Expect(typeof(expect(expected_value))) : NoExpectation(),
    name = &quot;default_vector_transport_method on $M $(ismissing(T) ? &quot;&quot; : &quot;for type $T&quot;)&quot;,
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a> on manifold <code>M</code>.</p><ul><li>that it returns an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>AbstractVectorTransportMethod</code></a></li><li>that the result matches <code>expected_value</code>, if given</li><li>that the result is of type <code>expected_type</code>, if given, defaults to the type of the value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L712-L724">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_distance"><a class="docstring-binding" href="#Manifolds.Test.test_distance"><code>Manifolds.Test.test_distance</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_distance(
    M, p, q;
    available_functions=[], expected_value=NoExpectation(),
    name = &quot;Distance on $M between $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the distance function on manifold <code>M</code> between points <code>p</code> and <code>q</code>.</p><ul><li>that the result is a nonnegative number</li><li>that the distance from <code>p</code> to <code>p</code> is zero</li><li>that the distance is symmetric</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the distance is equal to the norm of the logarithmic map (if <code>log</code> and <code>norm</code> are available)   (only performed if either <code>injectivity_radius</code> is not available or the points are within)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L740-L756">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_exp"><a class="docstring-binding" href="#Manifolds.Test.test_exp"><code>Manifolds.Test.test_exp</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_exp(
    M, p, X, t=1.0;
    available_functions=[], expected_value=NoExpectation(), test_mutating=true,
    test_log = (log in available_functions),
    test_fused = true,
    test_injectivity_radius = (injectivity_radius in available_functions),
    name = &quot;Exponential map on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the exponential map on manifold <code>M</code> at point <code>p</code> with tangent vector <code>X</code>.</p><ul><li>that the result is a valid point on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mutating version <code>exp!</code> matches the non-mutating version, (if activated)</li><li>that <code>exp!</code> works on aliased in put (<code>p=q</code>) (if activated for mutating)</li><li>that the logarithmic map inverts the exponential map (if activated)</li></ul><p>(only performed if either <code>injectivity_radius</code> is not available or <code>X</code> is within)</p><ul><li>that the fused version <code>exp_fused(M, p, t, X)</code> matches the non-fused version (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L942-L962">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_embed"><a class="docstring-binding" href="#Manifolds.Test.test_embed"><code>Manifolds.Test.test_embed</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_embed(
    M, p, X=missing;
    available_functions=[],
    expected_point=NoExpectation(),
    expected_vector=NoExpectation(),
    test_aliased=true,
    test_mutating=true,
    name = &quot;Embedding on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.embed-Tuple%7BAbstractManifold%2C%20Any%7D"><code>embed</code></a><code>(M, p)</code> and <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.embed-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>embed</code></a><code>(M, p, X)</code> to embed points and tangent vectors (if not <code>missing</code>).</p><p>Besides a simple call of <code>embed</code> (for both variants) the following ones are prefoemd if <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.get_embedding-Tuple%7BAbstractManifold%7D"><code>get_embedding</code></a> is available:</p><ul><li>that the embedded point is a valid point on the embedding manifold</li><li>that the embedded vector is a valid tangent vector on the embedding manifold (if <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.get_embedding-Tuple%7BAbstractManifold%7D"><code>get_embedding</code></a> is available and <code>X</code> is not <code>missing</code>)</li><li>that the result matches <code>expected_point</code> and <code>expected_vector</code>, respectively, if given</li><li>that the projection inverts the embedding (if <code>project</code> is available)</li><li>that the mutating version <code>embed!</code> produces the same result(s) (if activated <em>and</em> <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.get_embedding-Tuple%7BAbstractManifold%7D"><code>get_embedding</code></a> is available)</li><li>that <code>embed!</code> works on aliased input (<code>p=q</code> or <code>X=Y</code>) (if activated <em>and</em> p/q or X/Y are of same type)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L783-L806">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_embed_project"><a class="docstring-binding" href="#Manifolds.Test.test_embed_project"><code>Manifolds.Test.test_embed_project</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_embed_project(
    M, ap, aX = missing;
    available_functions=[],
    expected_point=NoExpectation(),
    expected_vector=NoExpectation(),
    test_aliased=true,
    test_mutating=true,
    name = &quot;Projection on $M for $(typeof(q)) points&quot;,
    kwargs...
)</code></pre><p>Test the <code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.embed_project-Tuple%7BAbstractManifold%2C%20Any%7D"><code>embed_project</code></a><code>(M, ap)</code> and <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.embed_project-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>embed_project</code></a><code>(M, p, aX)</code> to project points and tangent vectors (if not <code>aX</code> is not <code>missing</code>) after embedding them. Besides a simple call of <code>embed_project</code> (for both variants)  the following tests are performed</p><ul><li>that the projected point is a valid point on the manifold</li><li>that the projected vector is a valid tangent vector on the manifold</li><li>that the result matches <code>expected_point</code> and <code>expected_vector</code>, respectively, if given</li><li>that the mutating version <code>embed_project!</code> produces the same result(s) (if activated)</li><li>that <code>embed_project!</code> works on aliased input (<code>p=q</code> or <code>X=Y</code>) (if activated <em>and</em> p/q or X/Y are of same type)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L875-L896">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_flat"><a class="docstring-binding" href="#Manifolds.Test.test_flat"><code>Manifolds.Test.test_flat</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_flat(M, p, X;
    available_functions = [],
    expected_value= NoExpectation(),
    name = &quot;Flat on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the flat operation on manifold <code>M</code> at point <code>p</code> with tangent vector <code>X</code>.</p><ul><li>(we can not yet test valid cotangent vectors)</li><li>that the result matches <code>expected_value</code>, if given</li><li>that <a href="../../features/atlases/#Manifolds.sharp-Tuple{AbstractManifold, Any, Any}"><code>sharp</code></a> is the inverse</li><li>that mutating version <code>flat!</code> matches non-mutating version (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1015-L1028">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_injectivity_radius"><a class="docstring-binding" href="#Manifolds.Test.test_injectivity_radius"><code>Manifolds.Test.test_injectivity_radius</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_injectority_radius(M, p = missing;
    expected_value = NoExpectation(),
    expected_global_value = NoExpectation(),
    retraction_method = missing,
    name = &quot;Injectivity radius on $M at point $(ismissing(p) ? &quot;&quot; : &quot;$typeof(p)&quot;)) and $(retraction_method)&quot;,
    kwargs...
)</code></pre><p>Test the injectivity radius on manifold <code>M</code> at point <code>p</code>.</p><ul><li>that the result is a nonnegative real number</li><li>that the result matches <code>expected_value</code>, if given</li><li>if a point <code>p</code> is given, that the result is larger or equal to the global injectivity radius</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1298-L1312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_inner"><a class="docstring-binding" href="#Manifolds.Test.test_inner"><code>Manifolds.Test.test_inner</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_inner(M, p, X, Y;
    available_functions=[], expected_value = NoExpectation(),
    name = &quot;Inner product on $M at point $(typeof(p))&quot;,
    test_norm = (norm in available_functions),
    kwargs...
)</code></pre><p>Test the inner product on the manifold <code>M</code> at point <code>p</code> for tangent vectors <code>X</code> and <code>Y</code>.</p><ul><li>that the result is a real number</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the inner product of <code>X</code> with itself is non negative</li><li>that the inner product of <code>X</code> with itself is the same as its norm squared (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1338-L1352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_inverse_retract"><a class="docstring-binding" href="#Manifolds.Test.test_inverse_retract"><code>Manifolds.Test.test_inverse_retract</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_inverse_retraction(
    M, p, q, m::AbstractInverseRetractionMethod;
    available_functions=[],
    expected_value = NoExpectation(),
    name = &quot;Inverse retraction $m on $M at point $(typeof(p))&quot;,
    retraction_method = missing,
    test_mutating = true,
    test_retraction = (retract in available_functions) &amp;&amp; !ismissing(retraction_method),
    kwargs...
)</code></pre><p>Test the inverse retraction method <code>m</code> on manifold <code>M</code> at point <code>p</code> towards point <code>q</code>.</p><ul><li>that the result is a valid tangent vector at <code>p</code> on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mutating version <code>inverse_retract!</code> matches the non-mutating version, (if activated)</li><li>that the retraction inverts the inverse retraction (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1375-L1393">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_is_default_metric"><a class="docstring-binding" href="#Manifolds.Test.test_is_default_metric"><code>Manifolds.Test.test_is_default_metric</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_is_default_metric(M, metric::AbstractMetric;
name = &quot;is_default_metric on $M&quot;,
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#ManifoldsBase.is_default_metric-Tuple%7BAbstractManifold%2C%20AbstractMetric%7D"><code>is_default_metric</code></a> on manifold <code>M</code>.</p><ul><li>that it returns true for the given <code>metric</code></li><li>that it returns false for all other provided metrics</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1421-L1430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_is_flat"><a class="docstring-binding" href="#Manifolds.Test.test_is_flat"><code>Manifolds.Test.test_is_flat</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_is_flat(
M;
expected_value = NoExpectation(),
name = &quot;is_flat on $M&quot;,
)</code></pre><p>Test the function <a href="../../manifolds/centeredmatrices/#ManifoldsBase.is_flat-Tuple{CenteredMatrices}"><code>is_flat</code></a> on manifold <code>M</code>. Since it returns a boolean, there is also only the check that it agrees with the <code>expected_value</code>, if given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1441-L1450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_is_point"><a class="docstring-binding" href="#Manifolds.Test.test_is_point"><code>Manifolds.Test.test_is_point</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.is_point(
    M, p qs...;
    errors = [],
    name = &quot;is_point on $M for $(typeof(p)) points&quot;,
    test_warn = true,
    test_info = true,
    kwargs...
)</code></pre><p>Test the function <a href="../../manifolds/segre/#ManifoldsBase.is_point-Union{Tuple{V}, Tuple{Segre{‚Ñù, V}, Any}} where V"><code>is_point</code></a> on  for point <code>p</code> on manifold <code>M</code>.</p><ul><li>that for <code>p</code> it returns <code>true</code>.</li><li>that for each <code>q</code> in <code>qs</code> it<ul><li>returns <code>false</code></li><li>issues a warning (if activated)</li><li>isues an info message (if activated)</li><li>throws the corresponding error from <code>error_types</code> (if not <code>missing</code>)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1463-L1481">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_is_vector"><a class="docstring-binding" href="#Manifolds.Test.test_is_vector"><code>Manifolds.Test.test_is_vector</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_is_vector(
    M, p, X, Ys...;
    basepoint_error = missing,
    check_basepoint = true,
    errors = [],
    name = &quot;is_vector on $M for $(typeof(p)) points&quot;,
    test_warn = true,
    test_info = true,
    q = missing,
    kwargs...
)</code></pre><p>Test the function <a href="../../manifolds/segre/#ManifoldsBase.is_vector-Union{Tuple{V}, Tuple{Segre{‚Ñù, V}, Any, Any}} where V"><code>is_vector</code></a> on manifold <code>M</code> at point <code>p</code> for tangent vector <code>X</code>.</p><ul><li>that for <code>X</code> it returns <code>true</code>.</li><li>that for each <code>Y</code> in <code>Ys</code> it<ul><li>returns <code>false</code></li><li>issues a warning (if activated)</li><li>isues an info message (if activated)</li><li>throws the corresponding error from <code>error_types</code> (if not <code>missing</code>)</li></ul></li><li>if <code>check_basepoint</code> is <code>true</code>, then it checks that<ul><li>for <code>p</code> this still returns <code>true</code></li><li>for the base point <code>q</code> it<ul><li>returns <code>false</code></li><li>issues a warning (if activated)</li><li>isues an info message (if activated)</li><li>throws the corresponding error from <code>error_basepoint</code> (if activated)</li></ul></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1504-L1532">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_geodesic"><a class="docstring-binding" href="#Manifolds.Test.test_geodesic"><code>Manifolds.Test.test_geodesic</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_geodesic(M, p, X, t=1.0;
    available_functions=[],
    expected_value = NoExpectation(),
    N = 10,
    name = &quot;Geodesic on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the geodesic on manifold <code>M</code> at point <code>p</code> with tangent vector <code>X</code> at time <code>t</code>.</p><ul><li>that at time <code>0</code> the geodesic returns <code>p</code></li><li>that the function <code>Œ≥ = geodesic(M, p, X)</code> is consistent with evaluation at <code>0</code> and <code>t</code>`</li><li>that the result is a valid point on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the geodesic has constant speed (if activated) using <code>N</code> samples and each of the segments is of length equal to the average speed, i.e. <code>t*norm(M, p, X) / (N-1)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1053-L1069">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_get_basis"><a class="docstring-binding" href="#Manifolds.Test.test_get_basis"><code>Manifolds.Test.test_get_basis</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_get_basis(
    M, p, b::AbstractBasis;
    expected_value = NoExpectation(),
    expected_type = isexpected(expected_value) ? Expect(typeof(expect(expected_value))) : Expect(CachedBasis),
    name = &quot;get_basis on $M at point $(typeof(p)) for basis $(typeof(b))&quot;,
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_basis-Tuple%7BAbstractManifold%2C%20Any%2C%20ManifoldsBase.AbstractBasis%7D"><code>get_basis</code></a> on manifold <code>M</code> at point <code>p</code> for basis <code>b</code>.</p><ul><li>that it returns a basis of type <code>expected_type</code>, which defaults to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a>.</li><li>that the result matches <code>expected_value</code>, if given</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1148-L1160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_get_coordinates"><a class="docstring-binding" href="#Manifolds.Test.test_get_coordinates"><code>Manifolds.Test.test_get_coordinates</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_get_coordinates(
    M, p, X, B;
    available_functions = [],
    expected_value = NoExpectation(),
    name = &quot;get_coordinates on $M at point $(typeof(p))&quot;,
    test_mutating = true,
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_coordinates"><code>get_coordinates</code></a> on manifold <code>M</code> at point <code>p</code> for a tangent vector <code>X</code> and a basis <code>B</code>.</p><ul><li>that the result is a valid coordinate vector, that is of correct length</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mutating version <code>get_coordinates!</code> matches the non-mutating version, (if activated)</li><li>that <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_vector"><code>get_vector</code></a> inverts <code>get_coordinates</code> (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1105-L1121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_get_embedding"><a class="docstring-binding" href="#Manifolds.Test.test_get_embedding"><code>Manifolds.Test.test_get_embedding</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_get_embedding(M, P=missing;
    expected_value = NoExpectation(),
    expected_type = isexpected(expected_value) ? Expect(typeof(expect(expected_value))) : NoExpectation(),
    name = &quot;get_embedding on $M $(ismissing(P) ? &quot;&quot; : &quot;for type $P&quot;)&quot;,
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.get_embedding-Tuple%7BAbstractManifold%7D"><code>get_embedding</code></a> on manifold <code>M</code>.</p><ul><li>that it returns an <code>AbstractManifold</code>.</li><li>that its type matches <code>expected_type</code>, if given, defaults to the type of the expected value</li><li>that the result matches <code>expected_value</code>, if given</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1177-L1189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_get_vector"><a class="docstring-binding" href="#Manifolds.Test.test_get_vector"><code>Manifolds.Test.test_get_vector</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_get_vector(
    M, p, c, B;
    available_functions=[],
    expected_value = NoExpectation(),
    name = &quot;get_vector on $M at point $(typeof(p))&quot;,
    test_mutating = true,
    kwargs...
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_vector"><code>get_vector</code></a> on manifold <code>M</code> at point <code>p</code> for a vector of coordinates <code>c</code> in basis <code>B</code>.</p><ul><li>that the result is a valid tangent vector at <code>p</code> on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mutating version <code>get_vector!</code> matches the non-mutating version, (if activated)</li><li>that <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_coordinates"><code>get_coordinates</code></a> inverts <code>get_vector</code> (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1205-L1222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_get_vectors"><a class="docstring-binding" href="#Manifolds.Test.test_get_vectors"><code>Manifolds.Test.test_get_vectors</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_get_vectors(
    M, p, b;
    available_functions=[],
    name = &quot;get_vectors on $M at point $(typeof(p))&quot;,
    test_orthogonality = false,
    test_normality = false,
    kwargs...
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_vectors-Tuple%7BAbstractManifold%2C%20Any%2C%20ManifoldsBase.AbstractBasis%7D"><code>get_vectors</code></a> on manifold <code>M</code> at point <code>p</code> for basis <code>b</code>, where the basis is assumed to come from a call to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_basis-Tuple%7BAbstractManifold%2C%20Any%2C%20ManifoldsBase.AbstractBasis%7D"><code>get_basis</code></a>.</p><ul><li>that there are as many vectors as the manifold dimension (if available)</li><li>that each vector is a valid tangent vector at <code>p</code> on the manifold</li><li>that the vectors are orthogonal (if activated)</li><li>that the vectors are normal (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1248-L1265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_log"><a class="docstring-binding" href="#Manifolds.Test.test_log"><code>Manifolds.Test.test_log</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_log(
    M, p, q;
    available_functions=[], expected_value=NoExpectation(), test_mutating=true,
    test_exp = (exp in available_functions),
    test_injectivity_radius = (injectivity_radius in available_functions),
    name = &quot;Logarithmic map on $M for $(typeof(p)) points&quot;,
    kwargs...
)
Test the logarithmic map on manifold `M` at point `p` towards q

* that the result is a valid tangent vector at `p` on the manifold
* that the result matches `expected_value`, if given
* that the mutating version `log!` matches the non-mutating version, (if activated)
* that the exponential map inverts the logarithmic map (if activated)
(only performed if either `injectivity_radius` is not available or `X` is within)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1567-L1583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_manifold_dimension"><a class="docstring-binding" href="#Manifolds.Test.test_manifold_dimension"><code>Manifolds.Test.test_manifold_dimension</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_manifold_dimension(
    M;
    expected_value = NoExpectation(),
    expected_type = Int,
    name = &quot;Manifold dimension for $M&quot;,
)</code></pre><p>Test that the dimension of the manifold <code>M</code> is consistent.</p><ul><li>that the dimension is nonnegative</li><li>that it is an integer (of type <code>expected_type</code>, <code>Int</code> by default)</li><li>that it matches the expected value (if provided)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1617-L1630">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_manifold_volume"><a class="docstring-binding" href="#Manifolds.Test.test_manifold_volume"><code>Manifolds.Test.test_manifold_volume</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_manifold_volume(
    M;
    expected_value = NoExpectation(),
    name = &quot;Manifold volume for $M&quot;,
)</code></pre><p>Test the volume of the manifold <code>M</code>.</p><ul><li>that the volume is nonnegative</li><li>that it matches the expected value (if provided)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1646-L1657">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_mid_point"><a class="docstring-binding" href="#Manifolds.Test.test_mid_point"><code>Manifolds.Test.test_mid_point</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_mid_point(M, p, q;
    available_functions=[],
    expected_value = NoExpectation(),
    test_aliased = true,
    test_mutating = true,
    test_symmetry = true,
    name = &quot;Mid-point on $M between $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the mid-point function on manifold <code>M</code> between points <code>p</code> and <code>q</code>.</p><ul><li>that the result is a valid point on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mid-point is symmetric (if activated)</li><li>that the distance from <code>p</code> and <code>q</code> to the mid-point is half the distance from <code>p</code> to <code>q</code> (if distance is present)</li><li>that the mutating version <code>mid_point!</code> matches the non-mutating version (if activated)</li><li>that <code>mid_point!</code> works on aliased in put (<code>r=p</code> or <code>r=q</code>) (if activated for mutating)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1671-L1690">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_norm"><a class="docstring-binding" href="#Manifolds.Test.test_norm"><code>Manifolds.Test.test_norm</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_norm(M, p, X;
    available_functions = [], expected_value = NoExpectation(),
    name = &quot;Norm on $M at point $(typeof(p))&quot;,
    test_inner = (inner in available_functions),
    kwargs...
)</code></pre><p>Test the norm on the manifold <code>M</code> at point <code>p</code> for tangent vector <code>X</code>.</p><ul><li>that the result is a real number</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the norm of <code>X</code> with itself is non negative</li><li>that the inner product of <code>X</code> with itself is the same as its norm squared (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1731-L1745">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_parallel_transport"><a class="docstring-binding" href="#Manifolds.Test.test_parallel_transport"><code>Manifolds.Test.test_parallel_transport</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_parallel_transport(
    M, p, X, q;
    available_functions=[],
    direction = (log in available_functions) ? log(M, p, q) : missing,
    expected_value=NoExpectation(),
    expected_value_direction=NoExpectation(),
    name = &quot;Parallel transport on $M at point $(typeof(p))&quot;,
    test_aliased = true,
    test_mutating = true,
    kwargs...
)</code></pre><p>Test the parallel transport on manifold <code>M</code> at point <code>p</code> with tangent vector <code>X</code> to a point <code>q</code>.</p><p>this defaults to testing <code>parallel_transport_to</code>, but can also be used to test <code>parallel_transport_direction</code>, by passing that function to the <code>available_functions</code>, using the <code>direction</code> argument. The <code>direction</code> has to be the one that transports <code>X</code> also to <code>q</code>.</p><ul><li>that the result is a valid tangent vector at <code>q</code> on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mutating version <code>parallel_transport!</code> matches the non-mutating version</li><li>that <code>parallel_transport_to</code> works on aliased in put (<code>Y=X</code>) (if activated)</li><li>that the direction of the transport is consistent with <code>expected_direction</code>, if given</li><li>that the mutating version <code>parallel_transport_direction!</code> matches the non-mutating version (if activated)</li><li>that <code>parallel_transport_direction</code> works on aliased in put (<code>Y=X</code> or <code>Y=d</code>) (if activated for mutating)</li><li>that both functions are consistent</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1767-L1794">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_project"><a class="docstring-binding" href="#Manifolds.Test.test_project"><code>Manifolds.Test.test_project</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_project(
    M, q, Y = missing;
    available_functions = [],
    expected_point = NoExpectation(),
    expected_vector = NoExpectation(),
    test_aliased = true,
    test_mutating = true,
    name = &quot;Projection on $M for $(typeof(q)) points&quot;,
    kwargs...
)</code></pre><p>Test the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/projections/#ManifoldsBase.project-Tuple%7BAbstractManifold%2C%20Any%7D"><code>project</code></a><code>(M, q)</code> and <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/projections/#ManifoldsBase.project-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>project</code></a><code>(M, q, Y)</code> to project points and tangent vectors (if not <code>missing</code>).</p><p>Besides a simple call of <code>project</code> (for both variants)  the following tests are performed</p><ul><li>that the projected point is a valid point on the manifold</li><li>that the projected vector is a valid tangent vector on the manifold</li><li>that the result matches <code>expected_point</code> and <code>expected_vector</code>, respectively, if given</li><li>that the mutating version <code>project!</code> produces the same result(s) (if activated)</li><li>that <code>project!</code> works on aliased input (<code>p=q</code> or <code>X=Y</code>) (if activated <em>and</em> p/q or X/Y are of same type)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1844-L1866">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_rand"><a class="docstring-binding" href="#Manifolds.Test.test_rand"><code>Manifolds.Test.test_rand</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_rand(M;
    vector_at = missing,
    seed = missing,
    test_mutating = true,
    rng = missing,
    name = &quot;Random sampling on $M&quot;,
    kwargs...
)</code></pre><p>Test the random sampling functions <code>rand(M)</code> and <code>rand(M; vector_at=p</code> (if <code>vector_at</code> is given) on manifold <code>M</code>.</p><ul><li>that the result of <code>rand(M)</code> is a valid point on the manifold</li><li>that the result of <code>rand(M; vector_at=p)</code> is a valid tangent vector at <code>p</code> on the manifold (if <code>vector_at</code> is given)</li><li>that the mutating versions <code>rand!</code> match the non-mutating versions (if activated)</li><li>that the four mentioned functions also work with a seed upfront.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1931-L1947">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_repr"><a class="docstring-binding" href="#Manifolds.Test.test_repr"><code>Manifolds.Test.test_repr</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_repr(
    M;
    expected_value = NoExpectation(),
    name = &quot;(String) repr_esentation of $M&quot;,
)</code></pre><p>Test that the default <code>show</code> method works as expected by calling <code>repr(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1912-L1920">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_representation_size"><a class="docstring-binding" href="#Manifolds.Test.test_representation_size"><code>Manifolds.Test.test_representation_size</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_representation_size(
    M;
    expected_value = NoExpectation(),
    name = &quot;Representation size of $M&quot;,
)</code></pre><p>Test the representation size of the manifold <code>M</code>.</p><ul><li>that the result is tuple of nonnegative integers or nothing (if there is no reasonable representation)</li><li>that it matches the expected value (if provided)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L1980-L1991">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_retract"><a class="docstring-binding" href="#Manifolds.Test.test_retract"><code>Manifolds.Test.test_retract</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.test.test_retract(
    M, p, X, m::AbstractRetractionMethod;
    available_functions=[],
    expected_value = NoExpectation(),
    inverse_retraction_method = missing,
name = &quot;Retraction $m on $M at point $(typeof(p))&quot;,
    t = 1.0
    test_mutating = true,
    test_mutating = true,
    test_inverse_retraction = (inverse_retraction in available_functions) &amp;&amp; !ismissing(inverse_retraction_method),
    kwargs...
)</code></pre><p>Test the retraction method <code>m</code> on manifold <code>M</code> at point <code>p</code> with tangent vector <code>X</code>.</p><ul><li>that the result is a valid point on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mutating version <code>retract!</code> matches the non-mutating version, (if activated)</li><li>that <code>retract!</code> works on aliased in put (<code>p=q</code>) (if activated for mutating)</li><li>that the inverse retraction inverts the retraction (if activated)</li><li>that the fused version <code>retract_fused(M, p, X, t, m)</code> matches the non-fused version (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2007-L2029">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_sectional_curvature"><a class="docstring-binding" href="#Manifolds.Test.test_sectional_curvature"><code>Manifolds.Test.test_sectional_curvature</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_sectional_curvature(
    M, p, X, Y;
    expected_value = NoExpectation(),
    expected_min = NoExpectation(),
    expected_max = NoExpectation(),
    name = &quot;Sectional curvature on $M at point $(typeof(p))&quot;,
    kwargs...
)</code></pre><p>Test the sectional curvature on manifold <code>M</code> at point <code>p</code> for tangent vectors <code>X</code> and <code>Y</code>.</p><ul><li>that the result is a real number</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the minimum sectional curvature at <code>p</code> is less than or equal to the sectional curvature</li><li>that the maximum sectional curvature at <code>p</code> is greater than or equal to the sectional curvature</li><li>that the minimum and maximum sectional curvatures match <code>expected_min</code> and <code>expected_max</code>, if given</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2080-L2096">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_sharp"><a class="docstring-binding" href="#Manifolds.Test.test_sharp"><code>Manifolds.Test.test_sharp</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_sharp(M, p, Œæ;
    available_functions=[],
    expected_value = NoExpectation(),
    name = &quot;Sharp on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the sharp operation on manifold <code>M</code> at point <code>p</code> with cotangent vector <code>Œæ</code>.</p><ul><li>test that the result is a valid tangent vector at <code>p</code> on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that <a href="../../features/atlases/#Manifolds.flat-Tuple{AbstractManifold, Any, Any}"><code>flat</code></a> is the inverse</li><li>that mutating version <code>sharp!</code> matches non-mutating version (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2119-L2132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_shortest_geodesic"><a class="docstring-binding" href="#Manifolds.Test.test_shortest_geodesic"><code>Manifolds.Test.test_shortest_geodesic</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_shortest_geodesic(M, p, q, t=1.0;
    available_functions=[],
    expected_value = NoExpectation(),
    N = 10,
    name = &quot;Shortest geodesic on $M for $(typeof(p)) points&quot;,
    kwargs...
)</code></pre><p>Test the geodesic on manifold <code>M</code> at point <code>p</code> with tangent vector <code>X</code> at time <code>t</code>.</p><ul><li>that at time <code>0</code> the geodesic returns <code>p</code>, at time 2 it returns <code>q</code></li><li>that the function <code>Œ≥ = shortest_geodesic(M, p, X)</code> is consistent with evaluation at <code>0</code>, <code>1</code> and <code>t</code>`</li><li>that the result at <code>t</code> is a valid point on the manifold</li><li>that the geodesic has constant speed (if activated) using <code>N</code> samples and the approximated derivative via finite differences</li><li>that the geodesic is length minimizing, i.e. the sum of the segments is approximately equal to the distance from <code>p</code> to <code>q</code> (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2158-L2174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_vector_transport"><a class="docstring-binding" href="#Manifolds.Test.test_vector_transport"><code>Manifolds.Test.test_vector_transport</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_vector_transport(
    M, p, X, q, default_vector_transport_method(M);
    available_functions=[],
    direction = inverse_retract(M, p, q, default_inverse_retraction_method(M)),
    expected_value = NoExpectation(),
    expected_value_direction = NoExpectation(),
    test_aliased = true,
    test_mutating = true,
    name = &quot;Vector transport method $(vector_transport_method) on $M at point $(typeof(p))&quot;,
    kwargs...
)</code></pre><p>Test the vector transport on manifold <code>M</code> at point <code>p</code> with tangent vector <code>X</code> to a point <code>q</code>.</p><p>this defaults to testing <code>vector_transport_to</code>, but can also be used to test <code>vector_transport_direction</code>, by passing that function to the <code>available_functions</code>, using the <code>direction</code> argument. The <code>direction</code> has to be the one that transports <code>X</code> also to <code>q</code>.</p><ul><li>that the result is a valid tangent vector at <code>q</code> on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the mutating version <code>vector_transport!</code> matches the non-mutating version</li><li>that <code>vector_transport_to</code> works on aliased in put (<code>Y=X</code>) (if activated)</li><li>that the direction of the transport is consistent with <code>expected_direction</code>, if given</li><li>that the mutating version <code>vector_transport_direction!</code> matches the non-mutating version (if activated)</li><li>that <code>vector_transport_direction</code> works on aliased in put (<code>Y=X</code> or <code>Y=d</code>) (if activated for mutating)</li><li>that both functions are consistent</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2219-L2246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_volume_density"><a class="docstring-binding" href="#Manifolds.Test.test_volume_density"><code>Manifolds.Test.test_volume_density</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_volume_density(
    M, p, X;
    expected_value = NoExpectation(),
    name = &quot;Manifold volume density for $M&quot;,
    kwargs...
)</code></pre><p>Test the <a href="../../features/integration/#Manifolds.volume_density-Tuple{AbstractManifold, Any, Any}"><code>volume_density</code></a> of the manifold <code>M</code>.</p><ul><li>that it matches the expected value (if provided)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2296-L2307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_Weingarten"><a class="docstring-binding" href="#Manifolds.Test.test_Weingarten"><code>Manifolds.Test.test_Weingarten</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.Weingarten(
    M, p, X, V;
    expected_value = NoExpectation(),
    test_aliased = true,
    test_mutating = true,
    name = &quot;Weingarten map on $M at point $(typeof(p))&quot;,
    kwargs...
)</code></pre><p>Test the Weingarten map on manifold <code>M</code> at point <code>p</code> for tangent vector <code>X</code> and normal vector <code>V</code>.</p><ul><li>that the result is a valid tangent vector at <code>p</code> on the manifold</li><li>that the result matches <code>expected_value</code>, if given</li><li>that the result is consistent with the mutating version <code>weingarten!</code> (if activated)</li><li>that <code>Weingarten!</code> works on aliased in put (<code>Y=X</code>) (if activated for mutating)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2321-L2337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.test_zero_vector"><a class="docstring-binding" href="#Manifolds.Test.test_zero_vector"><code>Manifolds.Test.test_zero_vector</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.Test.test_zero_vector(M, p;
    available_functions=[],
    test_mutating = true,
    test_norm = (norm in available_functions),
    name = &quot;Zero vector test on $M at point $(typeof(p))&quot;,
)</code></pre><p>Test the zero vector on the manifold <code>M</code> at point <code>p</code>.</p><ul><li>verify that it is a valid tangent vector</li><li>verify that its norm is zero (if provided)</li><li>verify that the mutating version <code>zero_vector!</code> matches the non-mutating version (if activated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/ManifoldsTestExt.jl#L2365-L2377">source</a></section></details></article><h2 id="Internals-to-handle-expectations"><a class="docs-heading-anchor" href="#Internals-to-handle-expectations">Internals to handle expectations</a><a id="Internals-to-handle-expectations-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-to-handle-expectations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Manifolds.Test.AbstractExpectation"><a class="docstring-binding" href="#Manifolds.Test.AbstractExpectation"><code>Manifolds.Test.AbstractExpectation</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractExpectation</code></pre><p>An abstract type for expectations in tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/src/test.jl#L24-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.Expect"><a class="docstring-binding" href="#Manifolds.Test.Expect"><code>Manifolds.Test.Expect</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Expect{T} &lt;: AbstractExpectation</code></pre><p>A struct to hold expected values for tests of type <code>T</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::T</code> the expected value</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Expect(value::T)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/src/test.jl#L31-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.NoExpectation"><a class="docstring-binding" href="#Manifolds.Test.NoExpectation"><code>Manifolds.Test.NoExpectation</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoExcpectation &lt;: AbstractExpectation</code></pre><p>A struct to indicate that no expectation is provided for a test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/src/test.jl#L48-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.expect"><a class="docstring-binding" href="#Manifolds.Test.expect"><code>Manifolds.Test.expect</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">expect(e::Union{Expect{T}, NoExpectation}) where T</code></pre><p>Get the expected value if provided, error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/src/test.jl#L70-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.Test.isexpected"><a class="docstring-binding" href="#Manifolds.Test.isexpected"><code>Manifolds.Test.isexpected</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">expected(e::Union{Expect, NoExpectation})</code></pre><p>Check if an expectation is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/src/test.jl#L60-L64">source</a></section></details></article><h2 id="Former-tests"><a class="docs-heading-anchor" href="#Former-tests">Former tests</a><a id="Former-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Former-tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Manifolds.find_eps"><a class="docstring-binding" href="#Manifolds.find_eps"><code>Manifolds.find_eps</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.find_eps(x...)</code></pre><p>Find an appropriate tolerance for given points or tangent vectors, or their types.</p><div class="admonition is-info" id="Note-e37ed3c0365b665a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e37ed3c0365b665a" title="Permalink"></a></header><div class="admonition-body"><p>This function is soon deprecated and will be replaced by a more systematic way in <code>Manifolds.Test</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/tests_general.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.test_manifold"><a class="docstring-binding" href="#Manifolds.test_manifold"><code>Manifolds.test_manifold</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.test_manifold(M::AbstractManifold, pts::AbstractVector; kwargs...)</code></pre><p>Test general properties of manifold <code>M</code>, given at least three different points that lie on it (contained in <code>pts</code>).</p><div class="admonition is-info" id="Note-d7de6991a4f0b4a3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d7de6991a4f0b4a3" title="Permalink"></a></header><div class="admonition-body"><p>This is an old an soon deprecated interface, the new one is <code>Manifolds.Test.test_manifold</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>basis_has_specialized_diagonalizing_get = false</code>: if true, assumes that   <code>DiagonalizingOrthonormalBasis</code> given in <code>basis_types</code> has   <a href="../../manifolds/circle/#ManifoldsBase.get_coordinates-Tuple{Circle{‚ÑÇ}, Any, Any, DefaultOrthonormalBasis{&lt;:Any, TangentSpaceType}}"><code>get_coordinates</code></a> and <a href="../../manifolds/generalunitary/#ManifoldsBase.get_vector-Tuple{Manifolds.GeneralUnitaryMatrices{‚Ñù}, Vararg{Any}}"><code>get_vector</code></a> that work without caching.</li><li><code>basis_types_to_from = ()</code>: basis types that will be tested based on   <a href="../../manifolds/circle/#ManifoldsBase.get_coordinates-Tuple{Circle{‚ÑÇ}, Any, Any, DefaultOrthonormalBasis{&lt;:Any, TangentSpaceType}}"><code>get_coordinates</code></a> and <a href="../../manifolds/generalunitary/#ManifoldsBase.get_vector-Tuple{Manifolds.GeneralUnitaryMatrices{‚Ñù}, Vararg{Any}}"><code>get_vector</code></a>.</li><li><code>basis_types_vecs = ()</code> : basis types that will be tested based on <code>get_vectors</code></li><li><code>default_inverse_retraction_method = ManifoldsBase.LogarithmicInverseRetraction()</code>:   default method for inverse retractions (<code>log</code>.</li><li><code>default_retraction_method = ManifoldsBase.ExponentialRetraction()</code>: default method for   retractions (<code>exp</code>).</li><li><code>exp_log_atol_multiplier = 0</code>: change absolute tolerance of exp/log tests   (0 use default, i.e. deactivate atol and use rtol).</li><li><code>exp_log_rtol_multiplier = 1</code>: change the relative tolerance of exp/log tests   (1 use default). This is deactivated if the <code>exp_log_atol_multiplier</code> is nonzero.</li><li><code>expected_dimension_type = Integer</code>: expected type of value returned by   <code>manifold_dimension</code>.</li><li><code>inverse_retraction_methods = []</code>: inverse retraction methods that will be tested.</li><li><code>is_mutating = true</code>: whether mutating variants of functions should be tested.</li><li><code>is_point_atol_multiplier = 0</code>: determines atol of <code>is_point</code> checks.</li><li><code>is_tangent_atol_multiplier = 0</code>: determines atol of <code>is_vector</code> checks.</li><li><code>has_get_embedding = false</code>: whether the manifold has a specialized   <a href="../../manifolds/circle/#ManifoldsBase.get_embedding-Tuple{Circle{‚ÑÇ}}"><code>get_embedding</code></a><code>(M, p)</code> method (to test mutating <code>embed!</code>). This is experimental.</li><li><code>mid_point12 = test_exp_log ? shortest_geodesic(M, pts[1], pts[2], 0.5) : nothing</code>: if not <code>nothing</code>, then check   that <code>mid_point(M, pts[1], pts[2])</code> is approximately equal to <code>mid_point12</code>. This is   by default set to <code>nothing</code> if <code>text_exp_log</code> is set to false.</li><li><code>point_distributions = []</code> : point distributions to test.</li><li><code>rand_tvector_atol_multiplier = 0</code> : chage absolute tolerance in testing random vectors   (0 use default, i.e. deactivate atol and use rtol) random tangent vectors are tangent   vectors.</li><li><code>retraction_atol_multiplier = 0</code>: change absolute tolerance of (inverse) retraction tests   (0 use default, i.e. deactivate atol and use rtol).</li><li><code>retraction_rtol_multiplier = 1</code>: change the relative tolerance of (inverse) retraction   tests (1 use default). This is deactivated if the <code>exp_log_atol_multiplier</code> is nonzero.</li><li><code>retraction_methods = []</code>: retraction methods that will be tested.</li><li><code>test_atlases = []</code>: Vector or tuple of atlases that should be tested.</li><li><code>test_exp_log = true</code>: if true, check that <a href="../../manifolds/choleskyspace/#Base.exp-Tuple{CholeskySpace, Vararg{Any}}"><code>exp</code></a> is the inverse of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.log-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>log</code></a>.</li><li><code>test_injectivity_radius = true</code>: whether implementation of <a href="../../manifolds/circle/#ManifoldsBase.injectivity_radius-Tuple{Circle}"><code>injectivity_radius</code></a>   should be tested.</li><li><code>test_inplace = false</code> : if true check if inplace variants work if they are activated,  e.g. check that <code>exp!(M, p, p, X)</code> work if <code>test_exp_log = true</code>.  This in general requires <code>is_mutating</code> to be true.</li><li><code>test_is_tangent</code>: if true check that the <code>default_inverse_retraction_method</code>   actually returns valid tangent vectors.</li><li><code>test_musical_isomorphisms = false</code> : test musical isomorphisms.</li><li><code>test_mutating_rand = false</code> : test the mutating random function for points on manifolds.</li><li><code>test_project_point = false</code>: test projections onto the manifold.</li><li><code>test_project_tangent = false</code> : test projections on tangent spaces.</li><li><code>test_representation_size = true</code> : test representation size of points/tvectprs.</li><li><code>test_tangent_vector_broadcasting = true</code> : test boradcasting operators on TangentSpace.</li><li><code>test_vector_spaces = true</code> : test Vector bundle of this manifold.</li><li><code>test_default_vector_transport = false</code> : test the default vector transport (usually  parallel transport).</li><li><code>tvector_distributions = []</code> : tangent vector distributions to test.</li><li><code>vector_transport_methods = []</code>: vector transport methods that should be tested.</li><li><code>vector_transport_inverse_retractions = [default_inverse_retraction_method for _ in 1:length(vector_transport_methods)]</code>` inverse retractions to use with the vector transport method (especially the differentiated ones)</li><li><code>vector_transport_to = [ true for _ in 1:length(vector_transport_methods)]</code>: whether  to check the <code>to</code> variant of vector transport</li><li><code>vector_transport_direction = [ true for _ in 1:length(vector_transport_methods)]</code>: whether  to check the <code>direction</code> variant of vector transport</li></ul><div class="admonition is-info" id="Note-e37ed3c0365b665a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e37ed3c0365b665a" title="Permalink"></a></header><div class="admonition-body"><p>This function is soon deprecated and will be replaced by a more systematic way in <code>Manifolds.Test</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/tests_general.jl#L18-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manifolds.test_parallel_transport"><a class="docstring-binding" href="#Manifolds.test_parallel_transport"><code>Manifolds.test_parallel_transport</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Manifolds.test_parallel_transport(M,P; to=true, direction=true)</code></pre><p>Generic tests for parallel transport on <code>M</code>given at least two pointsin <code>P</code>.</p><p>The single functions to transport <code>to</code> (a point) or (in a) <code>direction</code> are sub-tests that can be activated by the keywords arguments</p><div class="admonition is-info" id="Note-e37ed3c0365b665a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e37ed3c0365b665a" title="Permalink"></a></header><div class="admonition-body"><p>This function is soon deprecated and will be replaced by a more systematic way in <code>Manifolds.Test</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/fba9ba085a85e9edbe4ed59b29262bd33009e38d/ext/ManifoldsTestExt/tests_general.jl#L767-L777">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">¬´ Internals</a><a class="docs-footer-nextpage" href="../notation/">Notation ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 11 December 2025 13:36">Thursday 11 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
