var documenterSearchIndex = {"docs":
[{"location":"features/statistics.html#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"features/statistics.html","page":"Statistics","title":"Statistics","text":"Modules = [Manifolds,ManifoldsBase]\nPages = [\"statistics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/statistics.html#Manifolds.AbstractEstimationMethod","page":"Statistics","title":"Manifolds.AbstractEstimationMethod","text":"AbstractEstimationMethod\n\nAbstract type for defining statistical estimation methods.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.CyclicProximalPointEstimation","page":"Statistics","title":"Manifolds.CyclicProximalPointEstimation","text":"CyclicProximalPointEstimation <: AbstractEstimationMethod\n\nMethod for estimation using the cyclic proximal point technique.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.ExtrinsicEstimation","page":"Statistics","title":"Manifolds.ExtrinsicEstimation","text":"ExtrinsicEstimation <: AbstractEstimationMethod\n\nMethod for estimation in the ambient space and projecting to the manifold.\n\nFor mean estimation, GeodesicInterpolation is used for mean estimation in the ambient space.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.GeodesicInterpolation","page":"Statistics","title":"Manifolds.GeodesicInterpolation","text":"GeodesicInterpolation <: AbstractEstimationMethod\n\nRepeated weighted geodesic interpolation method for estimating the Riemannian center of mass.\n\nThe algorithm proceeds with the following simple online update:\n\nbeginaligned\nμ_1 = x_1\nt_k = fracw_ksum_i=1^k w_i\nμ_k = γ_μ_k-1(x_k t_k)\nendaligned\n\nwhere x_k are points, w_k are weights, μ_k is the kth estimate of the mean, and γ_x(y t) is the point at time t along the shortest_geodesic between points xy  mathcal M. The algorithm terminates when all x_k have been considered. In the Euclidean case, this exactly computes the weighted mean.\n\nThe algorithm has been shown to converge asymptotically with the sample size for the following manifolds equipped with their default metrics when all sampled points are in an open geodesic ball about the mean with corresponding radius (see GeodesicInterpolationWithinRadius):\n\nAll simply connected complete Riemannian manifolds with non-positive sectional curvature at radius  [Cheng2016], in particular:\nEuclidean\nSymmetricPositiveDefinite [Ho2013]\nOther manifolds:\nSphere: fracπ2 [Salehian2015]\nGrassmann: fracπ4 [Chakraborty2015]\nStiefel/Rotations: fracπ2 sqrt 2 [Chakraborty2019]\n\nFor online variance computation, the algorithm additionally uses an analogous recursion to the weighted Welford algorithm [West1979].\n\n[Ho2013]: Ho J.; Cheng G.; Salehian H.; Vemuri B. C.; Recursive Karcher expectation estimators and geometric law of large numbers. Proceedings of the 16th International Conference on Artificial Intelligence and Statistics (2013), pp. 325–332. pdf.\n\n[Salehian2015]: Salehian H.; Chakraborty R.; Ofori E.; Vaillancourt D.; An efficient recursive estimator of the Fréchet mean on a hypersphere with applications to Medical Image Analysis. Mathematical Foundations of Computational Anatomy (2015). pdf.\n\n[Chakraborty2015]: Chakraborty R.; Vemuri B. C.; Recursive Fréchet Mean Computation on the Grassmannian and Its Applications to Computer Vision. Proceedings of the IEEE International Conference on Computer Vision (ICCV) (2015), pp. 4229-4237. doi: 10.1109/ICCV.2015.481, link.\n\n[Cheng2016]: Cheng G.; Ho J.; Salehian H.; Vemuri B. C.; Recursive Computation of the Fréchet Mean on Non-positively Curved Riemannian Manifolds with Applications. Riemannian Computing in Computer Vision. Springer, Cham (2016), pp. 21-43. doi: 10.1007/978-3-319-22957-7_2, pdf.\n\n[Chakraborty2019]: Chakraborty R.; Vemuri B. C.; Statistics on the (compact) Stiefel manifold: Theory and Applications. The Annals of Statistics (2019), 47(1), pp. 415-438. doi: 10.1214/18-AOS1692, arxiv: 1708.00045.\n\n[West1979]: West D. H. D.; Updating Mean and Variance Estimates: An Improved Method. Communications of the ACM (1979), 22(9), pp. 532–535. doi: 10.1145/359146.359153.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.GeodesicInterpolationWithinRadius","page":"Statistics","title":"Manifolds.GeodesicInterpolationWithinRadius","text":"GeodesicInterpolationWithinRadius{T} <: AbstractEstimationMethod\n\nEstimation of Riemannian center of mass using GeodesicInterpolation with fallback to GradientDescentEstimation if any points are outside of a geodesic ball of specified radius around the mean.\n\nConstructor\n\nGeodesicInterpolationWithinRadius(radius)\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.GradientDescentEstimation","page":"Statistics","title":"Manifolds.GradientDescentEstimation","text":"GradientDescentEstimation <: AbstractEstimationMethod\n\nMethod for estimation using gradient descent.\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.WeiszfeldEstimation","page":"Statistics","title":"Manifolds.WeiszfeldEstimation","text":"WeiszfeldEstimation <: AbstractEstimationMethod\n\nMethod for estimation using the Weiszfeld algorithm for the median\n\n\n\n\n\n","category":"type"},{"location":"features/statistics.html#Manifolds.default_estimation_method-Tuple{AbstractManifold, Any}","page":"Statistics","title":"Manifolds.default_estimation_method","text":"default_estimation_method(M::AbstractManifold, f)\n\nSpecify a default AbstractEstimationMethod for an AbstractManifold for a function f, e.g. the median or the mean.\n\nNote that his function is decorated, so it can inherit from the embedding, for example for the IsEmbeddedSubmanifold trait.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.cov-Tuple{AbstractManifold, AbstractVector{T} where T}","page":"Statistics","title":"Statistics.cov","text":"Statistics.cov(\n    M::AbstractManifold,\n    x::AbstractVector;\n    basis::AbstractBasis=DefaultOrthonormalBasis(),\n    tangent_space_covariance_estimator::CovarianceEstimator=SimpleCovariance(;\n        corrected=true,\n    ),\n    mean_estimation_method::AbstractEstimationMethod=GradientDescentEstimation(),\n    inverse_retraction_method::AbstractInverseRetractionMethod=default_inverse_retraction_method(\n        M,\n    ),\n)\n\nEstimate the covariance matrix of a set of points x on manifold M. Since the covariance matrix on a manifold is a rank 2 tensor, the function returns its coefficients in basis induced by the given tangent space basis. See Section 5 of [Pennec2006] for details.\n\nThe mean is calculated using the specified mean_estimation_method using [mean](@ref Statistics.mean(::AbstractManifold, ::AbstractVector, ::AbstractEstimationMethod), and tangent vectors at this mean are calculated using the provided inverse_retraction_method. Finally, the covariance matrix in the tangent plane is estimated using the Euclidean space  estimator tangent_space_covariance_estimator. The type CovarianceEstimator is defined  in StatsBase.jl  and examples of covariance estimation methods can be found in  CovarianceEstimation.jl.\n\n[Pennec2006]: X. Pennec, “Intrinsic Statistics on Riemannian Manifolds: Basic Tools for Geometric Measurements,” J Math Imaging Vis, vol. 25, no. 1, p. 127, Jul. 2006, doi: 10.1007/s10851-006-6228-4.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean!-Tuple{AbstractManifold, Vararg{Any, N} where N}","page":"Statistics","title":"Statistics.mean!","text":"mean!(M::AbstractManifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmean!(\n    M::AbstractManifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the mean in-place in y.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{AbstractManifold, AbstractVector{T} where T, AbstractVector{T} where T, ExtrinsicEstimation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::ExtrinsicEstimation;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using ExtrinsicEstimation, i.e. by computing the mean in the embedding and projecting the result back. You can specify an extrinsic_method to specify which mean estimation method to use in the embedding, which defaults to GeodesicInterpolation.\n\nSee mean for a description of the remaining kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{AbstractManifold, AbstractVector{T} where T, AbstractVector{T} where T, GeodesicInterpolationWithinRadius}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using GeodesicInterpolationWithinRadius.\n\nSee mean for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{AbstractManifold, AbstractVector{T} where T, AbstractVector{T} where T, GeodesicInterpolation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng=nothing,\n    retraction::AbstractRetractionMethod = default_retraction_method(M),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M),\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x in an online fashion using repeated weighted geodesic interpolation. See GeodesicInterpolation for details.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered for computing the mean.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.mean-Tuple{AbstractManifold, Vararg{Any, N} where N}","page":"Statistics","title":"Statistics.mean","text":"mean(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\n\nCompute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector x of points on the AbstractManifold  M, defined as the point that satisfies the minimizer\n\nargmin_y  mathcal M frac12 sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M^2(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance.\n\nIn the general case, the GradientDescentEstimation is used to compute the mean.     mean(         M::AbstractManifold,         x::AbstractVector,         [w::AbstractWeights,]         method::AbstractEstimationMethod=defaultestimationmethod(M);         kwargs...,     )\n\nCompute the mean using the specified method.\n\nmean(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GradientDescentEstimation;\n    p0=x[1],\n    stop_iter=100,\n    retraction::AbstractRetractionMethod = default_retraction_method(M),\n    inverse_retraction::AbstractInverseRetractionMethod = default_retraction_method(M),\n    kwargs...,\n)\n\nCompute the mean using the gradient descent scheme GradientDescentEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe Theory stems from[Karcher1977] and is also described in[PennecArsigny2013] as the exponential barycenter. The algorithm is further described in[Afsari2013].\n\n[Afsari2013]: Afsari, B; Tron, R.; Vidal, R.: On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass, SIAM Journal on Control and Optimization (2013), 51(3), pp. 2230–2260, doi: 10.1137/12086282X, arxiv: 1201.0925\n\n[PennecArsigny2013]: Pennec X., Arsigny V.: Exponential Barycenters of the Canonical Cartan Connection and Invariant Means on Lie Groups. In: Nielsen F., Bhatia R. (eds) Matrix Information Geometry, (2013), pp. 123-166. doi: 10.1007/978-3-642-30232-9_7, hal: https://hal.inria.fr/hal-00699361/document\n\n[Karcher1977]: Karcher, H.: Riemannian center of mass and mollifier smoothing. Communications on Pure Applied Mathematics (1977), 30, pp. 509–541. doi 10.1002/cpa.3160300502\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median!-Tuple{AbstractManifold, Vararg{Any, N} where N}","page":"Statistics","title":"Statistics.median!","text":"median!(M::AbstractManifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian!(\n    M::AbstractManifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\ncomputes the median in-place in y.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median-Tuple{AbstractManifold, AbstractVector{T} where T, AbstractVector{T} where T, CyclicProximalPointEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::CyclicProximalPointEstimation;\n    p0=x[1],\n    stop_iter=1000000,\n    retraction::AbstractRetractionMethod = default_retraction_method(M),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M),\n    kwargs...,\n)\n\nCompute the median using CyclicProximalPointEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe algorithm is further described in [Bačák2014].\n\n[Bačák2014]: Bačák, M: Computing Medians and Means in Hadamard Spaces. SIAM Journal on Optimization (2014), 24(3), pp. 1542–1566, doi: 10.1137/140953393, arxiv: 1210.2145\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median-Tuple{AbstractManifold, AbstractVector{T} where T, AbstractVector{T} where T, ExtrinsicEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::ExtrinsicEstimation;\n    extrinsic_method = CyclicProximalPointEstimation(),\n    kwargs...,\n)\n\nEstimate the median of x using ExtrinsicEstimation, i.e. by computing the median in the embedding and projecting the result back. You can specify an extrinsic_method to specify which median estimation method to use in the embedding, which defaults to CyclicProximalPointEstimation.\n\nSee median for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median-Tuple{AbstractManifold, AbstractVector{T} where T, AbstractVector{T} where T, Manifolds.WeiszfeldEstimation}","page":"Statistics","title":"Statistics.median","text":"median(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::WeiszfeldEstimation;\n    α = 1.0,\n    p0=x[1],\n    stop_iter=2000,\n    retraction::AbstractRetractionMethod = default_retraction_method(M),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M),\n    kwargs...,\n)\n\nCompute the median using WeiszfeldEstimation.\n\nOptionally, provide p0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nThe parameter αin (02 is a step size.\n\nThe algorithm is further described in [FletcherVenkatasubramanianJoshi2008], especially the update rule in Eq. (6), i.e. Let q_k denote the current iterate, n the number of points x_1ldotsx_n, and\n\nI_k = bigl i in 1ldotsn big x_i neq q_k bigr\n\nall indices of points that are not equal to the current iterate. Then the update reads q_k+1 = exp_q_k(αX), where\n\nX = frac1ssum_iin I_k fracw_id_mathcal M(q_kx_i)log_q_kx_i\nquad\ntext with \nquad\ns = sum_iin I_k fracw_id_mathcal M(q_kx_i)\n\nand where mathrmd_mathcal M denotes the Riemannian distance.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction, which by default use the exponential and logarithmic map, respectively.\n\n[FletcherVenkatasubramanianJoshi2008]: Fletcher, T., Venkatasubramanian, S., Joshi, S: Robust statistics on Riemannian manifolds via the geometric median 2008 IEEE Conference on Computer Vision and Pattern Recognition, doi: 10.1109/CVPR.2008.4587747,\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.median-Tuple{AbstractManifold, Vararg{Any, N} where N}","page":"Statistics","title":"Statistics.median","text":"median(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian(\n    M::AbstractManifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the (optionally weighted) Riemannian median of the vector x of points on the AbstractManifold  M, defined as the point that satisfies the minimizer\n\nargmin_y  mathcal M frac1sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance. This function is nonsmooth (i.e nondifferentiable).\n\nIn the general case, the CyclicProximalPointEstimation is used to compute the median. However, this default may be overloaded for specific manifolds.\n\nCompute the median using the specified method.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.std-Tuple{AbstractManifold, Vararg{Any, N} where N}","page":"Statistics","title":"Statistics.std","text":"std(M, x, m=mean(M, x); corrected=true, kwargs...)\nstd(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)\n\ncompute the optionally weighted standard deviation of a Vector x of n data points on the AbstractManifold  M, i.e.\n\nsqrtfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.std. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Statistics.var-Tuple{AbstractManifold, Any}","page":"Statistics","title":"Statistics.var","text":"var(M, x, m=mean(M, x); corrected=true)\nvar(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false)\n\ncompute the (optionally weighted) variance of a Vector x of n data points on the AbstractManifold  M, i.e.\n\nfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.var. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true. All further kwargs... are passed to the computation of the mean (if that is not provided).\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.kurtosis-Tuple{AbstractManifold, AbstractVector{T} where T, StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.kurtosis","text":"kurtosis(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the excess kurtosis of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_std-Tuple{AbstractManifold, Vararg{Any, N} where N}","page":"Statistics","title":"StatsBase.mean_and_std","text":"mean_and_std(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, std)\n\nCompute the mean and the standard deviation std simultaneously.\n\nmean_and_std(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and standard deviation. To use a mean-specific method, call mean and then std.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector{T} where T, StatsBase.AbstractWeights, GeodesicInterpolationWithinRadius}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n) -> (mean, var)\n\nUse repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nSee GeodesicInterpolationWithinRadius and mean_and_var for more information.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_var-Tuple{AbstractManifold, AbstractVector{T} where T, StatsBase.AbstractWeights, GeodesicInterpolation}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng::Union{AbstractRNG,Nothing} = nothing,\n    retraction::AbstractRetractionMethod = default_retraction_method(M),\n    inverse_retraction::AbstractInverseRetractionMethod = default_inverse_retraction_method(M),\n    kwargs...,\n) -> (mean, var)\n\nUse the repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered. Optionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nSee GeodesicInterpolation for details on the geodesic interpolation method.\n\nnote: Note\nThe Welford algorithm for the variance is experimental and is not guaranteed to give accurate results except on Euclidean.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.mean_and_var-Tuple{AbstractManifold, Vararg{Any, N} where N}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(M::AbstractManifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, var)\n\nCompute the mean and the variance simultaneously. See those functions for a description of the arguments.\n\nmean_and_var(\n    M::AbstractManifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and variance. To use a mean-specific method, call mean and then var.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#StatsBase.moment","page":"Statistics","title":"StatsBase.moment","text":"moment(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the kth central moment of points in x on manifold M. Optionally provide weights w and/or a precomputed mean.\n\n\n\n\n\n","category":"function"},{"location":"features/statistics.html#StatsBase.skewness-Tuple{AbstractManifold, AbstractVector{T} where T, StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.skewness","text":"skewness(M::AbstractManifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the standardized skewness of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"features/statistics.html#Literature","page":"Statistics","title":"Literature","text":"","category":"section"},{"location":"manifolds/spectrahedron.html#Spectrahedron","page":"Spectrahedron","title":"Spectrahedron","text":"","category":"section"},{"location":"manifolds/spectrahedron.html","page":"Spectrahedron","title":"Spectrahedron","text":"Modules = [Manifolds]\nPages = [\"manifolds/Spectrahedron.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/spectrahedron.html#Manifolds.Spectrahedron","page":"Spectrahedron","title":"Manifolds.Spectrahedron","text":"Spectrahedron{N,K} <: AbstractDecoratorManifold{ℝ}\n\nThe Spectrahedron manifold, also known as the set of correlation matrices (symmetric positive semidefinite matrices) of rank k with unit trace.\n\nbeginaligned\nmathcal S(nk) =\nbiglp  ℝ^n  n big a^mathrmTpa geq 0 text for all  a  ℝ^n\noperatornametr(p) = sum_i=1^n p_ii = 1\ntextand  p = qq^mathrmT text for  q in  ℝ^n  k\ntext with  operatornamerank(p) = operatornamerank(q) = k\nbigr\nendaligned\n\nThis manifold is working solely on the matrices q. Note that this q is not unique, indeed for any orthogonal matrix A we have (qA)(qA)^mathrmT = qq^mathrmT = p, so the manifold implemented here is the quotient manifold. The unit trace translates to unit frobenius norm of q.\n\nThe tangent space at p, denoted T_pmathcal E(nk), is also represented by matrices Yin ℝ^n  k and reads as\n\nT_pmathcal S(nk) = bigl\nX  ℝ^n  nX = qY^mathrmT + Yq^mathrmT\ntext with  operatornametr(X) = sum_i=1^nX_ii = 0\nbigr\n\nendowed with the Euclidean metric from the embedding, i.e. from the ℝ^n  k\n\nThis manifold was for example investigated in[JourneeBachAbsilSepulchre2010].\n\nConstructor\n\nSpectrahedron(n,k)\n\ngenerates the manifold mathcal S(nk) subset ℝ^n  n.\n\n[JourneeBachAbsilSepulchre2010]: Journée, M., Bach, F., Absil, P.-A., and Sepulchre, R.: “Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”, SIAM Journal on Optimization (20)5, pp. 2327–2351, 2010. doi: 10.1137/080731359, arXiv: 0807.4423.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.check_point-Union{Tuple{K}, Tuple{N}, Tuple{Spectrahedron{N, K}, Any}} where {N, K}","page":"Spectrahedron","title":"ManifoldsBase.check_point","text":"check_point(M::Spectrahedron, q; kwargs...)\n\nchecks, whether q is a valid reprsentation of a point p=qq^mathrmT on the Spectrahedron M, i.e. is a matrix of size (N,K), such that p is symmetric positive semidefinite and has unit trace, i.e. q has to have unit frobenius norm. Since by construction p is symmetric, this is not explicitly checked. Since p is by construction positive semidefinite, this is not checked. The tolerances for positive semidefiniteness and unit trace can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.check_vector-Union{Tuple{K}, Tuple{N}, Tuple{Spectrahedron{N, K}, Any, Any}} where {N, K}","page":"Spectrahedron","title":"ManifoldsBase.check_vector","text":"check_vector(M::Spectrahedron, q, Y; kwargs...)\n\nCheck whether X = qY^mathrmT + Yq^mathrmT is a tangent vector to p=qq^mathrmT on the Spectrahedron M, i.e. atfer check_point of q, Y has to be of same dimension as q and a X has to be a symmetric matrix with trace. The tolerance for the base point check and zero diagonal can be set using the kwargs.... Note that symmetry of X holds by construction and is not explicitly checked.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.manifold_dimension-Union{Tuple{Spectrahedron{N, K}}, Tuple{K}, Tuple{N}} where {N, K}","page":"Spectrahedron","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Spectrahedron)\n\nreturns the dimension of Spectrahedron M=mathcal S(nk) nk  ℕ, i.e.\n\ndim mathcal S(nk) = nk - 1 - frack(k-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.project-Tuple{Spectrahedron, Any}","page":"Spectrahedron","title":"ManifoldsBase.project","text":"project(M::Spectrahedron, q)\n\nproject q onto the manifold Spectrahedron M, by normalizing w.r.t. the Frobenius norm\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.project-Tuple{Spectrahedron, Vararg{Any, N} where N}","page":"Spectrahedron","title":"ManifoldsBase.project","text":"project(M::Spectrahedron, q, Y)\n\nProject Y onto the tangent space at q, i.e. row-wise onto the Spectrahedron manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.representation_size-Union{Tuple{Spectrahedron{N, K}}, Tuple{K}, Tuple{N}} where {N, K}","page":"Spectrahedron","title":"ManifoldsBase.representation_size","text":"representation_size(M::Spectrahedron)\n\nReturn the size of an array representing an element on the Spectrahedron manifold M, i.e. n  k, the size of such factor of p=qq^mathrmT on mathcal M = mathcal S(nk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.retract-Tuple{Spectrahedron, Any, Any, ProjectionRetraction}","page":"Spectrahedron","title":"ManifoldsBase.retract","text":"retract(M::Spectrahedron, q, Y, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting q+Y back onto the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.vector_transport_to-Tuple{Spectrahedron, Any, Any, Any, ProjectionTransport}","page":"Spectrahedron","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Spectrahedron, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#ManifoldsBase.zero_vector-Tuple{Spectrahedron, Vararg{Any, N} where N}","page":"Spectrahedron","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Spectrahedron,p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the Spectrahedron manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spectrahedron.html#Literature","page":"Spectrahedron","title":"Literature","text":"","category":"section"},{"location":"manifolds/choleskyspace.html#Cholesky-space","page":"Cholesky space","title":"Cholesky space","text":"","category":"section"},{"location":"manifolds/choleskyspace.html","page":"Cholesky space","title":"Cholesky space","text":"The Cholesky space is a Riemannian manifold on the lower triangular matrices. Its metric is based on the cholesky decomposition. The CholeskySpace is used to define the LogCholeskyMetric on the manifold of  SymmetricPositiveDefinite matrices.","category":"page"},{"location":"manifolds/choleskyspace.html","page":"Cholesky space","title":"Cholesky space","text":"Modules = [Manifolds]\nPages = [\"manifolds/CholeskySpace.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/choleskyspace.html#Manifolds.CholeskySpace","page":"Cholesky space","title":"Manifolds.CholeskySpace","text":"CholeskySpace{N} <: AbstractManifold{ℝ}\n\nThe manifold of lower triangular matrices with positive diagonal and a metric based on the cholesky decomposition. The formulae for this manifold are for example summarized in Table 1 of [Lin2019].\n\nConstructor\n\nCholeskySpace(n)\n\nGenerate the manifold of n n lower triangular matrices with positive diagonal.\n\n[Lin2019]: Lin, Zenhua: Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition, arXiv: 1908.09326.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/choleskyspace.html","page":"Cholesky space","title":"Cholesky space","text":"Modules = [Manifolds]\nPages = [\"manifolds/CholeskySpace.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/choleskyspace.html#Base.exp-Tuple{CholeskySpace, Vararg{Any, N} where N}","page":"Cholesky space","title":"Base.exp","text":"exp(M::CholeskySpace, p, X)\n\nCompute the exponential map on the CholeskySpace M emanating from the lower triangular matrix with positive diagonal p towards the lower triangular matrix X The formula reads\n\nexp_p X =  p  +  X  + operatornamediag(p)\noperatornamediag(p)expbigl( operatornamediag(X)operatornamediag(p)^-1bigr)\n\nwhere cdot denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#Base.log-Tuple{LinearAlgebra.Cholesky, Vararg{Any, N} where N}","page":"Cholesky space","title":"Base.log","text":"log(M::CholeskySpace, X, p, q)\n\nCompute the logarithmic map on the CholeskySpace M for the geodesic emanating from the lower triangular matrix with positive diagonal p towards q. The formula reads\n\nlog_p q =  p  -  q  + operatornamediag(p)logbigl(operatornamediag(q)operatornamediag(p)^-1bigr)\n\nwhere cdot denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.check_point-Tuple{CholeskySpace, Any}","page":"Cholesky space","title":"ManifoldsBase.check_point","text":"check_point(M::CholeskySpace, p; kwargs...)\n\nCheck whether the matrix p lies on the CholeskySpace M, i.e. it's size fits the manifold, it is a lower triangular matrix and has positive entries on the diagonal. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.check_vector-Tuple{CholeskySpace, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.check_vector","text":"check_vector(M::CholeskySpace, p, X; kwargs... )\n\nCheck whether v is a tangent vector to p on the CholeskySpace M, i.e. after check_point(M,p), X has to have the same dimension as p and a symmetric matrix. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.distance-Tuple{CholeskySpace, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.distance","text":"distance(M::CholeskySpace, p, q)\n\nCompute the Riemannian distance on the CholeskySpace M between two matrices p, q that are lower triangular with positive diagonal. The formula reads\n\nd_mathcal M(pq) = sqrtsum_ij (p_ij-q_ij)^2 +\nsum_j=1^m (log p_jj - log q_jj)^2\n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.inner-Tuple{CholeskySpace, Any, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.inner","text":"inner(M::CholeskySpace, p, X, Y)\n\nCompute the inner product on the CholeskySpace M at the lower triangular matric with positive diagonal p and the two tangent vectors X,Y, i.e they are both lower triangular matrices with arbitrary diagonal. The formula reads\n\ng_p(XY) = sum_ij X_ijY_ij + sum_j=1^m X_iiY_iip_ii^-2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.manifold_dimension-Union{Tuple{CholeskySpace{N}}, Tuple{N}} where N","page":"Cholesky space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::CholeskySpace)\n\nReturn the manifold dimension for the CholeskySpace M, i.e.\n\n    dim(mathcal M) = fracN(N+1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.parallel_transport_to-Tuple{CholeskySpace, Any, Any, Any}","page":"Cholesky space","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::CholeskySpace, p, X, q)\n\nParallely transport the tangent vector X at p along the geodesic to q on the CholeskySpace manifold M. The formula reads\n\nmathcal P_qp(X) =  X \n+ operatornamediag(q)operatornamediag(p)^-1operatornamediag(X)\n\nwhere cdot denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.representation_size-Union{Tuple{CholeskySpace{N}}, Tuple{N}} where N","page":"Cholesky space","title":"ManifoldsBase.representation_size","text":"representation_size(M::CholeskySpace)\n\nReturn the representation size for the CholeskySpace{N} M, i.e. (N,N).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.zero_vector-Tuple{CholeskySpace, Vararg{Any, N} where N}","page":"Cholesky space","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::CholeskySpace, p)\n\nReturn the zero tangent vector on the CholeskySpace M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#Literature","page":"Cholesky space","title":"Literature","text":"","category":"section"},{"location":"features/utilities.html#Ease-of-notation","page":"Utilities","title":"Ease of notation","text":"","category":"section"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"The following terms introduce a nicer notation for some operations, for example using the ∈ operator, p  mathcal M, to determine whether p is a point on the AbstractManifold  mathcal M.","category":"page"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"in\nTangentSpace","category":"page"},{"location":"features/utilities.html#Base.in","page":"Utilities","title":"Base.in","text":"Base.in(p, M::AbstractManifold; kwargs...)\np ∈ M\n\nCheck, whether a point p is a valid point (i.e. in) a AbstractManifold  M. This method employs is_point deactivating the error throwing option.\n\n\n\n\n\nBase.in(p, TpM::TangentSpaceAtPoint; kwargs...)\nX ∈ TangentSpaceAtPoint(M,p)\n\nCheck whether X is a tangent vector from (in) the tangent space T_pmathcal M, i.e. the TangentSpaceAtPoint at p on the AbstractManifold  M. This method uses is_vector deactivating the error throw option.\n\n\n\n\n\n","category":"function"},{"location":"features/utilities.html#ManifoldsBase.TangentSpace","page":"Utilities","title":"ManifoldsBase.TangentSpace","text":"TangentSpace(M::AbstractManifold, p)\n\nReturn a TangentSpaceAtPoint representing tangent space at p on the AbstractManifold  M.\n\n\n\n\n\n","category":"constant"},{"location":"features/utilities.html#Public-documentation","page":"Utilities","title":"Public documentation","text":"","category":"section"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"The following functions are of interest for extending and using the ProductManifold.","category":"page"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"submanifold_component\nsubmanifold_components\nProductRepr","category":"page"},{"location":"features/utilities.html#Manifolds.submanifold_component","page":"Utilities","title":"Manifolds.submanifold_component","text":"submanifold_component(M::AbstractManifold, p, i::Integer)\nsubmanifold_component(M::AbstractManifold, p, ::Val(i)) where {i}\nsubmanifold_component(p, i::Integer)\nsubmanifold_component(p, ::Val(i)) where {i}\n\nProject the product array p on M to its ith component. A new array is returned.\n\n\n\n\n\n","category":"function"},{"location":"features/utilities.html#Manifolds.submanifold_components","page":"Utilities","title":"Manifolds.submanifold_components","text":"submanifold_components(M::AbstractManifold, p)\nsubmanifold_components(p)\n\nGet the projected components of p on the submanifolds of M. The components are returned in a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"features/utilities.html#Manifolds.ProductRepr","page":"Utilities","title":"Manifolds.ProductRepr","text":"ProductRepr(parts)\n\nA more general but slower representation of points and tangent vectors on a product manifold.\n\nExample:\n\nA product point on a product manifold Sphere(2) × Euclidean(2) might be created as\n\nProductRepr([1.0, 0.0, 0.0], [2.0, 3.0])\n\nwhere [1.0, 0.0, 0.0] is the part corresponding to the sphere factor and [2.0, 3.0] is the part corresponding to the euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"features/utilities.html#Specific-exception-types","page":"Utilities","title":"Specific exception types","text":"","category":"section"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"For some manifolds it is useful to keep an extra index, at which point on the manifold, the error occurred as well as to collect all errors that occurred on a manifold. This page contains the manifold-specific error messages this package introduces.","category":"page"},{"location":"features/utilities.html","page":"Utilities","title":"Utilities","text":"Modules = [Manifolds]\nPages = [\"errors.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/oblique.html#Oblique-manifold","page":"Oblique manifold","title":"Oblique manifold","text":"","category":"section"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"The oblique manifold mathcalOB(nm) is modeled as an AbstractPowerManifold  of the (real-valued) Sphere and uses ArrayPowerRepresentation. Points on the torus are hence matrices, x  ℝ^nm.","category":"page"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/Oblique.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/oblique.html#Manifolds.Oblique","page":"Oblique manifold","title":"Manifolds.Oblique","text":"Oblique{N,M,𝔽} <: AbstractPowerManifold{𝔽}\n\nThe oblique manifold mathcalOB(nm) is the set of 𝔽-valued matrices with unit norm column endowed with the metric from the embedding. This yields exactly the same metric as considering the product metric of the unit norm vectors, i.e. PowerManifold of the (n-1)-dimensional Sphere.\n\nThe Sphere is stored internally within M.manifold, such that all functions of AbstractPowerManifold  can be used directly.\n\nConstructor\n\nOblique(n,m)\n\nGenerate the manifold of matrices mathbb R^n  m such that the m columns are unit vectors, i.e. from the Sphere(n-1).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/oblique.html#Functions","page":"Oblique manifold","title":"Functions","text":"","category":"section"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"Most functions are directly implemented for an AbstractPowerManifold  with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/oblique.html","page":"Oblique manifold","title":"Oblique manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/Oblique.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/oblique.html#ManifoldsBase.check_point-Tuple{Oblique, Any}","page":"Oblique manifold","title":"ManifoldsBase.check_point","text":"check_point(M::Oblique{n,m},p)\n\nChecks whether p is a valid point on the Oblique{m,n} M, i.e. is a matrix of m unit columns from mathbb R^n, i.e. each column is a point from Sphere(n-1).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/oblique.html#ManifoldsBase.check_vector-Union{Tuple{m}, Tuple{n}, Tuple{Oblique{n, m, 𝔽, S} where {𝔽, S}, Any, Any}} where {n, m}","page":"Oblique manifold","title":"ManifoldsBase.check_vector","text":"check_vector(M::Oblique p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the Oblique M. This means, that p is valid, that X is of correct dimension and columnswise a tangent vector to the columns of p on the Sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/oblique.html#ManifoldsBase.parallel_transport_to-Tuple{Oblique, Any, Any, Any}","page":"Oblique manifold","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Oblique, p, X, q)\n\nCompute the parallel transport on the Oblique manifold by doing a column wise parallel transport on the Sphere\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#Multinomial-doubly-stochastic-matrices","page":"Multinomial doubly stochastic matrices","title":"Multinomial doubly stochastic matrices","text":"","category":"section"},{"location":"manifolds/multinomialdoublystochastic.html","page":"Multinomial doubly stochastic matrices","title":"Multinomial doubly stochastic matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/MultinomialDoublyStochastic.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/multinomialdoublystochastic.html#Manifolds.AbstractMultinomialDoublyStochastic","page":"Multinomial doubly stochastic matrices","title":"Manifolds.AbstractMultinomialDoublyStochastic","text":"AbstractMultinomialDoublyStochastic{N} <: AbstractDecoratorManifold{ℝ}\n\nA common type for manifolds that are doubly stochastic, for example by direct constraint MultinomialDoubleStochastic or by symmetry MultinomialSymmetric, as long as they are also modeled as IsIsometricEmbeddedManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialdoublystochastic.html#Manifolds.MultinomialDoubleStochastic","page":"Multinomial doubly stochastic matrices","title":"Manifolds.MultinomialDoubleStochastic","text":"MultinomialDoublyStochastic{n} <: AbstractMultinomialDoublyStochastic{N}\n\nThe set of doubly stochastic multinomial matrices consists of all nn matrices with stochastic columns and rows, i.e.\n\nbeginaligned\nmathcalDP(n) coloneqq biglp  ℝ^nn big p_ij  0 text for all  i=1n j=1m\n pmathbf1_n = p^mathrmTmathbf1_n = mathbf1_n\nbigr\nendaligned\n\nwhere mathbf1_n is the vector of length n containing ones.\n\nThe tangent space can be written as\n\nT_pmathcalDP(n) coloneqq bigl\nX  ℝ^nn big X = X^mathrmT text and \nXmathbf1_n = X^mathrmTmathbf1_n = mathbf0_n\nbigr\n\nwhere mathbf0_n is the vector of length n containing zeros.\n\nMore details can be found in Section III[DouikHassibi2019].\n\nConstructor\n\nMultinomialDoubleStochastic(n)\n\nGenerate the manifold of matrices mathbb R^nn that are doubly stochastic and symmetric.\n\n[DouikHassibi2019]: A. Douik, B. Hassibi: AbstractManifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry, IEEE Transactions on Signal Processing 67(22), pp. 5761–5774, 2019. doi: 10.1109/tsp.2019.2946024, arXiv: 1802.02628.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.check_point-Union{Tuple{n}, Tuple{MultinomialDoubleStochastic{n}, Any}} where n","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.check_point","text":"check_point(M::MultinomialDoubleStochastic, p)\n\nChecks whether p is a valid point on the MultinomialDoubleStochastic(n) M, i.e. is a  matrix with positive entries whose rows and columns sum to one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.check_vector-Union{Tuple{n}, Tuple{MultinomialDoubleStochastic{n}, Any, Any}} where n","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::MultinomialDoubleStochastic p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialDoubleStochastic M. This means, that p is valid, that X is of correct dimension and sums to zero along any column or row.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.manifold_dimension-Union{Tuple{MultinomialDoubleStochastic{n}}, Tuple{n}} where n","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::MultinomialDoubleStochastic{n}) where {n}\n\nreturns the dimension of the MultinomialDoubleStochastic manifold namely\n\noperatornamedim_mathcalDP(n) = (n-1)^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.project-Tuple{Manifolds.AbstractMultinomialDoublyStochastic, Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.project","text":"project(\n    M::AbstractMultinomialDoublyStochastic,\n    p;\n    maxiter = 100,\n    tolerance = eps(eltype(p))\n)\n\nproject a matrix p with positive entries applying Sinkhorn's algorithm. Note that this projct method – different from the usual case, accepts keywords.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.project-Tuple{MultinomialDoubleStochastic, Any, Any}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.project","text":"project(M::MultinomialDoubleStochastic{n}, p, Y) where {n}\n\nProject Y onto the tangent space at p on the MultinomialDoubleStochastic M, return the result in X. The formula reads\n\n    operatornameproj_p(Y) = Y - (αmathbf1_n^mathrmT + mathbf1_nβ^mathrmT)  p\n\nwhere  denotes the Hadamard or elementwise product and mathbb1_n is the vector of length n containing ones. The two vectors αβ  ℝ^nn are computed as a solution (typically using the left pseudo inverse) of\n\n    beginpmatrix I_n  pp^mathrmT  I_n endpmatrix\n    beginpmatrix α βendpmatrix\n    =\n    beginpmatrix Ymathbf1Y^mathrmTmathbf1endpmatrix\n\nwhere I_n is the nn unit matrix and mathbf1_n is the vector of length n containing ones.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#ManifoldsBase.retract-Tuple{MultinomialDoubleStochastic, Any, Any, ProjectionRetraction}","page":"Multinomial doubly stochastic matrices","title":"ManifoldsBase.retract","text":"retract(M::MultinomialDoubleStochastic, p, X, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting podotexp(Xp) back onto the manifold, where  are elementwise multiplication and division, respectively. Similarly, exp refers to the elementwise exponentiation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialdoublystochastic.html#Literature","page":"Multinomial doubly stochastic matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/product.html#Product-manifold","page":"Product manifold","title":"Product manifold","text":"","category":"section"},{"location":"manifolds/product.html","page":"Product manifold","title":"Product manifold","text":"Product manifold mathcal M = mathcalM_1  mathcalM_2    mathcalM_n of manifolds mathcalM_1 mathcalM_2  mathcalM_n. Points on the product manifold can be constructed using ProductRepr with canonical projections Π_i  mathcalM  mathcalM_i for i  1 2  n provided by submanifold_component.","category":"page"},{"location":"manifolds/product.html","page":"Product manifold","title":"Product manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/ProductManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/product.html#Manifolds.InverseProductRetraction","page":"Product manifold","title":"Manifolds.InverseProductRetraction","text":"InverseProductRetraction(retractions::AbstractInverseRetractionMethod...)\n\nProduct inverse retraction of inverse retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductBasisData","page":"Product manifold","title":"Manifolds.ProductBasisData","text":"ProductBasisData\n\nA typed tuple to store tuples of data of stored/precomputed bases for a ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductFVectorDistribution","page":"Product manifold","title":"Manifolds.ProductFVectorDistribution","text":"ProductFVectorDistribution([type::VectorBundleFibers], [x], distrs...)\n\nGenerates a random vector at point x from vector space (a fiber of a tangent bundle) of type type using the product distribution of given distributions.\n\nVector space type and x can be automatically inferred from distributions distrs.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductManifold","page":"Product manifold","title":"Manifolds.ProductManifold","text":"ProductManifold{𝔽,TM<:Tuple} <: AbstractManifold{𝔽}\n\nProduct manifold M_1  M_2     M_n with product geometry.\n\nConstructor\n\nProductManifold(M_1, M_2, ..., M_n)\n\ngenerates the product manifold M_1  M_2    M_n. Alternatively, the same manifold can be contructed using the × operator: M_1 × M_2 × M_3.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductMetric","page":"Product manifold","title":"Manifolds.ProductMetric","text":"ProductMetric <: AbstractMetric\n\nA type to represent the product of metrics for a ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductPointDistribution","page":"Product manifold","title":"Manifolds.ProductPointDistribution","text":"ProductPointDistribution(M::ProductManifold, distributions)\n\nProduct distribution on manifold M, combined from distributions.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductRetraction","page":"Product manifold","title":"Manifolds.ProductRetraction","text":"ProductRetraction(retractions::AbstractRetractionMethod...)\n\nProduct retraction of retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductVectorTransport","page":"Product manifold","title":"Manifolds.ProductVectorTransport","text":"ProductVectorTransport(methods::AbstractVectorTransportMethod...)\n\nProduct vector transport type of methods. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Base.exp-Tuple{ProductManifold, Vararg{Any, N} where N}","page":"Product manifold","title":"Base.exp","text":"exp(M::ProductManifold, p, X)\n\ncompute the exponential map from p in the direction of X on the ProductManifold M, which is the elementwise exponential map on the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.getindex-Tuple{ProductManifold, Integer}","page":"Product manifold","title":"Base.getindex","text":"getindex(M::ProductManifold, i)\nM[i]\n\naccess the ith manifold component from the ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.getindex-Tuple{ProductRepr, ProductManifold, Union{Colon, Integer, Val, AbstractVector{T} where T}}","page":"Product manifold","title":"Base.getindex","text":"getindex(p, M::ProductManifold, i::Union{Integer,Colon,AbstractVector})\np[M::ProductManifold, i]\n\nAccess the element(s) at index i of a point p on a ProductManifold M by linear indexing. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.log-Tuple{ProductManifold, Vararg{Any, N} where N}","page":"Product manifold","title":"Base.log","text":"log(M::ProductManifold, p, q)\n\nCompute the logarithmic map from p to q on the ProductManifold M, which can be computed using the logarithmic maps of the manifolds elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.rand-Tuple{ProductManifold}","page":"Product manifold","title":"Base.rand","text":"rand(M::ProductManifold; parts_kwargs = map(_ -> (;), M.manifolds))\n\nReturn a random point on ProductManifold  M. parts_kwargs is a tuple of keyword arguments for rand on each manifold in M.manifolds.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.setindex!-Tuple{Union{ProductRepr, RecursiveArrayTools.ArrayPartition}, Any, ProductManifold, Union{Colon, Integer, Val, AbstractVector{T} where T}}","page":"Product manifold","title":"Base.setindex!","text":"setindex!(q, p, M::ProductManifold, i::Union{Integer,Colon,AbstractVector})\nq[M::ProductManifold,i...] = p\n\nset the element [i...] of a point q on a ProductManifold by linear indexing to q. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#LinearAlgebra.cross-Tuple{Vararg{AbstractManifold, N} where N}","page":"Product manifold","title":"LinearAlgebra.cross","text":"cross(M, N)\ncross(M1, M2, M3,...)\n\nReturn the ProductManifold For two AbstractManifolds M and N, where for the case that one of them is a ProductManifold itself, the other is either prepended (if N is a product) or appenden (if M) is. If both are product manifold, they are combined into one product manifold, keeping the order.\n\nFor the case that more than one is a product manifold of these is build with the same approach as above\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#LinearAlgebra.norm-Tuple{ProductManifold, Any, Any}","page":"Product manifold","title":"LinearAlgebra.norm","text":"norm(M::ProductManifold, p, X)\n\nCompute the norm of X from the tangent space of p on the ProductManifold, i.e. from the element wise norms the 2-norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.change_metric-Tuple{ProductManifold, AbstractMetric, Any, Any}","page":"Product manifold","title":"Manifolds.change_metric","text":"change_metric(M::ProductManifold, ::AbstractMetric, p, X)\n\nSince the metric on a product manifold decouples, the change of metric can be done elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.change_representer-Tuple{ProductManifold, AbstractMetric, Any, Any}","page":"Product manifold","title":"Manifolds.change_representer","text":"change_representer(M::ProductManifold, ::AbstractMetric, p, X)\n\nSince the metric on a product manifold decouples, the change of a representer can be done elementwise\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.flat-Tuple{ProductManifold, Vararg{Any, N} where N}","page":"Product manifold","title":"Manifolds.flat","text":"flat(M::ProductManifold, p, X::FVector{TangentSpaceType})\n\nuse the musical isomorphism to transform the tangent vector X from the tangent space at p on the ProductManifold M to a cotangent vector. This can be done elementwise for every entry of X (with respect to the corresponding entry in p) separately.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.number_of_components-Union{Tuple{ProductManifold{𝔽, var\"#s107\"} where var\"#s107\"<:Tuple{Vararg{Any, N}}}, Tuple{N}, Tuple{𝔽}} where {𝔽, N}","page":"Product manifold","title":"Manifolds.number_of_components","text":"number_of_components(M::ProductManifold{<:NTuple{N,Any}}) where {N}\n\nCalculate the number of manifolds multiplied in the given ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.sharp-Tuple{ProductManifold, Vararg{Any, N} where N}","page":"Product manifold","title":"Manifolds.sharp","text":"sharp(M::ProductManifold, p, ξ::FVector{CotangentSpaceType})\n\nUse the musical isomorphism to transform the cotangent vector ξ from the tangent space at p on the ProductManifold M to a tangent vector. This can be done elementwise for every entry of ξ (and p) separately\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold, Integer}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Integer)\n\nExtract the ith factor of the product manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold, Val}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Val)\nsubmanifold(M::ProductManifold, i::AbstractVector)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to Val((1, 3)) the product manifold constructed from the first and the third factor is returned.\n\nThe version with AbstractVector is not type-stable, for better preformance use Val.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_point-Tuple{ProductManifold, Union{ProductRepr, RecursiveArrayTools.ArrayPartition}}","page":"Product manifold","title":"ManifoldsBase.check_point","text":"check_point(M::ProductManifold, p; kwargs...)\n\nCheck whether p is a valid point on the ProductManifold M. If p is not a point on M a CompositeManifoldError.consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_size-Tuple{ProductManifold, Union{ProductRepr, RecursiveArrayTools.ArrayPartition}}","page":"Product manifold","title":"ManifoldsBase.check_size","text":"check_size(M::ProductManifold, p; kwargs...)\n\nCheck whether p is of valid size on the ProductManifold M. If p has components of wrong size a CompositeManifoldError.consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_vector-Tuple{ProductManifold, Union{ProductRepr, RecursiveArrayTools.ArrayPartition}, Union{ProductRepr, RecursiveArrayTools.ArrayPartition}}","page":"Product manifold","title":"ManifoldsBase.check_vector","text":"check_vector(M::ProductManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the ProductManifold M, i.e. all projections to base manifolds must be respective tangent vectors. If X is not a tangent vector to p on M a CompositeManifoldError.consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.distance-Tuple{ProductManifold, Any, Any}","page":"Product manifold","title":"ManifoldsBase.distance","text":"distance(M::ProductManifold, p, q)\n\nCompute the distance between two points p and q on the ProductManifold M, which is the 2-norm of the elementwise distances on the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.get_component-Tuple{ProductManifold, Any, Any}","page":"Product manifold","title":"ManifoldsBase.get_component","text":"get_component(M::ProductManifold, p, i)\n\nGet the ith component of a point p on a ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.injectivity_radius-Tuple{ProductManifold, Vararg{Any, N} where N}","page":"Product manifold","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::ProductManifold)\ninjectivity_radius(M::ProductManifold, x)\n\nCompute the injectivity radius on the ProductManifold, which is the minimum of the factor manifolds.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.inner-Tuple{ProductManifold, Any, Any, Any}","page":"Product manifold","title":"ManifoldsBase.inner","text":"inner(M::ProductManifold, p, X, Y)\n\ncompute the inner product of two tangent vectors X, Y from the tangent space at p on the ProductManifold M, which is just the sum of the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.inverse_retract-Tuple{ProductManifold, Any, Any, Any, Manifolds.InverseProductRetraction}","page":"Product manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProductManifold, p, q, m::InverseProductRetraction)\n\nCompute the inverse retraction from p with respect to q on the ProductManifold M using an InverseProductRetraction, which by default encapsulates a inverse retraction for each manifold of the product. Then this method is performed elementwise, so the encapsulated inverse retraction methods have to be available per factor.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.manifold_dimension-Tuple{ProductManifold}","page":"Product manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::ProductManifold)\n\nReturn the manifold dimension of the ProductManifold, which is the sum of the manifold dimensions the product is made of.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.retract-Tuple{ProductManifold, Vararg{Any, N} where N}","page":"Product manifold","title":"ManifoldsBase.retract","text":"retract(M::ProductManifold, p, X, m::ProductRetraction)\n\nCompute the retraction from p with tangent vector X on the ProductManifold M using an ProductRetraction, which by default encapsulates retractions of the base manifolds. Then this method is performed elementwise, so the encapsulated retractions method has to be one that is available on the manifolds.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.set_component!-Tuple{ProductManifold, Any, Any, Any}","page":"Product manifold","title":"ManifoldsBase.set_component!","text":"set_component!(M::ProductManifold, q, p, i)\n\nSet the ith component of a point q on a ProductManifold M to p, where p is a point on the AbstractManifold  this factor of the product manifold consists of.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.vector_transport_to-Tuple{ProductManifold, Any, Any, Any, ProductVectorTransport}","page":"Product manifold","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::ProductManifold, p, X, q, m::ProductVectorTransport)\n\nCompute the vector transport the tangent vector Xat p to q on the ProductManifold M using an ProductVectorTransport m. This method is performed elementwise, i.e. the method m has to be implemented on the base manifold.\n\n\n\n\n\n","category":"method"},{"location":"features/distributions.html#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"features/distributions.html","page":"Distributions","title":"Distributions","text":"The following functions and types provide support for manifold-valued and tangent space-valued distributions:","category":"page"},{"location":"features/distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [Manifolds]\nPages = [\"distributions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/distributions.html#Manifolds.FVectorDistribution","page":"Distributions","title":"Manifolds.FVectorDistribution","text":"FVectorDistribution{TSpace<:VectorBundleFibers, T}\n\nAn abstract distribution for vector bundle fiber-valued distributions (values from a fiber of a vector bundle at point x from the given manifold). For example used for tangent vector-valued distributions.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.FVectorSupport","page":"Distributions","title":"Manifolds.FVectorSupport","text":"FVectorSupport(space::AbstractManifold, VectorBundleFibers)\n\nValue support for vector bundle fiber-valued distributions (values from a fiber of a vector bundle at a point from the given manifold). For example used for tangent vector-valued distributions.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.FVectorvariate","page":"Distributions","title":"Manifolds.FVectorvariate","text":"FVectorvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a vector from a fiber of a vector bundle.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.MPointDistribution","page":"Distributions","title":"Manifolds.MPointDistribution","text":"MPointDistribution{TM<:AbstractManifold}\n\nAn abstract distribution for points on manifold of type TM.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.MPointSupport","page":"Distributions","title":"Manifolds.MPointSupport","text":"MPointSupport(M::AbstractManifold)\n\nValue support for manifold-valued distributions (values from given AbstractManifold  M).\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.MPointvariate","page":"Distributions","title":"Manifolds.MPointvariate","text":"MPointvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a point on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Base.rand-Tuple{AbstractManifold}","page":"Distributions","title":"Base.rand","text":"Random.rand(M::AbstractManifold, [d::Integer]; vector_at=nothing)\nRandom.rand(rng::AbstractRNG, M::AbstractManifold, [d::Integer]; vector_at=nothing)\n\nGenerate a random point on manifold M (when vector_at is nothing) or a tangent vector at point vector_at (when it is not nothing).\n\nOptionally a random number generator rng to be used can be specified. An optional integer d indicates that a vector of d points or tangent vectors is to be generated.\n\nnote: Note\nUsually a uniform distribution should be expected for compact manifolds and a Gaussian-like distribution for non-compact manifolds and tangent vectors, although it is not guaranteed. The distribution may change between releases.rand methods for specific manifolds may take additional keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"features/distributions.html#Distributions.support-Tuple{T} where T<:Manifolds.FVectorDistribution","page":"Distributions","title":"Distributions.support","text":"support(d::FVectorDistribution)\n\nGet the object of type FVectorSupport for the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"features/distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [Manifolds]\nPages = [\"projected_distribution.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/distributions.html#Manifolds.ProjectedFVectorDistribution","page":"Distributions","title":"Manifolds.ProjectedFVectorDistribution","text":"ProjectedFVectorDistribution(type::VectorBundleFibers, p, d, project!)\n\nGenerates a random vector from ambient space of manifold type.manifold at point p and projects it to vector space of type type using function project!, see project for documentation. Generated arrays are of type TResult.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.ProjectedPointDistribution","page":"Distributions","title":"Manifolds.ProjectedPointDistribution","text":"ProjectedPointDistribution(M::AbstractManifold, d, proj!, p)\n\nGenerates a random point in ambient space of M and projects it to M using function proj!. Generated arrays are of type TResult, which can be specified by providing the p argument.\n\n\n\n\n\n","category":"type"},{"location":"features/distributions.html#Manifolds.normal_tvector_distribution-Tuple{AbstractManifold, Any, Any}","page":"Distributions","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::Euclidean, p, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"features/distributions.html#Manifolds.projected_distribution","page":"Distributions","title":"Manifolds.projected_distribution","text":"projected_distribution(M::AbstractManifold, d, [p=rand(d)])\n\nWrap the standard distribution d into a manifold-valued distribution. Generated points will be of similar type to p. By default, the type is not changed.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/fixedrankmatrices.html#FixedRankMatrices","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"","category":"section"},{"location":"manifolds/fixedrankmatrices.html","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"Modules = [Manifolds]\nPages = [\"FixedRankMatrices.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.FixedRankMatrices","page":"Fixed-rank matrices","title":"Manifolds.FixedRankMatrices","text":"FixedRankMatrices{m,n,k,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe manifold of m  n real-valued or complex-valued matrices of fixed rank k, i.e.\n\nbigl p  𝔽^m  n big operatornamerank(p) = k bigr\n\nwhere 𝔽  ℝℂ and the rank is the number of linearly independent columns of a matrix.\n\nRepresentation with 3 matrix factors\n\nA point p  mathcal M can be stored using unitary matrices U  𝔽^m  k, V  𝔽^n  k as well as the k singular values of p = U_p S V_p^mathrmH, where cdot^mathrmH denotes the complex conjugate transpose or Hermitian. In other words, U and V are from the manifolds Stiefel(m,k,𝔽) and Stiefel(n,k,𝔽), respectively; see SVDMPoint for details.\n\nThe tangent space T_p mathcal M at a point p  mathcal M with p=U_p S V_p^mathrmH is given by\n\nT_pmathcal M = bigl U_p M V_p^mathrmH + U_X V_p^mathrmH + U_p V_X^mathrmH \n    M   𝔽^k  k\n    U_X   𝔽^m  k\n    V_X   𝔽^n  k\n    text st \n    U_p^mathrmHU_X = 0_k\n    V_p^mathrmHV_X = 0_k\nbigr\n\nwhere 0_k is the k  k zero matrix. See UMVTVector for details.\n\nThe (default) metric of this manifold is obtained by restricting the metric on ℝ^m  n to the tangent bundle[Vandereycken2013].\n\nConstructor\n\nFixedRankMatrices(m, n, k[, field=ℝ])\n\nGenerate the manifold of m-by-n (field-valued) matrices of rank k.\n\n[Vandereycken2013]: Bart Vandereycken: \"Low-rank matrix completion by Riemannian Optimization, SIAM Journal on Optiomoization, 23(2), pp. 1214–1236, 2013. doi: 10.1137/110845768, arXiv: 1209.3834.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.SVDMPoint","page":"Fixed-rank matrices","title":"Manifolds.SVDMPoint","text":"SVDMPoint <: AbstractManifoldPoint\n\nA point on a certain manifold, where the data is stored in a svd like fashion, i.e. in the form USV^mathrmH, where this structure stores U, S and V^mathrmH. The storage might also be shortened to just k singular values and accordingly shortened U (columns) and V^mathrmH (rows).\n\nConstructors\n\nSVDMPoint(A) for a matrix A, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(S) for an SVD object, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(U,S,Vt) for the svd factors to initialize the SVDMPoint(i.e. implicitlyk=\\min\\{m,n\\}`)\nSVDMPoint(A,k) for a matrix A, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(S,k) for an SVD object, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(U,S,Vt,k) for the svd factors to initialize the SVDMPoint, stores its svd factors shortened to the best rank k approximation\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.UMVTVector","page":"Fixed-rank matrices","title":"Manifolds.UMVTVector","text":"UMVTVector <: TVector\n\nA tangent vector that can be described as a product U_p M V_p^\\mathrm{H} + U_X V_p^\\mathrm{H} + U_p V_X^\\mathrm{H}, where X = U_X S V_X^\\mathrm{H} is its base point, see for example FixedRankMatrices. This vector structure stores the additionally (to the point) required fields.\n\nConstructors\n\nUMVTVector(U,M,Vt) store umv factors to initialize the UMVTVector\nUMVTVector(U,M,Vt,k) store the umv factors after shortening them down to inner dimensions k.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Base.rand-Union{Tuple{FixedRankMatrices{m, n, k, 𝔽} where 𝔽}, Tuple{k}, Tuple{n}, Tuple{m}} where {m, n, k}","page":"Fixed-rank matrices","title":"Base.rand","text":"Random.rand(M::FixedRankMatrices; vector_at=nothing, kwargs...)\n\nIf vector_at is nothing, return a random point on the FixedRankMatrices manifold. The orthogonal matrices are sampled from the [Stiefel(@ref) manifold and the singular values are sampled uniformly at random.\n\nIf vector_at is not nothing, generate a random tangent vector in the tangent space of the point vector_at on the FixedRankMatrices manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.check_point-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m, n, k, 𝔽} where 𝔽, Any}} where {m, n, k}","page":"Fixed-rank matrices","title":"ManifoldsBase.check_point","text":"check_point(M::FixedRankMatrices{m,n,k}, p; kwargs...)\n\nCheck whether the matrix or SVDMPoint x ids a valid point on the FixedRankMatrices{m,n,k,𝔽} M, i.e. is an m-byn matrix of rank k. For the SVDMPoint the internal representation also has to have the right shape, i.e. p.U and p.Vt have to be unitary. The keyword arguments are passed to the rank function that verifies the rank of p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.check_vector-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m, n, k, 𝔽} where 𝔽, SVDMPoint, UMVTVector}} where {m, n, k}","page":"Fixed-rank matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M:FixedRankMatrices{m,n,k}, p, X; kwargs...)\n\nCheck whether the tangent UMVTVector X is from the tangent space of the SVDMPoint p on the FixedRankMatrices M, i.e. that v.U and v.Vt are (columnwise) orthogonal to x.U and x.Vt, respectively, and its dimensions are consistent with p and X.M, i.e. correspond to m-by-n matrices of rank k.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.embed-Tuple{FixedRankMatrices, SVDMPoint, UMVTVector}","page":"Fixed-rank matrices","title":"ManifoldsBase.embed","text":"embed(M::FixedRankMatrices, p, X)\n\nEmbed the tangent vector X at point p in M from its UMVTVector representation  into the set of mn matrices.\n\nThe formula reads\n\nU_pMV_p^mathrmH + U_XV_p^mathrmH + U_pV_X^mathrmH\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.embed-Tuple{FixedRankMatrices, SVDMPoint}","page":"Fixed-rank matrices","title":"ManifoldsBase.embed","text":"embed(::FixedRankMatrices, p::SVDMPoint)\n\nEmbed the point p from its SVDMPoint representation into the set of mn matrices by computing USV^mathrmH.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.inner-Tuple{FixedRankMatrices, SVDMPoint, UMVTVector, UMVTVector}","page":"Fixed-rank matrices","title":"ManifoldsBase.inner","text":"inner(M::FixedRankMatrices, p::SVDMPoint, X::UMVTVector, Y::UMVTVector)\n\nCompute the inner product of X and Y in the tangent space of p on the FixedRankMatrices M, which is inherited from the embedding, i.e. can be computed using dot on the elements (U, Vt, M) of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.manifold_dimension-Union{Tuple{FixedRankMatrices{m, n, k, 𝔽}}, Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{m}} where {m, n, k, 𝔽}","page":"Fixed-rank matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::FixedRankMatrices{m,n,k,𝔽})\n\nReturn the manifold dimension for the 𝔽-valued FixedRankMatrices M of dimension mxn of rank k, namely\n\ndim(mathcal M) = k(m + n - k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.project-Tuple{FixedRankMatrices, Any, Any}","page":"Fixed-rank matrices","title":"ManifoldsBase.project","text":"project(M, p, A)\n\nProject the matrix A  ℝ^mn or from the embedding the tangent space at p on the FixedRankMatrices M, further decomposing the result into X=UMV^mathrmH, i.e. a UMVTVector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.representation_size-Union{Tuple{FixedRankMatrices{m, n, K, 𝔽} where {K, 𝔽}}, Tuple{n}, Tuple{m}} where {m, n}","page":"Fixed-rank matrices","title":"ManifoldsBase.representation_size","text":"representation_size(M::FixedRankMatrices{m,n,k})\n\nReturn the element size of a point on the FixedRankMatrices M, i.e. the size of matrices on this manifold (mn).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.retract-Tuple{FixedRankMatrices, Any, Any, PolarRetraction}","page":"Fixed-rank matrices","title":"ManifoldsBase.retract","text":"retract(M, p, X, ::PolarRetraction)\n\nCompute an SVD-based retraction on the FixedRankMatrices M by computing\n\n    q = U_kS_kV_k^mathrmH\n\nwhere U_k S_k V_k^mathrmH is the shortened singular value decomposition USV^mathrmH=p+X, in the sense that S_k is the diagonal matrix of size k  k with the k largest singular values and U and V are shortened accordingly.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.vector_transport_to!-Tuple{FixedRankMatrices, Any, Any, Any, ProjectionTransport}","page":"Fixed-rank matrices","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to(M::FixedRankMatrices, p, X, q, ::ProjectionTransport)\n\nCompute the vector transport of the tangent vector X at p to q, using the project of X to q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.zero_vector-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m, n, k, 𝔽} where 𝔽, SVDMPoint}} where {m, n, k}","page":"Fixed-rank matrices","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::FixedRankMatrices, p::SVDMPoint)\n\nReturn a UMVTVector representing the zero tangent vector in the tangent space of p on the FixedRankMatrices M, for example all three elements of the resulting structure are zero matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#Literature","page":"Fixed-rank matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/stiefel.html#Stiefel","page":"Stiefel","title":"Stiefel","text":"","category":"section"},{"location":"manifolds/stiefel.html#Common-and-metric-independent-functions","page":"Stiefel","title":"Common and metric independent functions","text":"","category":"section"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/Stiefel.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/stiefel.html#Manifolds.Stiefel","page":"Stiefel","title":"Manifolds.Stiefel","text":"Stiefel{n,k,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe Stiefel manifold consists of all n  k, n  k unitary matrices, i.e.\n\noperatornameSt(nk) = bigl p  𝔽^n  k big p^mathrmHp = I_k bigr\n\nwhere 𝔽  ℝ ℂ, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k  ℝ^k  k denotes the k  k identity matrix.\n\nThe tangent space at a point p  mathcal M is given by\n\nT_p mathcal M =  X  𝔽^n  k  p^mathrmHX + overlineX^mathrmHp = 0_k\n\nwhere 0_k is the k  k zero matrix and overlinecdot the (elementwise) complex conjugate.\n\nThis manifold is modeled as an embedded manifold to the Euclidean, i.e. several functions like the inner product and the zero_vector are inherited from the embedding.\n\nThe manifold is named after Eduard L. Stiefel (1909–1978).\n\nConstructor\n\nStiefel(n, k, field = ℝ)\n\nGenerate the (real-valued) Stiefel manifold of n  k dimensional orthonormal matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel.html#Base.rand-Tuple{Stiefel}","page":"Stiefel","title":"Base.rand","text":"rand(::Stiefel; vector_at=nothing, σ::Real=1.0)\n\nWhen vector_at is nothing, return a random (Gaussian) point x on the Stiefel manifold M by generating a (Gaussian) matrix with standard deviation σ and return the orthogonalized version, i.e. return the Q component of the QR decomposition of the random matrix of size nk.\n\nWhen vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_vector_atmathrmSt(nk) with mean zero and standard deviation σ by projecting a random Matrix onto the tangent vector at vector_at.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#Manifolds.uniform_distribution-Union{Tuple{k}, Tuple{n}, Tuple{Stiefel{n, k, ℝ}, Any}} where {n, k}","page":"Stiefel","title":"Manifolds.uniform_distribution","text":"uniform_distribution(M::Stiefel{n,k,ℝ}, p)\n\nUniform distribution on given (real-valued) Stiefel M. Specifically, this is the normalized Haar and Hausdorff measure on M. Generated points will be of similar type as p.\n\nThe implementation is based on Section 2.5.1 in [Chikuse2003]; see also Theorem 2.2.1(iii) in [Chikuse2003].\n\n[Chikuse2003]: Y. Chikuse: \"Statistics on Special Manifolds\", Springer New York, 2003, doi: 10.1007/978-0-387-21540-2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{Stiefel{n, k, 𝔽}, Any}} where {n, k, 𝔽}","page":"Stiefel","title":"ManifoldsBase.check_point","text":"check_point(M::Stiefel, p; kwargs...)\n\nCheck whether p is a valid point on the Stiefel M=operatornameSt(nk), i.e. that it has the right AbstractNumbers type and p^mathrmHp is (approximately) the identity, where cdot^mathrmH is the complex conjugate transpose. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{Stiefel{n, k, 𝔽}, Any, Any}} where {n, k, 𝔽}","page":"Stiefel","title":"ManifoldsBase.check_vector","text":"check_vector(M::Stiefel, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector at p on the Stiefel M=operatornameSt(nk), i.e. the AbstractNumbers fits and it (approximately) holds that p^mathrmHX + overlineX^mathrmHp = 0, where cdot^mathrmH denotes the Hermitian and overlinecdot the (elementwise) complex conjugate. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inverse_retract-Tuple{Stiefel, Any, Any, PolarInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, p, q, ::PolarInverseRetraction)\n\nCompute the inverse retraction based on a singular value decomposition for two points p, q on the Stiefel manifold M. This follows the folloing approach: From the Polar retraction we know that\n\noperatornameretr_p^-1q = qs - t\n\nif such a symmetric positive definite k  k matrix exists. Since qs - t is also a tangent vector at p we obtain\n\np^mathrmHqs + s(p^mathrmHq)^mathrmH + 2I_k = 0\n\nwhich can either be solved by a Lyapunov approach or a continuous-time algebraic Riccati equation.\n\nThis implementation follows the Lyapunov approach.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inverse_retract-Tuple{Stiefel, Any, Any, QRInverseRetraction}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, p, q, ::QRInverseRetraction)\n\nCompute the inverse retraction based on a qr decomposition for two points p, q on the Stiefel manifold M and return the resulting tangent vector in X. The computation follows Algorithm 1 in [KanekoFioriTanaka2013].\n\n[KanekoFioriTanaka2013]: T. Kaneko, S. Fiori, T. Tanaka: \"Empirical Arithmetic Averaging over the Compact Stiefel AbstractManifold\", IEEE Transactions on Signal Processing, 2013, doi: 10.1109/TSP.2012.2226167.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.manifold_dimension-Union{Tuple{Stiefel{n, k, ℝ}}, Tuple{k}, Tuple{n}} where {n, k}","page":"Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Stiefel)\n\nReturn the dimension of the Stiefel manifold M=operatornameSt(nk𝔽). The dimension is given by\n\nbeginaligned\ndim mathrmSt(n k ℝ) = nk - frac12k(k+1)\ndim mathrmSt(n k ℂ) = 2nk - k^2\ndim mathrmSt(n k ℍ) = 4nk - k(2k-1)\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.representation_size-Union{Tuple{Stiefel{n, k, 𝔽} where 𝔽}, Tuple{k}, Tuple{n}} where {n, k}","page":"Stiefel","title":"ManifoldsBase.representation_size","text":"representation_size(M::Stiefel)\n\nReturns the representation size of the Stiefel M=operatornameSt(nk), i.e. (n,k), which is the matrix dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, CayleyRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(::Stiefel, p, X, ::CayleyRetraction)\n\nCompute the retraction on the Stiefel that is based on the Cayley transform[Zhu2017]. Using\n\n  W_pX = operatornameP_pXp^mathrmH - pX^mathrmHoperatornameP_p\n  quadtextwhere \n  operatornameP_p = I - frac12pp^mathrmH\n\nthe formula reads\n\n    operatornameretr_pX = Bigl(I - frac12W_pXBigr)^-1Bigl(I + frac12W_pXBigr)p\n\nIt is implemented as the case m=1 of the PadeRetraction.\n\n[Zhu2017]: X. Zhu: A Riemannian conjugate gradient method for optimizazion on the Stiefel manifold, Computational Optimization and Applications 67(1), pp. 73–110, 2017. doi 10.1007/s10589-016-9883-4.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, PadeRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::PadeRetraction{m})\n\nCompute the retraction on the Stiefel manifold M based on the Padé approximation of order m[ZhuDuan2018]. Let p_m and q_m be defined for any matrix A  ℝ^nx as\n\n  p_m(A) = sum_k=0^m frac(2m-k)m(2m)(m-k)fracA^kk\n\nand\n\n  q_m(A) = sum_k=0^m frac(2m-k)m(2m)(m-k)frac(-A)^kk\n\nrespectively. Then the Padé approximation (of the matrix exponential exp(A)) reads\n\n  r_m(A) = q_m(A)^-1p_m(A)\n\nDefining further\n\n  W_pX = operatornameP_pXp^mathrmH - pX^mathrmHoperatornameP_p\n  quadtextwhere \n  operatornameP_p = I - frac12pp^mathrmH\n\nthe retraction reads\n\n  operatornameretr_pX = r_m(W_pX)p\n\n[ZhuDuan2018]: X. Zhu, C. Duan: On matrix exponentials and their approximations related to optimization on the Stiefel manifold, Optimizazion Letters 13(5), pp. 1069–1083, 2018. doi 10.1007/s11590-018-1341-z.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, PolarRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Stiefel manifold M. With USV = p + X the retraction reads\n\noperatornameretr_p X = UbarV^mathrmH\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.retract-Tuple{Stiefel, Any, Any, QRRetraction}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M::Stiefel, p, X, ::QRRetraction)\n\nCompute the QR-based retraction QRRetraction on the Stiefel manifold M. With QR = p + X the retraction reads\n\noperatornameretr_p X = QD\n\nwhere D is a n  k matrix with\n\nD = operatornamediagbigl(operatornamesgn(R_ii+05)_i=1^k bigr)\n\nwhere operatornamesgn(p) = begincases 1  text for  p  0\n0  text for  p = 0\n-1 text for  p  0 endcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.vector_transport_direction-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{CayleyRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(::Stiefel, p, X, d, ::DifferentiatedRetractionVectorTransport{CayleyRetraction})\n\nCompute the vector transport given by the differentiated retraction of the CayleyRetraction, cf. [Zhu2017] Equation (17).\n\nThe formula reads\n\noperatornameT_pd(X) =\nBigl(I - frac12W_pdBigr)^-1W_pXBigl(I - frac12W_pdBigr)^-1p\n\nwith\n\n  W_pX = operatornameP_pXp^mathrmH - pX^mathrmHoperatornameP_p\n  quadtextwhere \n  operatornameP_p = I - frac12pp^mathrmH\n\nSince this is the differentiated retraction as a vector transport, the result will be in the tangent space at q=operatornameretr_p(d) using the CayleyRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.vector_transport_direction-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{PolarRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::Stiefel, p, X, d, DifferentiatedRetractionVectorTransport{PolarRetraction})\n\nCompute the vector transport by computing the push forward of retract(::Stiefel, ::Any, ::Any, ::PolarRetraction) Section 3.5 of [Zhu2017]:\n\nT_pd^textPol(X) = q*Λ + (I-qq^mathrmT)X(1+d^mathrmTd)^-frac12\n\nwhere q = operatornameretr^mathrmPol_p(d), and Λ is the unique solution of the Sylvester equation\n\n    Λ(I+d^mathrmTd)^frac12 + (I + d^mathrmTd)^frac12 = q^mathrmTX - X^mathrmTq\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.vector_transport_direction-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{QRRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::Stiefel, p, X, d, DifferentiatedRetractionVectorTransport{QRRetraction})\n\nCompute the vector transport by computing the push forward of the retract(::Stiefel, ::Any, ::Any, ::QRRetraction), See [AbsilMahonySepulchre2008], p. 173, or Section 3.5 of [Zhu2017].\n\nT_pd^textQR(X) = q*rho_mathrms(q^mathrmTXR^-1) + (I-qq^mathrmT)XR^-1\n\nwhere q = operatornameretr^mathrmQR_p(d), R is the R factor of the QR decomposition of p + d, and\n\nbigl( rho_mathrms(A) bigr)_ij\n= begincases\nA_ijtext if  i  j\n0 text if  i = j\n-A_ji text if  i  j\nendcases\n\n[AbsilMahonySepulchre2008]: Absil, P.-A., Mahony, R. and Sepulchre R., Optimization Algorithms on Matrix Manifolds Princeton University Press, 2008, doi: 10.1515/9781400830244 open access\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.vector_transport_to-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{PolarRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Stiefel, p, X, q, DifferentiatedRetractionVectorTransport{PolarRetraction})\n\nCompute the vector transport by computing the push forward of the retract(M::Stiefel, ::Any, ::Any, ::PolarRetraction), see Section 4 of [HuangGallivanAbsil2015] or  Section 3.5 of [Zhu2017]:\n\nT_qgets p^textPol(X) = q*Λ + (I-qq^mathrmT)X(1+d^mathrmTd)^-frac12\n\nwhere d = bigl( operatornameretr^mathrmPol_pbigr)^-1(q), and Λ is the unique solution of the Sylvester equation\n\n    Λ(I+d^mathrmTd)^frac12 + (I + d^mathrmTd)^frac12 = q^mathrmTX - X^mathrmTq\n\n[HuangGallivanAbsil2015]: Huang, W., Gallivan, K. A., and Absil, P.-A.: A Broyden class of quasi-Newton methods for Riemannian optimization SIAM Journal of Optimization, 2015, Vol. 25, No. 3, pp. 1660–1685 doi: 10.1137/140955483 pdf: tech. report\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.vector_transport_to-Tuple{Stiefel, Any, Any, Any, DifferentiatedRetractionVectorTransport{QRRetraction}}","page":"Stiefel","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Stiefel, p, X, q, DifferentiatedRetractionVectorTransport{QRRetraction})\n\nCompute the vector transport by computing the push forward of the retract(M::Stiefel, ::Any, ::Any, ::QRRetraction), see [AbsilMahonySepulchre2008], p. 173, or Section 3.5 of [Zhu2017].\n\nT_q gets p^textQR(X) = q*rho_mathrms(q^mathrmTXR^-1) + (I-qq^mathrmT)XR^-1\n\nwhere d = bigl(operatornameretr^mathrmQRbigr)^-1_p(q), R is the R factor of the QR decomposition of p+X, and\n\nbigl( rho_mathrms(A) bigr)_ij\n= begincases\nA_ijtext if  i  j\n0 text if  i = j\n-A_ji text if  i  j\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.vector_transport_to-Tuple{Stiefel, Any, Any, Any, ProjectionTransport}","page":"Stiefel","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Stiefel, p, X, q, ::ProjectionTransport)\n\nCompute a vector transport by projection, i.e. project X from the tangent space at p by projection it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#Default-metric:-the-Euclidean-metric","page":"Stiefel","title":"Default metric: the Euclidean metric","text":"","category":"section"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"The EuclideanMetric is obtained from the embedding of the Stiefel manifold in ℝ^nk.","category":"page"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/StiefelEuclideanMetric.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/stiefel.html#Base.exp-Tuple{Stiefel, Vararg{Any, N} where N}","page":"Stiefel","title":"Base.exp","text":"exp(M::Stiefel, p, X)\n\nCompute the exponential map on the Stiefel{n,k,𝔽}() manifold M emanating from p in tangent direction X.\n\nexp_p X = beginpmatrix\n   pX\n endpmatrix\n operatornameExp\n left(\n beginpmatrix p^mathrmHX  - X^mathrmHX\n I_n  p^mathrmHXendpmatrix\n right)\nbeginpmatrix  exp( -p^mathrmHX)  0_nendpmatrix\n\nwhere operatornameExp denotes matrix exponential, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k and 0_k are the identity matrix and the zero matrix of dimension k  k, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.get_basis-Union{Tuple{k}, Tuple{n}, Tuple{Stiefel{n, k, ℝ}, Any, DefaultOrthonormalBasis{ℝ, ManifoldsBase.TangentSpaceType}}} where {n, k}","page":"Stiefel","title":"ManifoldsBase.get_basis","text":"get_basis(M::Stiefel{n,k,ℝ}, p, B::DefaultOrthonormalBasis) where {n,k}\n\nCreate the default basis using the parametrization for any X  T_pmathcal M. Set p_bot in ℝ^ntimes(n-k) the matrix such that the ntimes n matrix of the common columns p p_bot is an ONB. For any skew symmetric matrix a  ℝ^ktimes k and any b  ℝ^(n-k)times k the matrix\n\nX = pa + p_bot b  T_pmathcal M\n\nand we can use the frac12k(k-1) + (n-k)k = nk-frac12k(k+1) entries of a and b to specify a basis for the tangent space. using unit vectors for constructing both the upper matrix of a to build a skew symmetric matrix and the matrix b, the default basis is constructed.\n\nSince p p_bot is an automorphism on ℝ^ntimes p the elements of a and b are orthonormal coordinates for the tangent space. To be precise exactly one element in the upper trangular entries of a is set to 1 its symmetric entry to -1 and we normalize with the factor frac1sqrt2 and for b one can just use unit vectors reshaped to a matrix to obtain orthonormal set of parameters.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.project-Tuple{Stiefel, Any, Any}","page":"Stiefel","title":"ManifoldsBase.project","text":"project(M::Stiefel,p)\n\nProjects p from the embedding onto the Stiefel M, i.e. compute q as the polar decomposition of p such that q^mathrmHq is the identity, where cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.project-Tuple{Stiefel, Vararg{Any, N} where N}","page":"Stiefel","title":"ManifoldsBase.project","text":"project(M::Stiefel, p, X)\n\nProject X onto the tangent space of p to the Stiefel manifold M. The formula reads\n\noperatornameproj_mathcal M(p X) = X - p operatornameSym(p^mathrmHX)\n\nwhere operatornameSym(q) is the symmetrization of q, e.g. by operatornameSym(q) = fracq^mathrmH+q2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#The-canonical-metric","page":"Stiefel","title":"The canonical metric","text":"","category":"section"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"Any XT_pmathcal M, pmathcal M, can be written as","category":"page"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"X = pA + (I_n-pp^mathrmT)B\nquad\nA  ℝ^pp text skew-symmetric\nquad\nB  ℝ^np text arbitrary","category":"page"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"In the EuclideanMetric, the elements from A are counted twice (i.e. weighted with a factor of 2). The canonical metric avoids this.","category":"page"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/StiefelCanonicalMetric.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/stiefel.html#Manifolds.ApproximateLogarithmicMap","page":"Stiefel","title":"Manifolds.ApproximateLogarithmicMap","text":"ApproximateLogarithmicMap <: ApproximateInverseRetraction\n\nAn approximate implementation of the logarithmic map, which is an inverse_retraction. See inverse_retract(::MetricManifold{ℝ,Stiefel{n,k,ℝ},CanonicalMetric}, ::Any, ::Any, ::ApproximateLogarithmicMap) where {n,k} for a use case.\n\nFields\n\nmax_iterations – maximal number of iterations used in the approximation\ntolerance – a tolerance used as a stopping criterion\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel.html#Manifolds.CanonicalMetric","page":"Stiefel","title":"Manifolds.CanonicalMetric","text":"CanonicalMetric <: AbstractMetric\n\nThe Canonical Metric refers to a metric for the Stiefel manifold, see[EdelmanAriasSmith1998].\n\n[EdelmanAriasSmith1998]: Edelman, A., Ariar, T. A., Smith, S. T.: The Geometry of Algorihthms with Orthogonality Constraints, SIAM Journal on Matrix Analysis and Applications (20(2), pp. 303–353, 1998. doi: 10.1137/S0895479895290954 arxiv: 9806030\n\n\n\n\n\n","category":"type"},{"location":"manifolds/stiefel.html","page":"Stiefel","title":"Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/StiefelCanonicalMetric.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/stiefel.html#Base.exp-Union{Tuple{k}, Tuple{n}, Tuple{MetricManifold{ℝ, Stiefel{n, k, ℝ}, CanonicalMetric}, Vararg{Any, N} where N}} where {n, k}","page":"Stiefel","title":"Base.exp","text":"q = exp(M::MetricManifold{ℝ, Stiefel{n,k,ℝ}, CanonicalMetric}, p, X)\nexp!(M::MetricManifold{ℝ, Stiefel{n,k,ℝ}, q, CanonicalMetric}, p, X)\n\nCompute the exponential map on the Stiefel(n,k) manifold with respect to the CanonicalMetric.\n\nFirst, decompose The tangent vector X into its horizontal and vertical component with respect to p, i.e.\n\nX = pp^mathrmTX + (I_n-pp^mathrmT)X\n\nwhere I_n is the ntimes n identity matrix. We introduce A=p^mathrmTX and QR = (I_n-pp^mathrmT)X the qr decomposition of the vertical component. Then using the matrix exponential operatornameExp we introduce B and C as\n\nbeginpmatrix\nBC\nendpmatrix\ncoloneqq\noperatornameExpleft(\nbeginpmatrix\nA  -R^mathrmT R  0\nendpmatrix\nright)\nbeginpmatrixI_k0endpmatrix\n\nthe exponential map reads\n\nq = exp_p X = pC + QB\n\nFor more details, see [EdelmanAriasSmith1998][Zimmermann2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inner-Union{Tuple{k}, Tuple{n}, Tuple{MetricManifold{ℝ, Stiefel{n, k, ℝ}, CanonicalMetric}, Any, Any, Any}} where {n, k}","page":"Stiefel","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{ℝ, Stiefel{n,k,ℝ}, X, CanonicalMetric}, p, X, Y)\n\ncompute the inner procuct on the Stiefel manifold with respect to the CanonicalMetric. The formula reads\n\ng_p(XY) = operatornametrbigl( X^mathrmT(I_n - frac12pp^mathrmT)Y bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inverse_retract-Union{Tuple{k}, Tuple{n}, Tuple{MetricManifold{ℝ, Stiefel{n, k, ℝ}, CanonicalMetric}, Any, Any, ApproximateLogarithmicMap}} where {n, k}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"X = inverse_retract(M::MetricManifold{ℝ, Stiefel{n,k,ℝ}, CanonicalMetric}, p, q, a::ApproximateLogarithmicMap)\ninverse_retract!(M::MetricManifold{ℝ, Stiefel{n,k,ℝ}, X, CanonicalMetric}, p, q, a::ApproximateLogarithmicMap)\n\nCompute an approximation to the logarithmic map on the Stiefel(n,k) manifold with respect to the CanonicalMetric using a matrix-algebraic based approach to an iterative inversion of the formula of the exp.\n\nThe algorithm is derived in[Zimmermann2017] and it uses the max_iterations and the tolerance field from the ApproximateLogarithmicMap.\n\n[Zimmermann2017]: Zimmermann, R.: _A matrix-algebraic algorithm for the Riemannian logarithm on the Stiefel manifold under the canoncial metric. SIAM Journal on Matrix Analysis and Applications 28(2), pp. 322-342, 2017. doi: 10.1137/16M1074485, arXiv: 1604.05054.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#Literature","page":"Stiefel","title":"Literature","text":"","category":"section"},{"location":"manifolds/circle.html#Circle","page":"Circle","title":"Circle","text":"","category":"section"},{"location":"manifolds/circle.html","page":"Circle","title":"Circle","text":"Modules = [Manifolds]\nPages = [\"manifolds/Circle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/circle.html#Manifolds.Circle","page":"Circle","title":"Manifolds.Circle","text":"Circle{𝔽} <: AbstractManifold{𝔽}\n\nThe circle 𝕊^1 is a manifold here represented by real-valued points in -ππ) or complex-valued points z  ℂ of absolute value lvert zrvert = 1.\n\nConstructor\n\nCircle(𝔽=ℝ)\n\nGenerate the ℝ-valued Circle represented by angles, which alternatively can be set to use the AbstractNumbers 𝔽=ℂ to obtain the circle represented by ℂ-valued circle of unit numbers.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/circle.html#Base.exp-Tuple{Circle, Vararg{Any, N} where N}","page":"Circle","title":"Base.exp","text":"exp(M::Circle, p, X)\n\nCompute the exponential map on the Circle.\n\nexp_p X = (p+X)_2π\n\nwhere (cdot)_2π is the (symmetric) remainder with respect to division by 2π, i.e. in -ππ).\n\nFor the complex-valued case, the same formula as for the Sphere 𝕊^1 is applied to values in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Base.log-Tuple{Circle, Vararg{Any, N} where N}","page":"Circle","title":"Base.log","text":"log(M::Circle, p, q)\n\nCompute the logarithmic map on the Circle M.\n\nlog_p q = (q-p)_2π\n\nwhere (cdot)_2π is the (symmetric) remainder with respect to division by 2π, i.e. in -ππ).\n\nFor the complex-valued case, the same formula as for the Sphere 𝕊^1 is applied to values in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Base.rand-Tuple{Circle{ℝ}}","page":"Circle","title":"Base.rand","text":"Random.rand(M::Circle{ℝ}; vector_at = nothing, σ::Real=1.0)\n\nIf vector_at is nothing, return a random point on the Circle mathbb S^1 by picking a random element from -pipi) uniformly.\n\nIf vector_at is not nothing, return a random tangent vector from the tangent space of the point vector_at on the Circle` by using a normal distribution with mean 0 and standard deviation σ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.complex_dot-Tuple{Any, Any}","page":"Circle","title":"Manifolds.complex_dot","text":"complex_dot(a, b)\n\nCompute the inner product of two (complex) numbers with in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.sym_rem-Union{Tuple{N}, Tuple{N, Any}} where N<:Number","page":"Circle","title":"Manifolds.sym_rem","text":"sym_rem(x,[T=π])\n\nCompute symmetric remainder of x with respect to the interall 2*T, i.e. (x+T)%2T, where the default for T is π\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.check_point-Tuple{Circle, Vararg{Any, N} where N}","page":"Circle","title":"ManifoldsBase.check_point","text":"check_point(M::Circle, p)\n\nCheck whether p is a point on the Circle M. For the real-valued case, p is an angle and hence it checks that p   -ππ). for the complex-valued case, it is a unit number, p  ℂ with lvert p rvert = 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.check_vector-Tuple{Circle{ℝ}, Vararg{Any, N} where N}","page":"Circle","title":"ManifoldsBase.check_vector","text":"check_vector(M::Circle, p, X; kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the Circle M. For the real-valued case represented by angles, all X are valid, since the tangent space is the whole real line. For the complex-valued case X has to lie on the line parallel to the tangent line at p in the complex plane, i.e. their inner product has to be zero.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.distance-Tuple{Circle, Vararg{Any, N} where N}","page":"Circle","title":"ManifoldsBase.distance","text":"distance(M::Circle, p, q)\n\nCompute the distance on the Circle M, which is the absolute value of the symmetric remainder of p and q for the real-valued case and the angle between both complex numbers in the Gaussian plane for the complex-valued case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.embed-Tuple{Circle, Any, Any}","page":"Circle","title":"ManifoldsBase.embed","text":"embed(M::Circle, p, X)\n\nEmbed a tangent vector X at p on Circle M in the ambient space. It returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.embed-Tuple{Circle, Any}","page":"Circle","title":"ManifoldsBase.embed","text":"embed(M::Circle, p)\n\nEmbed a point p on Circle M in the ambient space. It returns p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.get_coordinates-Tuple{Circle{ℂ}, Any, Any, DefaultOrthonormalBasis{var\"#s108\", ManifoldsBase.TangentSpaceType} where var\"#s108\"}","page":"Circle","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Circle{ℂ}, p, X, B::DefaultOrthonormalBasis)\n\nReturn tangent vector coordinates in the Lie algebra of the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.get_vector_orthonormal-Tuple{Circle{ℂ}, Any, Any, ManifoldsBase.RealNumbers}","page":"Circle","title":"ManifoldsBase.get_vector_orthonormal","text":"get_vector(M::Circle{ℂ}, p, X, B::DefaultOrthonormalBasis)\n\nReturn tangent vector from the coordinates in the Lie algebra of the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.injectivity_radius-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Circle[, p])\n\nReturn the injectivity radius on the Circle M, i.e. π.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.inner-Tuple{Circle, Vararg{Any, N} where N}","page":"Circle","title":"ManifoldsBase.inner","text":"inner(M::Circle, p, X, Y)\n\nCompute the inner product of the two tangent vectors X,Y from the tangent plane at p on the Circle M using the restriction of the metric from the embedding, i.e.\n\ng_p(XY) = X*Y\n\nfor the real case and\n\ng_p(XY) = Y^mathrmTX\n\nfor the complex case interpreting complex numbers in the Gaussian plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.manifold_dimension-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Circle)\n\nReturn the dimension of the Circle M, i.e. dim(𝕊^1) = 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.parallel_transport_to-Tuple{Circle, Any, Any, Any}","page":"Circle","title":"ManifoldsBase.parallel_transport_to","text":" parallel_transport_to(M::Circle, p, X, q)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the Circle M. For the real-valued case this results in the identity. For the complex-valud case, the formula is the same as for the Sphere(1) in the complex plane.\n\nmathcal P_qp X = X - fraclog_p qX_pd^2_ℂ(pq)\nbigl(log_p q + log_q p bigr)\n\nwhere log denotes the logarithmic map on M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.project-Tuple{Circle, Any, Any}","page":"Circle","title":"ManifoldsBase.project","text":"project(M::Circle, p, X)\n\nProject a value X onto the tangent space of the point p on the Circle M.\n\nFor the real-valued case this is just the identity. For the complex valued case X is projected onto the line in the complex plane that is parallel to the tangent to p on the unit circle and contains 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.project-Tuple{Circle, Any}","page":"Circle","title":"ManifoldsBase.project","text":"project(M::Circle, p)\n\nProject a point p onto the Circle M. For the real-valued case this is the remainder with respect to modulus 2π. For the complex-valued case the result is the projection of p onto the unit circle in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Statistics.mean-Tuple{Circle{ℂ}, Any}","page":"Circle","title":"Statistics.mean","text":"mean(M::Circle{ℂ}, x::AbstractVector[, w::AbstractWeights])\n\nCompute the Riemannian mean of x of points on the Circle 𝕊^1, reprsented by complex numbers, i.e. embedded in the complex plade. Comuting the sum\n\ns = sum_i=1^n x_i\n\nthe mean is the angle of the complex number s, so represented in the complex plane as fracslvert s rvert, whenever s neq 0.\n\nIf the sum s=0, the mean is not unique. For example for opposite points or equally spaced angles.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Statistics.mean-Tuple{Circle{ℝ}, Any}","page":"Circle","title":"Statistics.mean","text":"mean(M::Circle{ℝ}, x::AbstractVector[, w::AbstractWeights])\n\nCompute the Riemannian mean of x of points on the Circle 𝕊^1, reprsented by real numbers, i.e. the angular mean\n\noperatornameatanBigl( sum_i=1^n w_isin(x_i)  sum_i=1^n w_isin(x_i) Bigr)\n\n\n\n\n\n","category":"method"},{"location":"misc/about.html#About-Manifolds.jl","page":"About","title":"About Manifolds.jl","text":"","category":"section"},{"location":"misc/about.html#License","page":"About","title":"License","text":"","category":"section"},{"location":"misc/about.html","page":"About","title":"About","text":"MIT License","category":"page"},{"location":"misc/about.html#Core-Developers","page":"About","title":"Core Developers","text":"","category":"section"},{"location":"misc/about.html","page":"About","title":"About","text":"Seth Axen\nMateusz Baran\nRonny Bergmann","category":"page"},{"location":"misc/about.html#Contributors","page":"About","title":"Contributors","text":"","category":"section"},{"location":"misc/about.html","page":"About","title":"About","text":"See the GitHub contributors page.","category":"page"},{"location":"misc/about.html","page":"About","title":"About","text":"Contributions are welcome!","category":"page"},{"location":"features/testing.html#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"features/testing.html","page":"Testing","title":"Testing","text":"Documentation for testing utilities for Manifolds.jl. The function test_manifold can be used to verify that your manifold correctly implements the Manifolds.jl interface. Similarly test_group and test_action can be used to verify implementation of groups and group actions.","category":"page"},{"location":"features/testing.html","page":"Testing","title":"Testing","text":"Modules = [Manifolds]\nPages = [\"tests/reversediff.jl\", \"tests/test_forwarddiff.jl\",\"tests/tests_general.jl\", \"tests/tests_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/testing.html#Manifolds.find_eps-Tuple","page":"Testing","title":"Manifolds.find_eps","text":"find_eps(x...)\n\nFind an appropriate tolerance for given points or tangent vectors, or their types.\n\n\n\n\n\n","category":"method"},{"location":"features/testing.html#Manifolds.test_manifold-Tuple{AbstractManifold, AbstractVector{T} where T}","page":"Testing","title":"Manifolds.test_manifold","text":"test_manifold(\n    M::AbstractManifold,\n    pts::AbstractVector;\n    args,\n)\n\nTest general properties of manifold M, given at least three different points that lie on it (contained in pts).\n\nArguments\n\nbasis_has_specialized_diagonalizing_get = false: if true, assumes that   DiagonalizingOrthonormalBasis given in basis_types has   get_coordinates and get_vector that work without caching.\nbasis_types_to_from = (): basis types that will be tested based on   get_coordinates and get_vector.\nbasis_types_vecs = () : basis types that will be tested based on get_vectors\ndefault_inverse_retraction_method = ManifoldsBase.LogarithmicInverseRetraction():   default method for inverse retractions (log.\ndefault_retraction_method = ManifoldsBase.ExponentialRetraction(): default method for   retractions (exp).\nexp_log_atol_multiplier = 0: change absolute tolerance of exp/log tests   (0 use default, i.e. deactivate atol and use rtol).\nexp_log_rtol_multiplier = 1: change the relative tolerance of exp/log tests   (1 use default). This is deactivated if the exp_log_atol_multiplier is nonzero.\nexpected_dimension_type = Integer: expected type of value returned by   manifold_dimension.\ninverse_retraction_methods = []: inverse retraction methods that will be tested.\nis_mutating = true: whether mutating variants of functions should be tested.\nis_point_atol_multiplier = 0: determines atol of is_point checks.\nis_tangent_atol_multiplier = 0: determines atol of is_vector checks.\nmid_point12 = test_exp_log ? shortest_geodesic(M, pts[1], pts[2], 0.5) : nothing: if not nothing, then check   that mid_point(M, pts[1], pts[2]) is approximately equal to mid_point12. This is   by default set to nothing if text_exp_log is set to false.\npoint_distributions = [] : point distributions to test.\nrand_tvector_atol_multiplier = 0 : chage absolute tolerance in testing random vectors   (0 use default, i.e. deactivate atol and use rtol) random tangent vectors are tangent   vectors.\nretraction_atol_multiplier = 0: change absolute tolerance of (inverse) retraction tests   (0 use default, i.e. deactivate atol and use rtol).\nretraction_rtol_multiplier = 1: change the relative tolerance of (inverse) retraction   tests (1 use default). This is deactivated if the exp_log_atol_multiplier is nonzero.\nretraction_methods = []: retraction methods that will be tested.\ntest_atlases = []: Vector or tuple of atlases that should be tested.\ntest_exp_log = true: if true, check that exp is the inverse of log.\ntest_injectivity_radius = true: whether implementation of injectivity_radius   should be tested.\ntest_inplace = false : if true check if inplace variants work if they are activated,  e.g. check that exp!(M, p, p, X) work if test_exp_log = true.  This in general requires is_mutating to be true.\ntest_is_tangent: if true check that the default_inverse_retraction_method   actually returns valid tangent vectors.\ntest_musical_isomorphisms = false : test musical isomorphisms.\ntest_mutating_rand = false : test the mutating random function for points on manifolds.\ntest_project_point = false: test projections onto the manifold.\ntest_project_tangent = false : test projections on tangent spaces.\ntest_representation_size = true : test repersentation size of points/tvectprs.\ntest_tangent_vector_broadcasting = true : test boradcasting operators on TangentSpace.\ntest_vector_spaces = true : test Vector bundle of this manifold.\ntest_default_vector_transport = false : test the default vector transport (usually  parallel transport).\ntest_vee_hat = false: test vee and hat functions.\ntvector_distributions = [] : tangent vector distributions to test.\nvector_transport_methods = []: vector transport methods that should be tested.\nvector_transport_inverse_retractions = [default_inverse_retraction_method for _ in 1:length(vector_transport_methods)]` inverse retractions to use with the vector transport method (especially the differentiated ones)\nvector_transport_to = [ true for _ in 1:length(vector_transport_methods)]: whether  to check the to variant of vector transport\nvector_transport_direction = [ true for _ in 1:length(vector_transport_methods)]: whether  to check the direction variant of vector transport\n\n\n\n\n\n","category":"method"},{"location":"features/testing.html#Manifolds.test_parallel_transport","page":"Testing","title":"Manifolds.test_parallel_transport","text":"test_parallel_transport(M,P; along=false, to=true, diretion=true)\n\nGeneric tests for parallel transport on Mgiven at least two pointsin P.\n\nThe single functions to transport along (a curve), to (a point) or (towards a) direction are sub-tests that can be activated by the keywords arguemnts\n\n!!! Note Since the interface to specify curves is not yet provided, the along keyword does not have an effect yet\n\n\n\n\n\n","category":"function"},{"location":"features/testing.html#Manifolds.test_action","page":"Testing","title":"Manifolds.test_action","text":"test_action(\n    A::AbstractGroupAction,\n    a_pts::AbstractVector,\n    m_pts::AbstractVector,\n    X_pts = [];\n    atol = 1e-10,\n    atol_ident_compose = 0,\n    test_optimal_alignment = false,\n    test_mutating_group=true,\n    test_mutating_action=true,\n    test_diff = false,\n    test_switch_direction = true,\n)\n\nTests general properties of the action A, given at least three different points that lie on it (contained in a_pts) and three different point that lie on the manifold it acts upon (contained in m_pts).\n\nArguments\n\natol_ident_compose = 0: absolute tolerance for the test that composition with identity doesn't change the group element.\n\n\n\n\n\n","category":"function"},{"location":"features/testing.html#Manifolds.test_group","page":"Testing","title":"Manifolds.test_group","text":"test_group(\n    G,\n    g_pts::AbstractVector,\n    X_pts::AbstractVector = [],\n    Xe_pts::AbstractVector = [];\n    atol = 1e-10,\n    test_mutating = true,\n    test_exp_lie_log = true,\n    test_diff = false,\n    test_invariance = false,\n    test_lie_bracket=false,\n    test_adjoint_action=false,\n    diff_convs = [(), (LeftAction(),), (RightAction(),)],\n)\n\nTests general properties of the group G, given at least three different points elements of it (contained in g_pts). Optionally, specify test_diff to test differentials of translation, using X_pts, which must contain at least one tangent vector at g_pts[1], and the direction conventions specified in diff_convs. Xe_pts should contain tangent vectors at identity for testing Lie algebra operations. If the group is equipped with an invariant metric, test_invariance indicates that the invariance should be checked for the provided points.\n\n\n\n\n\n","category":"function"},{"location":"misc/notation.html#Notation-overview","page":"Notation","title":"Notation overview","text":"","category":"section"},{"location":"misc/notation.html","page":"Notation","title":"Notation","text":"Since manifolds include a reasonable amount of elements and functions, the following list tries to keep an overview of used notation throughout Manifolds.jl. The order is alphabetical by name. They might be used in a plain form within the code or when referring to that code. This is for example the case with the calligraphic symbols.","category":"page"},{"location":"misc/notation.html","page":"Notation","title":"Notation","text":"Within the documented functions, the utf8 symbols are used whenever possible, as long as that renders correctly in TeX within this documentation.","category":"page"},{"location":"misc/notation.html","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\ntau_p action map by group element p mathrmL_p, mathrmR_p either left or right\noperatornameAd_p(X) adjoint action of element p of a Lie group on the element X of the corresponding Lie algebra  \ntimes Cartesian product of two manifolds  see ProductManifold\n^wedge (n-ary) Cartesian power of a manifold  see PowerManifold\na coordinates of a point in a chart  see get_parameters\nfracmathrmDmathrmdt covariant derivative of a vector field X(t)  \nT^*_p mathcal M the cotangent space at p  \nξ a cotangent vector from T^*_p mathcal M ξ_1 ξ_2 ηzeta sometimes written with base point ξ_p.\nmathrmdphi_p(q) Differential of a map phi mathcal M to mathcal N with respect to p at a point q. For functions of multiple variables, for example phi(p p_1) where p in mathcal M and p_1 in mathcal M_1, variable p is explicitly stated to specify with respect to which argument the differential is calculated. mathrmdphi_q, (mathrmdphi)_q, (phi_*)_q, D_pphi(q) pushes tangent vectors X in T_q mathcal M forward to mathrmdphi_p(q)X in T_phi(q) mathcal N\nn dimension (of a manifold) n_1n_2ldotsm dim(mathcal M) for the real dimension sometimes also dim_mathbb R(mathcal M)\nd(cdotcdot) (Riemannian) distance d_mathcal M(cdotcdot) \nexp_p X exponential map at p in mathcal M of a vector X in T_p mathcal M exp_p(X) \nF a fiber  see VectorBundleFibers\nmathbb F a field, usually mathbb F in mathbb Rmathbb C mathbb H, i.e. the real, complex, and quaternion numbers, respectively.  field a manifold or a basis is based on\ngamma a geodesic gamma_pq, gamma_pX connecting two points pq or starting in p with velocity X.\n f(p) gradient of function f colon mathcalM to mathbbR at p in mathcalM  \ncirc a group operation  \ncdot^mathrmH Hermitian or conjugate transposed  \ne identity element of a group  \nI_k identity matrix of size ktimes k  \nk indices ij \nlanglecdotcdotrangle inner product (in T_p mathcal M) langlecdotcdotrangle_p g_p(cdotcdot) \noperatornameretr^-1_pq an inverse retraction  \nmathfrak g a Lie algebra  \nmathcalG a (Lie) group  \nlog_p q logarithmic map at p in mathcal M of a point q in mathcal M log_p(q) \nmathcal M a manifold mathcal M_1 mathcal M_2ldotsmathcal N \noperatornameExp the matrix exponential  \noperatornameLog the matrix logarithm  \nmathcal P_qgets pX parallel transport  of the vector X from T_pmathcal M to T_qmathcal M\nmathcal P_pYX parallel transport in direction Y  of the vector X from T_pmathcal M to T_qmathcal M, q = exp_pY\nmathcal P_t_1gets t_0^cX parallel transport along the curve c mathcal P^cX=mathcal P_1gets 0^cX of the vector X from p=c(0) to c(1)\np a point on mathcal M p_1 p_2 ldotsq for 3 points one might use xyz\noperatornameretr_pX a retraction  \nξ a set of tangent vectors X_1ldotsX_n \nT_p mathcal M the tangent space at p  \nX a tangent vector from T_p mathcal M X_1X_2ldotsYZ sometimes written with base point X_p\noperatornametr trace (of a matrix)  \ncdot^mathrmT transposed  \ne_i in mathbb R^n the ith unit vector e_i^n the space dimension (n) is omited, when clear from context\nB a vector bundle  \nmathcal T_qgets pX vector transport  of the vector X from T_pmathcal M to T_qmathcal M\nmathcal T_pYX vector transport in direction Y  of the vector X from T_pmathcal M to T_qmathcal M, where q is deretmined by Y, for example using the exponential map or some retraction.\n0_k the ktimes k zero matrix.  ","category":"page"},{"location":"manifolds/symmetricpsdfixedrank.html#Symmetric-Positive-Semidefinite-Matrices-of-Fixed-Rank","page":"Symmetric positive semidefinite fixed rank","title":"Symmetric Positive Semidefinite Matrices of Fixed Rank","text":"","category":"section"},{"location":"manifolds/symmetricpsdfixedrank.html","page":"Symmetric positive semidefinite fixed rank","title":"Symmetric positive semidefinite fixed rank","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveSemidefiniteFixedRank.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpsdfixedrank.html#Manifolds.SymmetricPositiveSemidefiniteFixedRank","page":"Symmetric positive semidefinite fixed rank","title":"Manifolds.SymmetricPositiveSemidefiniteFixedRank","text":"SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold  $ \\operatorname{SPS}_k(n)$ consisting of the real- or complex-valued symmetric positive semidefinite matrices of size n  n and rank k, i.e. the set\n\noperatornameSPS_k(n) = bigl\np   𝔽^n  n big p^mathrmH = p\napa^mathrmH geq 0 text for all  a  𝔽\ntext and  operatornamerank(p) = kbigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ. We sometimes operatornameSPS_k𝔽(n), when distinguishing the real- and complex-valued manifold is important.\n\nAn element is represented by q  𝔽^n  k from the factorization p = qq^mathrmH. Note that since for any unitary (orthogonal) A  𝔽^n  n we have (Aq)(Aq)^mathrmH = qq^mathrmH = p, the representation is not unique, or in other words, the manifold is a quotient manifold of 𝔽^n  k.\n\nThe tangent space at p, T_poperatornameSPS_k(n), is also represented by matrices Y  𝔽^n  k and reads as\n\nT_poperatornameSPS_k(n) = bigl\nX  𝔽^n  nX = qY^mathrmH + Yq^mathrmH\ntext ie  X = X^mathrmH\nbigr\n\nNote that the metric used yields a non-complete manifold. The metric was used in[JourneeBachAbsilSepulchre2010][MassartAbsil2020].\n\nConstructor\n\nSymmetricPositiveSemidefiniteFixedRank(n::Int, k::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of n  n symmetric positive semidefinite matrices of rank k over the field of real numbers ℝ or complex numbers ℂ.\n\n[JourneeBachAbsilSepulchre2010]: Journée, M., Bach, F., Absil, P.-A., and Sepulchre, R.: “Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”, SIAM Journal on Optimization (20)5, pp. 2327–2351, 2010. doi: 10.1137/080731359, arXiv: 0807.4423.\n\n[MassartAbsil2020]: Massart, E., Absil, P.-A.: \"Quotient Geometry with Simple Geodesics for the AbstractManifold of Fixed-Rank Positive-Semidefinite Matrices\", SIAM Journal on Matrix Analysis and Applications (41)1, pp. 171–198, 2020. doi: 10.1137/18m1231389, preprint: sites.uclouvain.be/absil/2018.06.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpsdfixedrank.html#Base.exp-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.exp","text":"exp(M::SymmetricPositiveSemidefiniteFixedRank, q, Y)\n\nCompute the exponential map on the SymmetricPositiveSemidefiniteFixedRank, which just reads\n\n    exp_q Y = q+Y\n\nnote: Note\nSince the manifold is represented in the embedding and is a quotient manifold, the exponential and logarithmic map are a bijection only with respect to the equivalence classes. Computing    q_2 = exp_p(log_pq)might yield a matrix q_2neq q, but they represent the same point on the quotient manifold, i.e. d_operatornameSPS_k(n)(q_2q) = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#Base.isapprox-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.isapprox","text":"isapprox(M::SymmetricPositiveSemidefiniteFixedRank, p, q; kwargs...)\n\ntest, whether two points p, q are (approximately) nearly the same. Since this is a quotient manifold in the embedding, the test is performed by checking their distance, if they are not the same, i.e. that d_mathcal M(pq) approx 0, where the comparison is performed with the classical isapprox. The kwargs... are passed on to this accordingly.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#Base.log-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"Base.log","text":"log(M::SymmetricPositiveSemidefiniteFixedRank, q, p)\n\nCompute the logarithmic map on the SymmetricPositiveSemidefiniteFixedRank manifold by minimizing lVert p - qYrVert with respect to Y.\n\nnote: Note\nSince the manifold is represented in the embedding and is a quotient manifold, the exponential and logarithmic map are a bijection only with respect to the equivalence classes. Computing    q_2 = exp_p(log_pq)might yield a matrix q_2neq q, but they represent the same point on the quotient manifold, i.e. d_operatornameSPS_k(n)(q_2q) = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{SymmetricPositiveSemidefiniteFixedRank{n, k, 𝔽}, Any}} where {n, k, 𝔽}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.check_point","text":"check_point(M::SymmetricPositiveSemidefiniteFixedRank{n,𝔽}, q; kwargs...)\n\nCheck whether q is a valid manifold point on the SymmetricPositiveSemidefiniteFixedRank M, i.e. whether p=q*q' is a symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽. The symmetry of p is not explicitly checked since by using q p is symmetric by construction. The tolerance for the symmetry of p can and the rank of q*q' be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.check_vector-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SymmetricPositiveSemidefiniteFixedRank M, i.e. X has to be a symmetric matrix of size (n,n) and its values have to be from the correct AbstractNumbers.\n\nDue to the reduced representation this is fulfilled as soon as the matrix is of correct size.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.distance-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.distance","text":"distance(M::SymmetricPositiveSemidefiniteFixedRank, p, q)\n\nCompute the distance between two points p, q on the SymmetricPositiveSemidefiniteFixedRank, which is the Frobenius norm of Y which minimizes lVert p - qYrVert with respect to Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.manifold_dimension-Tuple{SymmetricPositiveSemidefiniteFixedRank}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricPositiveSemidefiniteFixedRank{n,k,𝔽})\n\nReturn the dimension of the SymmetricPositiveSemidefiniteFixedRank matrix M over the number system 𝔽, i.e.\n\nbeginaligned\ndim operatornameSPS_kℝ(n) = kn - frack(k-1)2\ndim operatornameSPS_kℂ(n) = 2kn - k^2\nendaligned\n\nwhere the last k^2 is due to the zero imaginary part for Hermitian matrices diagonal\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.vector_transport_to-Tuple{SymmetricPositiveSemidefiniteFixedRank, Any, Any, Any, ProjectionTransport}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::SymmetricPositiveSemidefiniteFixedRank, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpsdfixedrank.html#ManifoldsBase.zero_vector-Tuple{SymmetricPositiveSemidefiniteFixedRank, Vararg{Any, N} where N}","page":"Symmetric positive semidefinite fixed rank","title":"ManifoldsBase.zero_vector","text":" zero_vector(M::SymmetricPositiveSemidefiniteFixedRank, p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the SymmetricPositiveSemidefiniteFixedRank manifold M.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#atlases_and_charts","page":"Atlases and charts","title":"Atlases and charts","text":"","category":"section"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Atlases on an n-dimensional manifold mathcal M are collections of charts mathcal A = (U_i φ_i) colon i in I, where I is a (finite or infinte) index family, such that U_i subseteq mathcal M is an open set and each chart φ_i U_i to mathbbR^n is a homeomorphism. This means, that φ_i is bijecive – sometimes also called one-to-one and onto - and continuous, and its inverse φ_i^-1 is continuous as well. The inverse φ_i^-1 is called (local) parametrization. The resulting parameters a=φ(p) of p (with respect to the chart φ) are in the literature also called “(local) coordinates”. To distinguish the parameter a from  get_coordinates in a basis, we use the terminology parameter in this package.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"For an atlas mathcal A we further require that","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"displaystylebigcup_iin I U_i = mathcal M","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"We say that φ_i is a chart about p, if pin U_i. An atlas provides a connection between a manifold and the Euclidean space mathbbR^n, since locally, a chart about p can be used to identify its neighborhood (as long as you stay in U_i) with a subset of a Euclidean space. Most manifolds we consider are smooth, i.e. any change of charts φ_i circ φ_j^-1 mathbbR^ntomathbbR^n, where ijin I, is a smooth function. These changes of charts are also called transition maps.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Most operations on manifolds in Manifolds.jl avoid operating in a chart through appropriate embeddings and formulas derived for particular manifolds, though atlases provide the most general way of working with manifolds. Compared to these approaches, using an atlas is often more technical and time-consuming. They are extensively used in metric-related functions on MetricManifolds.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Atlases are represented by objects of subtypes of AbstractAtlas. There are no type restrictions for indices of charts in atlases.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Operations using atlases and charts are available through the following functions:","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"get_chart_index can be used to select an appropriate chart for the neighborhood of a given point p. This function should work deterministically, i.e. for a fixed p always return the same chart.\nget_parameters converts a point to its parameters with respect to the chart in a chart.\nget_point converts parameters (local coordinates) in a chart to the point that corresponds to them.\ninduced_basis returns a basis of a given vector space at a point induced by a chart φ.\ntransition_map converts coordinates of a point between two charts, e.g. computes φ_icirc φ_j^-1 mathbbR^ntomathbbR^n, ijin I.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"While an atlas could store charts as explicit functions, it is favourable, that the [get_parameters] actually implements a chart φ, get_point its inverse, the prametrization φ^-1.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Modules = [Manifolds,ManifoldsBase]\nPages = [\"atlases.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/atlases.html#Manifolds.AbstractAtlas","page":"Atlases and charts","title":"Manifolds.AbstractAtlas","text":"AbstractAtlas{𝔽}\n\nAn abstract class for atlases whith charts that have values in the vector space 𝔽ⁿ for some value of n. 𝔽 is a number system determined by an AbstractNumbers object.\n\n\n\n\n\n","category":"type"},{"location":"features/atlases.html#Manifolds.InducedBasis","page":"Atlases and charts","title":"Manifolds.InducedBasis","text":"InducedBasis(vs::VectorSpaceType, A::AbstractAtlas, i)\n\nThe basis induced by chart with index i from an AbstractAtlas A of vector space of type vs.\n\nFor the vs a TangentSpace this works as  follows:\n\nLet n denote the dimension of the manifold mathcal M.\n\nLet the parameter a=φ_i(p)  mathbb R^n and j1n. We can look at the jth parameter curve b_j(t) = a + te_j, where e_j denotes the jth unit vector. Using the parametrisation we obtain a curve c_j(t) = φ_i^-1(b_j(t)) which fulfills c(0) = p.\n\nNow taking the derivative(s) with respect to t (and evaluate at t=0), we obtain a tangent vector for each j corresponding to an equivalence class of curves (having the same derivative) as\n\nX_j = c_j = fracmathrmdmathrmdt c_i(t) Bigl_t=0\n\nand the set X_1ldotsX_n is the chart-induced basis of T_pmathcal M.\n\nSee also\n\nVectorSpaceType, AbstractBasis\n\n\n\n\n\n","category":"type"},{"location":"features/atlases.html#Manifolds.RetractionAtlas","page":"Atlases and charts","title":"Manifolds.RetractionAtlas","text":"RetractionAtlas{\n    𝔽,\n    TRetr<:AbstractRetractionMethod,\n    TInvRetr<:AbstractInverseRetractionMethod,\n    TBasis<:AbstractBasis,\n} <: AbstractAtlas{𝔽}\n\nAn atlas indexed by points on a manifold, mathcal M = I and parameters (local coordinates) are given in T_pmathcal M. This means that a chart φ_p = mathrmcordcircmathrmretr_p^-1 is only locally defined (around p), where mathrmcord is the decomposition of the tangent vector into coordinates with respect to the given basis of the tangent space, cf. get_coordinates. The parametrization is given by φ_p^-1=mathrmretr_pcircmathrmvec, where mathrmvec turns the basis coordinates into a tangent vector, cf. get_vector.\n\nIn short: The coordinates with respect to a basis are used together with a retraction as a parametrization.\n\nSee also\n\nAbstractAtlas, AbstractInverseRetractionMethod, AbstractRetractionMethod, AbstractBasis\n\n\n\n\n\n","category":"type"},{"location":"features/atlases.html#Manifolds.get_chart_index-Tuple{AbstractManifold, AbstractAtlas, Any}","page":"Atlases and charts","title":"Manifolds.get_chart_index","text":"get_chart_index(M::AbstractManifold, A::AbstractAtlas, p)\n\nSelect a chart from an AbstractAtlas A for manifold M that is suitable for representing the neighborhood of point p. This selection should be deterministic, although different charts may be selected for arbitrarily close but distinct points.\n\nSee also\n\nget_default_atlas\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.get_default_atlas-Tuple{AbstractManifold}","page":"Atlases and charts","title":"Manifolds.get_default_atlas","text":"get_default_atlas(::AbstractManifold)\n\nDetermine the default real-valued atlas for the given manifold.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.get_parameters-Tuple{AbstractManifold, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.get_parameters","text":"get_parameters(M::AbstractManifold, A::AbstractAtlas, i, p)\n\nCalculate parameters (local coordinates) of point p on manifold M in chart from an AbstractAtlas A at index i. This function is hence an implementation of the chart φ_i(p) iin I. The parameters are in the number system determined by A. If the point pnotin U_i is not in the domain of the chart, this method should throw an error.\n\nSee also\n\nget_point, get_chart_index\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.get_point-Tuple{AbstractManifold, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.get_point","text":"get_point(M::AbstractManifold, A::AbstractAtlas, i, a)\n\nCalculate point at parameters (local coordinates) a on manifold M in chart from an AbstractAtlas A at index i. This function is hence an implementation of the inverse φ_i^-1(a) iin I of a chart, also called a parametrization.\n\nSee also\n\nget_parameters, get_chart_index\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.induced_basis-Tuple{AbstractManifold, AbstractAtlas, Any, VectorSpaceType}","page":"Atlases and charts","title":"Manifolds.induced_basis","text":"induced_basis(M::AbstractManifold, A::AbstractAtlas, i, p, VST::VectorSpaceType)\n\nBasis of vector space of type VST at point p from manifold M induced by chart (A, i).\n\nSee also\n\nVectorSpaceType, AbstractAtlas\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.induced_basis-Union{Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, AbstractAtlas, Any, VectorSpaceType}} where 𝔽","page":"Atlases and charts","title":"Manifolds.induced_basis","text":"induced_basis(::AbstractManifold, A::AbstractAtlas, i, VST::VectorSpaceType)\n\nGet the basis induced by chart with index i from an AbstractAtlas A of vector space of type vs. Returns an object of type InducedBasis.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.local_metric-Tuple{AbstractManifold, Any, InducedBasis}","page":"Atlases and charts","title":"Manifolds.local_metric","text":"local_metric(M::AbstractManifold, p, B::InducedBasis)\n\nCompute the local metric tensor for vectors expressed in terms of coordinates in basis B on manifold M. The point p is not checked.\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.transition_map-Tuple{AbstractManifold, AbstractAtlas, Any, AbstractAtlas, Any, Any}","page":"Atlases and charts","title":"Manifolds.transition_map","text":"transition_map(M::AbstractManifold, A_from::AbstractAtlas, i_from, A_to::AbstractAtlas, i_to, a)\ntransition_map(M::AbstractManifold, A::AbstractAtlas, i_from, i_to, a)\n\nGiven coordinates a in chart (A_from, i_from) of a point on manifold M, returns coordinates of that point in chart (A_to, i_to). If A_from and A_to are equal, A_to can be omitted.\n\nMathematically this function is the transition map or change of charts, but it might even be between two atlases A_textfrom = (U_iφ_i)_iin I and A_textto = (V_jpsi_j)_jin J, and hence I J are their index sets. We have i_textfromin I, i_texttoin J.\n\nThis method then computes\n\nbigl(psi_i_texttocirc φ_i_textfrom^-1bigr)(a)\n\nNote that, similarly to get_parameters, this method should fail the same way if V_i_texttocap U_i_textfrom=emptyset.\n\nSee also\n\nAbstractAtlas, get_parameters, get_point\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Cotangent-space-and-musical-isomorphisms","page":"Atlases and charts","title":"Cotangent space and musical isomorphisms","text":"","category":"section"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Related to atlases, there is also support for the cotangent space and coefficients of cotangent vectors in bases of the cotangent space.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Functions sharp and flat implement musical isomorphisms for arbitrary vector bundles.","category":"page"},{"location":"features/atlases.html","page":"Atlases and charts","title":"Atlases and charts","text":"Modules = [Manifolds,ManifoldsBase]\nPages = [\"cotangent_space.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"features/atlases.html#Manifolds.RieszRepresenterCotangentVector","page":"Atlases and charts","title":"Manifolds.RieszRepresenterCotangentVector","text":"RieszRepresenterCotangentVector(M::AbstractManifold, p, X)\n\nCotangent vector in Riesz representer form on manifold M at point p with Riesz representer X.\n\n\n\n\n\n","category":"type"},{"location":"features/atlases.html#Manifolds.flat-Tuple{AbstractManifold, Any, Any}","page":"Atlases and charts","title":"Manifolds.flat","text":"flat(M::AbstractManifold, p, X)\n\nCompute the flat isomorphism (one of the musical isomorphisms) of tangent vector X from the vector space of type M at point p from the underlying AbstractManifold.\n\nThe function can be used for example to transform vectors from the tangent bundle to vectors from the cotangent bundle   Tmathcal M  T^*mathcal M\n\n\n\n\n\n","category":"method"},{"location":"features/atlases.html#Manifolds.sharp-Tuple{AbstractManifold, Any, Any}","page":"Atlases and charts","title":"Manifolds.sharp","text":"sharp(M::AbstractManifold, p, ξ)\n\nCompute the sharp isomorphism (one of the musical isomorphisms) of vector ξ from the vector space M at point p from the underlying AbstractManifold.\n\nThe function can be used for example to transform vectors from the cotangent bundle to vectors from the tangent bundle   T^*mathcal M  Tmathcal M\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Differentiation","page":"Differentiation","title":"Differentiation","text":"","category":"section"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Documentation for Manifolds.jl's methods and types for finite differences and automatic differentiation.","category":"page"},{"location":"features/differentiation.html#Differentiation-backends","page":"Differentiation","title":"Differentiation backends","text":"","category":"section"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Modules = [Manifolds]\nPages = [\"differentiation/differentiation.jl\"]\nOrder = [:type, :function, :constant]","category":"page"},{"location":"features/differentiation.html#Manifolds.AbstractDiffBackend","page":"Differentiation","title":"Manifolds.AbstractDiffBackend","text":"AbstractDiffBackend\n\nAn abstract type for diff backends. See FiniteDifferencesBackend for an example.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.CurrentDiffBackend","page":"Differentiation","title":"Manifolds.CurrentDiffBackend","text":"CurrentDiffBackend(backend::AbstractDiffBackend)\n\nA mutable struct for storing the current differentiation backend in a global constant _current_default_differential_backend.\n\nSee also\n\nAbstractDiffBackend, default_differential_backend, set_default_differential_backend!\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds._derivative","page":"Differentiation","title":"Manifolds._derivative","text":"_derivative(f, t[, backend::AbstractDiffBackend])\n\nCompute the derivative of a callable f at time t computed using the given backend, an object of type Manifolds.AbstractDiffBackend. If the backend is not explicitly specified, it is obtained using the function default_differential_backend.\n\nThis function calculates plain Euclidean derivatives, for Riemannian differentiation see for example differential.\n\nnote: Note\nNot specifying the backend explicitly will usually result in a type instability and decreased performance.\n\n\n\n\n\n","category":"function"},{"location":"features/differentiation.html#Manifolds._gradient","page":"Differentiation","title":"Manifolds._gradient","text":"_gradient(f, p[, backend::AbstractDiffBackend])\n\nCompute the gradient of a callable f at point p computed using the given backend, an object of type AbstractDiffBackend. If the backend is not explicitly specified, it is obtained using the function default_differential_backend.\n\nThis function calculates plain Euclidean gradients, for Riemannian gradient calculation see for example gradient.\n\nnote: Note\nNot specifying the backend explicitly will usually result in a type instability and decreased performance.\n\n\n\n\n\n","category":"function"},{"location":"features/differentiation.html#Manifolds._hessian","page":"Differentiation","title":"Manifolds._hessian","text":"_hessian(f, p[, backend::AbstractDiffBackend])\n\nCompute the Hessian of a callable f at point p computed using the given backend, an object of type AbstractDiffBackend. If the backend is not explicitly specified, it is obtained using the function default_differential_backend.\n\nThis function calculates plain Euclidean Hessian.\n\nnote: Note\nNot specifying the backend explicitly will usually result in a type instability and decreased performance.\n\n\n\n\n\n","category":"function"},{"location":"features/differentiation.html#Manifolds._jacobian","page":"Differentiation","title":"Manifolds._jacobian","text":"_jacobian(f, p[, backend::AbstractDiffBackend])\n\nCompute the Jacobian of a callable f at point p computed using the given backend, an object of type AbstractDiffBackend. If the backend is not explicitly specified, it is obtained using the function default_differential_backend.\n\nThis function calculates plain Euclidean Jacobians, for Riemannian Jacobian calculation see for example gradient.\n\nnote: Note\nNot specifying the backend explicitly will usually result in a type instability and decreased performance.\n\n\n\n\n\n","category":"function"},{"location":"features/differentiation.html#Manifolds.default_differential_backend-Tuple{}","page":"Differentiation","title":"Manifolds.default_differential_backend","text":"default_differential_backend() -> AbstractDiffBackend\n\nGet the default differentiation backend.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.set_default_differential_backend!-Tuple{Manifolds.AbstractDiffBackend}","page":"Differentiation","title":"Manifolds.set_default_differential_backend!","text":"set_default_differential_backend!(backend::AbstractDiffBackend)\n\nSet current backend for differentiation to backend.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds._current_default_differential_backend","page":"Differentiation","title":"Manifolds._current_default_differential_backend","text":"_current_default_differential_backend\n\nThe instance of Manifolds.CurrentDiffBackend that stores the globally default differentiation backend.\n\n\n\n\n\n","category":"constant"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Further differentiation backends and features are available in ManifoldDiff.jl.","category":"page"},{"location":"features/differentiation.html#FiniteDifferenes.jl","page":"Differentiation","title":"FiniteDifferenes.jl","text":"","category":"section"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Modules = [Manifolds]\nPages = [\"differentiation/finite_differences.jl\"]\nOrder = [:type, :function, :constant]","category":"page"},{"location":"features/differentiation.html#Manifolds.FiniteDifferencesBackend","page":"Differentiation","title":"Manifolds.FiniteDifferencesBackend","text":"FiniteDifferencesBackend(method::FiniteDifferenceMethod = central_fdm(5, 1))\n\nDifferentiation backend based on the FiniteDifferences package.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Riemannian-differentiation-backends","page":"Differentiation","title":"Riemannian differentiation backends","text":"","category":"section"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Modules = [Manifolds]\nPages = [\"differentiation/riemannian_diff.jl\"]\nOrder = [:type, :function, :constant]","category":"page"},{"location":"features/differentiation.html#Manifolds.AbstractRiemannianDiffBackend","page":"Differentiation","title":"Manifolds.AbstractRiemannianDiffBackend","text":"AbstractRiemannianDiffBackend\n\nAn abstract type for backends for differentiation.\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.RiemannianProjectionBackend","page":"Differentiation","title":"Manifolds.RiemannianProjectionBackend","text":"RiemannianProjectionBackend <: AbstractRiemannianDiffBackend\n\nThis backend computes the differentiation in the embedding, which is currently limited to the gradient. Let mathcal M denote a manifold embedded in some R^m, where m is usually (much) larger than the manifold dimension. Then we require three tools\n\nA function f ℝ^m  ℝ such that its restriction to the manifold yields the cost function f of interest.\nA project function to project tangent vectors from the embedding (at T_pℝ^m) back onto the tangent space T_pmathcal M. This also includes possible changes of the representation of the tangent vector (e.g. in the Lie algebra or in a different data format).\nA change_representer for non-isometrically embedded manifolds, i.e. where the tangent space T_pmathcal M of the manifold does not inherit the inner product from restriction of the inner product from the tangent space T_pℝ^m of the embedding\n\nFor more details see [AbsilMahonySepulchre2008], Section 3.6.1 for a derivation on submanifolds.\n\n[AbsilMahonySepulchre2008]: Absil, P.-A., Mahony, R. and Sepulchre R., Optimization Algorithms on Matrix Manifolds Princeton University Press, 2008, doi: 10.1515/9781400830244 open access\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.TangentDiffBackend","page":"Differentiation","title":"Manifolds.TangentDiffBackend","text":"TangentDiffBackend <: AbstractRiemannianDiffBackend\n\nA backend that uses tangent spaces and bases therein to derive an intrinsic differentiation scheme.\n\nSince it works in tangent spaces at argument and function value, methods might require a retraction and an inverse retraction as well as a basis.\n\nIn the tangent space itself, this backend then employs an (Euclidean) AbstractDiffBackend\n\nConstructor\n\nTangentDiffBackend(diff_backend)\n\nwhere diff_backend is an AbstractDiffBackend to be used on the tangent space.\n\nWith the keyword arguments\n\nretraction an AbstractRetractionMethod (ExponentialRetraction by default)\ninverse_retraction an AbstractInverseRetractionMethod LogarithmicInverseRetraction by default)\nbasis_arg an AbstractBasis (DefaultOrthogonalBasis by default)\nbasis_val an AbstractBasis (DefaultOrthogonalBasis by default)\n\n\n\n\n\n","category":"type"},{"location":"features/differentiation.html#Manifolds.differential-Tuple{AbstractManifold, Any, Real, Manifolds.AbstractRiemannianDiffBackend}","page":"Differentiation","title":"Manifolds.differential","text":"differential(M::AbstractManifold, f, t::Real, backend::AbstractDiffBackend)\ndifferential!(M::AbstractManifold, f, X, t::Real, backend::AbstractDiffBackend)\n\nCompute the Riemannian differential of a curve f ℝto M on a manifold M represented by function f at time t using the given backend. It is calculated as the tangent vector equal to mathrmdf_t(t)1.\n\nThe mutating variant computes the differential in place of X.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.gradient-Tuple{AbstractManifold, Any, Any, Manifolds.AbstractRiemannianDiffBackend}","page":"Differentiation","title":"Manifolds.gradient","text":"gradient(M::AbstractManifold, f, p, backend::AbstractRiemannianDiffBackend)\ngradient!(M::AbstractManifold, f, X, p, backend::AbstractRiemannianDiffBackend)\n\nCompute the Riemannian gradient f(p) of a real-valued function fmathcal M to ℝ at point p on the manifold M using the specified AbstractRiemannianDiffBackend.\n\nThe mutating variant computes the gradient in place of X.\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html#Manifolds.gradient-Tuple{AbstractManifold, Any, Any, Manifolds.TangentDiffBackend}","page":"Differentiation","title":"Manifolds.gradient","text":"gradient(M, f, p, backend::TangentDiffBackend)\n\nThis method uses the internal backend.diff_backend (Euclidean) on the function\n\n    f(retr_p(cdot))\n\nwhich is given on the tangent space. In detail, the gradient can be written in terms of the backend.basis_arg. We illustrate it here for an AbstractOrthonormalBasis, since that simplifies notations:\n\noperatornamegradf(p) = operatornamegradf(p) = sum_i=1^d g_p(operatornamegradf(p)X_i)X_i\n\t= sum_i=1^d Df(p)X_iX_i\n\nwhere the last equality is due to the definition of the gradient as the Riesz representer of the differential.\n\nIf the backend is a forward (or backward) finite difference, these coefficients in the sum can be approximates as\n\nDF(p)Y  frac1hbigl( f(exp_p(hY)) - f(p) bigr)\n\nwriting p=exp_p(0) we see that this is a finite difference of fcircexp_p, i.e. for a function on the tangent space, so we can also use other (Euclidean) backends\n\n\n\n\n\n","category":"method"},{"location":"features/differentiation.html","page":"Differentiation","title":"Differentiation","text":"Modules = [Manifolds]\nPages = [\"differentiation/embedded_diff.jl\"]\nOrder = [:type, :function, :constant]","category":"page"},{"location":"features/differentiation.html#Manifolds.ExplicitEmbeddedBackend","page":"Differentiation","title":"Manifolds.ExplicitEmbeddedBackend","text":"ExplicitEmbeddedBackend{TF<:NamedTuple} <: AbstractDiffBackend\n\nA backend to use with the RiemannianProjectionBackend or the TangentDiffBackend, when you have explicit formulae for the gradient in the embedding available.\n\nConstructor\n\nExplicitEmbeddedBackend(M::AbstractManifold; kwargs)\n\nConstruct an ExplicitEmbeddedBackend in the embedding M, where currently the following keywords may be used\n\ngradient for a(n allocating) gradient function gradient(M, p) defined in the embedding\ngradient! for a mutating gradient function gradient!(M, X, p).\n\nNote that the gradient functions are defined on the embedding manifold M passed to the Backend as well\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#HyperbolicSpace","page":"Hyperbolic space","title":"Hyperbolic space","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"The hyperbolic space can be represented in three different models.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Hyperboloid which is the default model, i.e. is used when using arbitrary array types for points and tangent vectors\nPoincaré ball with separate types for points and tangent vectors and a visualization for the two-dimensional case\nPoincaré half space with separate types for points and tangent vectors and a visualization for the two-dimensional cae.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"In the following the common functions are collected.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"A function in this general section uses vectors interpreted as if in the hyperboloid model, and other representations usually just convert to this representation to use these general functions.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Modules = [Manifolds]\nPages = [\"manifolds/Hyperbolic.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/hyperbolic.html#Manifolds.Hyperbolic","page":"Hyperbolic space","title":"Manifolds.Hyperbolic","text":"Hyperbolic{N} <: AbstractDecoratorManifold{ℝ}\n\nThe hyperbolic space mathcal H^n represented by n+1-Tuples, i.e. embedded in the Lorentzian manifold equipped with the MinkowskiMetric cdotcdot_mathrmM. The space is defined as\n\nmathcal H^n = Biglp  ℝ^n+1 Big pp_mathrmM= -p_n+1^2\n  + displaystylesum_k=1^n p_k^2 = -1 p_n+1  0Bigr\n\nThe tangent space T_p mathcal H^n is given by\n\nT_p mathcal H^n = bigl\nX  ℝ^n+1  pX_mathrmM = 0\nbigr\n\nNote that while the MinkowskiMetric renders the Lorentz manifold (only) pseudo-Riemannian, on the tangent bundle of the Hyperbolic space it induces a Riemannian metric. The corresponding sectional curvature is -1.\n\nIf p and X are Vectors of length n+1 they are assumed to be a HyperboloidPoint and a HyperboloidTVector, respectively\n\nOther models are the Poincaré ball model, see PoincareBallPoint and PoincareBallTVector, respectiely and the Poincaré half space model, see PoincareHalfSpacePoint and PoincareHalfSpaceTVector, respectively.\n\nConstructor\n\nHyperbolic(n)\n\nGenerate the Hyperbolic manifold of dimension n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Manifolds.HyperboloidPoint","page":"Hyperbolic space","title":"Manifolds.HyperboloidPoint","text":"HyperboloidPoint <: AbstractManifoldPoint\n\nIn the Hyperboloid model of the Hyperbolic mathcal H^n points are represented as vectors in ℝ^n+1 with MinkowskiMetric equal to -1.\n\nThis representation is the default, i.e. AbstractVectors are assumed to have this repesentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Manifolds.HyperboloidTVector","page":"Hyperbolic space","title":"Manifolds.HyperboloidTVector","text":"HyperboloidTVector <: TVector\n\nIn the Hyperboloid model of the Hyperbolic mathcal H^n tangent vctors are represented as vectors in ℝ^n+1 with MinkowskiMetric pX_mathrmM=0 to their base point p.\n\nThis representation is the default, i.e. vectors are assumed to have this repesentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Manifolds.PoincareBallPoint","page":"Hyperbolic space","title":"Manifolds.PoincareBallPoint","text":"PoincareBallPoint <: AbstractManifoldPoint\n\nA point on the Hyperbolic manifold mathcal H^n can be represented as a vector of norm less than one in mathbb R^n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Manifolds.PoincareBallTVector","page":"Hyperbolic space","title":"Manifolds.PoincareBallTVector","text":"PoincareBallTVector <: TVector\n\nIn the Poincaré ball model of the Hyperbolic mathcal H^n tangent vectors are represented as vectors in ℝ^n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Manifolds.PoincareHalfSpacePoint","page":"Hyperbolic space","title":"Manifolds.PoincareHalfSpacePoint","text":"PoincareHalfSpacePoint <: AbstractManifoldPoint\n\nA point on the Hyperbolic manifold mathcal H^n can be represented as a vector in the half plane, i.e. x  ℝ^n with x_d  0.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Manifolds.PoincareHalfSpaceTVector","page":"Hyperbolic space","title":"Manifolds.PoincareHalfSpaceTVector","text":"PoincareHalfPlaneTVector <: TVector\n\nIn the Poincaré half plane model of the Hyperbolic mathcal H^n tangent vectors are represented as vectors in ℝ^n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Base.exp-Tuple{Hyperbolic, Vararg{Any, N} where N}","page":"Hyperbolic space","title":"Base.exp","text":"exp(M::Hyperbolic, p, X)\n\nCompute the exponential map on the Hyperbolic space mathcal H^n emanating from p towards X. The formula reads\n\nexp_p X = cosh(sqrtXX_mathrmM)p\n+ sinh(sqrtXX_mathrmM)fracXsqrtXX_mathrmM\n\nwhere cdotcdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.log-Tuple{Hyperbolic, Vararg{Any, N} where N}","page":"Hyperbolic space","title":"Base.log","text":"log(M::Hyperbolic, p, q)\n\nCompute the logarithmic map on the Hyperbolic space mathcal H^n, the tangent vector representing the geodesic starting from p reaches q after time 1. The formula reads for p  q\n\nlog_p q = d_mathcal H^n(pq)\nfracq-pq_mathrmM plVert q-pq_mathrmM p rVert_2\n\nwhere cdotcdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold. For p=q the logarihmic map is equal to the zero vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.check_point-Tuple{Hyperbolic, Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_point","text":"check_point(M::Hyperbolic, p; kwargs...)\n\nCheck whether p is a valid point on the Hyperbolic M.\n\nFor the HyperboloidPoint or plain vectors this means that, p is a vector of length n+1 with inner product in the embedding of -1, see MinkowskiMetric. The tolerance for the last test can be set using the kwargs....\n\nFor the PoincareBallPoint a valid point is a vector p  ℝ^n with a norm stricly less than 1.\n\nFor the PoincareHalfSpacePoint a valid point is a vector from p  ℝ^n with a positive last entry, i.e. p_n0\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.check_vector-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_vector","text":"check_vector(M::Hyperbolic{n}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the Hyperbolic M, i.e. after check_point(M,p), X has to be of the same dimension as p. The tolerance for the last test can be set using the kwargs....\n\nFor a the hyperboloid model or vectors, X has to be  orthogonal to p with respect to the inner product from the embedding, see MinkowskiMetric.\n\nFor a the Poincaré ball as well as the Poincaré half plane model, X has to be a vector from ℝ^n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.injectivity_radius-Tuple{Hyperbolic}","page":"Hyperbolic space","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Hyperbolic)\ninjectivity_radius(M::Hyperbolic, p)\n\nReturn the injectivity radius on the Hyperbolic, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.manifold_dimension-Union{Tuple{Hyperbolic{N}}, Tuple{N}} where N","page":"Hyperbolic space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Hyperbolic)\n\nReturn the dimension of the hyperbolic space manifold mathcal H^n, i.e. dim(mathcal H^n) = n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.parallel_transport_to-Tuple{Hyperbolic, Any, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Hyperbolic, p, X, q)\n\nCompute the paralllel transport of the X from the tangent space at p on the Hyperbolic space mathcal H^n to the tangent at q along the geodesic connecting p and q. The formula reads\n\nmathcal P_qpX = X - fraclog_p qX_pd^2_mathcal H^n(pq)\nbigl(log_p q + log_qp bigr)\n\nwhere cdotcdot_p denotes the inner product in the tangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.project-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.project","text":"project(M::Hyperbolic, p, X)\n\nPerform an orthogonal projection with respect to the Minkowski inner product of X onto the tangent space at p of the Hyperbolic space M.\n\nThe formula reads\n\nY = X + pX_mathrmM p\n\nwhere cdot cdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold.\n\nnote: Note\nProjection is only available for the (default) HyperboloidTVector representation, the others don't have such an embedding\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Statistics.mean-Tuple{Hyperbolic, Vararg{Any, N} where N}","page":"Hyperbolic space","title":"Statistics.mean","text":"mean(\n    M::Hyperbolic,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = CyclicProximalPointEstimation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x on the Hyperbolic space using CyclicProximalPointEstimation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#hyperboloid_model","page":"Hyperbolic space","title":"hyperboloid model","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Modules = [Manifolds]\nPrivate = false\nPages = [\"manifolds/HyperbolicHyperboloid.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{HyperboloidPoint}, PoincareBallPoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidPoint}, p::PoincareBallPoint)\nconvert(::Type{AbstractVector}, p::PoincareBallPoint)\n\nconvert a point PoincareBallPoint x (from ℝ^n) from the Poincaré ball model of the Hyperbolic manifold mathcal H^n to a HyperboloidPoint π(p)  ℝ^n+1. The isometry is defined by\n\nπ(p) = frac11-lVert p rVert^2\nbeginpmatrix2p_12p_n1+lVert p rVert^2endpmatrix\n\nNote that this is also used, when the type to convert to is a vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{HyperboloidPoint}, PoincareHalfSpacePoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidPoint}, p::PoincareHalfSpacePoint)\nconvert(::Type{AbstractVector}, p::PoincareHalfSpacePoint)\n\nconvert a point PoincareHalfSpacePoint p (from ℝ^n) from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a HyperboloidPoint π(p)  ℝ^n+1.\n\nThis is done in two steps, namely transforming it to a Poincare ball point and from there further on to a Hyperboloid point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{HyperboloidTVector}, PoincareBallPoint, PoincareBallTVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidTVector}, p::PoincareBallPoint, X::PoincareBallTVector)\nconvert(::Type{AbstractVector}, p::PoincareBallPoint, X::PoincareBallTVector)\n\nConvert the PoincareBallTVector X from the tangent space at p to a HyperboloidTVector by computing the push forward of the isometric map, cf. convert(::Type{HyperboloidPoint}, p::PoincareBallPoint).\n\nThe push forward π_*(p) maps from ℝ^n to a subspace of ℝ^n+1, the formula reads\n\nπ_*(p)X = beginpmatrix\n    frac2X_11-lVert p rVert^2 + frac4(1-lVert p rVert^2)^2Xpp_1\n    \n    frac2X_n1-lVert p rVert^2 + frac4(1-lVert p rVert^2)^2Xpp_n\n    frac4(1-lVert p rVert^2)^2Xp\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{HyperboloidTVector}, PoincareHalfSpacePoint, PoincareHalfSpaceTVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{HyperboloidTVector}, p::PoincareHalfSpacePoint, X::PoincareHalfSpaceTVector)\nconvert(::Type{AbstractVector}, p::PoincareHalfSpacePoint, X::PoincareHalfSpaceTVector)\n\nconvert a point PoincareHalfSpaceTVector X (from ℝ^n) at p from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a HyperboloidTVector π(p)  ℝ^n+1.\n\nThis is done in two steps, namely transforming it to a Poincare ball point and from there further on to a Hyperboloid point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{Tuple{HyperboloidPoint, HyperboloidTVector}}, Tuple{PoincareBallPoint, PoincareBallTVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{HyperboloidPoint,HyperboloidTVector}}.\n    (p,X)::Tuple{PoincareBallPoint,PoincareBallTVector}\n)\nconvert(\n    ::Type{Tuple{P,T}},\n    (p, X)::Tuple{PoincareBallPoint,PoincareBallTVector},\n) where {P<:AbstractVector, T <: AbstractVector}\n\nConvert a PoincareBallPoint p and a PoincareBallTVector X to a HyperboloidPoint and a HyperboloidTVector simultaneously, see convert(::Type{HyperboloidPoint}, ::PoincareBallPoint) and convert(::Type{HyperboloidTVector}, ::PoincareBallPoint, ::PoincareBallTVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{Tuple{HyperboloidPoint, HyperboloidTVector}}, Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{HyperboloidPoint,HyperboloidTVector},\n    (p,X)::Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTVector}\n)\nconvert(\n    ::Type{Tuple{T,T},\n    (p,X)::Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTVector}\n) where {T<:AbstractVector}\n\nconvert a point PoincareHalfSpaceTVector X (from ℝ^n) at p from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a tuple of a HyperboloidPoint and a HyperboloidTVector π(p)  ℝ^n+1 simultaneously.\n\nThis is done in two steps, namely transforming it to the Poincare ball model and from there further on to a Hyperboloid.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Manifolds.change_representer-Tuple{Hyperbolic, EuclideanMetric, Any, Any}","page":"Hyperbolic space","title":"Manifolds.change_representer","text":"change_representer(M::Hyperbolic{n}, ::EuclideanMetric, p, X)\n\nChange the Eucliden representer X of a cotangent vector at point p. We only have to correct for the metric, which means that the sign of the last entry changes, since for the result Y  we are looking for a tangent vector such that\n\n    g_p(YZ) = -y_n+1z_n+1 + sum_i=1^n y_iz_i = sum_i=1^n+1 z_ix_i\n\nholds, which directly yields y_i=x_i for i=1ldotsn and y_n+1=-x_n+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.distance-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(M::Hyperbolic, p, q)\ndistance(M::Hyperbolic, p::HyperboloidPoint, q::HyperboloidPoint)\n\nCompute the distance on the Hyperbolic M, which reads\n\nd_mathcal H^n(pq) = operatornameacosh( - p q_mathrmM)\n\nwhere cdotcdot_mathrmM denotes the MinkowskiMetric on the embedding, the Lorentzian manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.get_coordinates-Tuple{Hyperbolic, Any, Any, DefaultOrthonormalBasis}","page":"Hyperbolic space","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Hyperbolic, p, X, ::DefaultOrthonormalBasis)\n\nCompute the coordinates of the vector X with respect to the orthogonalized version of the unit vectors from ℝ^n, where n is the manifold dimension of the Hyperbolic  M, utting them intop the tangent space at p and orthonormalizing them.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.get_vector-Tuple{Hyperbolic, Any, Any, DefaultOrthonormalBasis}","page":"Hyperbolic space","title":"ManifoldsBase.get_vector","text":"get_vector(M::Hyperbolic, p, c, ::DefaultOrthonormalBasis)\n\nCompute the vector from the coordinates with respect to the orthogonalized version of the unit vectors from ℝ^n, where n is the manifold dimension of the Hyperbolic  M, utting them intop the tangent space at p and orthonormalizing them.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.inner-Tuple{Hyperbolic, Any, Any, Any}","page":"Hyperbolic space","title":"ManifoldsBase.inner","text":"inner(M::Hyperbolic{n}, p, X, Y)\ninner(M::Hyperbolic{n}, p::HyperboloidPoint, X::HyperboloidTVector, Y::HyperboloidTVector)\n\nCmpute the inner product in the Hyperboloid model, i.e. the minkowski_metric in the embedding. The formula reads\n\ng_p(XY) = XY_mathrmM = -X_nY_n + displaystylesum_k=1^n-1 X_kY_k\n\nThis employs the metric of the embedding, see Lorentz space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#hyperboloid_plot","page":"Hyperbolic space","title":"Visualization of the Hyperboloid","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"For the case of Hyperbolic(2) there is plotting available based on a PlottingRecipe. You can easily plot points, connecting geodesics as well as tangent vectors.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"note: Note\nThe recipes are only loaded if Plots.jl or RecipesBase.jl is loaded.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"If we consider a set of points, we can first plot these and their connecting geodesics using the geodesic_interpolation for the points. This variable specifies with how many points a geodesic between two successive points is sampled (per default it's -1, which deactivates geodesics) and the line style is set to be a path.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"In general you can plot the surface of the hyperboloid either as wireframe (wireframe=true) additionally specifying wires (or wires_x and wires_y) to change the density of wires and a wireframe_color. The same holds for the plot as a surface (which is false by default) and its surface_resolution (or surface_resolution_x or surface_resolution_y) and a surface_color.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"using Manifolds, Plots\nM = Hyperbolic(2)\npts =  [ [0.85*cos(φ), 0.85*sin(φ), sqrt(0.85^2+1)] for φ ∈ range(0,2π,length=11) ]\nscene = plot(M, pts; geodesic_interpolation=100)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"To just plot the points atop, we can just omit the geodesic_interpolation parameter to obtain a scatter plot. Note that we avoid redrawing the wireframe in the following plot! calls.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, pts; wireframe=false)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"We can further generate tangent vectors in these spaces and use a plot for there. Keep in mind that a tangent vector in plotting always requires its base point.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"pts2 = [ [0.45 .*cos(φ + 6π/11), 0.45 .*sin(φ + 6π/11), sqrt(0.45^2+1) ] for φ ∈ range(0,2π,length=11)]\nvecs = log.(Ref(M),pts,pts2)\nplot!(scene, M, pts, vecs; wireframe=false)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Just to illustrate, for the first point the tangent vector is pointing along the following geodesic","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, [pts[1], pts2[1]]; geodesic_interpolation=100, wireframe=false)","category":"page"},{"location":"manifolds/hyperbolic.html#Internal-functions","page":"Hyperbolic space","title":"Internal functions","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"The following functions are available for internal use to construct points in the hyperboloid model","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Modules = [Manifolds]\nPublic = false\nPages = [\"manifolds/HyperbolicHyperboloid.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/hyperbolic.html#Manifolds._hyperbolize-Tuple{Hyperbolic, Any, Any}","page":"Hyperbolic space","title":"Manifolds._hyperbolize","text":"_hyperbolize(M, p, Y)\n\nGiven the Hyperbolic(n) manifold using the hyperboloid model and a point p thereon, we can put a vector Yin ℝ^n  into the tangent space by computing its last component such that for the resulting p we have that its minkowski_metric is pX_mathrmM = 0, i.e. X_n+1 = fractilde p Yp_n+1, where tilde p = (p_1ldotsp_n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Manifolds._hyperbolize-Tuple{Hyperbolic, Any}","page":"Hyperbolic space","title":"Manifolds._hyperbolize","text":"_hyperbolize(M,q)\n\nGiven the Hyperbolic(n) manifold using the hyperboloid model, a point from the qin ℝ^n can be set onto the manifold by computing its last component such that for the resulting p we have that its minkowski_metric is pp_mathrmM = - 1, i.e. p_n+1 = sqrtlVert q rVert^2 - 1\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#poincare_ball","page":"Hyperbolic space","title":"Poincaré ball model","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Modules = [Manifolds]\nPages = [\"manifolds/HyperbolicPoincareBall.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareBallPoint}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareBallPoint}, p::HyperboloidPoint)\nconvert(::Type{PoincareBallPoint}, p::T) where {T<:AbstractVector}\n\nconvert a HyperboloidPoint pℝ^n+1 from the hyperboloid model of the Hyperbolic manifold mathcal H^n to a PoincareBallPoint π(p)ℝ^n in the Poincaré ball model. The isometry is defined by\n\nπ(p) = frac11+p_n+1 beginpmatrixp_1p_nendpmatrix\n\nNote that this is also used, when x is a vector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareBallPoint}, PoincareHalfSpacePoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareBallPoint}, p::PoincareHalfSpacePoint)\n\nconvert a point PoincareHalfSpacePoint p (from ℝ^n) from the Poincaré half plane model of the Hyperbolic manifold mathcal H^n to a PoincareBallPoint π(p)  ℝ^n. Denote by tilde p = (p_1ldotsp_d-1)^mathrmT. Then the isometry is defined by\n\nπ(p) = frac1lVert tilde p rVert^2 + (p_n+1)^2\nbeginpmatrix2p_12p_n-1lVert prVert^2 - 1endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareBallTVector}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareBallTVector}, p::HyperboloidPoint, X::HyperboloidTVector)\nconvert(::Type{PoincareBallTVector}, p::P, X::T) where {P<:AbstractVector, T<:AbstractVector}\n\nconvert a HyperboloidTVector X at p to a PoincareBallTVector on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Hyperboloid to the Poincaré ball, cf. convert(::Type{PoincareBallPoint}, ::HyperboloidPoint).\n\nThe formula reads\n\nπ_*(p)X = frac1p_n+1+1Bigl(tilde X - fracX_n+1p_n+1+1tilde p Bigl)\n\nwhere tilde X = beginpmatrixX_1X_nendpmatrix and tilde p = beginpmatrixp_1p_nendpmatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareBallTVector}, PoincareHalfSpacePoint, PoincareHalfSpaceTVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{PoincareBallTVector},\n    p::PoincareHalfSpacePoint,\n    X::PoincareHalfSpaceTVector\n)\n\nconvert a PoincareHalfSpaceTVector X at p to a PoincareBallTVector on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Poincaré half space to the Poincaré ball, cf. convert(::Type{PoincareBallPoint}, ::PoincareHalfSpacePoint).\n\nThe formula reads\n\nπ_*(p)X =\nfrac1lVert tilde prVert^2 + (1+p_n)^2\nbeginpmatrix\n2X_1\n\n2X_n-1\n2Xp\nendpmatrix\n-\nfrac2(lVert tilde prVert^2 + (1+p_n)^2)^2\nbeginpmatrix\n2p_1(Xp+X_n)\n\n2p_n-1(Xp+X_n)\n(lVert p rVert^2-1)(Xp+X_n)\nendpmatrix\n\nwhere tilde p = beginpmatrixp_1p_n-1endpmatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{Tuple{PoincareBallPoint, PoincareBallTVector}}, Tuple{HyperboloidPoint, HyperboloidTVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTVector}},\n    (p,X)::Tuple{HyperboloidPoint,HyperboloidTVector}\n)\nconvert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTVector}},\n    (p, X)::Tuple{P,T},\n) where {P<:AbstractVector, T <: AbstractVector}\n\nConvert a HyperboloidPoint p and a HyperboloidTVector X to a PoincareBallPoint and a PoincareBallTVector simultaneously, see convert(::Type{PoincareBallPoint}, ::HyperboloidPoint) and convert(::Type{PoincareBallTVector}, ::HyperboloidPoint, ::HyperboloidTVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{Tuple{PoincareBallPoint, PoincareBallTVector}}, Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTVector}},\n    (p,X)::Tuple{HyperboloidPoint,HyperboloidTVector}\n)\nconvert(\n    ::Type{Tuple{PoincareBallPoint,PoincareBallTVector}},\n    (p, X)::Tuple{T,T},\n) where {T <: AbstractVector}\n\nConvert a PoincareHalfSpacePoint p and a PoincareHalfSpaceTVector X to a PoincareBallPoint and a PoincareBallTVector simultaneously, see convert(::Type{PoincareBallPoint}, ::PoincareHalfSpacePoint) and convert(::Type{PoincareBallTVector}, ::PoincareHalfSpacePoint, ::PoincareHalfSpaceTVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Manifolds.change_metric-Tuple{Hyperbolic, EuclideanMetric, PoincareBallPoint, PoincareBallTVector}","page":"Hyperbolic space","title":"Manifolds.change_metric","text":"change_metric(M::Hyperbolic{n}, ::EuclideanMetric, p::PoincareBallPoint, X::PoincareBallTVector)\n\nSince in the metric we always have the term α = frac21-sum_i=1^n p_i^2 per element, the correction for the metric reads Z = frac1αX.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Manifolds.change_representer-Tuple{Hyperbolic, EuclideanMetric, PoincareBallPoint, PoincareBallTVector}","page":"Hyperbolic space","title":"Manifolds.change_representer","text":"change_representer(M::Hyperbolic{n}, ::EuclideanMetric, p::PoincareBallPoint, X::PoincareBallTVector)\n\nSince in the metric we have the term α = frac21-sum_i=1^n p_i^2 per element, the correction for the gradient reads Y = frac1α^2X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.distance-Tuple{Hyperbolic, PoincareBallPoint, PoincareBallPoint}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(::Hyperbolic, p::PoincareBallPoint, q::PoincareBallPoint)\n\nCompute the distance on the Hyperbolic manifold mathcal H^n represented in the Poincaré ball model. The formula reads\n\nd_mathcal H^n(pq) =\noperatornameacoshBigl(\n  1 + frac2lVert p - q rVert^2(1-lVert prVert^2)(1-lVert qrVert^2)\nBigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.inner-Tuple{Hyperbolic, PoincareBallPoint, PoincareBallTVector, PoincareBallTVector}","page":"Hyperbolic space","title":"ManifoldsBase.inner","text":"inner(::Hyperbolic, p::PoincareBallPoint, X::PoincareBallTVector, Y::PoincareBallTVector)\n\nCompute the inner producz in the Poincaré ball model. The formula reads\n\ng_p(XY) = frac4(1-lVert p rVert^2)^2  X Y \n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.project-Tuple{Hyperbolic, PoincareBallPoint, PoincareBallTVector}","page":"Hyperbolic space","title":"ManifoldsBase.project","text":"project(::Hyperbolic, ::PoincareBallPoint, ::PoincareBallTVector)\n\nprojction of tangent vectors in the Poincaré ball model is just the identity, since the tangent space consists of all ℝ^n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#poincare_ball_plot","page":"Hyperbolic space","title":"Visualization of the Poincaré ball","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"For the case of Hyperbolic(2) there is a plotting available based on a PlottingRecipe you can easily plot points, connecting geodesics as well as tangent vectors.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"note: Note\nThe recipes are only loaded if Plots.jl or RecipesBase.jl is loaded.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"If we consider a set of points, we can first plot these and their connecting geodesics using the geodesic_interpolation For the points. This variable specifies with how many points a geodesic between two successive points is sampled (per default it's -1, which deactivates geodesics) and the line style is set to be a path. Another keyword argument added is the border of the Poincaré disc, namely circle_points = 720 resolution of the drawn boundary (every hlaf angle) as well as its color, hyperbolic_border_color = RGBA(0.0, 0.0, 0.0, 1.0).","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"using Manifolds, Plots\nM = Hyperbolic(2)\npts = PoincareBallPoint.( [0.85 .* [cos(φ), sin(φ)] for φ ∈ range(0,2π,length=11)])\nscene = plot(M, pts, geodesic_interpolation = 100)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"To just plot the points atop, we can just omit the geodesic_interpolation parameter to obtain a scatter plot","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, pts)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"We can further generate tangent vectors in these spaces and use a plot for there. Keep in mind, that a tangent vector in plotting always requires its base point","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"pts2 = PoincareBallPoint.( [0.45 .* [cos(φ + 6π/11), sin(φ + 6π/11)] for φ ∈ range(0,2π,length=11)])\nvecs = log.(Ref(M),pts,pts2)\nplot!(scene, M, pts,vecs)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Just to illustrate, for the first point the tangent vector is pointing along the following geodesic","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, [pts[1], pts2[1]], geodesic_interpolation=100)","category":"page"},{"location":"manifolds/hyperbolic.html#poincare_halfspace","page":"Hyperbolic space","title":"Poincaré half space model","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"Modules = [Manifolds]\nPages = [\"manifolds/HyperbolicPoincareHalfspace.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareHalfSpacePoint}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpacePoint}, p::Hyperboloid)\nconvert(::Type{PoincareHalfSpacePoint}, p)\n\nconvert a HyperboloidPoint or Vectorp (from ℝ^n+1) from the Hyperboloid model of the Hyperbolic manifold mathcal H^n to a PoincareHalfSpacePoint π(x)  ℝ^n.\n\nThis is done in two steps, namely transforming it to a Poincare ball point and from there further on to a PoincareHalfSpacePoint point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareHalfSpacePoint}, PoincareBallPoint}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpacePoint}, p::PoincareBallPoint)\n\nconvert a point PoincareBallPoint p (from ℝ^n) from the Poincaré ball model of the Hyperbolic manifold mathcal H^n to a PoincareHalfSpacePoint π(p)  ℝ^n. Denote by tilde p = (p_1ldotsp_n-1). Then the isometry is defined by\n\nπ(p) = frac1lVert tilde p rVert^2 - (p_n-1)^2\nbeginpmatrix2p_12p_n-11-lVert prVert^2endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareHalfSpaceTVector}, Any}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpaceTVector}, p::HyperboloidPoint, ::HyperboloidTVector)\nconvert(::Type{PoincareHalfSpaceTVector}, p::P, X::T) where {P<:AbstractVector, T<:AbstractVector}\n\nconvert a HyperboloidTVector X at p to a PoincareHalfSpaceTVector on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Hyperboloid to the Poincaré half space, cf. convert(::Type{PoincareHalfSpacePoint}, ::HyperboloidPoint).\n\nThis is done similarly to the approach there, i.e. by using the Poincaré ball model as an intermediate step.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{PoincareHalfSpaceTVector}, PoincareBallPoint, PoincareBallTVector}","page":"Hyperbolic space","title":"Base.convert","text":"convert(::Type{PoincareHalfSpaceTVector}, p::PoincareBallPoint, X::PoincareBallTVector)\n\nconvert a PoincareBallTVector X at p to a PoincareHalfSpacePoint on the Hyperbolic manifold mathcal H^n by computing the push forward π_*(p)X of the isometry π that maps from the Poincaré ball to the Poincaré half space, cf. convert(::Type{PoincareHalfSpacePoint}, ::PoincareBallPoint).\n\nThe formula reads\n\nπ_*(p)X =\nfrac1lVert tilde prVert^2 + (1-p_n)^2\nbeginpmatrix\n2X_1\n\n2X_n-1\n-2Xp\nendpmatrix\n-\nfrac2(lVert tilde prVert^2 + (1-p_n)^2)^2\nbeginpmatrix\n2p_1(Xp-X_n)\n\n2p_n-1(Xp-X_n)\n(lVert p rVert^2-1)(Xp-X_n)\nendpmatrix\n\nwhere tilde p = beginpmatrixp_1p_n-1endpmatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTVector}}, Tuple{HyperboloidPoint, HyperboloidTVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareHalfSpacePoint,PoincareHalfSpaceTVector}},\n    (p,X)::Tuple{HyperboloidPoint,HyperboloidTVector}\n)\nconvert(\n    ::Type{Tuple{PoincareHalfSpacePoint,PoincareHalfSpaceTVector}},\n    (p, X)::Tuple{P,T},\n) where {P<:AbstractVector, T <: AbstractVector}\n\nConvert a HyperboloidPoint p and a HyperboloidTVector X to a PoincareHalfSpacePoint and a PoincareHalfSpaceTVector simultaneously, see convert(::Type{PoincareHalfSpacePoint}, ::HyperboloidPoint) and convert(::Type{PoincareHalfSpaceTVector}, ::Tuple{HyperboloidPoint,HyperboloidTVector}) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.convert-Tuple{Type{Tuple{PoincareHalfSpacePoint, PoincareHalfSpaceTVector}}, Tuple{PoincareBallPoint, PoincareBallTVector}}","page":"Hyperbolic space","title":"Base.convert","text":"convert(\n    ::Type{Tuple{PoincareHalfSpacePoint,PoincareHalfSpaceTVector}},\n    (p,X)::Tuple{PoincareBallPoint,PoincareBallTVector}\n)\n\nConvert a PoincareBallPoint p and a PoincareBallTVector X to a PoincareHalfSpacePoint and a PoincareHalfSpaceTVector simultaneously, see convert(::Type{PoincareHalfSpacePoint}, ::PoincareBallPoint) and convert(::Type{PoincareHalfSpaceTVector}, ::PoincareBallPoint,::PoincareBallTVector) for the formulae.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.distance-Tuple{Hyperbolic, PoincareHalfSpacePoint, PoincareHalfSpacePoint}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(::Hyperbolic, p::PoincareHalfSpacePoint, q::PoincareHalfSpacePoint)\n\nCompute the distance on the Hyperbolic manifold mathcal H^n represented in the Poincaré half space model. The formula reads\n\nd_mathcal H^n(pq) = operatornameacoshBigl( 1 + fraclVert p - q rVert^22 p_n q_n Bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.inner-Tuple{Hyperbolic, PoincareHalfSpacePoint, PoincareHalfSpaceTVector, PoincareHalfSpaceTVector}","page":"Hyperbolic space","title":"ManifoldsBase.inner","text":"inner(\n    ::Hyperbolic{n},\n    p::PoincareHalfSpacePoint,\n    X::PoincareHalfSpaceTVector,\n    Y::PoincareHalfSpaceTVector\n)\n\nCompute the inner product in the Poincaré half space model. The formula reads\n\ng_p(XY) = fracXYp_n^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.project-Tuple{Hyperbolic, PoincareHalfSpaceTVector}","page":"Hyperbolic space","title":"ManifoldsBase.project","text":"project(::Hyperbolic, ::PoincareHalfSpacePoint ::PoincareHalfSpaceTVector)\n\nprojction of tangent vectors in the Poincaré half space model is just the identity, since the tangent space consists of all ℝ^n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#poincare_half_plane_plot","page":"Hyperbolic space","title":"Visualization on the Poincaré half plane","text":"","category":"section"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"For the case of Hyperbolic(2) there is a plotting available based on a PlottingRecipe you can easily plot points, connecting geodesics as well as tangent vectors.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"note: Note\nThe recipes are only loaded if Plots.jl or RecipesBase.jl is loaded.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"We again have two different recipes, one for points, one for tangent vectors, where the first one again can be equipped with geodesics between the points. In the following example we generate 7 points on an ellipse in the Hyperboloid model.","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"using Manifolds, Plots\nM = Hyperbolic(2)\npre_pts = [2.0 .* [5.0*cos(φ), sin(φ)] for φ ∈ range(0,2π,length=7)]\npts = convert.(\n    Ref(PoincareHalfSpacePoint),\n    Manifolds._hyperbolize.(Ref(M), pre_pts)\n)\nscene = plot(M, pts, geodesic_interpolation = 100)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"To just plot the points atop, we can just omit the geodesic_interpolation parameter to obtain a scatter plot","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, pts)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"We can further generate tangent vectors in these spaces and use a plot for there. Keep in mind, that a tangent vector in plotting always requires its base point. Here we would like to look at the tangent vectors pointing to the origin","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"origin = PoincareHalfSpacePoint([0.0,1.0])\nvecs = [log(M,p,origin) for p ∈ pts]\nscene = plot!(scene, M, pts, vecs)","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"And we can again look at the corresponding geodesics, for example","category":"page"},{"location":"manifolds/hyperbolic.html","page":"Hyperbolic space","title":"Hyperbolic space","text":"plot!(scene, M, [pts[1], origin], geodesic_interpolation=100)\nplot!(scene, M, [pts[2], origin], geodesic_interpolation=100)","category":"page"},{"location":"manifolds/projectivespace.html#Projective-space","page":"Projective space","title":"Projective space","text":"","category":"section"},{"location":"manifolds/projectivespace.html","page":"Projective space","title":"Projective space","text":"Modules = [Manifolds]\nPages = [\"manifolds/ProjectiveSpace.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/projectivespace.html#Manifolds.AbstractProjectiveSpace","page":"Projective space","title":"Manifolds.AbstractProjectiveSpace","text":"AbstractProjectiveSpace{𝔽} <: AbstractDecoratorManifold{𝔽}\n\nAn abstract type to represent a projective space over 𝔽 that is represented isometrically in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/projectivespace.html#Manifolds.ArrayProjectiveSpace","page":"Projective space","title":"Manifolds.ArrayProjectiveSpace","text":"ArrayProjectiveSpace{T<:Tuple,𝔽} <: AbstractProjectiveSpace{𝔽}\n\nThe projective space 𝔽ℙ^n₁n₂nᵢ is the manifold of all lines in 𝔽^n₁n₂nᵢ. The default representation is in the embedding, i.e. as unit (Frobenius) norm matrices in 𝔽^n₁n₂nᵢ:\n\n𝔽ℙ^n_1 n_2  n_i = bigl p  𝔽^n_1 n_2  n_i  big lVert p rVert_mathrmF = 1 λ  𝔽 λ = 1 p  p λ bigr\n\nwhere p is an equivalence class of points p, sim indicates equivalence, and lVert  rVert_mathrmF is the Frobenius norm. Note that unlike ProjectiveSpace, the argument for ArrayProjectiveSpace is given by the size of the embedding. This means that ProjectiveSpace(2) and ArrayProjectiveSpace(3) are the same manifold. Additionally, ArrayProjectiveSpace(n,1;field=𝔽) and Grassmann(n,1;field=𝔽) are the same.\n\nThe tangent space at point p is given by\n\nT_p 𝔽ℙ^n_1 n_2  n_i = bigl X  𝔽^n_1 n_2  n_i  pX_mathrmF = 0 bigr \n\nwhere _mathrmF denotes the (Frobenius) inner product in the embedding 𝔽^n_1 n_2  n_i.\n\nConstructor\n\nArrayProjectiveSpace(n₁,n₂,...,nᵢ; field=ℝ)\n\nGenerate the projective space 𝔽ℙ^n_1 n_2  n_i, defaulting to the real projective space, where field can also be used to generate the complex- and right-quaternionic projective spaces.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/projectivespace.html#Manifolds.ProjectiveSpace","page":"Projective space","title":"Manifolds.ProjectiveSpace","text":"ProjectiveSpace{n,𝔽} <: AbstractProjectiveSpace{𝔽}\n\nThe projective space 𝔽ℙ^n is the manifold of all lines in 𝔽^n+1. The default representation is in the embedding, i.e. as unit norm vectors in 𝔽^n+1:\n\n𝔽ℙ^n = bigl p  𝔽^n+1  big lVert p rVert = 1 λ  𝔽 λ = 1 p  p λ bigr\n\nwhere p is an equivalence class of points p, and  indicates equivalence. For example, the real projective space ℝℙ^n is represented as the unit sphere 𝕊^n, where antipodal points are considered equivalent.\n\nThe tangent space at point p is given by\n\nT_p 𝔽ℙ^n = bigl X  𝔽^n+1 big pX = 0 bigr \n\nwhere  denotes the inner product in the embedding 𝔽^n+1.\n\nWhen 𝔽 = ℍ, this implementation of ℍℙ^n is the right-quaternionic projective space.\n\nConstructor\n\nProjectiveSpace(n[, field=ℝ])\n\nGenerate the projective space 𝔽ℙ^n  𝔽^n+1, defaulting to the real projective space ℝℙ^n, where field can also be used to generate the complex- and right-quaternionic projective spaces.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/projectivespace.html#Base.isapprox-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"Base.isapprox","text":"isapprox(M::AbstractProjectiveSpace, p, q; kwargs...)\n\nCheck that points p and q on the AbstractProjectiveSpace M=𝔽ℙ^n are members of the same equivalence class, i.e. that p = q λ for some element λ  𝔽 with unit absolute value, that is, λ = 1. This is equivalent to the Riemannian distance being 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#Base.log-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"Base.log","text":"log(M::AbstractProjectiveSpace, p, q)\n\nCompute the logarithmic map on AbstractProjectiveSpace M$ = 𝔽ℙ^n$, i.e. the tangent vector whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = (q λ - cos θ p) fracθsin θ\n\nwhere θ = arccosq p_mathrmF is the distance between p and q,  _mathrmF is the Frobenius inner product, and λ = fracq p_mathrmFq p_mathrmF  𝔽 is the unit scalar that minimizes d_𝔽^n+1(p - q λ). That is, q λ is the member of the equivalence class q that is closest to p in the embedding. As a result, exp_p circ log_p colon q  q λ.\n\nThe logarithmic maps for the real AbstractSphere 𝕊^n and the real projective space ℝℙ^n are identical when p and q are in the same hemisphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#Manifolds.uniform_distribution-Union{Tuple{n}, Tuple{ProjectiveSpace{n, ℝ}, Any}} where n","page":"Projective space","title":"Manifolds.uniform_distribution","text":"uniform_distribution(M::ProjectiveSpace{n,ℝ}, p) where {n}\n\nUniform distribution on given ProjectiveSpace M. Generated points will be of similar type as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.check_point-Tuple{AbstractProjectiveSpace, Any}","page":"Projective space","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractProjectiveSpace, p; kwargs...)\n\nCheck whether p is a valid point on the AbstractProjectiveSpace M, i.e. that it has the same size as elements of the embedding and has unit Frobenius norm. The tolerance for the norm check can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.check_vector-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractProjectiveSpace, p, X; kwargs... )\n\nCheck whether X is a tangent vector in the tangent space of p on the AbstractProjectiveSpace M, i.e. that X has the same size as elements of the tangent space of the embedding and that the Frobenius inner product p X_mathrmF = 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.distance-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"ManifoldsBase.distance","text":"distance(M::AbstractProjectiveSpace, p, q)\n\nCompute the Riemannian distance on AbstractProjectiveSpace M=𝔽ℙ^n between points p and q, i.e.\n\nd_𝔽ℙ^n(p q) = arccosbigl p q_mathrmF bigr\n\nNote that this definition is similar to that of the AbstractSphere. However, the absolute value ensures that all equivalent p and q have the same pairwise distance.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.get_coordinates-Tuple{AbstractProjectiveSpace{ℝ}, Any, Any, DefaultOrthonormalBasis}","page":"Projective space","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractProjectiveSpace, p, X, B::DefaultOrthonormalBasis{ℝ})\n\nRepresent the tangent vector X at point p from the AbstractProjectiveSpace M = 𝔽ℙ^n in an orthonormal basis by unitarily transforming the hyperplane containing X, whose normal is p, to the hyperplane whose normal is the x-axis.\n\nGiven q = p overlineλ + x, where λ = fracx p_mathrmFx p_mathrmF,  _mathrmF denotes the Frobenius inner product, and overline denotes complex or quaternionic conjugation, the formula for Y is\n\nbeginpmatrix0  Yendpmatrix = left(X - qfrac2 q X_mathrmFq q_mathrmFright)overlineλ\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.get_vector-Tuple{AbstractProjectiveSpace, Any, Any, DefaultOrthonormalBasis{ℝ, VST} where VST<:VectorSpaceType}","page":"Projective space","title":"ManifoldsBase.get_vector","text":"get_vector(M::AbstractProjectiveSpace, p, X, B::DefaultOrthonormalBasis{ℝ})\n\nConvert a one-dimensional vector of coefficients X in the basis B of the tangent space at p on the AbstractProjectiveSpace M=𝔽ℙ^n to a tangent vector Y at p by unitarily transforming the hyperplane containing X, whose normal is the x-axis, to the hyperplane whose normal is p.\n\nGiven q = p overlineλ + x, where λ = fracx p_mathrmFx p_mathrmF,  _mathrmF denotes the Frobenius inner product, and overline denotes complex or quaternionic conjugation, the formula for Y is\n\nY = left(X - qfrac2 leftlangle q beginpmatrix0  Xendpmatrixrightrangle_mathrmFq q_mathrmFright) λ\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.inverse_retract-Tuple{AbstractProjectiveSpace, Any, Any, Union{PolarInverseRetraction, ProjectionInverseRetraction, QRInverseRetraction}}","page":"Projective space","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractProjectiveSpace, p, q, method::ProjectionInverseRetraction)\ninverse_retract(M::AbstractProjectiveSpace, p, q, method::PolarInverseRetraction)\ninverse_retract(M::AbstractProjectiveSpace, p, q, method::QRInverseRetraction)\n\nCompute the equivalent inverse retraction ProjectionInverseRetraction, PolarInverseRetraction, and QRInverseRetraction on the AbstractProjectiveSpace manifold M=𝔽ℙ^n, i.e.\n\noperatornameretr_p^-1 q = q frac1p q_mathrmF - p\n\nwhere  _mathrmF is the Frobenius inner product.\n\nNote that this inverse retraction is equivalent to the three corresponding inverse retractions on Grassmann(n+1,1,𝔽), where the three inverse retractions in this case coincide. For ℝℙ^n, it is the same as the ProjectionInverseRetraction on the real Sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.manifold_dimension-Union{Tuple{AbstractProjectiveSpace{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Projective space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractProjectiveSpace{𝔽}) where {𝔽}\n\nReturn the real dimension of the AbstractProjectiveSpace M, respectively i.e. the real dimension of the embedding minus the real dimension of the field 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.parallel_transport_direction-Tuple{AbstractProjectiveSpace, Any, Any, Any}","page":"Projective space","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::AbstractProjectiveSpace, p, X, d)\n\nParallel transport a vector X from the tangent space at a point p on the AbstractProjectiveSpace M along the geodesic in the direction indicated by the tangent vector d, i.e.\n\nmathcalP_exp_p (d)  p(X) = X - left(p fracsin θθ + d frac1 - cos θθ^2right) d X_p\n\nwhere θ = lVert d rVert, and  _p is the inner product at the point p. For the real projective space, this is equivalent to the same vector transport on the real AbstractSphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.parallel_transport_to-Tuple{AbstractProjectiveSpace, Any, Any, Any}","page":"Projective space","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::AbstractProjectiveSpace, p, X, q)\n\nParallel transport a vector X from the tangent space at a point p on the AbstractProjectiveSpace M=𝔽ℙ^n to the tangent space at another point q.\n\nThis implementation proceeds by transporting X to T_q λ M using the same approach as parallel_transport_direction, where λ = fracq p_mathrmFq p_mathrmF  𝔽 is the unit scalar that takes q to the member q λ of its equivalence class q closest to p in the embedding. It then maps the transported vector from T_q λ M to T_q M. The resulting transport to T_q M is\n\nmathcalP_q  p(X) = left(X - left(p fracsin θθ + d frac1 - cos θθ^2right) d X_pright) overlineλ\n\nwhere d = log_p q is the direction of the transport, θ = lVert d rVert_p is the distance between p and q, and overline denotes complex or quaternionic conjugation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.project-Tuple{AbstractProjectiveSpace, Any, Any}","page":"Projective space","title":"ManifoldsBase.project","text":"project(M::AbstractProjectiveSpace, p, X)\n\nOrthogonally project the point X onto the tangent space at p on the AbstractProjectiveSpace M:\n\noperatornameproj_p (X) = X - pp X_mathrmF\n\nwhere  _mathrmF denotes the Frobenius inner product. For the real AbstractSphere and AbstractProjectiveSpace, this projection is the same.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.project-Tuple{AbstractProjectiveSpace, Any}","page":"Projective space","title":"ManifoldsBase.project","text":"project(M::AbstractProjectiveSpace, p)\n\nOrthogonally project the point p from the embedding onto the AbstractProjectiveSpace M:\n\noperatornameproj(p) = fracplVert p rVert_mathrmF\n\nwhere lVert  rVert_mathrmF denotes the Frobenius norm. This is identical to projection onto the AbstractSphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.representation_size-Union{Tuple{ArrayProjectiveSpace{N, 𝔽} where 𝔽}, Tuple{N}} where N","page":"Projective space","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractProjectiveSpace)\n\nReturn the size points on the AbstractProjectiveSpace M are represented as, i.e., the representation size of the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#ManifoldsBase.retract-Tuple{AbstractProjectiveSpace, Any, Any, Union{PolarRetraction, ProjectionRetraction, QRRetraction}}","page":"Projective space","title":"ManifoldsBase.retract","text":"retract(M::AbstractProjectiveSpace, p, X, method::ProjectionRetraction)\nretract(M::AbstractProjectiveSpace, p, X, method::PolarRetraction)\nretract(M::AbstractProjectiveSpace, p, X, method::QRRetraction)\n\nCompute the equivalent retraction ProjectionRetraction, PolarRetraction, and QRRetraction on the AbstractProjectiveSpace manifold M=𝔽ℙ^n, i.e.\n\noperatornameretr_p X = operatornameproj_p(p + X)\n\nNote that this retraction is equivalent to the three corresponding retractions on Grassmann(n+1,1,𝔽), where in this case they coincide. For ℝℙ^n, it is the same as the ProjectionRetraction on the real Sphere.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/projectivespace.html#Statistics.mean-Tuple{AbstractProjectiveSpace, Vararg{Any, N} where N}","page":"Projective space","title":"Statistics.mean","text":"mean(\n    M::AbstractProjectiveSpace,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of points in vector x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Vector-bundles","page":"Vector bundle","title":"Vector bundles","text":"","category":"section"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Vector bundle E is a manifold that is built on top of another manifold mathcal M (base space). It is characterized by a continuous function Π  E  mathcal M, such that for each point p  mathcal M the preimage of p by Π, Π^-1(p), has a structure of a vector space. These vector spaces are called fibers. Bundle projection can be performed using function bundle_projection.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Tangent bundle is a simple example of a vector bundle, where each fiber is the tangent space at the specified point x. An object representing a tangent bundle can be obtained using the constructor called TangentBundle.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Fibers of a vector bundle are represented by the type VectorBundleFibers. The important difference between functions operating on VectorBundle and VectorBundleFibers is that in the first case both a point on the underlying manifold and the vector are represented together (by a single argument) while in the second case only the vector part is present, while the point is supplied in a different argument where needed.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"VectorBundleFibers refers to the whole set of fibers of a vector bundle. There is also another type, VectorSpaceAtPoint, that represents a specific fiber at a given point. This distinction is made to reduce the need to repeatedly construct objects of type VectorSpaceAtPoint in certain usage scenarios. This is also considered a manifold.","category":"page"},{"location":"manifolds/vector_bundle.html#FVector","page":"Vector bundle","title":"FVector","text":"","category":"section"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"For cases where confusion between different types of vectors is possible, the type FVector can be used to express which type of vector space the vector belongs to. It is used for example in musical isomorphisms (the flat and sharp functions) that are used to go from a tangent space to cotangent space and vice versa.","category":"page"},{"location":"manifolds/vector_bundle.html#Example","page":"Vector bundle","title":"Example","text":"","category":"section"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"The following code defines two points on a tangent bundle of the sphere S^2 and calculates distance between them, distance between their base points and norm of one of these tangent vectors.","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"using Manifolds\nM = Sphere(2)\nTB = TangentBundle(M)\np = ProductRepr([1.0, 0.0, 0.0], [0.0, 1.0, 3.0])\nq = ProductRepr([0.0, 1.0, 0.0], [2.0, 0.0, -1.0])\nprintln(\"Distance between p and q: \", distance(TB, p, q))\nprintln(\"Distance between base points of p and q: \", distance(M, p[TB, :point], q[TB, :point]))\nprintln(\"Norm of p: \", norm(M, p[TB, :point], p[TB, :vector]))","category":"page"},{"location":"manifolds/vector_bundle.html","page":"Vector bundle","title":"Vector bundle","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/VectorBundle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/vector_bundle.html#Manifolds.CotangentSpaceAtPoint-Tuple{AbstractManifold, Any}","page":"Vector bundle","title":"Manifolds.CotangentSpaceAtPoint","text":"CotangentSpaceAtPoint(M::AbstractManifold, p)\n\nReturn an object of type VectorSpaceAtPoint representing cotangent space at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TangentSpaceAtPoint-Tuple{AbstractManifold, Any}","page":"Vector bundle","title":"Manifolds.TangentSpaceAtPoint","text":"TangentSpaceAtPoint(M::AbstractManifold, p)\n\nReturn an object of type VectorSpaceAtPoint representing tangent space at p on the AbstractManifold  M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TensorProductType","page":"Vector bundle","title":"Manifolds.TensorProductType","text":"TensorProductType(spaces::VectorSpaceType...)\n\nVector space type corresponding to the tensor product of given vector space types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundle","page":"Vector bundle","title":"Manifolds.VectorBundle","text":"VectorBundle{𝔽,TVS<:VectorSpaceType,TM<:AbstractManifold{𝔽}} <: AbstractManifold{𝔽}\n\nVector bundle on a AbstractManifold  M of type VectorSpaceType.\n\nConstructor\n\nVectorBundle(M::AbstractManifold, type::VectorSpaceType)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundleFibers","page":"Vector bundle","title":"Manifolds.VectorBundleFibers","text":"VectorBundleFibers(fiber::VectorSpaceType, M::AbstractManifold)\n\nType representing a family of vector spaces (fibers) of a vector bundle over M with vector spaces of type fiber. In contrast with VectorBundle, operations on VectorBundleFibers expect point-like and vector-like parts to be passed separately instead of being bundled together. It can be thought of as a representation of vector spaces from a vector bundle but without storing the point at which a vector space is attached (which is specified separately in various functions).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundleVectorTransport","page":"Vector bundle","title":"Manifolds.VectorBundleVectorTransport","text":"VectorBundleVectorTransport(\n    method_point::AbstractVectorTransportMethod,\n    method_vector::AbstractVectorTransportMethod,\n)\n\nVector transport type on VectorBundle. method_point is used for vector transport of the point part and method_vector is used for transport of the vector part\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceAtPoint","page":"Vector bundle","title":"Manifolds.VectorSpaceAtPoint","text":"VectorSpaceAtPoint{\n    𝔽,\n    TFiber<:VectorBundleFibers{<:VectorSpaceType,<:AbstractManifold{𝔽}},\n    TX,\n} <: AbstractManifold{𝔽}\n\nA vector space at a point p on the manifold. This is modelled using VectorBundleFibers with only a vector-like part and fixing the point-like part to be just p.\n\nThis vector space itself is also a manifold. Especially, it's flat and hence isometric to the Euclidean manifold.\n\nConstructor\n\nVectorSpaceAtPoint(fiber::VectorBundleFibers, p)\n\nA vector space (fiber type fiber of a vector bundle) at point p from the manifold fiber.manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Base.exp-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}, Any, Any}","page":"Vector bundle","title":"Base.exp","text":"exp(M::TangentSpaceAtPoint, p, X)\n\nExponential map of tangent vectors X and p from the tangent space M. It is calculated as their sum.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.exp-Tuple{VectorBundle, Any, Any}","page":"Vector bundle","title":"Base.exp","text":"exp(B::VectorBundle, p, X)\n\nExponential map of tangent vector X at point p from vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe tangent vector X = (V_XM V_XF)  T_pB where V_XM is a tangent vector from the tangent space T_x_pmathcal M and V_XF is a tangent vector from the tangent space T_V_pF (isomorphic to F).\n\nThe exponential map is calculated as\n\nexp_p(X) = (exp_x_p(V_XM) V_exp)\n\nwhere V_exp is the result of vector transport of V_p + V_XF to the point exp_x_p(V_XM). The sum V_p + V_XF corresponds to the exponential map in the vector space F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.getindex-Tuple{ProductRepr, VectorBundle, Symbol}","page":"Vector bundle","title":"Base.getindex","text":"getindex(p::ProductRepr, M::VectorBundle, s::Symbol)\np[M::VectorBundle, s]\n\nAccess the element(s) at index s of a point p on a VectorBundle M by using the symbols :point and :vector for the base and vector component, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.getindex-Tuple{RecursiveArrayTools.ArrayPartition, VectorBundle, Symbol}","page":"Vector bundle","title":"Base.getindex","text":"getindex(p::ArrayPartition, M::VectorBundle, s::Symbol)\np[M::VectorBundle, s]\n\nAccess the element(s) at index s of a point p on a VectorBundle M by using the symbols :point and :vector for the base and vector component, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.log-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}, Vararg{Any, N} where N}","page":"Vector bundle","title":"Base.log","text":"log(M::TangentSpaceAtPoint, p, q)\n\nLogarithmic map on the tangent space manifold M, calculated as the difference of tangent vectors q and p from M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.log-Tuple{VectorBundle, Vararg{Any, N} where N}","page":"Vector bundle","title":"Base.log","text":"log(B::VectorBundle, p, q)\n\nLogarithmic map of the point y at point p from vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B. Similarly, q = (x_q V_q).\n\nThe logarithmic map is calculated as\n\nlog_p q = (log_x_p(x_q) V_log - V_p)\n\nwhere V_log is the result of vector transport of V_q to the point x_p. The difference V_log - V_p corresponds to the logarithmic map in the vector space F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.setindex!-Tuple{ProductRepr, Any, VectorBundle, Symbol}","page":"Vector bundle","title":"Base.setindex!","text":"setindex!(p::ProductRepr, val, M::VectorBundle, s::Symbol)\np[M::VectorBundle, s] = val\n\nSet the element(s) at index s of a point p on a VectorBundle M to val by using the symbols :point and :vector for the base and vector component, respectively.\n\nnote: Note\nThe content of element of p is replaced, not the element itself.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.setindex!-Tuple{RecursiveArrayTools.ArrayPartition, Any, VectorBundle, Symbol}","page":"Vector bundle","title":"Base.setindex!","text":"setindex!(p::ArrayPartition, val, M::VectorBundle, s::Symbol)\np[M::VectorBundle, s] = val\n\nSet the element(s) at index s of a point p on a VectorBundle M to val by using the symbols :point and :vector for the base and vector component, respectively.\n\nnote: Note\nThe content of element of p is replaced, not the element itself.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#LinearAlgebra.norm-Tuple{VectorBundleFibers, Any, Any}","page":"Vector bundle","title":"LinearAlgebra.norm","text":"norm(B::VectorBundleFibers, p, q)\n\nNorm of the vector X from the vector space of type B.fiber at point p from manifold B.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.bundle_projection-Tuple{VectorBundle, Any}","page":"Vector bundle","title":"Manifolds.bundle_projection","text":"bundle_projection(B::VectorBundle, x::ProductRepr)\n\nProjection of point p from the bundle M to the base manifold. Returns the point on the base manifold B.manifold at which the vector part of p is attached.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.vector_bundle_transport-Tuple{VectorSpaceType, AbstractManifold}","page":"Vector bundle","title":"Manifolds.vector_bundle_transport","text":"vector_bundle_transport(fiber::VectorSpaceType, M::AbstractManifold)\n\nDetermine the vector tranport used for exp and log maps on a vector bundle with vector space type fiber and manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.allocate_result-Union{Tuple{TF}, Tuple{VectorBundleFibers, TF, Vararg{Any, N} where N}} where TF","page":"Vector bundle","title":"ManifoldsBase.allocate_result","text":"allocate_result(B::VectorBundleFibers, f, x...)\n\nAllocates an array for the result of function f that is an element of the vector space of type B.fiber on manifold B.manifold and arguments x... for implementing the non-modifying operation using the modifying operation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{TF}, Tuple{VectorBundleFibers, TF, Tuple{Vararg{Any, N}}}} where {TF, N}","page":"Vector bundle","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(B::VectorBundleFibers, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f for representing an operation with result in the vector space fiber for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(M::TangentSpaceAtPoint, p, q)\n\nDistance between vectors p and q from the vector space M. It is calculated as the norm of their difference.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundle, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundle, p, q)\n\nDistance between points x and y from the vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p   mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B. Similarly, q = (x_q V_q).\n\nThe distance is calculated as\n\nd_B(x y) = sqrtd_M(x_p x_q)^2 + d_F(V_p V_qp)^2\n\nwhere d_mathcal M is the distance on manifold mathcal M, d_F is the distance between two vectors from the fiber F and V_qp is the result of parallel transport of vector V_q to point x_p. The default behavior of vector_transport_to is used to compute the vector transport.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundleFibers, Any, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundleFibers, p, X, Y)\n\nDistance between vectors X and Y from the vector space at point p from the manifold B.manifold, that is the base manifold of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.injectivity_radius-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}}","page":"Vector bundle","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::TangentSpaceAtPoint)\n\nReturn the injectivity radius on the TangentSpaceAtPoint M, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}, Any, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(M::TangentSpaceAtPoint, p, X, Y)\n\nInner product of vectors X and Y from the tangent space at M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundle, Any, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundle, p, X, Y)\n\nInner product of tangent vectors X and Y at point p from the vector bundle B over manifold B.fiber (denoted mathcal M).\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe tangent vector v = (V_XM V_XF)  T_xB where V_XM is a tangent vector from the tangent space T_x_pmathcal M and V_XF is a tangent vector from the tangent space T_V_pF (isomorphic to F). Similarly for the other tangent vector w = (V_YM V_YF)  T_xB.\n\nThe inner product is calculated as\n\nX Y_p = V_XM V_YM_x_p + V_XF V_YF_V_p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundleFibers, Any, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundleFibers, p, X, Y)\n\nInner product of vectors X and Y from the vector space of type B.fiber at point p from manifold B.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(M::TangentSpaceAtPoint, p, X)\n\nProject the vector X from the tangent space M, that is project the vector X tangent at M.point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}, Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(M::TangentSpaceAtPoint, p)\n\nProject the point p from the tangent space M, that is project the vector p tangent at M.point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{VectorBundle, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundle, p, X)\n\nProject the element X of the ambient space of the tangent space T_p B to the tangent space T_p B.\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\nThe vector x = (V_XM V_XF) where x_p belongs to the ambient space of T_x_pmathcal M and V_XF belongs to the ambient space of the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting V_XM to tangent space T_x_pmathcal M and then projecting the vector V_XF to the fiber F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{VectorBundle, Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundle, p)\n\nProject the point p from the ambient space of the vector bundle B over manifold B.fiber (denoted mathcal M) to the vector bundle.\n\nNotation:\n\nThe point p = (x_p V_p) where x_p belongs to the ambient space of mathcal M and V_p belongs to the ambient space of the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting the point x_p to the manifold mathcal M and then projecting the vector V_p to the tangent space T_x_pmathcal M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project-Tuple{VectorBundleFibers, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.project","text":"project(B::VectorBundleFibers, p, X)\n\nProject vector X from the vector space of type B.fiber at point p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.vector_transport_to-Tuple{VectorBundle, Any, Any, Any, Manifolds.VectorBundleVectorTransport}","page":"Vector bundle","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::VectorBundle, p, X, q, m::VectorBundleVectorTransport)\n\nCompute the vector transport the tangent vector Xat p to q on the VectorBundle M using the VectorBundleVectorTransport m.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.zero_vector!-Tuple{VectorBundleFibers, Any, Any}","page":"Vector bundle","title":"ManifoldsBase.zero_vector!","text":"zero_vector!(B::VectorBundleFibers, X, p)\n\nSave the zero vector from the vector space of type B.fiber at point p from manifold B.manifold to X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.zero_vector-Tuple{TangentSpaceAtPoint{𝔽, M, TX} where {𝔽, M<:AbstractManifold{𝔽}, TX}, Vararg{Any, N} where N}","page":"Vector bundle","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::TangentSpaceAtPoint, p)\n\nZero tangent vector at point p from the tangent space M, that is the zero tangent vector at point M.point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.zero_vector-Tuple{VectorBundle, Vararg{Any, N} where N}","page":"Vector bundle","title":"ManifoldsBase.zero_vector","text":"zero_vector(B::VectorBundle, p)\n\nZero tangent vector at point p from the vector bundle B over manifold B.fiber (denoted mathcal M). The zero vector belongs to the space T_pB\n\nNotation:\n\nThe point p = (x_p V_p) where x_p  mathcal M and V_p belongs to the fiber F=π^-1(x_p) of the vector bundle B where π is the canonical projection of that vector bundle B.\n\nThe zero vector is calculated as\n\nmathbf0_p = (mathbf0_x_p mathbf0_F)\n\nwhere mathbf0_x_p is the zero tangent vector from T_x_pmathcal M and mathbf0_F is the zero element of the vector space F.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.zero_vector-Tuple{VectorBundleFibers, Any}","page":"Vector bundle","title":"ManifoldsBase.zero_vector","text":"zero_vector(B::VectorBundleFibers, p)\n\nCompute the zero vector from the vector space of type B.fiber at point p from manifold B.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#Unit-norm-symmetric-matrices","page":"Unit-norm symmetric matrices","title":"Unit-norm symmetric matrices","text":"","category":"section"},{"location":"manifolds/spheresymmetricmatrices.html","page":"Unit-norm symmetric matrices","title":"Unit-norm symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/SphereSymmetricMatrices.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/spheresymmetricmatrices.html#Manifolds.SphereSymmetricMatrices","page":"Unit-norm symmetric matrices","title":"Manifolds.SphereSymmetricMatrices","text":"SphereSymmetricMatrices{n,𝔽} <: AbstractEmbeddedManifold{ℝ,TransparentIsometricEmbedding}\n\nThe AbstractManifold  consisting of the n  n symmetric matrices of unit Frobenius norm, i.e.\n\nmathcalS_textsym =biglp   𝔽^n  n big p^mathrmH = p lVert p rVert = 1 bigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ.\n\nConstructor\n\nSphereSymmetricMatrices(n[, field=ℝ])\n\nGenerate the manifold of n-by-n symmetric matrices of unit Frobenius norm.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{SphereSymmetricMatrices{n, 𝔽}, Any}} where {n, 𝔽}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.check_point","text":"check_point(M::SphereSymmetricMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether the matrix is a valid point on the SphereSymmetricMatrices M, i.e. is an n-by-n symmetric matrix of unit Frobenius norm.\n\nThe tolerance for the symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{n}, Tuple{SphereSymmetricMatrices{n, 𝔽}, Any, Any}} where {n, 𝔽}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::SphereSymmetricMatrices{n,𝔽}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SphereSymmetricMatrices M, i.e. X has to be a symmetric matrix of size (n,n) of unit Frobenius norm.\n\nThe tolerance for the symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.manifold_dimension-Union{Tuple{SphereSymmetricMatrices{n, 𝔽}}, Tuple{𝔽}, Tuple{n}} where {n, 𝔽}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SphereSymmetricMatrices{n,𝔽})\n\nReturn the manifold dimension of the SphereSymmetricMatrices n-by-n symmetric matrix M of unit Frobenius norm over the number system 𝔽, i.e.\n\nbeginaligned\ndim(mathcalS_textsym)(nℝ) = fracn(n+1)2 - 1\ndim(mathcalS_textsym)(nℂ) = 2fracn(n+1)2 - n -1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.project-Tuple{SphereSymmetricMatrices, Any, Any}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SphereSymmetricMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SphereSymmetricMatrices M, i.e.\n\noperatornameproj_p(X) = fracX + X^mathrmH2 - p fracX + X^mathrmH2p\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/spheresymmetricmatrices.html#ManifoldsBase.project-Tuple{SphereSymmetricMatrices, Any}","page":"Unit-norm symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SphereSymmetricMatrices, p)\n\nProjects p from the embedding onto the SphereSymmetricMatrices M, i.e.\n\noperatornameproj_mathcalS_textsym(p) = frac12 bigl( p + p^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#Positive-Numbers","page":"Positive numbers","title":"Positive Numbers","text":"","category":"section"},{"location":"manifolds/positivenumbers.html","page":"Positive numbers","title":"Positive numbers","text":"The manifold PositiveNumbers represents positive numbers with hyperbolic geometry. Additionally, there are also short forms for its corresponding PowerManifolds, i.e. PositiveVectors, PositiveMatrices, and PositiveArrays.","category":"page"},{"location":"manifolds/positivenumbers.html","page":"Positive numbers","title":"Positive numbers","text":"Modules = [Manifolds]\nPages = [\"manifolds/PositiveNumbers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/positivenumbers.html#Manifolds.PositiveNumbers","page":"Positive numbers","title":"Manifolds.PositiveNumbers","text":"PositiveNumbers <: AbstractManifold{ℝ}\n\nThe hyperbolic manifold of positive numbers H^1 is a the hyperbolic manifold represented by just positive numbers.\n\nConstructor\n\nPositiveNumbers()\n\nGenerate the ℝ-valued hyperbolic model represented by positive positive numbers. To use this with arrays (1-element arrays), please use SymmetricPositiveDefinite(1).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/positivenumbers.html#Base.exp-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"Base.exp","text":"exp(M::PositiveNumbers, p, X)\n\nCompute the exponential map on the PositiveNumbers M.\n\nexp_p X = poperatornameexp(Xp)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#Base.log-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"Base.log","text":"log(M::PositiveNumbers, p, q)\n\nCompute the logarithmic map on the PositiveNumbers M.\n\nlog_p q = plogfracqp\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#Manifolds.PositiveArrays-Union{Tuple{Vararg{Int64, I}}, Tuple{I}} where I","page":"Positive numbers","title":"Manifolds.PositiveArrays","text":"PositiveArrays(n₁,n₂,...,nᵢ)\n\nGenerate the manifold of i-dimensional arrays with positive entries. This manifold is modeled as a PowerManifold of PositiveNumbers.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#Manifolds.PositiveMatrices-Tuple{Integer, Integer}","page":"Positive numbers","title":"Manifolds.PositiveMatrices","text":"PositiveMatrices(m,n)\n\nGenerate the manifold of matrices with positive entries. This manifold is modeled as a PowerManifold of PositiveNumbers.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#Manifolds.PositiveVectors-Tuple{Integer}","page":"Positive numbers","title":"Manifolds.PositiveVectors","text":"PositiveVectors(n)\n\nGenerate the manifold of vectors with positive entries. This manifold is modeled as a PowerManifold of PositiveNumbers.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#Manifolds.change_metric-Tuple{PositiveNumbers, EuclideanMetric, Any, Any}","page":"Positive numbers","title":"Manifolds.change_metric","text":"change_metric(M::PositiveNumbers, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function with respect to the EuclideanMetric g_E, this function changes the representer into the one with respect to the positivity metric of PositiveNumbers M.\n\nFor all ZY we are looking for the function c on the tangent space at p such that\n\n    ZY = XY = fracc(Z)c(Y)p^2 = g_p(c(Y)c(Z))\n\nand hence C(X) = pX.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#Manifolds.change_representer-Tuple{PositiveNumbers, EuclideanMetric, Any, Any}","page":"Positive numbers","title":"Manifolds.change_representer","text":"change_representer(M::PositiveNumbers, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function with respect to the EuclideanMetric g_E, this function changes the representer into the one with respect to the positivity metric representation of PositiveNumbers M.\n\nFor all tangent vectors Y the result Z has to fulfill\n\n    XY = XY = fracZYp^2 = g_p(YZ)\n\nand hence Z = p^2X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.check_point-Tuple{PositiveNumbers, Any}","page":"Positive numbers","title":"ManifoldsBase.check_point","text":"check_point(M::PositiveNumbers, p)\n\nCheck whether p is a point on the PositiveNumbers M, i.e. p0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.check_vector-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.check_vector","text":"check_vector(M::PositiveNumbers, p, X; kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the PositiveNumbers M. For the real-valued case represented by positive numbers, all X are valid, since the tangent space is the whole real line. For the complex-valued case X [...]\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.distance-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.distance","text":"distance(M::PositiveNumbers, p, q)\n\nCompute the distance on the PositiveNumbers M, which is\n\nd(pq) = Bigllvert log fracpq Bigrrvert = lvert log p - log qrvert\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.injectivity_radius-Tuple{PositiveNumbers}","page":"Positive numbers","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::PositiveNumbers[, p])\n\nReturn the injectivity radius on the PositiveNumbers M, i.e. infty.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.inner-Tuple{PositiveNumbers, Vararg{Any, N} where N}","page":"Positive numbers","title":"ManifoldsBase.inner","text":"inner(M::PositiveNumbers, p, X, Y)\n\nCompute the inner product of the two tangent vectors X,Y from the tangent plane at p on the PositiveNumbers M, i.e.\n\ng_p(XY) = fracXYp^2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.manifold_dimension-Tuple{PositiveNumbers}","page":"Positive numbers","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PositiveNumbers)\n\nReturn the dimension of the PositiveNumbers M, i.e. of the 1-dimensional hyperbolic space,\n\ndim(H^1) = 1\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.parallel_transport_to-Tuple{PositiveNumbers, Any, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::PositiveNumbers, p, X, q)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the PositiveNumbers M.\n\nmathcal P_qgets p(X) = Xcdotfracqp\n\n\n\n\n\n","category":"method"},{"location":"manifolds/positivenumbers.html#ManifoldsBase.project-Tuple{PositiveNumbers, Any, Any}","page":"Positive numbers","title":"ManifoldsBase.project","text":"project(M::PositiveNumbers, p, X)\n\nProject a value X onto the tangent space of the point p on the PositiveNumbers M, which is just the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus.html#Torus","page":"Torus","title":"Torus","text":"","category":"section"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"The torus 𝕋^d  -ππ)^d is modeled as an AbstractPowerManifold  of the (real-valued) Circle and uses ArrayPowerRepresentation. Points on the torus are hence row vectors, x  ℝ^d.","category":"page"},{"location":"manifolds/torus.html#Example","page":"Torus","title":"Example","text":"","category":"section"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"The following code can be used to make a three-dimensional torus 𝕋^3 and compute a tangent vector:","category":"page"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"using Manifolds\nM = Torus(3)\np = [0.5, 0.0, 0.0]\nq = [0.0, 0.5, 1.0]\nX = log(M, p, q)","category":"page"},{"location":"manifolds/torus.html#Types-and-functions","page":"Torus","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"Most functions are directly implemented for an AbstractPowerManifold  with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/torus.html","page":"Torus","title":"Torus","text":"Modules = [Manifolds]\nPages = [\"manifolds/Torus.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/torus.html#Manifolds.Torus","page":"Torus","title":"Manifolds.Torus","text":"Torus{N} <: AbstractPowerManifold\n\nThe n-dimensional torus is the n-dimensional product of the Circle.\n\nThe Circle is stored internally within M.manifold, such that all functions of AbstractPowerManifold  can be used directly.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/torus.html#ManifoldsBase.check_point-Tuple{Torus, Any}","page":"Torus","title":"ManifoldsBase.check_point","text":"check_point(M::Torus{n},p)\n\nChecks whether p is a valid point on the Torus M, i.e. each of its entries is a valid point on the Circle and the length of x is n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus.html#ManifoldsBase.check_vector-Union{Tuple{N}, Tuple{Torus{N}, Any, Any}} where N","page":"Torus","title":"ManifoldsBase.check_vector","text":"check_vector(M::Torus{n}, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the Torus M. This means, that p is valid, that X is of correct dimension and elementwise a tangent vector to the elements of p on the Circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#The-probability-simplex","page":"Probability simplex","title":"The probability simplex","text":"","category":"section"},{"location":"manifolds/probabilitysimplex.html","page":"Probability simplex","title":"Probability simplex","text":"Modules = [Manifolds]\nPages = [\"manifolds/ProbabilitySimplex.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/probabilitysimplex.html#Manifolds.FisherRaoMetric","page":"Probability simplex","title":"Manifolds.FisherRaoMetric","text":"FisherRaoMetric <: AbstractMetric\n\nThe Fisher-Rao metric or Fisher information metric is a particular Riemannian metric which can be defined on a smooth statistical manifold, i.e., a smooth manifold whose points are probability measures defined on a common probability space.\n\nSee for example the ProbabilitySimplex.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex.html#Manifolds.ProbabilitySimplex","page":"Probability simplex","title":"Manifolds.ProbabilitySimplex","text":"ProbabilitySimplex{n} <: AbstractDecoratorManifold{𝔽}\n\nThe (relative interior of) the probability simplex is the set\n\nΔ^n = biggl p  ℝ^n+1 big p_i  0 text for all  i=1n+1\ntext and  mathbb1p = sum_i=1^n+1 p_i = 1biggr\n\nwhere mathbb1=(11)^mathrmT ℝ^n+1 denotes the vector containing only ones.\n\nThis set is also called the unit simplex or standard simplex.\n\nThe tangent space is given by\n\nT_pΔ^n = biggl X  ℝ^n+1 big mathbb1X = sum_i=1^n+1 X_i = 0 biggr\n\nThe manifold is implemented assuming the Fisher-Rao metric for the multinomial distribution, which is equivalent to the induced metric from isometrically embedding the probability simplex in the n-sphere of radius 2. The corresponding diffeomorphism varphi mathbb Δ^n  mathcal N, where mathcal N subset 2𝕊^n is given by varphi(p) = 2sqrtp.\n\nThis implementation follows the notation in [ÅströmPetraSchmitzerSchnörr2017].\n\n[ÅströmPetraSchmitzerSchnörr2017]: F. Åström, S. Petra, B. Schmitzer, C. Schnörr: “Image Labeling by Assignment”, Journal of Mathematical Imaging and Vision, 58(2), pp. 221–238, 2017. doi: 10.1007/s10851-016-0702-4 arxiv: 1603.05285.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/probabilitysimplex.html#Base.exp-Tuple{ProbabilitySimplex, Vararg{Any, N} where N}","page":"Probability simplex","title":"Base.exp","text":"exp(M::ProbabilitySimplex,p,X)\n\nCompute the exponential map on the probability simplex.\n\nexp_pX = frac12Bigl(p+fracX_p^2lVert X_p rVert^2Bigr)\n+ frac12Bigl(p - fracX_p^2lVert X_p rVert^2Bigr)cos(lVert X_prVert)\n+ frac1lVert X_p rVertsqrtpsin(lVert X_prVert)\n\nwhere X_p = fracXsqrtp, with its division meant elementwise, as well as for the operations X_p^2 and sqrtp.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Base.log-Tuple{ProbabilitySimplex, Vararg{Any, N} where N}","page":"Probability simplex","title":"Base.log","text":"log(M::ProbabilitySimplex, p, q)\n\nCompute the logarithmic map of p and q on the ProbabilitySimplex M.\n\nlog_pq = fracd_Δ^n(pq)sqrt1-sqrtpsqrtq(sqrtpq - sqrtpsqrtqp)\n\nwhere pq and sqrtp is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Manifolds.change_metric-Tuple{ProbabilitySimplex, EuclideanMetric, Any, Any}","page":"Probability simplex","title":"Manifolds.change_metric","text":"change_metric(M::ProbabilitySimplex, ::EuclideanMetric, p, X)\n\nTo change the metric, we are looking for a function ccolon T_pΔ^n to T_pΔ^n such that for all XY  T_pΔ^n\n\n    XY = X^mathrmTY = sum_i=1^n+1fracc(X)_ic(Y)_ip_i = g_p(XY)\n\nand hence C(X)_i = X_isqrtp_i i=1n+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Manifolds.change_representer-Tuple{ProbabilitySimplex, EuclideanMetric, Any, Any}","page":"Probability simplex","title":"Manifolds.change_representer","text":"change_representer(M::ProbabilitySimplex, ::EuclideanMetric, p, X)\n\nGiven a tangent vector with respect to the metric from the embedding, the EuclideanMetric, the representer of a linear functional on the tangent space is adapted as Z = p * X, since this “compensates” for the divsion by p in the Riemannian metric on the ProbabilitySimplex.\n\nTo be precise for any Y  T_pΔ^n we are looking for Z  T_pΔ^n such that\n\n    XY = X^mathrmTY = sum_i=1^n+1fracZ_iY_ip_i = g_p(ZY)\n\nand hence Z_i = X_ip_i i=1n+1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.check_point-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"ManifoldsBase.check_point","text":"check_point(M::ProbabilitySimplex, p; kwargs...)\n\nCheck whether p is a valid point on the ProbabilitySimplex M, i.e. is a point in the embedding with positive entries that sum to one The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.check_vector-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.check_vector","text":"check_vector(M::ProbabilitySimplex, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the ProbabilitySimplex M, i.e. after check_point(M,p), X has to be of same dimension as p and its elements have to sum to one. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.distance-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.distance","text":"distance(M,p,q)\n\nCompute the distance between two points on the ProbabilitySimplex M. The formula reads\n\nd_Δ^n(pq) = 2arccos biggl( sum_i=1^n+1 sqrtp_i q_i biggr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.injectivity_radius-Union{Tuple{n}, Tuple{ProbabilitySimplex{n}, Any}} where n","page":"Probability simplex","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M,p)\n\ncompute the injectivity radius on the ProbabilitySimplex M at the point p, i.e. the distanceradius to a point near/on the boundary, that could be reached by following the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.inner-Tuple{ProbabilitySimplex, Any, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.inner","text":"inner(M::ProbabilitySimplex,p,X,Y)\n\nCompute the inner product of two tangent vectors X, Y from the tangent space T_pΔ^n at p. The formula reads\n\ng_p(XY) = sum_i=1^n+1fracX_iY_ip_i\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.inverse_retract-Tuple{ProbabilitySimplex, Any, Any, SoftmaxInverseRetraction}","page":"Probability simplex","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProbabilitySimplex, p, q, ::SoftmaxInverseRetraction)\n\nCompute a first order approximation by projection. The formula reads\n\noperatornameretr^-1_p q = bigl( I_n+1 - frac1nmathbb1^n+1n+1 bigr)(log(q)-log(p))\n\nwhere mathbb1^mn is the size (m,n) matrix containing ones, and log is applied elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.manifold_dimension-Union{Tuple{ProbabilitySimplex{n}}, Tuple{n}} where n","page":"Probability simplex","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::ProbabilitySimplex{n})\n\nReturns the manifold dimension of the probability simplex in ℝ^n+1, i.e.\n\n    dim_Δ^n = n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.project-Tuple{ProbabilitySimplex, Any, Any}","page":"Probability simplex","title":"ManifoldsBase.project","text":"project(M::ProbabilitySimplex, p, Y)\n\nproject Y from the embedding onto the tangent space at p on the ProbabilitySimplex M. The formula reads\n\noperatornameproj_Δ^n(pY) = Y - mathbb 1Yp\n\nwhere mathbb 1  ℝ denotes the vector of ones.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.project-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"ManifoldsBase.project","text":"project(M::ProbabilitySimplex, p)\n\nproject p from the embedding onto the ProbabilitySimplex M. The formula reads\n\noperatornameproj_Δ^n(p) = frac1mathbb 1pp\n\nwhere mathbb 1  ℝ denotes the vector of ones. Not that this projection is only well-defined if p has positive entries.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.representation_size-Union{Tuple{ProbabilitySimplex{n}}, Tuple{n}} where n","page":"Probability simplex","title":"ManifoldsBase.representation_size","text":"representation_size(::ProbabilitySimplex{n})\n\nreturn the representation size of points in the n-dimensional probability simplex, i.e. an array size of (n+1,).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.retract-Tuple{ProbabilitySimplex, Any, Any, SoftmaxRetraction}","page":"Probability simplex","title":"ManifoldsBase.retract","text":"retract(M::ProbabilitySimplex, p, X, ::SoftmaxRetraction)\n\nCompute a first order approximation by applying the softmax function. The formula reads\n\noperatornameretr_p X = fracpmathrme^Xpmathrme^X\n\nwhere multiplication, exponentiation and division are meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#ManifoldsBase.zero_vector-Tuple{ProbabilitySimplex, Any}","page":"Probability simplex","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::ProbabilitySimplex,p)\n\nreturns the zero tangent vector in the tangent space of the point p  from the ProbabilitySimplex M, i.e. its representation by the zero vector in the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Statistics.mean-Tuple{ProbabilitySimplex, Vararg{Any, N} where N}","page":"Probability simplex","title":"Statistics.mean","text":"mean(\n    M::ProbabilitySimplex,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/probabilitysimplex.html#Literature","page":"Probability simplex","title":"Literature","text":"","category":"section"},{"location":"manifolds/generalizedstiefel.html#Generalized-Stiefel","page":"Generalized Stiefel","title":"Generalized Stiefel","text":"","category":"section"},{"location":"manifolds/generalizedstiefel.html","page":"Generalized Stiefel","title":"Generalized Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/GeneralizedStiefel.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/generalizedstiefel.html#Manifolds.GeneralizedStiefel","page":"Generalized Stiefel","title":"Manifolds.GeneralizedStiefel","text":"GeneralizedStiefel{n,k,𝔽,B} <: AbstractDecoratorManifold{𝔽}\n\nThe Generalized Stiefel manifold consists of all ntimes k, ngeq k orthonormal matrices w.r.t. an arbitrary scalar product with symmetric positive definite matrix Bin R^n  n, i.e.\n\noperatornameSt(nkB) = bigl p in mathbb F^n  k big p^mathrmH B p = I_k bigr\n\nwhere 𝔽  ℝ ℂ, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k in mathbb R^k  k denotes the k  k identity matrix.\n\nIn the case B=I_k one gets the usual Stiefel manifold.\n\nThe tangent space at a point pinmathcal M=operatornameSt(nkB) is given by\n\nT_pmathcal M =  X in 𝔽^n  k  p^mathrmHBX + X^mathrmHBp=0_n\n\nwhere 0_k is the k  k zero matrix.\n\nThis manifold is modeled as an embedded manifold to the Euclidean, i.e. several functions like the zero_vector are inherited from the embedding.\n\nThe manifold is named after Eduard L. Stiefel (1909–1978).\n\nConstructor\n\nGeneralizedStiefel(n, k, B=I_n, F=ℝ)\n\nGenerate the (real-valued) Generalized Stiefel manifold of ntimes k dimensional orthonormal matrices with scalar product B.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{GeneralizedStiefel{n, k, 𝔽, TB} where TB<:(AbstractMatrix{T} where T), Any}} where {n, k, 𝔽}","page":"Generalized Stiefel","title":"ManifoldsBase.check_point","text":"check_point(M::GeneralizedStiefel, p; kwargs...)\n\nCheck whether p is a valid point on the GeneralizedStiefel M=operatornameSt(nkB), i.e. that it has the right AbstractNumbers type and x^mathrmHBx is (approximately) the identity, where cdot^mathrmH is the complex conjugate transpose. The settings for approximately can be set with kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{B}, Tuple{k}, Tuple{n}, Tuple{GeneralizedStiefel{n, k, 𝔽, TB} where TB<:(AbstractMatrix{T} where T), Any, Any}} where {n, k, B, 𝔽}","page":"Generalized Stiefel","title":"ManifoldsBase.check_vector","text":"check_vector(M::GeneralizedStiefel, p, X; kwargs...)\n\nCheck whether X is a valid tangent vector at p on the GeneralizedStiefel M=operatornameSt(nkB), i.e. the AbstractNumbers fits, p is a valid point on M and it (approximately) holds that p^mathrmHBX + overlineX^mathrmHBp = 0, where kwargs... is passed to the isapprox.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.inner-Tuple{GeneralizedStiefel, Any, Any, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.inner","text":"inner(M::GeneralizedStiefel, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the GeneralizedStiefel manifold M. The formula reads\n\n(X Y)_p = operatornametrace(v^mathrmHBw)\n\ni.e. the metric induced by the scalar product B from the embedding, restricted to the tangent space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.manifold_dimension-Union{Tuple{GeneralizedStiefel{n, k, ℝ, TB} where TB<:(AbstractMatrix{T} where T)}, Tuple{k}, Tuple{n}} where {n, k}","page":"Generalized Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::GeneralizedStiefel)\n\nReturn the dimension of the GeneralizedStiefel manifold M=operatornameSt(nkB𝔽). The dimension is given by\n\nbeginaligned\ndim mathrmSt(n k B ℝ) = nk - frac12k(k+1) \ndim mathrmSt(n k B ℂ) = 2nk - k^2\ndim mathrmSt(n k B ℍ) = 4nk - k(2k-1)\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.project-Tuple{GeneralizedStiefel, Any, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.project","text":"project(M:GeneralizedStiefel, p, X)\n\nProject X onto the tangent space of p to the GeneralizedStiefel manifold M. The formula reads\n\noperatornameproj_operatornameSt(nk)(pX) = X - poperatornameSym(p^mathrmHBX)\n\nwhere operatornameSym(y) is the symmetrization of y, e.g. by operatornameSym(y) = fracy^mathrmH+y2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.project-Tuple{GeneralizedStiefel, Any}","page":"Generalized Stiefel","title":"ManifoldsBase.project","text":"project(M::GeneralizedStiefel,p)\n\nProject p from the embedding onto the GeneralizedStiefel M, i.e. compute q as the polar decomposition of p such that q^mathrmHBq is the identity, where cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedstiefel.html#ManifoldsBase.retract-Tuple{GeneralizedStiefel, Vararg{Any, N} where N}","page":"Generalized Stiefel","title":"ManifoldsBase.retract","text":"retract(M::GeneralizedStiefel, p, X)\nretract(M::GeneralizedStiefel, p, X, ::PolarRetraction)\nretract(M::GeneralizedStiefel, p, X, ::ProjectionRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the GeneralizedStiefel manifold M, which in this case is the same as the projection based retraction employing the exponential map in the embedding and projecting the result back to the manifold.\n\nThe default retraction for this manifold is the ProjectionRetraction.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#Symplectic-Stiefel","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"","category":"section"},{"location":"manifolds/symplecticstiefel.html","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"The SymplecticStiefel manifold, denoted operatornameSpSt(2n 2k),  represents canonical symplectic bases of 2k dimensonal symplectic subspaces of mathbbR^2n times 2n.  This means that the columns of each element p in operatornameSpSt(2n 2k) subset mathbbR^2n times 2k  constitute a canonical symplectic basis of operatornamespan(p).  The canonical symplectic form is a non-degenerate, bilinear, and skew symmetric map  omega_2kcolon mathbbF^2k times mathbbF^2k  rightarrow mathbbF, given by omega_2k(x y) = x^T Q_2k y for elements x y in mathbbF^2k, with","category":"page"},{"location":"manifolds/symplecticstiefel.html","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"    Q_2k = \n    beginbmatrix\n     0_k    I_k \n    -I_k    0_k\n    endbmatrix","category":"page"},{"location":"manifolds/symplecticstiefel.html","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"Specifically given an element p in operatornameSpSt(2n 2k) we require that","category":"page"},{"location":"manifolds/symplecticstiefel.html","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"    omega_2n (p x p y) = x^T(p^TQ_2np)y = x^TQ_2ky = omega_2k(x y) forall x y in mathbbF^2k","category":"page"},{"location":"manifolds/symplecticstiefel.html","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"leading to the requirement on p that p^TQ_2np = Q_2k. In the case that k = n, this manifold reduces to the Symplectic manifold, which is also known as the symplectic group.","category":"page"},{"location":"manifolds/symplecticstiefel.html","page":"Symplectic Stiefel","title":"Symplectic Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymplecticStiefel.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symplecticstiefel.html#Manifolds.SymplecticStiefel","page":"Symplectic Stiefel","title":"Manifolds.SymplecticStiefel","text":"SymplecticStiefel{n, k, 𝔽} <: AbstractEmbeddedManifold{𝔽, DefaultIsometricEmbeddingType}\n\nThe symplectic Stiefel manifold consists of all 2n  2k  n geq k matrices satisfying the requirement\n\noperatornameSpSt(2n 2k ℝ)\n    = bigl p  ℝ^2n  2n  big  p^TQ_2np = Q_2k bigr\n\nwhere\n\nQ_2n =\nbeginbmatrix\n  0_n  I_n \n -I_n  0_n\nendbmatrix\n\nThe symplectic Stiefel tangent space at p can be parametrized as [Bendokat2021]\n\n    beginalign*\n    T_poperatornameSpSt(2n 2k)\n    = X in mathbbR^2n times 2k  p^TQ_2nX + X^TQ_2np = 0  \n    = X = pΩ + p^sB \n        Ω  ℝ^2k  2k Ω^+ = -Ω \n         p^s  operatornameSpSt(2n 2(n- k)) B  ℝ^2(n-k)  2k \n    endalign*\n\nwhere Ω in mathfraksp(2nF) is Hamiltonian and p^s means the symplectic complement of p s.t. p^+p^s = 0.\n\nConstructor\n\nSymplecticStiefel(2n::Int, 2k::Int, field::AbstractNumbers=ℝ)\n    -> SymplecticStiefel{div(2n, 2), div(2k, 2), field}()\n\nGenerate the (real-valued) symplectic Stiefel manifold of 2n times 2k matrices which span a 2k dimensional symplectic subspace of ℝ^2n times 2n. The constructor for the SymplecticStiefel manifold accepts the even column dimension 2n and an even number of columns 2k for the real symplectic Stiefel manifold with elements p in ℝ^2n  2k.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplecticstiefel.html#Base.exp-Tuple{SymplecticStiefel, Any, Any}","page":"Symplectic Stiefel","title":"Base.exp","text":"exp(::SymplecticStiefel, p, X)\nexp!(M::SymplecticStiefel, q, p, X)\n\nCompute the exponential mapping\n\n    operatornameexpcolon ToperatornameSpSt(2n 2k)\n    rightarrow operatornameSpSt(2n 2k)\n\nat a point p in  operatornameSpSt(2n 2k) in the direction of X in T_poperatornameSpSt(2n 2k).\n\nThe tangent vector X can be written in the form X = barOmegap [Bendokat2021], with\n\n    barOmega = X (p^Tp)^-1p^T\n        + Q_2np(p^Tp)^-1X^T(I_2n - Q_2n^Tp(p^Tp)^-1p^TQ_2n)Q_2n\n        in ℝ^2n times 2n\n\nwhere Q_2n is the SymplecticMatrix. Using this expression for X, the exponential mapping can be computed as\n\n    operatornameexp_p(X) = operatornameExp(barOmega - barOmega^T)\n                              operatornameExp(barOmega^T)p\n\nwhere operatornameExp(cdot) denotes the matrix exponential.\n\nComputing the above mapping directly however, requires taking matrix exponentials of two 2n times 2n matrices, which is computationally expensive when n increases. Therefore we instead follow [Bendokat2021] who express the above exponential mapping in a way which only requires taking matrix exponentials of an 8k times 8k matrix and a 4k times 4k matrix.\n\nTo this end, first define\n\nbarA = Q_2kp^TX(p^Tp)^-1Q_2k +\n            (p^Tp)^-1X^T(p - Q_2n^Tp(p^Tp)^-1Q_2k) in ℝ^2k times 2k\n\nand\n\nbarH = (I_2n - pp^+)Q_2nX(p^Tp)^-1Q_2k in ℝ^2n times 2k\n\nWe then let barDelta = pbarA + barH, and define the matrices\n\n    γ = leftleft(I_2n - frac12pp^+right)barDelta quad\n              -p right in ℝ^2n times 4k\n\nand\n\n    λ = leftQ_2n^TpQ_2k quad\n        left(barDelta^+left(I_2n\n              - frac12pp^+right)right)^Tright in ℝ^2n times 4k\n\nWith the above defined matrices it holds that barOmega = λγ^T.  As a last preliminary step, concatenate γ and λ to define the matrices Γ = λ quad -γ in ℝ^2n times 8k and Λ = γ quad λ in ℝ^2n times 8k.\n\nWith these matrix constructions done, we can compute the exponential mapping as\n\n    operatornameexp_p(X) =\n        Γ operatornameExp(ΛΓ^T)\n        beginbmatrix\n            0_4k \n            I_4k\n        endbmatrix\n        operatornameExp(λγ^T)\n        beginbmatrix\n            0_2k \n            I_2k\n        endbmatrix\n\nwhich only requires computing the matrix exponentials of ΛΓ^T in ℝ^8k times 8k and λγ^T in ℝ^4k times 4k.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#Base.inv-Union{Tuple{k}, Tuple{n}, Tuple{SymplecticStiefel{n, k, 𝔽} where 𝔽, Any}} where {n, k}","page":"Symplectic Stiefel","title":"Base.inv","text":"inv(::SymplecticStiefel{n, k}, A)\ninv!(::SymplecticStiefel{n, k}, q, p)\n\nCompute the symplectic inverse A^+ of matrix A  ℝ^2n  2k. Given a matrix\n\nA  ℝ^2n  2kquad\nA =\nbeginbmatrix\nA_1 1  A_1 2 \nA_2 1  A_2 2\nendbmatrix A_i j in ℝ^2n  2k\n\nthe symplectic inverse is defined as:\n\nA^+ = Q_2k^T A^T Q_2n\n\nwhere\n\nQ_2n =\nbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix\n\nFor any p in operatornameSpSt(2n 2k) we have that p^+p = I_2k.\n\nThe symplectic inverse of a matrix A can be expressed explicitly as:\n\nA^+ =\nbeginbmatrix\n  A_2 2^T  -A_1 2^T 12mm\n -A_2 1^T   A_1 1^T\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#Base.rand-Union{Tuple{SymplecticStiefel{n, k, 𝔽} where {k, 𝔽}}, Tuple{n}} where n","page":"Symplectic Stiefel","title":"Base.rand","text":"rand(M::SymplecticStiefel; vector_at=nothing,\n    hamiltonian_norm=(vector_at === nothing ? 1/2 : 1.0))\n\nGenerate a random point p in operatornameSpSt(2n 2k) or a random tangent vector X in T_poperatornameSpSt(2n 2k) if vector_at is set to a point p in operatornameSp(2n).\n\nA random point on operatornameSpSt(2n 2k) is found by first generating a random point on the symplectic manifold operatornameSp(2n), and then projecting onto the Symplectic Stiefel manifold using the canonical_projection π_operatornameSpSt(2n 2k). That is, p = π_operatornameSpSt(2n 2k)(p_operatornameSp).\n\nTo generate a random tangent vector in T_poperatornameSpSt(2n 2k) this code exploits the second tangent vector space parametrization of SymplecticStiefel, showing that any X in T_poperatornameSpSt(2n 2k) can be written as X = pΩ_X + p^sB_X. To generate random tangent vectors at p then, this function sets B_X = 0 and generates a random Hamiltonian matrix Ω_X in mathfraksp(2nF) with Frobenius norm of hamiltonian_norm before returning X = pΩ_X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#Manifolds.canonical_projection-Union{Tuple{k}, Tuple{n}, Tuple{SymplecticStiefel{n, k, 𝔽} where 𝔽, Any}} where {n, k}","page":"Symplectic Stiefel","title":"Manifolds.canonical_projection","text":"canonical_projection(::SymplecticStiefel, p_Sp)\ncanonical_projection!(::SymplecticStiefel{n,k}, p, p_Sp)\n\nDefine the canonical projection from operatornameSp(2n 2n) onto operatornameSpSt(2n 2k), by projecting onto the first k columns and the n + 1'th onto the n + k'th columns [Bendokat2021].\n\nIt is assumed that the point p is on operatornameSp(2n 2n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#Manifolds.gradient-Tuple{SymplecticStiefel, Any, Any, Manifolds.RiemannianProjectionBackend}","page":"Symplectic Stiefel","title":"Manifolds.gradient","text":"gradient(::SymplecticStiefel, f, p, backend::RiemannianProjectionBackend)\ngradient!(::SymplecticStiefel, f, X, p, backend::RiemannianProjectionBackend)\n\nCompute the gradient of fcolon operatornameSpSt(2n 2k) rightarrow ℝ at p in operatornameSpSt(2n 2k).\n\nThis function first computes the embedding gradient f(p) in ℝ^2n times 2k using the AbstractRiemannianDiffBackend in the RiemannianProjectionBackend. Then it transforms the embedding gradient to the unique tangent vector space element textgradf(p) in T_poperatornameSpSt(2n 2k) which fulfills the variational equation\n\n    g_p(textgradf(p) X)\n    = textDf(p)\n    = langle f(p) X rangle\n    quadforall X in T_poperatornameSpSt(2n 2k)\n\nThe manifold gradient textgradf(p) is computed from f(p) as\n\n    textgradf(p) = f(p)p^Tp + Q_2npf(p)^TQ_2np\n\nwhere Q_2n is the SymplecticMatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#Manifolds.symplectic_inverse_times-Union{Tuple{k}, Tuple{n}, Tuple{SymplecticStiefel{n, k, 𝔽} where 𝔽, Any, Any}} where {n, k}","page":"Symplectic Stiefel","title":"Manifolds.symplectic_inverse_times","text":"symplectic_inverse_times(::SymplecticStiefel, p, q)\nsymplectic_inverse_times!(::SymplecticStiefel, A, p, q)\n\nDirectly compute the symplectic inverse of p in operatornameSpSt(2n 2k), multiplied with q in operatornameSpSt(2n 2k). That is, this function efficiently computes p^+q = (Q_2kp^TQ_2n)q in ℝ^2k times 2k, where Q_2n Q_2k are the SymplecticMatrix of sizes 2n times 2n and 2k times 2k respectively.\n\nThis function performs this common operation without allocating more than a 2k times 2k matrix to store the result in, or in the case of the in-place function, without allocating memory at all.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#ManifoldsBase.check_point-Union{Tuple{k}, Tuple{n}, Tuple{SymplecticStiefel{n, k, 𝔽} where 𝔽, Any}} where {n, k}","page":"Symplectic Stiefel","title":"ManifoldsBase.check_point","text":"check_point(M::SymplecticStiefel, p; kwargs...)\n\nCheck whether p is a valid point on the SymplecticStiefel, operatornameSpSt(2n 2k) manifold. That is, the point has the right AbstractNumbers type and p^+p is (approximately) the identity, where for A in mathbbR^2n times 2k, A^+ = Q_2k^TA^TQ_2n is the symplectic inverse, with\n\nQ_2n =\nbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix\n\nThe tolerance can be set with kwargs... (e.g. atol = 1.0e-14).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#ManifoldsBase.check_vector-Tuple{SymplecticStiefel, Vararg{Any, N} where N}","page":"Symplectic Stiefel","title":"ManifoldsBase.check_vector","text":"check_vector(M::Symplectic, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector at p on the SymplecticStiefel, operatornameSpSt(2n 2k) manifold. First recall the definition of the symplectic inverse for A in mathbbR^2n times 2k, A^+ = Q_2k^TA^TQ_2n is the symplectic inverse, with\n\n    Q_2n =\n    beginbmatrix\n    0_n  I_n \n     -I_n  0_n\nendbmatrix\n\nThe we check that H = p^+X in 𝔤_2k, where 𝔤 is the Lie Algebra of the symplectic group operatornameSp(2k), characterized as [Bendokat2021],\n\n    𝔤_2k = H in ℝ^2k times 2k  H^+ = -H \n\nThe tolerance can be set with kwargs... (e.g. atol = 1.0e-14).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#ManifoldsBase.inner-Union{Tuple{k}, Tuple{n}, Tuple{SymplecticStiefel{n, k, 𝔽} where 𝔽, Any, Any, Any}} where {n, k}","page":"Symplectic Stiefel","title":"ManifoldsBase.inner","text":"inner(M::SymplecticStiefel{n, k}, p, X. Y)\n\nCompute the Riemannian inner product g^operatornameSpSt at p in operatornameSpSt between tangent vectors X X in T_poperatornameSpSt. Given by Proposition 3.10 in [Bendokat2021].\n\ng^operatornameSpSt_p(X Y)\n    = operatornametrleft(X^Tleft(I_2n -\n        frac12Q_2n^Tp(p^Tp)^-1p^TQ_2nright)Y(p^Tp)^-1right)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#ManifoldsBase.inverse_retract-Tuple{SymplecticStiefel, Any, Any, CayleyInverseRetraction}","page":"Symplectic Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(::SymplecticStiefel, p, q, ::CayleyInverseRetraction)\ninverse_retract!(::SymplecticStiefel, q, p, X, ::CayleyInverseRetraction)\n\nCompute the Cayley Inverse Retraction X = mathcalL_p^operatornameSpSt(q) such that the Cayley Retraction from p along X lands at q, i.e. mathcalR_p(X) = q [Bendokat2021].\n\nFirst, recall the definition the standard symplectic matrix\n\nQ =\nbeginbmatrix\n 0      I \n-I      0\nendbmatrix\n\nas well as the symplectic inverse of a matrix A, A^+ = Q^T A^T Q.\n\nFor p q  operatornameSpSt(2n 2k ℝ) then, we can define the inverse cayley retraction as long as the following matrices exist.\n\n    U = (I + p^+ q)^-1 in ℝ^2k times 2k\n    quad\n    V = (I + q^+ p)^-1 in ℝ^2k times 2k\n\nIf that is the case, the inverse cayley retration at p applied to q is\n\nmathcalL_p^operatornameSp(q) = 2pbigl(V - Ubigr) + 2bigl((p + q)U - pbigr)\n                                         T_poperatornameSp(2n)\n\n[Bendokat2021]: Bendokat, Thomas and Zimmermann, Ralf: The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications arXiv preprint arXiv:2108.12447, 2021 (https://arxiv.org/abs/2108.12447)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymplecticStiefel{n, k, 𝔽} where 𝔽}, Tuple{k}, Tuple{n}} where {n, k}","page":"Symplectic Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(::SymplecticStiefel{n, k})\n\nReturns the dimension of the symplectic Stiefel manifold embedded in ℝ^2n times 2k, i.e. [Bendokat2021]\n\n    operatornamedim(operatornameSpSt(2n 2k)) = (4n - 2k + 1)k\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#ManifoldsBase.project-Tuple{SymplecticStiefel, Any, Any}","page":"Symplectic Stiefel","title":"ManifoldsBase.project","text":"project(::SymplecticStiefel, p, A)\nproject!(::SymplecticStiefel, Y, p, A)\n\nGiven a point p in operatornameSpSt(2n 2k), project an element A in mathbbR^2n times 2k onto the tangent space T_poperatornameSpSt(2n 2k) relative to the euclidean metric of the embedding mathbbR^2n times 2k.\n\nThat is, we find the element X in T_poperatornameSpSt(2n 2k) which solves the constrained optimization problem\n\n    operatornamemin_X in mathbbR^2n times 2k frac12X - A^2 quad\n    textst\n    h(X)colon= X^T Q p + p^T Q X = 0\n\nwhere h  mathbbR^2n times 2k rightarrow operatornameskew(2k) defines the restriction of X onto the tangent space T_poperatornameSpSt(2n 2k).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#ManifoldsBase.retract-Tuple{SymplecticStiefel, Any, Any, CayleyRetraction}","page":"Symplectic Stiefel","title":"ManifoldsBase.retract","text":"retract(::SymplecticStiefel, p, X, ::CayleyRetraction)\nretract!(::SymplecticStiefel, q, p, X, ::CayleyRetraction)\n\nCompute the Cayley retraction on the Symplectic Stiefel manifold, computed inplace of q from p along X.\n\nGiven a point p in operatornameSpSt(2n 2k), every tangent vector X in T_poperatornameSpSt(2n 2k) is of the form X = tildeOmegap, with\n\n    tildeOmega = left(I_2n - frac12pp^+right)Xp^+ -\n                     pX^+left(I_2n - frac12pp^+right) in ℝ^2n times 2n\n\nas shown in Proposition 3.5 of [Bendokat2021]. Using this representation of X, the Cayley retraction on operatornameSpSt(2n 2k) is defined pointwise as\n\n    mathcalR_p(X) = operatornamecayleft(frac12tildeOmegaright)p\n\nThe operator operatornamecay(A) = (I - A)^-1(I + A) is the Cayley transform.\n\nHowever, the computation of an 2n times 2n matrix inverse in the expression above can be reduced down to inverting a 2k times 2k matrix due to Proposition 5.2 of [Bendokat2021].\n\nLet A = p^+X and H = X - pA. Then an equivalent expression for the Cayley retraction defined pointwise above is\n\n    mathcalR_p(X) = -p + (H + 2p)(H^+H4 - A2 + I_2k)^-1\n\nIt is this expression we compute inplace of q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplecticstiefel.html#Literature","page":"Symplectic Stiefel","title":"Literature","text":"","category":"section"},{"location":"manifolds/connection.html#Connection-manifold","page":"Connection manifold","title":"Connection manifold","text":"","category":"section"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"A connection manifold always consists of a topological manifold together with a connection Gamma.","category":"page"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"However, often there is an implicitly assumed (default) connection, like the LeviCivitaConnection connection on a Riemannian manifold. It is not necessary to use this decorator if you implement just one (or the first) connection. If you later introduce a second, the old (first) connection can be used without an explicitly stated connection.","category":"page"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"This manifold decorator serves two purposes:","category":"page"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"to implement different connections (e.g. in closed form) for one AbstractManifold\nto provide a way to compute geodesics on manifolds, where this AbstractAffineConnection does not yield a closed formula.","category":"page"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"An example of usage can be found in Cartan-Schouten connections, see AbstractCartanSchoutenConnection.","category":"page"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"Pages = [\"connection.md\"]\nDepth = 2","category":"page"},{"location":"manifolds/connection.html#Types","page":"Connection manifold","title":"Types","text":"","category":"section"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/ConnectionManifold.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/connection.html#Manifolds.AbstractAffineConnection","page":"Connection manifold","title":"Manifolds.AbstractAffineConnection","text":"AbstractAffineConnection\n\nAbstract type for affine connections on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection.html#Manifolds.ConnectionManifold","page":"Connection manifold","title":"Manifolds.ConnectionManifold","text":"ConnectionManifold{𝔽,,M<:AbstractManifold{𝔽},G<:AbstractAffineConnection} <: AbstractDecoratorManifold{𝔽}\n\nConstructor\n\nConnectionManifold(M, C)\n\nDecorate the AbstractManifold  M with AbstractAffineConnection C.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection.html#Manifolds.IsConnectionManifold","page":"Connection manifold","title":"Manifolds.IsConnectionManifold","text":"IsConnectionManifold <: AbstractTrait\n\nSpecify that a certain decorated Manifold is a connection manifold in the sence that it provides explicit connection properties, extending/changing the default connection properties of a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection.html#Manifolds.IsDefaultConnection","page":"Connection manifold","title":"Manifolds.IsDefaultConnection","text":"IsDefaultConnection{G<:AbstractAffineConnection}\n\nSpecify that a certain AbstractAffineConnection is the default connection for a manifold. This way the corresponding ConnectionManifold falls back to the default methods of the manifold it decorates.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection.html#Manifolds.LeviCivitaConnection","page":"Connection manifold","title":"Manifolds.LeviCivitaConnection","text":"LeviCivitaConnection\n\nThe Levi-Civita connection of a Riemannian manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/connection.html#Functions","page":"Connection manifold","title":"Functions","text":"","category":"section"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/ConnectionManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/connection.html#Base.exp-Tuple{ManifoldsBase.TraitList{IsConnectionManifold, T2} where T2<:AbstractTrait, AbstractDecoratorManifold, Any, Any}","page":"Connection manifold","title":"Base.exp","text":"exp(::TraitList{IsConnectionManifold}, M::AbstractDecoratorManifold, p, X)\n\nCompute the exponential map on a manifold that IsConnectionManifold M equipped with corresponding affine connection.\n\nIf M is a MetricManifold with a IsDefaultMetric trait, this method falls back to exp(M, p, X).\n\nOtherwise it numerically integrates the underlying ODE, see solve_exp_ode. Currently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.christoffel_symbols_first-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.christoffel_symbols_first","text":"christoffel_symbols_first(\n    M::AbstractManifold,\n    p,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend = default_differential_backend(),\n)\n\nCompute the Christoffel symbols of the first kind in local coordinates of basis B. The Christoffel symbols are (in Einstein summation convention)\n\nΓ_ijk = frac12 Biglg_kji + g_ikj - g_ijkBigr\n\nwhere g_ijk=frac p^k g_ij is the coordinate derivative of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.christoffel_symbols_second-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.christoffel_symbols_second","text":"christoffel_symbols_second(\n    M::AbstractManifold,\n    p,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend = default_differential_backend(),\n)\n\nCompute the Christoffel symbols of the second kind in local coordinates of basis B. For affine connection manifold the Christoffel symbols need to be explicitly implemented while, for a MetricManifold they are computed as (in Einstein summation convention)\n\nΓ^l_ij = g^kl Γ_ijk\n\nwhere Γ_ijk are the Christoffel symbols of the first kind (see christoffel_symbols_first), and g^kl is the inverse of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (lij).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.christoffel_symbols_second_jacobian-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.christoffel_symbols_second_jacobian","text":"christoffel_symbols_second_jacobian(\n    M::AbstractManifold,\n    p,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend = default_differential_backend(),\n)\n\nGet partial derivatives of the Christoffel symbols of the second kind for manifold M at p with respect to the coordinates of B, i.e.\n\nfrac p^l Γ^k_ij = Γ^k_ijl\n\nThe dimensions of the resulting multi-dimensional array are ordered (ijkl).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.connection-Tuple{AbstractManifold}","page":"Connection manifold","title":"Manifolds.connection","text":"connection(M::AbstractManifold)\n\nGet the connection (an object of a subtype of AbstractAffineConnection) of AbstractManifold  M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.connection-Tuple{ConnectionManifold}","page":"Connection manifold","title":"Manifolds.connection","text":"connection(M::ConnectionManifold)\n\nReturn the connection associated with ConnectionManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.gaussian_curvature-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.gaussian_curvature","text":"gaussian_curvature(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = default_differential_backend())\n\nCompute the Gaussian curvature of the manifold M at the point p using basis B. This is equal to half of the scalar Ricci curvature, see ricci_curvature.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.is_default_connection-Tuple{AbstractManifold, AbstractAffineConnection}","page":"Connection manifold","title":"Manifolds.is_default_connection","text":"is_default_connection(M::AbstractManifold, G::AbstractAffineConnection)\n\nreturns whether an AbstractAffineConnection is the default metric on the manifold M or not. This can be set by defining this function, or setting the IsDefaultConnection trait for an AbstractDecoratorManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.ricci_tensor-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.ricci_tensor","text":"ricci_tensor(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = default_differential_backend())\n\nCompute the Ricci tensor, also known as the Ricci curvature tensor, of the manifold M at the point p using basis B, see https://en.wikipedia.org/wiki/Ricci_curvature#Introduction_and_local_definition.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.riemann_tensor-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Connection manifold","title":"Manifolds.riemann_tensor","text":"riemann_tensor(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend=default_differential_backend())\n\nCompute the Riemann tensor R^l_ijk, also known as the Riemann curvature tensor, at the point p in local coordinates defined by B. The dimensions of the resulting multi-dimensional array are ordered (lijk).\n\nThe function uses the coordinate expression involving the second Christoffel symbol, see https://en.wikipedia.org/wiki/Riemann_curvature_tensor#Coordinate_expression for details.\n\nSee also\n\nchristoffel_symbols_second, christoffel_symbols_second_jacobian\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#Manifolds.solve_exp_ode-Tuple{Any, Any, Any}","page":"Connection manifold","title":"Manifolds.solve_exp_ode","text":"solve_exp_ode(\n    M::AbstractConnectionManifold,\n    p,\n    X,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend = default_differential_backend(),\n    solver = AutoVern9(Rodas5()),\n    kwargs...,\n)\n\nApproximate the exponential map on the manifold by evaluating the ODE descripting the geodesic at 1, assuming the default connection of the given manifold by solving the ordinary differential equation\n\nfracd^2dt^2 p^k + Γ^k_ij fracddt p_i fracddt p_j = 0\n\nwhere Γ^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed. The argument solver follows the OrdinaryDiffEq conventions. kwargs... specify keyword arguments that will be passed to OrdinaryDiffEq.solve.\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\nnote: Note\nThis function only works when OrdinaryDiffEq.jl is loaded withusing OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"manifolds/connection.html#connections_charts","page":"Connection manifold","title":"Charts and bases of vector spaces","text":"","category":"section"},{"location":"manifolds/connection.html","page":"Connection manifold","title":"Connection manifold","text":"All connection-related functions take a basis of a vector space as one of the arguments. This is needed because generally there is no way to define these functions without referencing a basis. In some cases there is no need to be explicit about this basis, and then for example a DefaultOrthonormalBasis object can be used. In cases where being explicit about these bases is needed, for example when using multiple charts, a basis can be specified, for example using induced_basis.","category":"page"},{"location":"index.html#Manifolds","page":"Home","title":"Manifolds","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package Manifolds aims to provide a library of manifolds to be used within your project. The implemented manifolds are accompanied by their mathematical formulae.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The manifolds are implemented using the interface for manifolds given in ManifoldsBase.jl. You can use that interface to implement your own software on manifolds, such that all manifolds based on that interface can be used within your code.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For more information, see the About section.","category":"page"},{"location":"index.html#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To install the package just type","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add Manifolds","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then you can directly start, for example to stop half way from the north pole on the Sphere to a point on the the equator, you can generate the shortest_geodesic. It internally employs log and exp.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Manifolds\nM = Sphere(2)\nγ = shortest_geodesic(M, [0., 0., 1.], [0., 1., 0.])\nγ(0.5)","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use Manifolds.jl in your work, please cite the following","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@online{2106.08777,\n    Author = {Seth D. Axen and Mateusz Baran and Ronny Bergmann and Krzysztof Rzecki},\n    Title = {Manifolds.jl: An Extensible Julia Framework for Data Analysis on Manifolds},\n    Year = {2021},\n    Eprint = {2106.08777},\n    Eprinttype = {arXiv},\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To refer to a certain version we recommend to also cite for example","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@softawre{manifoldsjl-zenodo-mostrecent,\n  Author = {Seth D. Axen and Mateusz Baran and Ronny Bergmann},\n  Title = {Manifolds.jl},\n  Doi = {10.5281/ZENODO.4292129},\n  Url = {https://zenodo.org/record/4292129},\n  Publisher = {Zenodo},\n  Year = {2021},\n  Copyright = {MIT License}\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"for the most recent version or a corresponding version specific DOI, see the list of all versions. Note that both citations are in BibLaTeX format.","category":"page"},{"location":"manifolds/lorentz.html#Lorentzian-Manifold","page":"Lorentzian manifold","title":"Lorentzian Manifold","text":"","category":"section"},{"location":"manifolds/lorentz.html","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"The Lorentz manifold is a pseudo-Riemannian manifold. It is named after the Dutch physicist Hendrik Lorentz (1853–1928). The default LorentzMetric is the MinkowskiMetric named after the German mathematician Hermann Minkowski (1864–1909).","category":"page"},{"location":"manifolds/lorentz.html","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"Within Manifolds.jl it is used as the embedding of the Hyperbolic space.","category":"page"},{"location":"manifolds/lorentz.html","page":"Lorentzian manifold","title":"Lorentzian manifold","text":"Modules = [Manifolds]\nPages = [\"Lorentz.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/lorentz.html#Manifolds.Lorentz","page":"Lorentzian manifold","title":"Manifolds.Lorentz","text":"Lorentz{N} = MetricManifold{Euclidean{N,ℝ},LorentzMetric}\n\nThe Lorentz manifold (or Lorentzian) is a pseudo-Riemannian manifold.\n\nConstructor\n\nLorentz(n[, metric=MinkowskiMetric()])\n\nGenerate the Lorentz manifold of dimension n with the LorentzMetric m, which is by default set to the MinkowskiMetric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz.html#Manifolds.LorentzMetric","page":"Lorentzian manifold","title":"Manifolds.LorentzMetric","text":"LorentzMetric <: AbstractMetric\n\nAbstract type for Lorentz metrics, which have a single time dimension. These metrics assume the spacelike convention with the time dimension being last, giving the signature (+++-).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz.html#Manifolds.MinkowskiMetric","page":"Lorentzian manifold","title":"Manifolds.MinkowskiMetric","text":"MinkowskiMetric <: LorentzMetric\n\nAs a special metric of signature  (+++-), i.e. a LorentzMetric, see minkowski_metric for the formula.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/lorentz.html#Manifolds.minkowski_metric-Tuple{Any, Any}","page":"Lorentzian manifold","title":"Manifolds.minkowski_metric","text":"minkowski_metric(a,b)\n\nCompute the minkowski metric on mathbb R^n is given by\n\nab_mathrmM = -a_nb_n +\ndisplaystylesum_k=1^n-1 a_kb_k\n\n\n\n\n\n","category":"method"},{"location":"misc/internals.html#Internal-documentation","page":"Internals","title":"Internal documentation","text":"","category":"section"},{"location":"misc/internals.html","page":"Internals","title":"Internals","text":"This page documents the internal types and methods of Manifolds.jl's that might be of use for writing your own manifold.","category":"page"},{"location":"misc/internals.html#Functions","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"misc/internals.html","page":"Internals","title":"Internals","text":"Manifolds.eigen_safe\nManifolds.isnormal\nManifolds.log_safe\nManifolds.log_safe!\nManifolds.mul!_safe\nManifolds.nzsign\nManifolds.realify\nManifolds.realify!\nManifolds.select_from_tuple\nManifolds.unrealify!\nManifolds.usinc\nManifolds.usinc_from_cos\nManifolds.vec2skew!\nManifolds.ziptuples","category":"page"},{"location":"misc/internals.html#Manifolds.eigen_safe","page":"Internals","title":"Manifolds.eigen_safe","text":"eigen_safe(x)\n\nCompute the eigendecomposition of x. If x is a StaticMatrix, it is converted to a Matrix before the decomposition.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.isnormal","page":"Internals","title":"Manifolds.isnormal","text":"isnormal(x; kwargs...) -> Bool\n\nCheck if the matrix or number x is normal, that is, if it commutes with its adjoint:\n\nx x^mathrmH = x^mathrmH x\n\nBy default, this is an equality check. Provide kwargs for isapprox to perform an approximate check.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.log_safe","page":"Internals","title":"Manifolds.log_safe","text":"log_safe(x)\n\nCompute the matrix logarithm of x. If x is a StaticMatrix, it is converted to a Matrix before computing the log.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.log_safe!","page":"Internals","title":"Manifolds.log_safe!","text":"log_safe!(y, x)\n\nCompute the matrix logarithm of x. If the eltype of y is real, then the imaginary part of x is ignored, and a DomainError is raised if real(x) has no real logarithm.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.mul!_safe","page":"Internals","title":"Manifolds.mul!_safe","text":"mul!_safe(Y, A, B) -> Y\n\nCall mul! safely, that is, A and/or B are permitted to alias with Y.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.nzsign","page":"Internals","title":"Manifolds.nzsign","text":"nzsign(z[, absz])\n\nCompute a modified sign(z) that is always nonzero, i.e. where\n\noperatorname(nzsign)(z) = begincases\n    1  textif  z = 0\n    fraczz  textotherwise\nendcases\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.realify","page":"Internals","title":"Manifolds.realify","text":"realify(X::AbstractMatrix{T𝔽}, 𝔽::AbstractNumbers) -> Y::AbstractMatrix{<:Real}\n\nGiven a matrix X  𝔽^n  n, compute Y  ℝ^m  m, where m = n operatornamedim_𝔽, and operatornamedim_𝔽 is the real_dimension of the number field 𝔽, using the map ϕ colon X  Y, that preserves the matrix product, so that for all CD  𝔽^n  n,\n\nϕ(C) ϕ(D) = ϕ(CD)\n\nSee realify! for an in-place version, and unrealify! to compute the inverse of ϕ.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.realify!","page":"Internals","title":"Manifolds.realify!","text":"realify!(Y::AbstractMatrix{<:Real}, X::AbstractMatrix{T𝔽}, 𝔽::AbstractNumbers)\n\nIn-place version of realify.\n\n\n\n\n\nrealify!(Y::AbstractMatrix{<:Real}, X::AbstractMatrix{<:Complex}, ::typeof(ℂ))\n\nGiven a complex matrix X = A + iB  ℂ^n  n, compute its realified matrix Y  ℝ^2n  2n, written where\n\nY = beginpmatrixA  -B  B  A endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.select_from_tuple","page":"Internals","title":"Manifolds.select_from_tuple","text":"select_from_tuple(t::NTuple{N, Any}, positions::Val{P})\n\nSelects elements of tuple t at positions specified by the second argument. For example select_from_tuple((\"a\", \"b\", \"c\"), Val((3, 1, 1))) returns (\"c\", \"a\", \"a\").\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.unrealify!","page":"Internals","title":"Manifolds.unrealify!","text":"unrealify!(X::AbstractMatrix{T𝔽}, Y::AbstractMatrix{<:Real}, 𝔽::AbstractNumbers[, n])\n\nGiven a real matrix Y  ℝ^m  m, where m = n operatornamedim_𝔽, and operatornamedim_𝔽 is the real_dimension of the number field 𝔽, compute in-place its equivalent matrix X  𝔽^n  n. Note that this function does not check that Y has a valid structure to be un-realified.\n\nSee realify! for the inverse of this function.\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.usinc","page":"Internals","title":"Manifolds.usinc","text":"usinc(θ::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(θ) = fracsin(θ)θ. This is equivalent to sinc(θ/π).\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.usinc_from_cos","page":"Internals","title":"Manifolds.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(θ) = fracsin(θ)θ, computed from x = cos(θ).\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.vec2skew!","page":"Internals","title":"Manifolds.vec2skew!","text":"vec2skew!(X, v, k)\n\ncreate a skew symmetric matrix inplace in X of size ktimes k from a vector v, for example for v=[1,2,3] and k=3 this yields\n\n[  0  1  2;\n  -1  0  3;\n  -2 -3  0\n]\n\n\n\n\n\n","category":"function"},{"location":"misc/internals.html#Manifolds.ziptuples","page":"Internals","title":"Manifolds.ziptuples","text":"ziptuples(a, b[, c[, d[, e]]])\n\nZips tuples a, b, and remaining in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/sphere.html#Sphere-and-unit-norm-arrays","page":"Sphere","title":"Sphere and unit norm arrays","text":"","category":"section"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"AbstractSphere","category":"page"},{"location":"manifolds/sphere.html#Manifolds.AbstractSphere","page":"Sphere","title":"Manifolds.AbstractSphere","text":"AbstractSphere{𝔽} <: AbstractDecoratorManifold{𝔽}\n\nAn abstract type to represent a unit sphere that is represented isometrically in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"The classical sphere, i.e. unit norm (real- or complex-valued) vectors can be generated as usual: to create the 2-dimensional sphere (in ℝ^3), use Sphere(2) and Sphere(2,ℂ), respectively.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"Sphere","category":"page"},{"location":"manifolds/sphere.html#Manifolds.Sphere","page":"Sphere","title":"Manifolds.Sphere","text":"Sphere{n,𝔽} <: AbstractSphere{𝔽}\n\nThe (unit) sphere manifold 𝕊^n is the set of all unit norm vectors in 𝔽^n+1. The sphere is represented in the embedding, i.e.\n\n𝕊^n = bigl p in 𝔽^n+1 big lVert p rVert = 1 bigr\n\nwhere 𝔽inℝℂℍ. Note that compared to the ArraySphere, here the argument n of the manifold is the dimension of the manifold, i.e. 𝕊^n  𝔽^n+1, nin ℕ.\n\nThe tangent space at point p is given by\n\nT_p𝕊^n = bigl X  𝔽^n+1  Re(pX) = 0 bigr \n\nwhere 𝔽inℝℂℍ and cdotcdot denotes the inner product in the embedding 𝔽^n+1.\n\nFor 𝔽=ℂ, the manifold is the complex sphere, written ℂ𝕊^n, embedded in ℂ^n+1. ℂ𝕊^n is the complexification of the real sphere 𝕊^2n+1. Likewise, the quaternionic sphere ℍ𝕊^n is the quaternionification of the real sphere 𝕊^4n+3. Consequently, ℂ𝕊^0 is equivalent to 𝕊^1 and Circle, while ℂ𝕊^1 and ℍ𝕊^0 are equivalent to 𝕊^3, though with different default representations.\n\nThis manifold is modeled as a special case of the more general case, i.e. as an embedded manifold to the Euclidean, and several functions like the inner product and the zero_vector are inherited from the embedding.\n\nConstructor\n\nSphere(n[, field=ℝ])\n\nGenerate the (real-valued) sphere 𝕊^n  ℝ^n+1, where field can also be used to generate the complex- and quaternionic-valued sphere.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"For the higher-dimensional arrays, for example unit (Frobenius) norm matrices, the manifold is generated using the size of the matrix. To create the unit sphere of 32 real-valued matrices, write ArraySphere(3,2) and the complex case is done – as for the Euclidean case – with an keyword argument ArraySphere(3,2; field = ℂ). This case also covers the classical sphere as a special case, but you specify the size of the vectors/embedding instead: The 2-sphere can here be generated ArraySphere(3).","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"ArraySphere","category":"page"},{"location":"manifolds/sphere.html#Manifolds.ArraySphere","page":"Sphere","title":"Manifolds.ArraySphere","text":"ArraySphere{T<:Tuple,𝔽} <: AbstractSphere{𝔽}\n\nThe (unit) sphere manifold 𝕊^n₁n₂nᵢ is the set of all unit (Frobenius) norm elements of 𝔽^n₁n₂nᵢ, where 𝔽\\in{ℝ,ℂ,ℍ}. The generalized sphere is represented in the embedding, and supports arbitrary sized arrays or in other words arbitrary tensors of unit norm. The set formally reads\n\n𝕊^n_1 n_2  n_i = bigl p in 𝔽^n_1 n_2  n_i big lVert p rVert = 1 bigr\n\nwhere 𝔽inℝℂℍ. Setting i=1 and 𝔽=ℝ  this  simplifies to unit vectors in ℝ^n, see Sphere for this special case. Note that compared to this classical case, the argument for the generalized case here is given by the dimension of the embedding. This means that Sphere(2) and ArraySphere(3) are the same manifold.\n\nThe tangent space at point p is given by\n\nT_p 𝕊^n_1 n_2  n_i = bigl X  𝔽^n_1 n_2  n_i  Re(pX) = 0 bigr \n\nwhere 𝔽inℝℂℍ and cdotcdot denotes the (Frobenius) inner product in the embedding 𝔽^n_1 n_2  n_i.\n\nThis manifold is modeled as an embedded manifold to the Euclidean, i.e. several functions like the inner product and the zero_vector are inherited from the embedding.\n\nConstructor\n\nArraySphere(n₁,n₂,...,nᵢ; field=ℝ)\n\nGenerate sphere in 𝔽^n_1 n_2  n_i, where 𝔽 defaults to the real-valued case ℝ.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"There is also one atlas available on the sphere.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"Manifolds.StereographicAtlas","category":"page"},{"location":"manifolds/sphere.html#Manifolds.StereographicAtlas","page":"Sphere","title":"Manifolds.StereographicAtlas","text":"StereographicAtlas()\n\nThe stereographic atlas of S^n with two charts: one with the singular point (-1, 0, ..., 0) (called :north) and one with the singular point (1, 0, ..., 0) (called :south).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html#Functions-on-unit-spheres","page":"Sphere","title":"Functions on unit spheres","text":"","category":"section"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"Modules = [Manifolds]\nPages = [\"manifolds/Sphere.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/sphere.html#Base.exp-Tuple{AbstractSphere, Vararg{Any, N} where N}","page":"Sphere","title":"Base.exp","text":"exp(M::AbstractSphere, p, X)\n\nCompute the exponential map from p in the tangent direction X on the AbstractSphere M by following the great arc eminating from p in direction X.\n\nexp_p X = cos(lVert X rVert_p)p + sin(lVert X rVert_p)fracXlVert X rVert_p\n\nwhere lVert X rVert_p is the norm on the tangent space at p of the AbstractSphere M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Base.log-Tuple{AbstractSphere, Vararg{Any, N} where N}","page":"Sphere","title":"Base.log","text":"log(M::AbstractSphere, p, q)\n\nCompute the logarithmic map on the AbstractSphere M, i.e. the tangent vector, whose geodesic starting from p reaches q after time 1. The formula reads for x  -y\n\nlog_p q = d_𝕊(pq) fracq-Re(pq) plVert q-Re(pq) p rVert_2\n\nand a deterministic choice from the set of tangent vectors is returned if x=-y, i.e. for opposite points.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.local_metric-Union{Tuple{n}, Tuple{Sphere{n, ℝ}, Any, DefaultOrthonormalBasis}} where n","page":"Sphere","title":"Manifolds.local_metric","text":"local_metric(M::Sphere{n}, p, ::DefaultOrthonormalBasis)\n\nreturn the local representation of the metric in a DefaultOrthonormalBasis, namely the diagonal matrix of size nn with ones on the diagonal, since the metric is obtained from the embedding by restriction to the tangent space T_pmathcal M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.uniform_distribution-Union{Tuple{n}, Tuple{Sphere{n, ℝ}, Any}} where n","page":"Sphere","title":"Manifolds.uniform_distribution","text":"uniform_distribution(M::Sphere{n,ℝ}, p) where {n}\n\nUniform distribution on given Sphere M. Generated points will be of similar type as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_point-Tuple{AbstractSphere, Any}","page":"Sphere","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractSphere, p; kwargs...)\n\nCheck whether p is a valid point on the AbstractSphere M, i.e. is a point in the embedding of unit length. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_vector-Tuple{AbstractSphere, Any, Any}","page":"Sphere","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractSphere, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the AbstractSphere M, i.e. after check_point(M,p), X has to be of same dimension as p and orthogonal to p. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.distance-Tuple{AbstractSphere, Any, Any}","page":"Sphere","title":"ManifoldsBase.distance","text":"distance(M::AbstractSphere, p, q)\n\nCompute the geodesic distance betweeen p and q on the AbstractSphere M. The formula is given by the (shorter) great arc length on the (or a) great circle both p and q lie on.\n\nd_𝕊(pq) = arccos(Re(pq))\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.get_coordinates-Tuple{AbstractSphere{ℝ}, Any, Any, DefaultOrthonormalBasis}","page":"Sphere","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractSphere{ℝ}, p, X, B::DefaultOrthonormalBasis)\n\nRepresent the tangent vector X at point p from the AbstractSphere M in an orthonormal basis by rotating the hyperplane containing X to a hyperplane whose normal is the x-axis.\n\nGiven q = p λ + x, where λ = operatornamesgn(x p), and  _mathrmF denotes the Frobenius inner product, the formula for Y is\n\nbeginpmatrix0  Yendpmatrix = X - qfrac2 q X_mathrmFq q_mathrmF\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.get_vector-Tuple{AbstractSphere{ℝ}, Any, Any, DefaultOrthonormalBasis}","page":"Sphere","title":"ManifoldsBase.get_vector","text":"get_vector(M::AbstractSphere{ℝ}, p, X, B::DefaultOrthonormalBasis)\n\nConvert a one-dimensional vector of coefficients X in the basis B of the tangent space at p on the AbstractSphere M to a tangent vector Y at p by rotating the hyperplane containing X, whose normal is the x-axis, to the hyperplane whose normal is p.\n\nGiven q = p λ + x, where λ = operatornamesgn(x p), and  _mathrmF denotes the Frobenius inner product, the formula for Y is\n\nY = X - qfrac2 leftlangle q beginpmatrix0  Xendpmatrixrightrangle_mathrmFq q_mathrmF\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.injectivity_radius-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractSphere[, p])\n\nReturn the injectivity radius for the AbstractSphere M, which is globally π.\n\ninjectivity_radius(M::Sphere, x, ::ProjectionRetraction)\n\nReturn the injectivity radius for the ProjectionRetraction on the AbstractSphere, which is globally fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.inverse_retract-Tuple{AbstractSphere, Any, Any, ProjectionInverseRetraction}","page":"Sphere","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractSphere, p, q, ::ProjectionInverseRetraction)\n\nCompute the inverse of the projection based retraction on the AbstractSphere M, i.e. rearranging p+X = qlVert p+XrVert_2 yields since Re(pX) = 0 and when d_𝕊^2(pq)  fracπ2 that\n\noperatornameretr_p^-1(q) = fracqRe(p q) - p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.manifold_dimension-Tuple{AbstractSphere}","page":"Sphere","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractSphere)\n\nReturn the dimension of the AbstractSphere M, respectively i.e. the dimension of the embedding -1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.parallel_transport_to-Tuple{AbstractSphere, Any, Any, Any, Any}","page":"Sphere","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::AbstractSphere, p, X, q)\n\nCompute the parallel transport on the Sphere of the tangent vector X at p to q, provided, the geodesic between p and q is unique. The formula reads\n\nP_pq(X) = X - fracRe(log_p qX_p)d^2_𝕊(pq)\nbigl(log_p q + log_q p bigr)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.project-Tuple{AbstractSphere, Any, Any}","page":"Sphere","title":"ManifoldsBase.project","text":"project(M::AbstractSphere, p, X)\n\nProject the point X onto the tangent space at p on the Sphere M.\n\noperatornameproj_p(X) = X - Re(p X)p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.project-Tuple{AbstractSphere, Any}","page":"Sphere","title":"ManifoldsBase.project","text":"project(M::AbstractSphere, p)\n\nProject the point p from the embedding onto the Sphere M.\n\noperatornameproj(p) = fracplVert p rVert\n\nwhere lVertcdotrVert denotes the usual 2-norm for vectors if m=1 and the Frobenius norm for the case m1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.representation_size-Union{Tuple{ArraySphere{N, 𝔽} where 𝔽}, Tuple{N}} where N","page":"Sphere","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractSphere)\n\nReturn the size points on the AbstractSphere M are represented as, i.e., the representation size of the embedding.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.retract-Tuple{AbstractSphere, Any, Any, ProjectionRetraction}","page":"Sphere","title":"ManifoldsBase.retract","text":"retract(M::AbstractSphere, p, X, ::ProjectionRetraction)\n\nCompute the retraction that is based on projection, i.e.\n\noperatornameretr_p(X) = fracp+XlVert p+X rVert_2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Statistics.mean-Tuple{AbstractSphere, Vararg{Any, N} where N}","page":"Sphere","title":"Statistics.mean","text":"mean(\n    S::AbstractSphere,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Visualization-on-Sphere{2,ℝ}","page":"Sphere","title":"Visualization on Sphere{2,ℝ}","text":"","category":"section"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"You can visualize both points and tangent vectors on the sphere.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"note: Note\nThere seems to be no unified way to draw spheres in the backends of Plots.jl. This recipe currently uses the seriestype wireframe and surface, which does not yet work with the default backend GR.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"In general you can plot the surface of the hyperboloid either as wireframe (wireframe=true) additionally specifying wires (or wires_x and wires_y) to change the density of the wires and a wireframe_color for their color. The same holds for the plot as a surface (which is false by default) and its surface_resolution (or surface_resolution_lat or surface_resolution_lon) and a surface_color.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"using Manifolds, Plots\npyplot()\nM = Sphere(2)\npts = [ [1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0] ]\nscene = plot(M, pts; wireframe_color=colorant\"#CCCCCC\", markersize=10)","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"which scatters our points. We can also draw connecting geodesics, which here is a geodesic triangle. Here we discretize each geodesic with 100 points along the geodesic. The default value is geodesic_interpolation=-1 which switches to scatter plot of the data.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"plot!(scene, M, pts; wireframe=false, geodesic_interpolation=100, linewidth=2)","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"And we can also add tangent vectors, for example tangents pointing towards the geometric center of given points.","category":"page"},{"location":"manifolds/sphere.html","page":"Sphere","title":"Sphere","text":"pts2 =  [ [1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0] ]\np3 = 1/sqrt(3) .* [1.0, -1.0, 1.0]\nvecs = log.(Ref(M), pts2, Ref(p3))\nplot!(scene, M, pts2, vecs; wireframe = false, linewidth=1.5)","category":"page"},{"location":"manifolds/graph.html#Graph-manifold","page":"Graph manifold","title":"Graph manifold","text":"","category":"section"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"For a given graph G(VE) implemented using Graphs.jl, the GraphManifold models a PowerManifold either on the nodes or edges of the graph, depending on the GraphManifoldType. i.e., it's either a mathcal M^lvert V rvert for the case of a vertex manifold or a mathcal M^lvert E rvert for the case of a edge manifold.","category":"page"},{"location":"manifolds/graph.html#Example","page":"Graph manifold","title":"Example","text":"","category":"section"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"To make a graph manifold over ℝ^2 with three vertices and two edges, one can use","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"using Manifolds\nusing Graphs\nM = Euclidean(2)\np = [[1., 4.], [2., 5.], [3., 6.]]\nq = [[4., 5.], [6., 7.], [8., 9.]]\nx = [[6., 5.], [4., 3.], [2., 8.]]\nG = SimpleGraph(3)\nadd_edge!(G, 1, 2)\nadd_edge!(G, 2, 3)\nN = GraphManifold(G, M, VertexManifold())","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"It supports all AbstractPowerManifold  operations (it is based on NestedPowerRepresentation) and furthermore it is possible to compute a graph logarithm:","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"using Manifolds\nusing Graphs\nM = Euclidean(2)\np = [[1., 4.], [2., 5.], [3., 6.]]\nq = [[4., 5.], [6., 7.], [8., 9.]]\nx = [[6., 5.], [4., 3.], [2., 8.]]\nG = SimpleGraph(3)\nadd_edge!(G, 1, 2)\nadd_edge!(G, 2, 3)\nN = GraphManifold(G, M, VertexManifold())","category":"page"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"incident_log(N, p)","category":"page"},{"location":"manifolds/graph.html#Types-and-functions","page":"Graph manifold","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/graph.html","page":"Graph manifold","title":"Graph manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/GraphManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/graph.html#Manifolds.EdgeManifold","page":"Graph manifold","title":"Manifolds.EdgeManifold","text":"EdgeManifoldManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the edges.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.GraphManifold","page":"Graph manifold","title":"Manifolds.GraphManifold","text":"GraphManifold{G,𝔽,M,T} <: AbstractPowerManifold{𝔽,M,NestedPowerRepresentation}\n\nBuild a manifold, that is a PowerManifold of the AbstractManifold  M either on the edges or vertices of a graph G depending on the GraphManifoldType T.\n\nFields\n\nG is an AbstractSimpleGraph\nM is a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.GraphManifoldType","page":"Graph manifold","title":"Manifolds.GraphManifoldType","text":"GraphManifoldType\n\nThis type represents the type of data on the graph that the GraphManifold represents.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.VertexManifold","page":"Graph manifold","title":"Manifolds.VertexManifold","text":"VectexGraphManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the vertices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.incident_log-Tuple{GraphManifold{var\"#s108\", 𝔽, var\"#s107\", VertexManifold} where {𝔽, var\"#s108\"<:Graphs.AbstractGraph, var\"#s107\"<:AbstractManifold{𝔽}}, Any}","page":"Graph manifold","title":"Manifolds.incident_log","text":"incident_log(M::GraphManifold, x)\n\nReturn the tangent vector on the (vertex) GraphManifold, where at each node the sum of the logs to incident nodes is computed. For a SimpleGraph, an egde is interpreted as double edge in the corresponding SimpleDiGraph\n\nIf the internal graph is a SimpleWeightedGraph the weighted sum of the tangent vectors is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.check_point-Tuple{GraphManifold, Vararg{Any, N} where N}","page":"Graph manifold","title":"ManifoldsBase.check_point","text":"check_point(M::GraphManifold, p)\n\nCheck whether p is a valid point on the GraphManifold, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of p passes the check_point test for the base manifold M.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.check_vector-Tuple{GraphManifold, Vararg{Any, N} where N}","page":"Graph manifold","title":"ManifoldsBase.check_vector","text":"check_vector(M::GraphManifold, p, X; kwargs...)\n\nCheck whether p is a valid point on the GraphManifold, and X it from its tangent space, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of X together with its corresponding entry of p passes the check_vector test for the base manifold M.manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{var\"#s108\", 𝔽, var\"#s107\", EdgeManifold} where {𝔽, var\"#s108\"<:Graphs.AbstractGraph, var\"#s107\"<:AbstractManifold{𝔽}}}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,𝔽,M,EdgeManifold})\n\nreturns the manifold dimension of the GraphManifold N on the edges of a graph G=(VE), i.e.\n\ndim(mathcal N) = lvert E rvert dim(mathcal M)\n\nwhere mathcal M is the manifold of the data on the edges.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{var\"#s108\", 𝔽, var\"#s107\", VertexManifold} where {𝔽, var\"#s108\"<:Graphs.AbstractGraph, var\"#s107\"<:AbstractManifold{𝔽}}}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,𝔽,M,VertexManifold})\n\nreturns the manifold dimension of the GraphManifold N on the vertices of a graph G=(VE), i.e.\n\ndim(mathcal N) = lvert V rvert dim(mathcal M)\n\nwhere mathcal M is the manifold of the data on the nodes.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Euclidean-space","page":"Euclidean","title":"Euclidean space","text":"","category":"section"},{"location":"manifolds/euclidean.html","page":"Euclidean","title":"Euclidean","text":"The Euclidean space ℝ^n is a simple model space, since it has curvature constantly zero everywhere; hence, nearly all operations simplify. The easiest way to generate an Euclidean space is to use a field, i.e. AbstractNumbers, e.g. to create the ℝ^n or ℝ^ntimes n you can simply type M = ℝ^n or ℝ^(n,n), respectively.","category":"page"},{"location":"manifolds/euclidean.html","page":"Euclidean","title":"Euclidean","text":"Modules = [Manifolds]\nPages = [\"manifolds/Euclidean.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/euclidean.html#Manifolds.Euclidean","page":"Euclidean","title":"Manifolds.Euclidean","text":"Euclidean{T<:Tuple,𝔽} <: AbstractManifold{𝔽}\n\nEuclidean vector space.\n\nConstructor\n\nEuclidean(n)\n\nGenerate the n-dimensional vector space ℝ^n.\n\nEuclidean(n₁,n₂,...,nᵢ; field=ℝ)\n𝔽^(n₁,n₂,...,nᵢ) = Euclidean(n₁,n₂,...,nᵢ; field=𝔽)\n\nGenerate the vector space of k = n_1 cdot n_2 cdot  cdot n_i values, i.e. the manifold 𝔽^n_1 n_2  n_i, 𝔽inℝℂ, whose elements are interpreted as n_1  n_2    n_i arrays. For i=2 we obtain a matrix space. The default field=ℝ can also be set to field=ℂ. The dimension of this space is k dim_ℝ 𝔽, where dim_ℝ 𝔽 is the real_dimension of the field 𝔽.\n\nEuclidean(; field=ℝ)\n\nGenerate the 1D Euclidean manifold for an ℝ-, ℂ-valued  real- or complex-valued immutable values (in contrast to 1-element arrays from the constructor above).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Manifolds.EuclideanMetric","page":"Euclidean","title":"Manifolds.EuclideanMetric","text":"EuclideanMetric <: RiemannianMetric\n\nA general type for any manifold that employs the Euclidean Metric, for example the Euclidean manifold itself, or the Sphere, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).\n\nSince the metric is independent of the field type, this metric is also used for the Hermitian metrics, i.e. metrics that are analogous to the EuclideanMetric but where the field type of the manifold is ℂ.\n\nThis metric is the default metric for example for the Euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Base.exp-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"Base.exp","text":"exp(M::Euclidean, p, X)\n\nCompute the exponential map on the Euclidean manifold M from p in direction X, which in this case is just\n\nexp_p X = p + X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Base.log-Tuple{Euclidean, Vararg{Any, N} where N}","page":"Euclidean","title":"Base.log","text":"log(M::Euclidean, p, q)\n\nCompute the logarithmic map on the Euclidean M from p to q, which in this case is just\n\nlog_p q = q-p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#LinearAlgebra.norm-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"LinearAlgebra.norm","text":"norm(M::Euclidean, p, X)\n\nCompute the norm of a tangent vector X at p on the Euclidean M, i.e. since every tangent space can be identified with M itself in this case, just the (Frobenius) norm of X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.distance-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"ManifoldsBase.distance","text":"distance(M::Euclidean, p, q)\n\nCompute the Euclidean distance between two points on the Euclidean manifold M, i.e. for vectors it's just the norm of the difference, for matrices and higher order arrays, the matrix and ternsor Frobenius norm, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.embed-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"ManifoldsBase.embed","text":"embed(M::Euclidean, p, X)\n\nEmbed the tangent vector X at point p in M. Equivalent to an identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.embed-Tuple{Euclidean, Any}","page":"Euclidean","title":"ManifoldsBase.embed","text":"embed(M::Euclidean, p)\n\nEmbed the point p in M. Equivalent to an identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.injectivity_radius-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Euclidean)\n\nReturn the injectivity radius on the Euclidean M, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.inner-Tuple{Euclidean, Vararg{Any, N} where N}","page":"Euclidean","title":"ManifoldsBase.inner","text":"inner(M::Euclidean, p, X, Y)\n\nCompute the inner product on the Euclidean M, which is just the inner product on the real-valued or complex valued vector space of arrays (or tensors) of size n_1  n_2       n_i, i.e.\n\ng_p(XY) = sum_k  I overlineX_k Y_k\n\nwhere I is the set of vectors k  ℕ^i, such that for all\n\ni  j  i it holds 1  k_j  n_j and overlinecdot denotes the complex conjugate.\n\nFor the special case of i  2, i.e. matrices and vectors, this simplifies to\n\ng_p(XY) = X^mathrmHY\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.manifold_dimension-Union{Tuple{Euclidean{N, 𝔽}}, Tuple{𝔽}, Tuple{N}} where {N, 𝔽}","page":"Euclidean","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Euclidean)\n\nReturn the manifold dimension of the Euclidean M, i.e. the product of all array dimensions and the real_dimension of the underlying number system.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.parallel_transport_along-Tuple{Euclidean, Any, Any, AbstractVector{T} where T}","page":"Euclidean","title":"ManifoldsBase.parallel_transport_along","text":"parallel_transport_along(M::Euclidean, p, X, c)\n\nthe parallel transport on Euclidean is the identiy, i.e. returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.parallel_transport_direction-Tuple{Euclidean, Any, Any, Any}","page":"Euclidean","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::Euclidean, p, X, d)\n\nthe parallel transport on Euclidean is the identiy, i.e. returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.parallel_transport_to-Tuple{Euclidean, Any, Any, Any}","page":"Euclidean","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::Euclidean, p, X, q)\n\nthe parallel transport on Euclidean is the identiy, i.e. returns X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project-Tuple{Euclidean, Any, Any}","page":"Euclidean","title":"ManifoldsBase.project","text":"project(M::Euclidean, p, X)\n\nProject an arbitrary vector X into the tangent space of a point p on the Euclidean M, which is just the identity, since any tangent space of M can be identified with all of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project-Tuple{Euclidean, Any}","page":"Euclidean","title":"ManifoldsBase.project","text":"project(M::Euclidean, p)\n\nProject an arbitrary point p onto the Euclidean manifold M, which is of course just the identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.representation_size-Union{Tuple{Euclidean{N, 𝔽} where 𝔽}, Tuple{N}} where N","page":"Euclidean","title":"ManifoldsBase.representation_size","text":"representation_size(M::Euclidean)\n\nReturn the array dimensions required to represent an element on the Euclidean M, i.e. the vector of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.vector_transport_to-Tuple{Euclidean, Any, Any, Any, AbstractVectorTransportMethod}","page":"Euclidean","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Euclidean, p, X, q, ::AbstractVectorTransportMethod)\n\nTransport the vector X from the tangent space at p to the tangent space at q on the Euclidean M, which simplifies to the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.zero_vector-Tuple{Euclidean, Vararg{Any, N} where N}","page":"Euclidean","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Euclidean, x)\n\nReturn the zero vector in the tangent space of x on the Euclidean M, which here is just a zero filled array the same size as x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#Multinomial-symmetric-matrices","page":"Multinomial symmetric matrices","title":"Multinomial symmetric matrices","text":"","category":"section"},{"location":"manifolds/multinomialsymmetric.html","page":"Multinomial symmetric matrices","title":"Multinomial symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/MultinomialSymmetric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/multinomialsymmetric.html#Manifolds.MultinomialSymmetric","page":"Multinomial symmetric matrices","title":"Manifolds.MultinomialSymmetric","text":"MultinomialSymmetric{n} <: AbstractMultinomialDoublyStochastic{N}\n\nThe multinomial symmetric matrices manifold consists of all symmetric nn matrices with positive entries such that each column sums to one, i.e.\n\nbeginaligned\nmathcalSP(n) coloneqq biglp  ℝ^nn big p_ij  0 text for all  i=1n j=1m\n p^mathrmT = p\n pmathbf1_n = mathbf1_n\nbigr\nendaligned\n\nwhere mathbf1_n is the vector of length n containing ones.\n\nIt is modeled as IsIsometricEmbeddedManifold. via the AbstractMultinomialDoublyStochastic type, since it shares a few functions also with AbstractMultinomialDoublyStochastic, most and foremost projection of a point from the embedding onto the manifold.\n\nThe tangent space can be written as\n\nT_pmathcalSP(n) coloneqq bigl\nX  ℝ^nn big X = X^mathrmT text and \nXmathbf1_n = mathbf0_n\nbigr\n\nwhere mathbf0_n is the vector of length n containing zeros.\n\nMore details can be found in Section IV[DouikHassibi2019].\n\nConstructor\n\nMultinomialSymmetric(n)\n\nGenerate the manifold of matrices mathbb R^nn that are doubly stochastic and symmetric.\n\n[DouikHassibi2019]: A. Douik, B. Hassibi: AbstractManifold Optimization Over the Set of Doubly Stochastic Matrices: A Second-Order Geometry, IEEE Transactions on Signal Processing 67(22), pp. 5761–5774, 2019. doi: 10.1109/tsp.2019.2946024, arXiv: 1802.02628.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.check_point-Union{Tuple{n}, Tuple{MultinomialSymmetric{n}, Any}} where n","page":"Multinomial symmetric matrices","title":"ManifoldsBase.check_point","text":"check_point(M::MultinomialSymmetric, p)\n\nChecks whether p is a valid point on the MultinomialSymmetric(m,n) M, i.e. is a symmetric matrix with positive entries whose rows sum to one.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.check_vector-Union{Tuple{n}, Tuple{MultinomialSymmetric{n}, Any, Any}} where n","page":"Multinomial symmetric matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::MultinomialSymmetric p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialSymmetric M. This means, that p is valid, that X is of correct dimension, symmetric, and sums to zero along any row.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{MultinomialSymmetric{n}}, Tuple{n}} where n","page":"Multinomial symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::MultinomialSymmetric{n}) where {n}\n\nreturns the dimension of the MultinomialSymmetric manifold namely\n\noperatornamedim_mathcalSP(n) = fracn(n-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.project-Tuple{MultinomialSymmetric, Any, Any}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.project","text":"project(M::MultinomialSymmetric{n}, p, Y) where {n}\n\nProject Y onto the tangent space at p on the MultinomialSymmetric M, return the result in X. The formula reads\n\n    operatornameproj_p(Y) = Y - (αmathbf1_n^mathrmT + mathbf1_n α^mathrmT)  p\n\nwhere  denotes the Hadamard or elementwise product and mathbb1_n is the vector of length n containing ones. The two vector α  ℝ^nn is given by solving\n\n    (I_n+p)α =  Ymathbf1\n\nwhere I_n is teh nn unit matrix and mathbf1_n is the vector of length n containing ones.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#ManifoldsBase.retract-Tuple{MultinomialSymmetric, Any, Any, ProjectionRetraction}","page":"Multinomial symmetric matrices","title":"ManifoldsBase.retract","text":"retract(M::MultinomialSymmetric, p, X, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting podotexp(Xp) back onto the manifold, where  are elementwise multiplication and division, respectively. Similarly, exp refers to the elementwise exponentiation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomialsymmetric.html#Literature","page":"Multinomial symmetric matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/centeredmatrices.html#Centered-matrices","page":"Centered matrices","title":"Centered matrices","text":"","category":"section"},{"location":"manifolds/centeredmatrices.html","page":"Centered matrices","title":"Centered matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/CenteredMatrices.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/centeredmatrices.html#Manifolds.CenteredMatrices","page":"Centered matrices","title":"Manifolds.CenteredMatrices","text":"CenteredMatrices{m,n,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe manifold of m  n real-valued or complex-valued matrices whose columns sum to zero, i.e.\n\nbigl p  𝔽^m  n big 1  1 * p = 0  0 bigr\n\nwhere 𝔽  ℝℂ.\n\nConstructor\n\nCenteredMatrices(m, n[, field=ℝ])\n\nGenerate the manifold of m-by-n (field-valued) matrices whose columns sum to zero.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{m}, Tuple{CenteredMatrices{m, n, 𝔽}, Any}} where {m, n, 𝔽}","page":"Centered matrices","title":"ManifoldsBase.check_point","text":"check_point(M::CenteredMatrices{m,n,𝔽}, p; kwargs...)\n\nCheck whether the matrix is a valid point on the CenteredMatrices M, i.e. is an m-by-n matrix whose columns sum to zero.\n\nThe tolerance for the column sums of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{n}, Tuple{m}, Tuple{CenteredMatrices{m, n, 𝔽}, Any, Any}} where {m, n, 𝔽}","page":"Centered matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::CenteredMatrices{m,n,𝔽}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the CenteredMatrices M, i.e. that X is a matrix of size (m, n) whose columns sum to zero and its values are from the correct AbstractNumbers. The tolerance for the column sums of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.manifold_dimension-Union{Tuple{CenteredMatrices{m, n, 𝔽}}, Tuple{𝔽}, Tuple{n}, Tuple{m}} where {m, n, 𝔽}","page":"Centered matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::CenteredMatrices{m,n,𝔽})\n\nReturn the manifold dimension of the CenteredMatrices m-by-n matrix M over the number system 𝔽, i.e.\n\ndim(mathcal M) = (m*n - n) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.project-Tuple{CenteredMatrices, Any, Any}","page":"Centered matrices","title":"ManifoldsBase.project","text":"project(M::CenteredMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the CenteredMatrices M, i.e.\n\noperatornameproj_p(X) = X - beginbmatrix\n1\n\n1\nendbmatrix * c_1 dots c_n\n\nwhere c_i = frac1msum_j=1^m x_ji  for i = 1 dots n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/centeredmatrices.html#ManifoldsBase.project-Tuple{CenteredMatrices, Any}","page":"Centered matrices","title":"ManifoldsBase.project","text":"project(M::CenteredMatrices, p)\n\nProjects p from the embedding onto the CenteredMatrices M, i.e.\n\noperatornameproj_mathcal M(p) = p - beginbmatrix\n1\n\n1\nendbmatrix * c_1 dots c_n\n\nwhere c_i = frac1msum_j=1^m p_ji for i = 1 dots n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Group-manifolds-and-actions","page":"Group manifold","title":"Group manifolds and actions","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Lie groups, groups that are Riemannian manifolds with a smooth binary group operation AbstractGroupOperation, are implemented as AbstractDecoratorManifold and specifying the group operation using the IsGroupManifold or by decorating an existing manifold with a group operation using GroupManifold.","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"The common addition and multiplication group operations of AdditionOperation and MultiplicationOperation are provided, though their behavior may be customized for a specific group.","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"There are short introductions at the beginning of each subsection. They briefly mention what is available with links to more detailed descriptions.","category":"page"},{"location":"manifolds/group.html#Contents","page":"Group manifold","title":"Contents","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Pages = [\"group.md\"]\nDepth = 3","category":"page"},{"location":"manifolds/group.html#Groups","page":"Group manifold","title":"Groups","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"The following operations are available for group manifolds:","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Identity: an allocation-free representation of the identity element of the group.\ninv: get the inverse of a given element.\ncompose: compose two given elements of a group.\nidentity_element get the identity element of the group, in the representation used by other points from the group.","category":"page"},{"location":"manifolds/group.html#Group-manifold","page":"Group manifold","title":"Group manifold","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"GroupManifold adds a group structure to the wrapped manifold. It does not affect metric (or connection) structure of the wrapped manifold, however it can to be further wrapped in MetricManifold to get invariant metrics, or in a ConnectionManifold to equip it with a Cartan-Schouten connection.","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AbstractGroupOperation","page":"Group manifold","title":"Manifolds.AbstractGroupOperation","text":"AbstractGroupOperation\n\nAbstract type for smooth binary operations  on elements of a Lie group mathcalG:\n\n  mathcalG  mathcalG  mathcalG\n\nAn operation can be either defined for a specific group manifold over number system 𝔽 or in general, by defining for an operation Op the following methods:\n\nidentity_element!(::AbstractDecoratorManifold, q, q)\ninv!(::AbstractDecoratorManifold, q, p)\n_compose!(::AbstractDecoratorManifold, x, p, q)\n\nNote that a manifold is connected with an operation by wrapping it with a decorator, AbstractDecoratorManifold using the IsGroupManifold to specify the operation. For a concrete case the concrete wrapper GroupManifold can be used.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.AbstractInvarianceTrait","page":"Group manifold","title":"Manifolds.AbstractInvarianceTrait","text":"AbstractInvarianceTrait <: AbstractTrait\n\nA common supertype for anz AbstractTrait related to metric invariance\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.ActionDirection","page":"Group manifold","title":"Manifolds.ActionDirection","text":"ActionDirection\n\nDirection of action on a manifold, either LeftAction or RightAction.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.GroupExponentialRetraction","page":"Group manifold","title":"Manifolds.GroupExponentialRetraction","text":"GroupExponentialRetraction{D<:ActionDirection} <: AbstractRetractionMethod\n\nRetraction using the group exponential exp_lie \"translated\" to any point on the manifold.\n\nFor more details, see retract.\n\nConstructor\n\nGroupExponentialRetraction(conv::ActionDirection = LeftAction())\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.GroupLogarithmicInverseRetraction","page":"Group manifold","title":"Manifolds.GroupLogarithmicInverseRetraction","text":"GroupLogarithmicInverseRetraction{D<:ActionDirection} <: AbstractInverseRetractionMethod\n\nRetraction using the group logarithm log_lie \"translated\" to any point on the manifold.\n\nFor more details, see inverse_retract.\n\nConstructor\n\nGroupLogarithmicInverseRetraction(conv::ActionDirection = LeftAction())\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.HasBiinvariantMetric","page":"Group manifold","title":"Manifolds.HasBiinvariantMetric","text":"HasBiinvariantMetric <: AbstractInvarianceTrait\n\nSpecify that a certain the metric of a GroupManifold is a bi-invariant metric\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.HasLeftInvariantMetric","page":"Group manifold","title":"Manifolds.HasLeftInvariantMetric","text":"HasLeftInvariantMetric <: AbstractInvarianceTrait\n\nSpecify that a certain the metric of a GroupManifold is a left-invariant metric\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.HasRightInvariantMetric","page":"Group manifold","title":"Manifolds.HasRightInvariantMetric","text":"HasRightInvariantMetric <: AbstractInvarianceTrait\n\nSpecify that a certain the metric of a GroupManifold is a right-invariant metric\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.Identity","page":"Group manifold","title":"Manifolds.Identity","text":"Identity{O<:AbstractGroupOperation}\n\nRepresent the group identity element e  mathcalG on a Lie group mathcal G with AbstractGroupOperation of type O.\n\nSimilar to the philosophy that points are agnostic of their group at hand, the identity does not store the group g it belongs to. However it depends on the type of the AbstractGroupOperation used.\n\nSee also identity_element on how to obtain the corresponding AbstractManifoldPoint or array representation.\n\nConstructors\n\nIdentity(G::AbstractDecoratorManifold{𝔽})\nIdentity(o::O)\nIdentity(::Type{O})\n\ncreate the identity of the corresponding subtype O<:AbstractGroupOperation\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.IsGroupManifold","page":"Group manifold","title":"Manifolds.IsGroupManifold","text":"IsGroupManifold{O<:AbstractGroupOperation} <: AbstractTrait\n\nA trait to declare an AbstractManifold  as a manifold with group structure with operation of type O.\n\nUsing this trait you can turn a manifold that you implement implictly into a Lie group. If you wish to decorate an existing manifold with one (or different) AbstractGroupActions, see GroupManifold.\n\nConstructor\n\nIsGroupManifold(op)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.LeftAction","page":"Group manifold","title":"Manifolds.LeftAction","text":"LeftAction()\n\nLeft action of a group on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.RightAction","page":"Group manifold","title":"Manifolds.RightAction","text":"RightAction()\n\nRight action of a group on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Base.inv-Tuple{AbstractDecoratorManifold, Vararg{Any, N} where N}","page":"Group manifold","title":"Base.inv","text":"inv(G::AbstractDecoratorManifold, p)\n\nInverse p^-1  mathcalG of an element p  mathcalG, such that p circ p^-1 = p^-1 circ p = e  mathcalG, where e is the Identity element of mathcalG.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.adjoint_action-Tuple{AbstractDecoratorManifold, Any, Any}","page":"Group manifold","title":"Manifolds.adjoint_action","text":"adjoint_action(G::AbstractDecoratorManifold, p, X)\n\nAdjoint action of the element p of the Lie group G on the element X of the corresponding Lie algebra.\n\nIt is defined as the differential of the group authomorphism Ψ_p(q) = pqp¹ at the identity of G.\n\nThe formula reads\n\noperatornameAd_p(X) = dΨ_p(e)X\n\nwhere e is the identity element of G.\n\nNote that the adjoint representation of a Lie group isn't generally faithful. Notably the adjoint representation of SO(2) is trivial.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.compose-Tuple{AbstractDecoratorManifold, Vararg{Any, N} where N}","page":"Group manifold","title":"Manifolds.compose","text":"compose(G::AbstractDecoratorManifold, p, q)\n\nCompose elements pq  mathcalG using the group operation p circ q.\n\nFor implementing composition on a new group manifold, please overload _compose instead so that methods with Identity arguments are not ambiguous.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.exp_lie-Tuple{AbstractManifold, Any}","page":"Group manifold","title":"Manifolds.exp_lie","text":"exp_lie(G, X)\nexp_lie!(G, q, X)\n\nCompute the group exponential of the Lie algebra element X. It is equivalent to the exponential map defined by the CartanSchoutenMinus connection.\n\nGiven an element X  𝔤 = T_e mathcalG, where e is the Identity element of the group mathcalG, and 𝔤 is its Lie algebra, the group exponential is the map\n\nexp  𝔤  mathcalG\n\nsuch that for ts  ℝ, γ(t) = exp (t X) defines a one-parameter subgroup with the following properties:\n\nbeginaligned\nγ(t) = γ(-t)^-1\nγ(t + s) = γ(t) circ γ(s) = γ(s) circ γ(t)\nγ(0) = e\nlim_t  0 fracddt γ(t) = X\nendaligned\n\nnote: Note\nIn general, the group exponential map is distinct from the Riemannian exponential map exp.\n\nFor example for the MultiplicationOperation and either Number or AbstractMatrix the Lie exponential is the numeric/matrix exponential.\n\nexp X = operatornameExp X = sum_n=0^ frac1n X^n\n\nSince this function also depends on the group operation, make sure to implement the corresponding trait version exp_lie(::TraitList{<:IsGroupManifold}, G, X).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.get_coordinates_lie-Tuple{ManifoldsBase.TraitList{var\"#s78\", T2} where {var\"#s78\"<:IsGroupManifold, T2<:AbstractTrait}, AbstractManifold, Any, AbstractBasis}","page":"Group manifold","title":"Manifolds.get_coordinates_lie","text":"get_coordinates_lie(G::AbstractManifold, X, B::AbstractBasis)\n\nGet the coordinates of an element X from the Lie algebra og G with respect to a basis B. This is similar to calling get_coordinates at the p=Identity(G).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.get_vector_lie-Tuple{ManifoldsBase.TraitList{var\"#s78\", T2} where {var\"#s78\"<:IsGroupManifold, T2<:AbstractTrait}, AbstractManifold, Any, AbstractBasis}","page":"Group manifold","title":"Manifolds.get_vector_lie","text":"get_vector_lie(G::AbstractDecoratorManifold, a, B::AbstractBasis)\n\nReconstruct a tangent vector from the Lie algebra of G from cooordinates a of a basis B. This is similar to calling get_vector at the p=Identity(G).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.identity_element-Tuple{AbstractDecoratorManifold, Any}","page":"Group manifold","title":"Manifolds.identity_element","text":"identity_element(G::AbstractDecoratorManifold, p)\n\nReturn a point representation of the Identity on the IsGroupManifold G, where p indicates the type to represent the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.identity_element-Tuple{AbstractDecoratorManifold}","page":"Group manifold","title":"Manifolds.identity_element","text":"identity_element(G)\n\nReturn a point representation of the Identity on the IsGroupManifold G. By default this representation is the default array or number representation. It should return the corresponding default representation of e as a point on G if points are not represented by arrays.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_translate-Tuple{AbstractDecoratorManifold, Vararg{Any, N} where N}","page":"Group manifold","title":"Manifolds.inverse_translate","text":"inverse_translate(G::AbstractDecoratorManifold, p, q, conv::ActionDirection=LeftAction())\n\nInverse translate group element q by p with the inverse translation τ_p^-1 with the specified convention, either left (L_p^-1) or right (R_p^-1), defined as\n\nbeginaligned\nL_p^-1  q  p^-1 circ q\nR_p^-1  q  q circ p^-1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_translate_diff-Tuple{AbstractDecoratorManifold, Vararg{Any, N} where N}","page":"Group manifold","title":"Manifolds.inverse_translate_diff","text":"inverse_translate_diff(G::AbstractDecoratorManifold, p, q, X, conv::ActionDirection=LeftAction())\n\nFor group elements p q  mathcalG and tangent vector X  T_q mathcalG, compute the action on X of the differential of the inverse translation τ_p by p, with the specified left or right convention. The differential transports vectors:\n\n(mathrmdτ_p^-1)_q  T_q mathcalG  T_τ_p^-1 q mathcalG\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.is_group_manifold-Tuple{AbstractManifold, AbstractGroupOperation}","page":"Group manifold","title":"Manifolds.is_group_manifold","text":"is_group_manifold(G::GroupManifold)\nis_group_manifoldd(G::AbstractManifold, o::AbstractGroupOperation)\n\nreturns whether an AbstractDecoratorManifold is a group manifold with AbstractGroupOperation o. For a GroupManifold G this checks whether the right operations is stored within G.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.is_identity-Tuple{AbstractDecoratorManifold, Any}","page":"Group manifold","title":"Manifolds.is_identity","text":"is_identity(G::AbstractDecoratorManifold, q; kwargs)\n\nCheck whether q is the identity on the IsGroupManifold G, i.e. it is either the Identity{O} with the corresponding AbstractGroupOperation O, or (approximately) the correct point representation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.lie_bracket-Tuple{AbstractDecoratorManifold, Any, Any}","page":"Group manifold","title":"Manifolds.lie_bracket","text":"lie_bracket(G::AbstractDecoratorManifold, X, Y)\n\nLie bracket between elements X and Y of the Lie algebra corresponding to the Lie group G, cf. IsGroupManifold.\n\nThis can be used to compute the adjoint representation of a Lie algebra. Note that this representation isn't generally faithful. Notably the adjoint representation of 𝔰𝔬(2) is trivial.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.log_lie-Tuple{AbstractDecoratorManifold, Any}","page":"Group manifold","title":"Manifolds.log_lie","text":"log_lie(G, q)\nlog_lie!(G, X, q)\n\nCompute the Lie group logarithm of the Lie group element q. It is equivalent to the logarithmic map defined by the CartanSchoutenMinus connection.\n\nGiven an element q  mathcalG, compute the right inverse of the group exponential map exp_lie, that is, the element log q = X  𝔤 = T_e mathcalG, such that q = exp X\n\nnote: Note\nIn general, the group logarithm map is distinct from the Riemannian logarithm map log.For matrix Lie groups this is equal to the (matrix) logarithm:\n\nlog q = operatornameLog q = sum_n=1^ frac(-1)^n+1n (q - e)^n\n\nwhere e here is the Identity element, that is, 1 for numeric q or the identity matrix I_m for matrix q  ℝ^m  m.\n\nSince this function also depends on the group operation, make sure to implement either\n\n_log_lie(G, q) and _log_lie!(G, X, q) for the points not being the Identity\nthe trait version log_lie(::TraitList{<:IsGroupManifold}, G, e), log_lie(::TraitList{<:IsGroupManifold}, G, X, e) for own implementations of the identity case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.switch_direction-Tuple{ActionDirection}","page":"Group manifold","title":"Manifolds.switch_direction","text":"switch_direction(::ActionDirection)\n\nReturns a RightAction when given a LeftAction and vice versa.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate-Tuple{AbstractDecoratorManifold, Vararg{Any, N} where N}","page":"Group manifold","title":"Manifolds.translate","text":"translate(G::AbstractDecoratorManifold, p, q, conv::ActionDirection=LeftAction()])\n\nTranslate group element q by p with the translation τ_p with the specified convention, either left (L_p) or right (R_p), defined as\n\nbeginaligned\nL_p  q  p circ q\nR_p  q  q circ p\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate_diff-Tuple{AbstractDecoratorManifold, Vararg{Any, N} where N}","page":"Group manifold","title":"Manifolds.translate_diff","text":"translate_diff(G::AbstractDecoratorManifold, p, q, X, conv::ActionDirection=LeftAction())\n\nFor group elements p q  mathcalG and tangent vector X  T_q mathcalG, compute the action of the differential of the translation τ_p by p on X, with the specified left or right convention. The differential transports vectors:\n\n(mathrmdτ_p)_q  T_q mathcalG  T_τ_p q mathcalG\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.hat-Union{Tuple{O}, Tuple{AbstractDecoratorManifold, Identity{O}, Any}} where O<:AbstractGroupOperation","page":"Group manifold","title":"ManifoldsBase.hat","text":"hat(M::AbstractDecoratorManifold{𝔽,O}, ::Identity{O}, Xⁱ) where {𝔽,O<:AbstractGroupOperation}\n\nGiven a basis e_i on the tangent space at a the Identity and tangent component vector X^i, compute the equivalent vector representation ``X=X^i e_i**, where Einstein summation notation is used:\n\n  X^i  X^i e_i\n\nFor array manifolds, this converts a vector representation of the tangent vector to an array representation. The vee map is the hat map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.inverse_retract-Tuple{ManifoldsBase.TraitList{var\"#s78\", T2} where {var\"#s78\"<:IsGroupManifold, T2<:AbstractTrait}, AbstractDecoratorManifold, Any, Any, Manifolds.GroupLogarithmicInverseRetraction}","page":"Group manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(\n    G::AbstractDecoratorManifold,\n    p,\n    X,\n    method::GroupLogarithmicInverseRetraction{<:ActionDirection},\n)\n\nCompute the inverse retraction using the group logarithm log_lie \"translated\" to any point on the manifold. With a group translation (translate) τ_p in a specified direction, the retraction is\n\noperatornameretr_p^-1 = (mathrmdτ_p)_e circ log circ τ_p^-1\n\nwhere log is the group logarithm (log_lie), and (mathrmdτ_p)_e is the action of the differential of translation τ_p evaluated at the identity element e (see translate_diff).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.retract-Tuple{ManifoldsBase.TraitList{var\"#s78\", T2} where {var\"#s78\"<:IsGroupManifold, T2<:AbstractTrait}, AbstractDecoratorManifold, Any, Any, Manifolds.GroupExponentialRetraction}","page":"Group manifold","title":"ManifoldsBase.retract","text":"retract(\n    G::AbstractDecoratorManifold,\n    p,\n    X,\n    method::GroupExponentialRetraction{<:ActionDirection},\n)\n\nCompute the retraction using the group exponential exp_lie \"translated\" to any point on the manifold. With a group translation (translate) τ_p in a specified direction, the retraction is\n\noperatornameretr_p = τ_p circ exp circ (mathrmdτ_p^-1)_p\n\nwhere exp is the group exponential (exp_lie), and (mathrmdτ_p^-1)_p is the action of the differential of inverse translation τ_p^-1 evaluated at p (see inverse_translate_diff).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.vee-Union{Tuple{O}, Tuple{AbstractDecoratorManifold, Identity{O}, Any}} where O<:AbstractGroupOperation","page":"Group manifold","title":"ManifoldsBase.vee","text":"vee(M::AbstractManifold, p, X)\n\nGiven a basis e_i on the tangent space at a point p and tangent vector X, compute the vector components X^i, such that X = X^i e_i, where Einstein summation notation is used:\n\nvee  X^i e_i  X^i\n\nFor array manifolds, this converts an array representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#GroupManifold","page":"Group manifold","title":"GroupManifold","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"As a concrete wrapper for manifolds (e.g. when the manifold per se is a group manifold but another group structure should be implemented), there is the GroupManifold","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/GroupManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.GroupManifold","page":"Group manifold","title":"Manifolds.GroupManifold","text":"GroupManifold{𝔽,M<:AbstractManifold{𝔽},O<:AbstractGroupOperation} <: AbstractDecoratorManifold{𝔽}\n\nDecorator for a smooth manifold that equips the manifold with a group operation, thus making it a Lie group. See IsGroupManifold for more details.\n\nGroup manifolds by default forward metric-related operations to the wrapped manifold.\n\nConstructor\n\nGroupManifold(manifold, op)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Generic-Operations","page":"Group manifold","title":"Generic Operations","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"For groups based on an addition operation or a group operation, several default implementations are provided.","category":"page"},{"location":"manifolds/group.html#Addition-Operation","page":"Group manifold","title":"Addition Operation","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/addition_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AdditionOperation","page":"Group manifold","title":"Manifolds.AdditionOperation","text":"AdditionOperation <: AbstractGroupOperation\n\nGroup operation that consists of simple addition.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Multiplication-Operation","page":"Group manifold","title":"Multiplication Operation","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/multiplication_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.MultiplicationOperation","page":"Group manifold","title":"Manifolds.MultiplicationOperation","text":"MultiplicationOperation <: AbstractGroupOperation\n\nGroup operation that consists of multiplication.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Product-group","page":"Group manifold","title":"Product group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.ProductGroup-Union{Tuple{ProductManifold{𝔽, TM} where TM<:Tuple}, Tuple{𝔽}} where 𝔽","page":"Group manifold","title":"Manifolds.ProductGroup","text":"ProductGroup{𝔽,T} <: GroupManifold{𝔽,ProductManifold{T},ProductOperation}\n\nDecorate a product manifold with a ProductOperation.\n\nEach submanifold must also have a IsGroupManifold or a decorated instance of one. This type is mostly useful for equipping the direct product of group manifolds with an Identity element.\n\nConstructor\n\nProductGroup(manifold::ProductManifold)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.ProductOperation","page":"Group manifold","title":"Manifolds.ProductOperation","text":"ProductOperation <: AbstractGroupOperation\n\nDirect product group operation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Semidirect-product-group","page":"Group manifold","title":"Semidirect product group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/semidirect_product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SemidirectProductGroup-Union{Tuple{𝔽}, Tuple{GroupManifold{𝔽, M, O} where {M<:AbstractManifold{𝔽}, O<:AbstractGroupOperation}, GroupManifold{𝔽, M, O} where {M<:AbstractManifold{𝔽}, O<:AbstractGroupOperation}, AbstractGroupAction}} where 𝔽","page":"Group manifold","title":"Manifolds.SemidirectProductGroup","text":"SemidirectProductGroup(N::GroupManifold, H::GroupManifold, A::AbstractGroupAction)\n\nA group that is the semidirect product of a normal group mathcalN and a subgroup mathcalH, written mathcalG = mathcalN _θ mathcalH, where θ mathcalH  mathcalN  mathcalN is an automorphism action of mathcalH on mathcalN. The group mathcalG has the composition rule\n\ng circ g = (n h) circ (n h) = (n circ θ_h(n) h circ h)\n\nand the inverse\n\ng^-1 = (n h)^-1 = (θ_h^-1(n^-1) h^-1)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.SemidirectProductOperation","page":"Group manifold","title":"Manifolds.SemidirectProductOperation","text":"SemidirectProductOperation(action::AbstractGroupAction)\n\nGroup operation of a semidirect product group. The operation consists of the operation opN on a normal subgroup N, the operation opH on a subgroup H, and an automorphism action of elements of H on N. Only the action is stored.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.identity_element-Tuple{SemidirectProductGroup{𝔽, N, H, A} where {𝔽, N, H, A<:AbstractGroupAction}}","page":"Group manifold","title":"Manifolds.identity_element","text":"identity_element(G::SemidirectProductGroup)\n\nGet the identity element of SemidirectProductGroup G. Uses ProductRepr to represent the point.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate_diff-Tuple{SemidirectProductGroup{𝔽, N, H, A} where {𝔽, N, H, A<:AbstractGroupAction}, Any, Any, Any, LeftAction}","page":"Group manifold","title":"Manifolds.translate_diff","text":"translate_diff(G::SemidirectProductGroup, p, q, X, conX::LeftAction)\n\nPerform differential of the left translation on the semidirect product group G.\n\nSince the left translation is defined as (cf. SemidirectProductGroup):\n\nL_(n h) (n h) = ( L_n θ_h(n) L_h h)\n\nthen its differential can be computed as\n\nmathrmdL_(n h)(X_n X_h) = ( mathrmdL_n (mathrmdθ_h(X_n)) mathrmdL_h X_h)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Power-group","page":"Group manifold","title":"Power group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/power_group.jl\"]\nOrder = [:type, :function, :constant]","category":"page"},{"location":"manifolds/group.html#Manifolds.PowerGroup-Tuple{AbstractPowerManifold}","page":"Group manifold","title":"Manifolds.PowerGroup","text":"PowerGroup{𝔽,T} <: GroupManifold{𝔽,<:AbstractPowerManifold{𝔽,M,RPT},ProductOperation}\n\nDecorate a power manifold with a ProductOperation.\n\nConstituent manifold of the power manifold must also have a IsGroupManifold or a decorated instance of one. This type is mostly useful for equipping the direct product of group manifolds with an Identity element.\n\nConstructor\n\nPowerGroup(manifold::AbstractPowerManifold)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.PowerGroupNested","page":"Group manifold","title":"Manifolds.PowerGroupNested","text":"PowerGroupNested\n\nAlias to PowerGroup with NestedPowerRepresentation representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.PowerGroupNestedReplacing","page":"Group manifold","title":"Manifolds.PowerGroupNestedReplacing","text":"PowerGroupNestedReplacing\n\nAlias to PowerGroup with NestedReplacingPowerRepresentation representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Circle-group","page":"Group manifold","title":"Circle group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/circle_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.CircleGroup","page":"Group manifold","title":"Manifolds.CircleGroup","text":"CircleGroup <: GroupManifold{Circle{ℂ},MultiplicationOperation}\n\nThe circle group is the complex circle (Circle(ℂ)) equipped with the group operation of complex multiplication (MultiplicationOperation).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.RealCircleGroup","page":"Group manifold","title":"Manifolds.RealCircleGroup","text":"RealCircleGroup <: GroupManifold{Circle{ℝ},AdditionOperation}\n\nThe real circle group is the real circle (Circle(ℝ)) equipped with the group operation of addition (AdditionOperation).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#General-linear-group","page":"Group manifold","title":"General linear group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/general_linear.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.GeneralLinear","page":"Group manifold","title":"Manifolds.GeneralLinear","text":"GeneralLinear{n,𝔽} <:\n    AbstractDecoratorManifold{𝔽}\n\nThe general linear group, that is, the group of all invertible matrices in 𝔽^nn.\n\nThe default metric is the left-mathrmGL(n)-right-mathrmO(n)-invariant metric whose inner product is\n\nX_pY_p_p = p^-1X_pp^-1Y_p_mathrmF = X_e Y_e_mathrmF\n\nwhere X_p Y_p  T_p mathrmGL(n 𝔽), X_e = p^-1X_p  𝔤𝔩(n) = T_e mathrmGL(n 𝔽) = 𝔽^nn is the corresponding vector in the Lie algebra, and _mathrmF denotes the Frobenius inner product.\n\nBy default, tangent vectors X_p are represented with their corresponding Lie algebra vectors X_e = p^-1X_p.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Base.exp-Tuple{GeneralLinear, Any, Any}","page":"Group manifold","title":"Base.exp","text":"exp(G::GeneralLinear, p, X)\n\nCompute the exponential map on the GeneralLinear group.\n\nThe exponential map is\n\nexp_p colon X  p operatornameExp(X^mathrmH) operatornameExp(X - X^mathrmH)\n\nwhere operatornameExp() denotes the matrix exponential, and ^mathrmH is the conjugate transpose. [AndruchowLarotondaRechtVarela2014][MartinNeff2016]\n\n[AndruchowLarotondaRechtVarela2014]: Andruchow E., Larotonda G., Recht L., and Varela A.: “The left invariant metric in the general linear group”, Journal of Geometry and Physics 86, pp. 241-257, 2014. doi: 10.1016/j.geomphys.2014.08.009, arXiv: 1109.0520v1.\n\n[MartinNeff2016]: Martin, R. J. and Neff, P.: “Minimal geodesics on GL(n) for left-invariant, right-O(n)-invariant Riemannian metrics”, Journal of Geometric Mechanics 8(3), pp. 323-357, 2016. doi: 10.3934/jgm.2016010, arXiv: 1409.7849v2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Base.log-Tuple{GeneralLinear, Any, Any}","page":"Group manifold","title":"Base.log","text":"log(G::GeneralLinear, p, q)\n\nCompute the logarithmic map on the GeneralLinear(n) group.\n\nThe algorithm proceeds in two stages. First, the point r = p^-1 q is projected to the nearest element (under the Frobenius norm) of the direct product subgroup mathrmO(n)  S^+, whose logarithmic map is exactly computed using the matrix logarithm. This initial tangent vector is then refined using the NLSolveInverseRetraction.\n\nFor GeneralLinear(n, ℂ), the logarithmic map is instead computed on the realified supergroup GeneralLinear(2n) and the resulting tangent vector is then complexified.\n\nNote that this implementation is experimental.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Special-linear-group","page":"Group manifold","title":"Special linear group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/special_linear.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SpecialLinear","page":"Group manifold","title":"Manifolds.SpecialLinear","text":"SpecialLinear{n,𝔽} <: AbstractDecoratorManifold\n\nThe special linear group mathrmSL(n𝔽) that is, the group of all invertible matrices with unit determinant in 𝔽^nn.\n\nThe Lie algebra 𝔰𝔩(n 𝔽) = T_e mathrmSL(n𝔽) is the set of all matrices in 𝔽^nn with trace of zero. By default, tangent vectors X_p  T_p mathrmSL(n𝔽) for p  mathrmSL(n𝔽) are represented with their corresponding Lie algebra vector X_e = p^-1X_p  𝔰𝔩(n 𝔽).\n\nThe default metric is the same left-mathrmGL(n)-right-mathrmO(n)-invariant metric used for GeneralLinear(n, 𝔽). The resulting geodesic on mathrmGL(n𝔽) emanating from an element of mathrmSL(n𝔽) in the direction of an element of 𝔰𝔩(n 𝔽) is a closed subgroup of mathrmSL(n𝔽). As a result, most metric functions forward to GeneralLinear.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#ManifoldsBase.project-Tuple{SpecialLinear, Any, Any}","page":"Group manifold","title":"ManifoldsBase.project","text":"project(G::SpecialLinear, p, X)\n\nOrthogonally project X  𝔽^n  n onto the tangent space of p to the SpecialLinear G = mathrmSL(n 𝔽). The formula reads\n\noperatornameproj_p\n    = (mathrmdL_p)_e  operatornameproj_𝔰𝔩(n 𝔽)  (mathrmdL_p^-1)_p\n    colon X  X - fracoperatornametr(X)n I\n\nwhere the last expression uses the tangent space representation as the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.project-Tuple{SpecialLinear, Any}","page":"Group manifold","title":"ManifoldsBase.project","text":"project(G::SpecialLinear, p)\n\nProject p  mathrmGL(n 𝔽) to the SpecialLinear group G=mathrmSL(n 𝔽).\n\nGiven the singular value decomposition of p, written p = U S V^mathrmH, the formula for the projection is\n\noperatornameproj_mathrmSL(n 𝔽)(p) = U S D V^mathrmH\n\nwhere\n\nD_ij = δ_ij begincases\n    1             text if  i  n \n    det(p)^-1  text if  i = n\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Special-orthogonal-group","page":"Group manifold","title":"Special orthogonal group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/special_orthogonal.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SpecialOrthogonal","page":"Group manifold","title":"Manifolds.SpecialOrthogonal","text":"SpecialOrthogonal{n} <: GroupManifold{ℝ,Rotations{n},MultiplicationOperation}\n\nSpecial orthogonal group mathrmSO(n) represented by rotation matrices.\n\nConstructor\n\nSpecialOrthogonal(n)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Translation-group","page":"Group manifold","title":"Translation group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/translation_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.TranslationGroup","page":"Group manifold","title":"Manifolds.TranslationGroup","text":"TranslationGroup{T<:Tuple,𝔽} <: GroupManifold{Euclidean{T,𝔽},AdditionOperation}\n\nTranslation group mathrmT(n) represented by translation arrays.\n\nConstructor\n\nTranslationGroup(n₁,...,nᵢ; field = 𝔽)\n\nGenerate the translation group on 𝔽^n₁nᵢ = Euclidean(n₁,...,nᵢ; field = 𝔽), which is isomorphic to the group itself.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Special-Euclidean-group","page":"Group manifold","title":"Special Euclidean group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/special_euclidean.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SpecialEuclidean","page":"Group manifold","title":"Manifolds.SpecialEuclidean","text":"SpecialEuclidean(n)\n\nSpecial Euclidean group mathrmSE(n), the group of rigid motions.\n\nmathrmSE(n) is the semidirect product of the TranslationGroup on ℝ^n and SpecialOrthogonal(n)\n\nmathrmSE(n)  mathrmT(n) _θ mathrmSO(n)\n\nwhere θ is the canonical action of mathrmSO(n) on mathrmT(n) by vector rotation.\n\nThis constructor is equivalent to calling\n\nTn = TranslationGroup(n)\nSOn = SpecialOrthogonal(n)\nSemidirectProductGroup(Tn, SOn, RotationAction(Tn, SOn))\n\nPoints on mathrmSE(n) may be represented as points on the underlying product manifold mathrmT(n)  mathrmSO(n). For group-specific functions, they may also be represented as affine matrices with size (n + 1, n + 1) (see affine_matrix), for which the group operation is MultiplicationOperation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.SpecialEuclideanInGeneralLinear","page":"Group manifold","title":"Manifolds.SpecialEuclideanInGeneralLinear","text":"SpecialEuclideanInGeneralLinear\n\nAn explicit isometric and homomorphic embedding of mathrmSE(n) in mathrmGL(n+1) and 𝔰𝔢(n) in 𝔤𝔩(n+1). Note that this is not a transparently isometric embedding.\n\nConstructor\n\nSpecialEuclideanInGeneralLinear(n)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.adjoint_action-Tuple{GroupManifold{ℝ, ProductManifold{ℝ, Tuple{TranslationGroup{Tuple{3}, ℝ}, SpecialOrthogonal{3}}}, Manifolds.SemidirectProductOperation{RotationAction{TranslationGroup{Tuple{3}, ℝ}, SpecialOrthogonal{3}, LeftAction}}}, Any, TFVector{var\"#s107\", VeeOrthogonalBasis{ℝ}} where var\"#s107\"}","page":"Group manifold","title":"Manifolds.adjoint_action","text":"adjoint_action(::SpecialEuclidean{3}, p, fX::TFVector{<:Any,VeeOrthogonalBasis{ℝ}})\n\nAdjoint action of the SpecialEuclidean group on the vector with coefficients fX tangent at point p.\n\nThe formula for the coefficients reads t(Rω) + Rr for the translation part and Rω for the rotation part, where t is the translation part of p, R is the rotation matrix part of p, r is the translation part of fX and ω is the rotation part of fX,  is the cross product and  is the matrix product.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.affine_matrix-Union{Tuple{n}, Tuple{SpecialEuclidean{n}, Any}} where n","page":"Group manifold","title":"Manifolds.affine_matrix","text":"affine_matrix(G::SpecialEuclidean, p) -> AbstractMatrix\n\nRepresent the point p  mathrmSE(n) as an affine matrix. For p = (t R)  mathrmSE(n), where t  mathrmT(n) R  mathrmSO(n), the affine representation is the n + 1  n + 1 matrix\n\nbeginpmatrix\nR  t \n0^mathrmT  1\nendpmatrix\n\nThis function embeds mathrmSE(n) in the general linear group mathrmGL(n+1). It is an isometric embedding and group homomorphism [RicoMartinez1988].\n\nSee also screw_matrix for matrix representations of the Lie algebra.\n\n[RicoMartinez1988]: Rico Martinez, J. M., “Representations of the Euclidean group and its applications to the kinematics of spatial chains,” PhD Thesis, University of Florida, 1988.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.exp_lie-Tuple{GroupManifold{ℝ, ProductManifold{ℝ, Tuple{TranslationGroup{Tuple{2}, ℝ}, SpecialOrthogonal{2}}}, Manifolds.SemidirectProductOperation{RotationAction{TranslationGroup{Tuple{2}, ℝ}, SpecialOrthogonal{2}, LeftAction}}}, Any}","page":"Group manifold","title":"Manifolds.exp_lie","text":"exp_lie(G::SpecialEuclidean{2}, X)\n\nCompute the group exponential of X = (b Ω)  𝔰𝔢(2), where b  𝔱(2) and Ω  𝔰𝔬(2):\n\nexp X = (t R) = (U(θ) b exp Ω)\n\nwhere t  mathrmT(2), R = exp Ω is the group exponential on mathrmSO(2),\n\nU(θ) = fracsin θθ I_2 + frac1 - cos θθ^2 Ω\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.exp_lie-Tuple{GroupManifold{ℝ, ProductManifold{ℝ, Tuple{TranslationGroup{Tuple{3}, ℝ}, SpecialOrthogonal{3}}}, Manifolds.SemidirectProductOperation{RotationAction{TranslationGroup{Tuple{3}, ℝ}, SpecialOrthogonal{3}, LeftAction}}}, Any}","page":"Group manifold","title":"Manifolds.exp_lie","text":"exp_lie(G::SpecialEuclidean{3}, X)\n\nCompute the group exponential of X = (b Ω)  𝔰𝔢(3), where b  𝔱(3) and Ω  𝔰𝔬(3):\n\nexp X = (t R) = (U(θ) b exp Ω)\n\nwhere t  mathrmT(3), R = exp Ω is the group exponential on mathrmSO(3),\n\nU(θ) = I_3 + frac1 - cos θθ^2 Ω + fracθ - sin θθ^3 Ω^2\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.exp_lie-Tuple{SpecialEuclidean{N} where N, Any}","page":"Group manifold","title":"Manifolds.exp_lie","text":"exp_lie(G::SpecialEuclidean{n}, X)\n\nCompute the group exponential of X = (b Ω)  𝔰𝔢(n), where b  𝔱(n) and Ω  𝔰𝔬(n):\n\nexp X = (t R)\n\nwhere t  mathrmT(n) and R = exp Ω is the group exponential on mathrmSO(n).\n\nIn the screw_matrix representation, the group exponential is the matrix exponential (see exp_lie).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.lie_bracket-Tuple{SpecialEuclidean{N} where N, ProductRepr, ProductRepr}","page":"Group manifold","title":"Manifolds.lie_bracket","text":"lie_bracket(G::SpecialEuclidean, X::ProductRepr, Y::ProductRepr)\nlie_bracket(G::SpecialEuclidean, X::AbstractMatrix, Y::AbstractMatrix)\n\nCalculate the Lie bracket between elements X and Y of the special Euclidean Lie algebra. For the matrix representation (which can be obtained using screw_matrix) the formula is X Y = XY-YX, while in the ProductRepr representation the formula reads X Y = (t_1 R_1) (t_2 R_2) = (R_1 t_2 - R_2 t_1 R_1 R_2 - R_2 R_1).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.log_lie-Tuple{GroupManifold{ℝ, ProductManifold{ℝ, Tuple{TranslationGroup{Tuple{2}, ℝ}, SpecialOrthogonal{2}}}, Manifolds.SemidirectProductOperation{RotationAction{TranslationGroup{Tuple{2}, ℝ}, SpecialOrthogonal{2}, LeftAction}}}, Any}","page":"Group manifold","title":"Manifolds.log_lie","text":"log_lie(G::SpecialEuclidean{2}, p)\n\nCompute the group logarithm of p = (t R)  mathrmSE(2), where t  mathrmT(2) and R  mathrmSO(2):\n\nlog p = (b Ω) = (U(θ)^-1 t log R)\n\nwhere b  𝔱(2), Ω = log R  𝔰𝔬(2) is the group logarithm on mathrmSO(2),\n\nU(θ) = fracsin θθ I_2 + frac1 - cos θθ^2 Ω\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.log_lie-Tuple{GroupManifold{ℝ, ProductManifold{ℝ, Tuple{TranslationGroup{Tuple{3}, ℝ}, SpecialOrthogonal{3}}}, Manifolds.SemidirectProductOperation{RotationAction{TranslationGroup{Tuple{3}, ℝ}, SpecialOrthogonal{3}, LeftAction}}}, Any}","page":"Group manifold","title":"Manifolds.log_lie","text":"log_lie(G::SpecialEuclidean{3}, p)\n\nCompute the group logarithm of p = (t R)  mathrmSE(3), where t  mathrmT(3) and R  mathrmSO(3):\n\nlog p = (b Ω) = (U(θ)^-1 t log R)\n\nwhere b  𝔱(3), Ω = log R  𝔰𝔬(3) is the group logarithm on mathrmSO(3),\n\nU(θ) = I_3 + frac1 - cos θθ^2 Ω + fracθ - sin θθ^3 Ω^2\n\nand θ = frac1sqrt2 lVert Ω rVert_e (see norm) is the angle of the rotation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.log_lie-Tuple{SpecialEuclidean{N} where N, Any}","page":"Group manifold","title":"Manifolds.log_lie","text":"log_lie(G::SpecialEuclidean{n}, p) where {n}\n\nCompute the group logarithm of p = (t R)  mathrmSE(n), where t  mathrmT(n) and R  mathrmSO(n):\n\nlog p = (b Ω)\n\nwhere b  𝔱(n) and Ω = log R  𝔰𝔬(n) is the group logarithm on mathrmSO(n).\n\nIn the affine_matrix representation, the group logarithm is the matrix logarithm (see log_lie):\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.screw_matrix-Union{Tuple{n}, Tuple{SpecialEuclidean{n}, Any}} where n","page":"Group manifold","title":"Manifolds.screw_matrix","text":"screw_matrix(G::SpecialEuclidean, X) -> AbstractMatrix\n\nRepresent the Lie algebra element X  𝔰𝔢(n) = T_e mathrmSE(n) as a screw matrix. For X = (b Ω)  𝔰𝔢(n), where Ω  𝔰𝔬(n) = T_e mathrmSO(n), the screw representation is the n + 1  n + 1 matrix\n\nbeginpmatrix\nΩ  b \n0^mathrmT  0\nendpmatrix\n\nThis function embeds 𝔰𝔢(n) in the general linear Lie algebra 𝔤𝔩(n+1) but it's not a homomorphic embedding (see SpecialEuclideanInGeneralLinear for a homomorphic one).\n\nSee also affine_matrix for matrix representations of the Lie group.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate_diff-Tuple{SpecialEuclidean{N} where N, Any, Any, Any, RightAction}","page":"Group manifold","title":"Manifolds.translate_diff","text":"translate_diff(G::SpecialEuclidean, p, q, X, ::RightAction)\n\nDifferential of the right action of the SpecialEuclidean group on itself. The formula for the rotation part is the differential of the right rotation action, while the formula for the translation part reads\n\nR_qX_Rt_p + X_t\n\nwhere R_q is the rotation part of q, X_R is the rotation part of X, t_p is the translation part of p and X_t is the translation part of X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.embed-Tuple{EmbeddedManifold{ℝ, var\"#s108\", var\"#s107\"} where {var\"#s108\"<:(SpecialEuclidean{N} where N), var\"#s107\"<:GeneralLinear}, Any, Any}","page":"Group manifold","title":"ManifoldsBase.embed","text":"embed(M::SpecialEuclideanInGeneralLinear, p, X)\n\nEmbed the tangent vector X at point p on SpecialEuclidean in the GeneralLinear group. Point p can use any representation valid for SpecialEuclidean. The embedding is similar from the one defined by screw_matrix but the translation part is multiplied by inverse of the rotation part.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.embed-Tuple{EmbeddedManifold{ℝ, var\"#s108\", var\"#s107\"} where {var\"#s108\"<:(SpecialEuclidean{N} where N), var\"#s107\"<:GeneralLinear}, Any}","page":"Group manifold","title":"ManifoldsBase.embed","text":"embed(M::SpecialEuclideanInGeneralLinear, p)\n\nEmbed the point p on SpecialEuclidean in the GeneralLinear group. The embedding is calculated using affine_matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.project-Tuple{EmbeddedManifold{ℝ, var\"#s108\", var\"#s107\"} where {var\"#s108\"<:(SpecialEuclidean{N} where N), var\"#s107\"<:GeneralLinear}, Any, Any}","page":"Group manifold","title":"ManifoldsBase.project","text":"project(M::SpecialEuclideanInGeneralLinear, p, X)\n\nProject tangent vector X at point p in GeneralLinear to the SpecialEuclidean Lie algebra. This reverses the transformation performed by embed\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.project-Tuple{EmbeddedManifold{ℝ, var\"#s108\", var\"#s107\"} where {var\"#s108\"<:(SpecialEuclidean{N} where N), var\"#s107\"<:GeneralLinear}, Any}","page":"Group manifold","title":"ManifoldsBase.project","text":"project(M::SpecialEuclideanInGeneralLinear, p)\n\nProject point p in GeneralLinear to the SpecialEuclidean group. This is performed by extracting the rotation and translation part as in affine_matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Heisenberg-group","page":"Group manifold","title":"Heisenberg group","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/heisenberg.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/group.html#Manifolds.HeisenbergGroup","page":"Group manifold","title":"Manifolds.HeisenbergGroup","text":"HeisenbergGroup{n} <: AbstractDecoratorManifold{ℝ}\n\nHeisenberg group HeisenbergGroup(n) is the group of (n+2)  (n+2) matrices [BinzPods2008]\n\nbeginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\nwhere I_n is the nn unit matrix, mathbfa is a row vector of length n, mathbfb is a column vector of length n and c is a real number. The group operation is matrix multiplication.\n\nThe left-invariant metric on the manifold is used.\n\n[BinzPods2008]: E. Binz and S. Pods, The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization. American Mathematical Soc., 2008.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Base.exp-Tuple{HeisenbergGroup, Any, Any}","page":"Group manifold","title":"Base.exp","text":"exp(M::HeisenbergGroup, p, X)\n\nExponential map on the HeisenbergGroup M with the left-invariant metric. The expression reads\n\nexp_beginbmatrix 1  mathbfa_p  c_p \nmathbf0  I_n  mathbfb_p \n0  mathbf0  1 endbmatrixleft(beginbmatrix 0  mathbfa_X  c_X \nmathbf0  0_n  mathbfb_X \n0  mathbf0  0 endbmatrixright) =\nbeginbmatrix 1  mathbfa_p + mathbfa_X  c_p + c_X + mathbfa_Xmathbfb_X2 + mathbfa_pmathbfb_X \nmathbf0  I_n  mathbfb_p + mathbfb_X \n0  mathbf0  1 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Base.log-Tuple{HeisenbergGroup, Any, Any}","page":"Group manifold","title":"Base.log","text":"log(G::HeisenbergGroup, p, q)\n\nCompute the logarithmic map on the HeisenbergGroup group. The formula reads\n\nlog_beginbmatrix 1  mathbfa_p  c_p \nmathbf0  I_n  mathbfb_p \n0  mathbf0  1 endbmatrixleft(beginbmatrix 1  mathbfa_q  c_q \nmathbf0  I_n  mathbfb_q \n0  mathbf0  1 endbmatrixright) =\nbeginbmatrix 0  mathbfa_q - mathbfa_p  c_q - c_p + mathbfa_pmathbfb_p - mathbfa_qmathbfb_q - (mathbfa_q - mathbfa_p)(mathbfb_q - mathbfb_p)  2 \nmathbf0  0_n  mathbfb_q - mathbfb_p \n0  mathbf0  0 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.exp_lie-Tuple{HeisenbergGroup, Any}","page":"Group manifold","title":"Manifolds.exp_lie","text":"exp_lie(M::HeisenbergGroup, X)\n\nLie group exponential for the HeisenbergGroup M of the vector X. The formula reads\n\nexpleft(beginbmatrix 0  mathbfa  c \nmathbf0  0_n  mathbfb \n0  mathbf0  0 endbmatrixright) = beginbmatrix 1  mathbfa  c + mathbfamathbfb2 \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.log_lie-Tuple{HeisenbergGroup, Any}","page":"Group manifold","title":"Manifolds.log_lie","text":"log_lie(M::HeisenbergGroup, p)\n\nLie group logarithm for the HeisenbergGroup M of the point p. The formula reads\n\nlogleft(beginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrixright) =\nbeginbmatrix 0  mathbfa  c - mathbfamathbfb2 \nmathbf0  0_n  mathbfb \n0  mathbf0  0 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.get_coordinates-Tuple{HeisenbergGroup, Any, Any, DefaultOrthonormalBasis{ℝ, ManifoldsBase.TangentSpaceType}}","page":"Group manifold","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::HeisenbergGroup, p, X, ::DefaultOrthonormalBasis{ℝ,TangentSpaceType})\n\nGet coordinates of tangent vector X at point p from the HeisenbergGroup M. Given a matrix\n\nbeginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\nthe coordinates are concatenated vectors mathbfa, mathbfb, and number c.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.get_vector-Tuple{HeisenbergGroup, Any, Any, DefaultOrthonormalBasis{ℝ, ManifoldsBase.TangentSpaceType}}","page":"Group manifold","title":"ManifoldsBase.get_vector","text":"get_vector(M::HeisenbergGroup, p, Xⁱ, ::DefaultOrthonormalBasis{ℝ,TangentSpaceType})\n\nGet tangent vector with coordinates Xⁱ at point p from the HeisenbergGroup M. Given a vector of coordinates beginbmatrixmathbba  mathbbb  cendbmatrix the tangent vector is equal to\n\nbeginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.injectivity_radius-Tuple{HeisenbergGroup}","page":"Group manifold","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::HeisenbergGroup)\n\nReturn the injectivity radius on the HeisenbergGroup M, which is .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.project-Union{Tuple{n}, Tuple{HeisenbergGroup{n}, Any, Any}} where n","page":"Group manifold","title":"ManifoldsBase.project","text":"project(M::HeisenbergGroup{n}, p, X)\n\nProject a matrix X in the Euclidean embedding onto the Lie algebra of HeisenbergGroup M. Sets the diagonal elements to 0 and all non-diagonal elements except the first row and the last column to 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.project-Union{Tuple{n}, Tuple{HeisenbergGroup{n}, Any}} where n","page":"Group manifold","title":"ManifoldsBase.project","text":"project(M::HeisenbergGroup{n}, p)\n\nProject a matrix p in the Euclidean embedding onto the HeisenbergGroup M. Sets the diagonal elements to 1 and all non-diagonal elements except the first row and the last column to 0.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Group-actions","page":"Group manifold","title":"Group actions","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Group actions represent actions of a given group on a specified manifold. The following operations are available:","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"apply: performs given action of an element of the group on an object of compatible type.\napply_diff: differential of apply with respect to the object it acts upon.\ndirection: tells whether a given action is LeftAction or RightAction.\ninverse_apply: performs given action of the inverse of an element of the group on an object of compatible type. By default inverts the element and calls apply but it may be have a faster implementation for some actions.\ninverse_apply_diff: counterpart of apply_diff for inverse_apply.\noptimal_alignment: determine the element of a group that, when it acts upon a point, produces the element closest to another given point in the metric of the G-manifold.","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Furthermore, group operation action features the following:","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"translate: an operation that performs either left (LeftAction) or right (RightAction) translation. This is by default performed by calling compose with appropriate order of arguments. This function is separated from compose mostly to easily represent its differential, translate_diff.\ntranslate_diff: differential of translate with respect to the point being translated.\nadjoint_action: adjoint action of a given element of a Lie group on an element of its Lie algebra.\nlie_bracket: Lie bracket of two vectors from a Lie algebra corresponding to a given group.","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"The following group actions are available:","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Group operation action GroupOperationAction that describes action of a group on itself.\nRotationAction, that is action of SpecialOrthogonal group on different manifolds.\nTranslationAction, which is the action of TranslationGroup group on different manifolds.","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AbstractGroupAction","page":"Group manifold","title":"Manifolds.AbstractGroupAction","text":"AbstractGroupAction\n\nAn abstract group action on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.apply!-Tuple{AbstractGroupAction{LeftAction}, Any, Any, Any}","page":"Group manifold","title":"Manifolds.apply!","text":"apply!(A::AbstractGroupAction, q, a, p)\n\nApply action a to the point p with the rule specified by A. The result is saved in q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.apply-Tuple{AbstractGroupAction, Any, Any}","page":"Group manifold","title":"Manifolds.apply","text":"apply(A::AbstractGroupAction, a, p)\n\nApply action a to the point p using map τ_a, specified by A. Unless otherwise specified, the right action is defined in terms of the left action:\n\nmathrmR_a = mathrmL_a^-1\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.apply_diff-Tuple{AbstractGroupAction, Any, Any, Any}","page":"Group manifold","title":"Manifolds.apply_diff","text":"apply_diff(A::AbstractGroupAction, a, p, X)\n\nFor group point p  mathcal M and tangent vector X  T_p mathcal M, compute the action on X of the differential of the action of a  mathcalG, specified by rule A. Written as (mathrmdτ_a)_p, with the specified left or right convention, the differential transports vectors\n\n(mathrmdτ_a)_p  T_p mathcal M  T_τ_a p mathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.base_group-Tuple{AbstractGroupAction}","page":"Group manifold","title":"Manifolds.base_group","text":"base_group(A::AbstractGroupAction)\n\nThe group that acts in action A.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.center_of_orbit","page":"Group manifold","title":"Manifolds.center_of_orbit","text":"center_of_orbit(\n    A::AbstractGroupAction,\n    pts,\n    p,\n    mean_method::AbstractEstimationMethod = GradientDescentEstimation(),\n)\n\nCalculate an action element a of action A that is the mean element of the orbit of p with respect to given set of points pts. The mean is calculated using the method mean_method.\n\nThe orbit of p with respect to the action of a group mathcalG is the set\n\nO =  τ_a p  a  mathcalG \n\nThis function is useful for computing means on quotients of manifolds by a Lie group action.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/group.html#Manifolds.direction-Union{Tuple{AbstractGroupAction{AD}}, Tuple{AD}} where AD","page":"Group manifold","title":"Manifolds.direction","text":"direction(::AbstractGroupAction{AD}) -> AD\n\nGet the direction of the action\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.group_manifold-Tuple{AbstractGroupAction}","page":"Group manifold","title":"Manifolds.group_manifold","text":"group_manifold(A::AbstractGroupAction)\n\nThe manifold the action A acts upon.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply!-Tuple{AbstractGroupAction, Any, Any, Any}","page":"Group manifold","title":"Manifolds.inverse_apply!","text":"inverse_apply!(A::AbstractGroupAction, q, a, p)\n\nApply inverse of action a to the point p with the rule specified by A. The result is saved in q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply-Tuple{AbstractGroupAction, Any, Any}","page":"Group manifold","title":"Manifolds.inverse_apply","text":"inverse_apply(A::AbstractGroupAction, a, p)\n\nApply inverse of action a to the point p. The action is specified by A.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply_diff-Tuple{AbstractGroupAction, Any, Any, Any}","page":"Group manifold","title":"Manifolds.inverse_apply_diff","text":"inverse_apply_diff(A::AbstractGroupAction, a, p, X)\n\nFor group point p  mathcal M and tangent vector X  T_p mathcal M, compute the action on X of the differential of the inverse action of a  mathcalG, specified by rule A. Written as (mathrmdτ_a^-1)_p, with the specified left or right convention, the differential transports vectors\n\n(mathrmdτ_a^-1)_p  T_p mathcal M  T_τ_a^-1 p mathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.optimal_alignment!-Tuple{AbstractGroupAction, Any, Any, Any}","page":"Group manifold","title":"Manifolds.optimal_alignment!","text":"optimal_alignment!(A::AbstractGroupAction, x, p, q)\n\nCalculate an action element of action A that acts upon p to produce the element closest to q. The result is written to x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.optimal_alignment-Tuple{AbstractGroupAction, Any, Any}","page":"Group manifold","title":"Manifolds.optimal_alignment","text":"optimal_alignment(A::AbstractGroupAction, p, q)\n\nCalculate an action element a of action A that acts upon p to produce the element closest to q in the metric of the G-manifold:\n\nargmin_a  mathcalG d_mathcal M(τ_a p q)\n\nwhere mathcalG is the group that acts on the G-manifold mathcal M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Group-operation-action","page":"Group manifold","title":"Group operation action","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group_operation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.GroupOperationAction","page":"Group manifold","title":"Manifolds.GroupOperationAction","text":"GroupOperationAction(group::AbstractDecoratorManifold, AD::ActionDirection = LeftAction())\n\nAction of a group upon itself via left or right translation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Rotation-action","page":"Group manifold","title":"Rotation action","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/rotation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.RotationAction","page":"Group manifold","title":"Manifolds.RotationAction","text":"RotationAction(\n    M::AbstractManifold,\n    SOn::SpecialOrthogonal,\n    AD::ActionDirection = LeftAction(),\n)\n\nSpace of actions of the SpecialOrthogonal group mathrmSO(n) on a Euclidean-like manifold M of dimension n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.RotationAroundAxisAction","page":"Group manifold","title":"Manifolds.RotationAroundAxisAction","text":"RotationAroundAxisAction(axis::AbstractVector)\n\nSpace of actions of the circle group RealCircleGroup on ℝ^3 around given axis.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.apply-Tuple{Manifolds.RotationAroundAxisAction, Any, Any}","page":"Group manifold","title":"Manifolds.apply","text":"apply(A::RotationAroundAxisAction, θ, p)\n\nRotate point p from Euclidean(3) manifold around axis A.axis by angle θ. The formula reads\n\np_rot = (cos(θ))p + (kp) sin(θ) + k (kp) (1-cos(θ))\n\nwhere k is the vector A.axis and ⋅ is the dot product.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Translation-action","page":"Group manifold","title":"Translation action","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/translation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.TranslationAction","page":"Group manifold","title":"Manifolds.TranslationAction","text":"TranslationAction(\n    M::AbstractManifold,\n    Rn::TranslationGroup,\n    AD::ActionDirection = LeftAction(),\n)\n\nSpace of actions of the TranslationGroup mathrmT(n) on a Euclidean-like manifold M.\n\nThe left and right actions are equivalent.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Metrics-on-groups","page":"Group manifold","title":"Metrics on groups","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Lie groups by default typically forward all metric-related operations like exponential or logarithmic map to the underlying manifold, for example SpecialOrthogonal uses methods for Rotations (which is, incidentally, bi-invariant), or SpecialEuclidean uses product metric of the translation and rotation parts (which is not invariant under group operation).","category":"page"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"It is, however, possible to change the metric used by a group by wrapping it in a MetricManifold decorator.","category":"page"},{"location":"manifolds/group.html#Invariant-metrics","page":"Group manifold","title":"Invariant metrics","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/metric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.LeftInvariantMetric","page":"Group manifold","title":"Manifolds.LeftInvariantMetric","text":"LeftInvariantMetric <: AbstractMetric\n\nAn AbstractMetric that changes the metric of a Lie group to the left-invariant metric obtained by left-translations to the identity. Adds the HasLeftInvariantMetric trait.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.RightInvariantMetric","page":"Group manifold","title":"Manifolds.RightInvariantMetric","text":"RightInvariantMetric <: AbstractMetric\n\nAn AbstractMetric that changes the metric of a Lie group to the right-invariant metric obtained by right-translations to the identity. Adds the HasRightInvariantMetric trait.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.direction-Tuple{AbstractDecoratorManifold}","page":"Group manifold","title":"Manifolds.direction","text":"direction(::AbstractDecoratorManifold) -> AD\n\nGet the direction of the action a certain Lie group with its implicit metric has\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.has_approx_invariant_metric-Tuple{AbstractDecoratorManifold, Any, Any, Any, Any, ActionDirection}","page":"Group manifold","title":"Manifolds.has_approx_invariant_metric","text":"has_approx_invariant_metric(\n    G::AbstractDecoratorManifold,\n    p,\n    X,\n    Y,\n    qs::AbstractVector,\n    conv::ActionDirection = LeftAction();\n    kwargs...,\n) -> Bool\n\nCheck whether the metric on the group mathcalG is (approximately) invariant using a set of predefined points. Namely, for p  mathcalG, XY  T_p mathcalG, a metric g, and a translation map τ_q in the specified direction, check for each q  mathcalG that the following condition holds:\n\ng_p(X Y)  g_τ_q p((mathrmdτ_q)_p X (mathrmdτ_q)_p Y)\n\nThis is necessary but not sufficient for invariance.\n\nOptionally, kwargs passed to isapprox may be provided.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Cartan-Schouten-connections","page":"Group manifold","title":"Cartan-Schouten connections","text":"","category":"section"},{"location":"manifolds/group.html","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/connections.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AbstractCartanSchoutenConnection","page":"Group manifold","title":"Manifolds.AbstractCartanSchoutenConnection","text":"AbstractCartanSchoutenConnection\n\nAbstract type for Cartan-Schouten connections, that is connections whose geodesics going through group identity are one-parameter subgroups. See[Pennec2020] for details.\n\n[Pennec2020]: X. Pennec and M. Lorenzi, “5 - Beyond Riemannian geometry: The affine connection setting for transformation groups,” in Riemannian Geometric Statistics in Medical Image Analysis, X. Pennec, S. Sommer, and T. Fletcher, Eds. Academic Press, 2020, pp. 169–229. doi: 10.1016/B978-0-12-814725-2.00012-1.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.CartanSchoutenMinus","page":"Group manifold","title":"Manifolds.CartanSchoutenMinus","text":"CartanSchoutenMinus\n\nThe unique Cartan-Schouten connection such that all left-invariant vector fields are globally defined by their value at identity. It is biinvariant with respect to the group operation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.CartanSchoutenPlus","page":"Group manifold","title":"Manifolds.CartanSchoutenPlus","text":"CartanSchoutenPlus\n\nThe unique Cartan-Schouten connection such that all right-invariant vector fields are globally defined by their value at identity. It is biinvariant with respect to the group operation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.CartanSchoutenZero","page":"Group manifold","title":"Manifolds.CartanSchoutenZero","text":"CartanSchoutenZero\n\nThe unique torsion-free Cartan-Schouten connection. It is biinvariant with respect to the group operation.\n\nIf the metric on the underlying manifold is bi-invariant then it is equivalent to the Levi-Civita connection of that metric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Base.exp-Union{Tuple{𝔽}, Tuple{ConnectionManifold{𝔽, var\"#s79\", var\"#s78\"} where {var\"#s79\"<:AbstractDecoratorManifold{𝔽}, var\"#s78\"<:AbstractCartanSchoutenConnection}, Any, Any}} where 𝔽","page":"Group manifold","title":"Base.exp","text":"exp(M::ConnectionManifold{𝔽,<:AbstractDecoratorManifold{𝔽},<:AbstractCartanSchoutenConnection}, p, X) where {𝔽}\n\nCompute the exponential map on the ConnectionManifold M with a Cartan-Schouten connection. See Sections 5.3.2 and 5.3.3 of [Pennec2020] for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Base.log-Union{Tuple{𝔽}, Tuple{ConnectionManifold{𝔽, var\"#s79\", var\"#s78\"} where {var\"#s79\"<:AbstractDecoratorManifold{𝔽}, var\"#s78\"<:AbstractCartanSchoutenConnection}, Any, Any}} where 𝔽","page":"Group manifold","title":"Base.log","text":"log(M::ConnectionManifold{𝔽,<:AbstractDecoratorManifold{𝔽},<:AbstractCartanSchoutenConnection}, p, q) where {𝔽}\n\nCompute the logarithmic map on the ConnectionManifold M with a Cartan-Schouten connection. See Sections 5.3.2 and 5.3.3 of [Pennec2020] for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.parallel_transport_direction-Tuple{ConnectionManifold{𝔽, M, CartanSchoutenZero} where {𝔽, M}, Identity, Any, Any}","page":"Group manifold","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::CartanSchoutenZeroGroup, ::Identity, X, d)\n\nTransport tangent vector X at identity on the group manifold with the CartanSchoutenZero connection in the direction d. See [Pennec2020] for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.parallel_transport_to-Tuple{ConnectionManifold{𝔽, M, CartanSchoutenMinus} where {𝔽, M}, Any, Any, Any}","page":"Group manifold","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::CartanSchoutenMinusGroup, p, X, q)\n\nTransport tangent vector X at point p on the group manifold M with the CartanSchoutenMinus connection to point q. See [Pennec2020] for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.parallel_transport_to-Tuple{ConnectionManifold{𝔽, M, CartanSchoutenPlus} where {𝔽, M}, Any, Any, Any}","page":"Group manifold","title":"ManifoldsBase.parallel_transport_to","text":"vector_transport_to(M::CartanSchoutenPlusGroup, p, X, q)\n\nTransport tangent vector X at point p on the group manifold M with the CartanSchoutenPlus connection to point q. See [Pennec2020] for details.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#ManifoldsBase.parallel_transport_to-Tuple{ConnectionManifold{𝔽, M, CartanSchoutenZero} where {𝔽, M}, Identity, Any, Any}","page":"Group manifold","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::CartanSchoutenZeroGroup, p::Identity, X, q)\n\nTransport vector X at identity of group M equipped with the CartanSchoutenZero connection to point q using parallel transport.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Metric-manifold","page":"Metric manifold","title":"Metric manifold","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"A Riemannian manifold always consists of a topological manifold together with a smoothly varying metric g.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"However, often there is an implicitly assumed (default) metric, like the usual inner product on Euclidean space. This decorator takes this into account. It is not necessary to use this decorator if you implement just one (or the first) metric. If you later introduce a second, the old (first) metric can be used with the (non MetricManifold) AbstractManifold, i.e. without an explicitly stated metric.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"This manifold decorator serves two purposes:","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"to implement different metrics (e.g. in closed form) for one AbstractManifold\nto provide a way to compute geodesics on manifolds, where this AbstractMetric does not yield closed formula.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Pages = [\"metric.md\"]\nDepth = 2","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Note that a metric manifold is has a IsConnectionManifold trait referring to the LeviCivitaConnection of the metric g, and thus a large part of metric manifold's functionality relies on this.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Let's first look at the provided types.","category":"page"},{"location":"manifolds/metric.html#Types","page":"Metric manifold","title":"Types","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/MetricManifold.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/metric.html#Manifolds.AbstractMetric","page":"Metric manifold","title":"Manifolds.AbstractMetric","text":"AbstractMetric\n\nAbstract type for the pseudo-Riemannian metric tensor g, a family of smoothly varying inner products on the tangent space. See inner.\n\nFunctor\n\n(metric::Metric)(M::AbstractManifold)\n(metric::Metric)(M::MetricManifold)\n\nGenerate the MetricManifold that wraps the manifold M with given metric. This works for both a variable containing the metric as well as a subtype T<:AbstractMetric, where a zero parameter constructor T() is availabe. If M is already a metric manifold, the inner manifold with the new metric is returned.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.IsDefaultMetric","page":"Metric manifold","title":"Manifolds.IsDefaultMetric","text":"IsDefaultMetric{G<:AbstractMetric}\n\nSpecify that a certain AbstractMetric is the default metric for a manifold. This way the corresponding MetricManifold falls back to the default methods of the manifold it decorates.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.IsMetricManifold","page":"Metric manifold","title":"Manifolds.IsMetricManifold","text":"IsMetricManifold <: AbstractTrait\n\nSpecify that a certain decorated Manifold is a metric manifold in the sence that it provides explicit metric properties, extending/changing the default metric properties of a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.MetricManifold","page":"Metric manifold","title":"Manifolds.MetricManifold","text":"MetricManifold{𝔽,M<:AbstractManifold{𝔽},G<:AbstractMetric} <: AbstractDecoratorManifold{𝔽}\n\nEquip a AbstractManifold explicitly with a AbstractMetric G.\n\nFor a Metric AbstractManifold, by default, assumes, that you implement the linear form from local_metric in order to evaluate the exponential map.\n\nIf the corresponding AbstractMetric G yields closed form formulae for e.g. the exponential map and this is implemented directly (without solving the ode), you can of course still implement that directly.\n\nConstructor\n\nMetricManifold(M, G)\n\nGenerate the AbstractManifold M as a manifold with the AbstractMetric G.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.RiemannianMetric","page":"Metric manifold","title":"Manifolds.RiemannianMetric","text":"RiemannianMetric <: AbstractMetric\n\nAbstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for X   T_p mathcal M, the inner product g(X X)  0 whenever X is not the zero vector.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Implement-Different-Metrics-on-the-same-Manifold","page":"Metric manifold","title":"Implement Different Metrics on the same Manifold","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"In order to distinguish different metrics on one manifold, one can introduce two AbstractMetrics and use this type to dispatch on the metric, see SymmetricPositiveDefinite. To avoid overhead, one AbstractMetric can then be marked as being the default, i.e. the one that is used, when no MetricManifold decorator is present. This avoids reimplementation of the first existing metric, access to the metric-dependent functions that were implemented using the undecorated manifold, as well as the transparent fallback of the corresponding MetricManifold with default metric to the undecorated implementations. This does not cause any runtime overhead. Introducing a default AbstractMetric serves a better readability of the code when working with different metrics.","category":"page"},{"location":"manifolds/metric.html#Implementation-of-Metrics","page":"Metric manifold","title":"Implementation of Metrics","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"For the case that a local_metric is implemented as a bilinear form that is positive definite, the following further functions are provided, unless the corresponding AbstractMetric is marked as default – then the fallbacks mentioned in the last section are used for e.g. the exp!onential map.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/MetricManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/metric.html#Base.log-Tuple{MetricManifold, Vararg{Any, N} where N}","page":"Metric manifold","title":"Base.log","text":"log(N::MetricManifold{M,G}, p, q)\n\nCopute the logarithmic map on the AbstractManifold M equipped with the AbstractMetric G.\n\nIf the metric was declared the default metric using the IsDefaultMetric trait or is_default_metric, this method falls back to log(M,p,q). Otherwise, you have to provide an implementation for the non-default AbstractMetric G metric within its MetricManifold{M,G}.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.change_metric-Tuple{AbstractManifold, AbstractMetric, Any, Any}","page":"Metric manifold","title":"Manifolds.change_metric","text":"change_metric(M::AbstractcManifold, G2::AbstractMetric, p, X)\n\nOn the AbstractManifold M with implicitly given metric g_1 and a second AbstractMetric g_2 this function performs a change of metric in the sense that it returns the tangent vector Z=BX such that the linear map B fulfills\n\ng_2(Y_1Y_2) = g_1(BY_1BY_2) quad textfor all  Y_1 Y_2  T_pmathcal M\n\nIf both metrics are given in their local_metric (symmetric positive defintie) matrix representations G_1 = C_1C_1^mathrmH and G_2 = C_2C_2^mathrmH, where C_1C_2 denote their respective Cholesky factors, then solving C_2C_2^mathrmH = G_2 = B^mathrmHG_1B = B^mathrmHC_1C_1^mathrmHB yields B = (C_1 backslash C_2)^mathrmH, where cdot^mathrmH denotes the conjugate transpose.\n\nThis function returns Z = BX.\n\nExamples\n\nchange_metric(Sphere(2), EuclideanMetric(), p, X)\n\nSince the metric in T_pmathbb S^2 is the Euclidean metric from the embedding restricted to T_pmathbb S^2, this just returns X\n\nchange_metric(SymmetricPOsitiveDefinite(3), EuclideanMetric, p, X)\n\nHere, the default metric in mathcal P(3) is the LinearAffineMetric and the transformation can be computed as B=p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.change_representer-Tuple{AbstractManifold, AbstractMetric, Any, Any}","page":"Metric manifold","title":"Manifolds.change_representer","text":"change_representer(M::AbstractManifold, G2::AbstractMetric, p, X)\n\nConvert the representer X of a linear function (in other words a cotangent vector at p) in the tangent space at p on the AbstractManifold M given with respect to the AbstractMetric G2 into the representer with respect to the (implicit) metric of M.\n\nIn order to convert X into the representer with respect to the (implicitly given) metric g_1 of M, we have to find the conversion function c T_pmathcal M to T_pmathcal M such that\n\n    g_2(XY) = g_1(c(X)Y)\n\nIf both metrics are given in their local_metric (symmetric positive defintie) matrix representations G_1 and G_2 and xy are the local coordinates with respect to the same basis of the tangent space, the equation reads\n\n   x^mathrmHG_2y = c(x)^mathrmHG_1 y quad textfor all  y in ℝ^d\n\nwhere cdot^mathrmH denotes the conjugate transpose. We obtain c(X) = (G_1backslash G_2)^mathrmHX\n\nFor example X could be the gradient operatornamegradf of a real-valued function f mathcal M to ℝ, i.e.\n\n    g_2(XY) = Df(p)Y quad textfor all  Y  T_pmathcal M\n\nand we would change the Riesz representer X to the representer with respect to the metric g_1.\n\nExamples\n\nchange_representer(Sphere(2), EuclideanMetric(), p, X)\n\nSince the metric in T_pmathbb S^2 is the Euclidean metric from the embedding restricted to T_pmathbb S^2, this just returns X\n\nchange_representer(SymmetricPositiveDefinite(3), EuclideanMetric(), p, X)\n\nHere, the default metric in mathcal P(3) is the LinearAffineMetric and the transformation can be computed as pXp\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.connection-Tuple{MetricManifold}","page":"Metric manifold","title":"Manifolds.connection","text":"connection(::MetricManifold)\n\nReturn the LeviCivitaConnection for a metric manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.det_local_metric-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.det_local_metric","text":"det_local_metric(M::AbstractManifold, p, B::AbstractBasis)\n\nReturn the determinant of local matrix representation of the metric tensor g, i.e. of the matrix G(p) representing the metric in the tangent space at p with as a matrix.\n\nSee also local_metric\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.einstein_tensor-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.einstein_tensor","text":"einstein_tensor(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = diff_badefault_differential_backendckend())\n\nCompute the Einstein tensor of the manifold M at the point p, see https://en.wikipedia.org/wiki/Einstein_tensor\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.flat-Tuple{MetricManifold, Any, TFVector{TData, TBasis} where {TData, TBasis<:AbstractBasis}}","page":"Metric manifold","title":"Manifolds.flat","text":"flat(N::MetricManifold{M,G}, p, X::TFVector)\n\nCompute the musical isomorphism to transform the tangent vector X from the AbstractManifold M equipped with AbstractMetric G to a cotangent by computing\n\nX^= G_p X\n\nwhere G_p is the local matrix representation of G, see local_metric\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.inverse_local_metric-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.inverse_local_metric","text":"inverse_local_metric(M::AbstractcManifold{𝔽}, p, B::AbstractBasis)\n\nReturn the local matrix representation of the inverse metric (cometric) tensor of the tangent space at p on the AbstractManifold M with respect to the AbstractBasis basis B.\n\nThe metric tensor (see local_metric) is usually denoted by G = (g_ij)  𝔽^dd, where d is the dimension of the manifold.\n\nThen the inverse local metric is denoted by G^-1 = g^ij.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.is_default_metric-Tuple{AbstractManifold, AbstractMetric}","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(M::AbstractManifold, G::AbstractMetric)\n\nreturns whether an AbstractMetric is the default metric on the manifold M or not. This can be set by defining this function, or setting the IsDefaultMetric trait for an AbstractDecoratorManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.local_metric","text":"local_metric(M::AbstractManifold{𝔽}, p, B::AbstractBasis)\n\nReturn the local matrix representation at the point p of the metric tensor g with respect to the AbstractBasis B on the AbstractManifold M. Let ddenote the dimension of the manifold and b_1ldotsb_d the basis vectors. Then the local matrix representation is a matrix Gin 𝔽^ntimes n whose entries are given by g_ij = g_p(b_ib_j) ijin1d.\n\nThis yields the property for two tangent vectors (using Einstein summation convention) X = X^ib_i Y=Y^ib_i in T_pmathcal M we get g_p(X Y) = g_ij X^i Y^j.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric_jacobian-Tuple{AbstractManifold, Any, AbstractBasis, Manifolds.AbstractDiffBackend}","page":"Metric manifold","title":"Manifolds.local_metric_jacobian","text":"local_metric_jacobian(\n    M::AbstractManifold,\n    p,\n    B::AbstractBasis;\n    backend::AbstractDiffBackend,\n)\n\nGet partial derivatives of the local metric of M at p in basis B with respect to the coordinates of p, frac p^k g_ij = g_ijk. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.log_local_metric_density-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.log_local_metric_density","text":"log_local_metric_density(M::AbstractManifold, p, B::AbstractBasis)\n\nReturn the natural logarithm of the metric density ρ of M at p, which is given by ρ = log sqrtdet g_ij for the metric tensor expressed in basis B.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.metric-Tuple{MetricManifold}","page":"Metric manifold","title":"Manifolds.metric","text":"metric(M::MetricManifold)\n\nGet the metric g of the manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_curvature-Tuple{AbstractManifold, Any, AbstractBasis}","page":"Metric manifold","title":"Manifolds.ricci_curvature","text":"ricci_curvature(M::AbstractManifold, p, B::AbstractBasis; backend::AbstractDiffBackend = default_differential_backend())\n\nCompute the Ricci scalar curvature of the manifold M at the point p using basis B. The curvature is computed as the trace of the Ricci curvature tensor with respect to the metric, that is R=g^ijR_ij where R is the scalar Ricci curvature at p, g^ij is the inverse local metric (see inverse_local_metric) at p and R_ij is the Riccie curvature tensor, see ricci_tensor. Both the tensor and inverse local metric are expressed in local coordinates defined by B, and the formula uses the Einstein summation convention.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.sharp-Tuple{MetricManifold, Any, CoTFVector{TData, TBasis} where {TData, TBasis<:AbstractBasis}}","page":"Metric manifold","title":"Manifolds.sharp","text":"sharp(N::MetricManifold{M,G}, p, ξ::CoTFVector)\n\nCompute the musical isomorphism to transform the cotangent vector ξ from the AbstractManifold M equipped with AbstractMetric G to a tangent by computing\n\nξ^ = G_p^-1 ξ\n\nwhere G_p is the local matrix representation of G, i.e. one employs inverse_local_metric here to obtain G_p^-1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#ManifoldsBase.inner-Tuple{MetricManifold, Any, Any, Any}","page":"Metric manifold","title":"ManifoldsBase.inner","text":"inner(N::MetricManifold{M,G}, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on the AbstractManifold M using the AbstractMetric G. If M has G as its IsDefaultMetric trait, this is done using inner(M, p, X, Y), otherwise the local_metric(M, p) is employed as\n\ng_p(X Y) = X G_p Y\n\nwhere G_p is the loal matrix representation of the AbstractMetric G.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Metrics,-charts-and-bases-of-vector-spaces","page":"Metric manifold","title":"Metrics, charts and bases of vector spaces","text":"","category":"section"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Metric-related functions, similarly to connection-related functions, need to operate in a basis of a vector space, see here.","category":"page"},{"location":"manifolds/metric.html","page":"Metric manifold","title":"Metric manifold","text":"Metric-related functions can take bases of associated tangent spaces as arguments. For example local_metric can take the basis of the tangent space it is supposed to operate on instead of a custom basis of the space of symmetric bilinear operators.","category":"page"},{"location":"manifolds/symmetric.html#Symmetric-matrices","page":"Symmetric matrices","title":"Symmetric matrices","text":"","category":"section"},{"location":"manifolds/symmetric.html","page":"Symmetric matrices","title":"Symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/Symmetric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetric.html#Manifolds.SymmetricMatrices","page":"Symmetric matrices","title":"Manifolds.SymmetricMatrices","text":"SymmetricMatrices{n,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold  $ \\operatorname{Sym}(n)$ consisting of the real- or complex-valued symmetric matrices of size n  n, i.e. the set\n\noperatornameSym(n) = biglp   𝔽^n  n big p^mathrmH = p bigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ.\n\nThough it is slightly redundant, usually the matrices are stored as n  n arrays.\n\nNote that in this representation, the complex valued case has to have a real-valued diagonal, which is also reflected in the manifold_dimension.\n\nConstructor\n\nSymmetricMatrices(n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of n  n symmetric matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{SymmetricMatrices{n, 𝔽}, Any}} where {n, 𝔽}","page":"Symmetric matrices","title":"ManifoldsBase.check_point","text":"check_point(M::SymmetricMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether p is a valid manifold point on the SymmetricMatrices M, i.e. whether p is a symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽.\n\nThe tolerance for the symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{n}, Tuple{SymmetricMatrices{n, 𝔽}, Any, Any}} where {n, 𝔽}","page":"Symmetric matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymmetricMatrices{n,𝔽}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SymmetricMatrices M, i.e. X has to be a symmetric matrix of size (n,n) and its values have to be from the correct AbstractNumbers.\n\nThe tolerance for the symmetry of X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricMatrices{N, 𝔽}}, Tuple{𝔽}, Tuple{N}} where {N, 𝔽}","page":"Symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricMatrices{n,𝔽})\n\nReturn the dimension of the SymmetricMatrices matrix M over the number system 𝔽, i.e.\n\nbeginaligned\ndim mathrmSym(nℝ) = fracn(n+1)2\ndim mathrmSym(nℂ) = 2fracn(n+1)2 - n = n^2\nendaligned\n\nwhere the last -n is due to the zero imaginary part for Hermitian matrices\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project-Tuple{SymmetricMatrices, Any, Any}","page":"Symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SymmetricMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SymmetricMatrices M,\n\noperatornameproj_p(X) = frac12 bigl( X + X^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project-Tuple{SymmetricMatrices, Any}","page":"Symmetric matrices","title":"ManifoldsBase.project","text":"project(M::SymmetricMatrices, p)\n\nProjects p from the embedding onto the SymmetricMatrices M, i.e.\n\noperatornameproj_operatornameSym(n)(p) = frac12 bigl( p + p^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Grassmannian-manifold","page":"Grassmann","title":"Grassmannian manifold","text":"","category":"section"},{"location":"manifolds/grassmann.html","page":"Grassmann","title":"Grassmann","text":"Modules = [Manifolds]\nPages = [\"manifolds/Grassmann.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/grassmann.html#Manifolds.Grassmann","page":"Grassmann","title":"Manifolds.Grassmann","text":"Grassmann{n,k,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe Grassmann manifold operatornameGr(nk) consists of all subspaces spanned by k linear independent vectors 𝔽^n, where 𝔽   ℝ ℂ is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of ℝ^n for the real-valued case and all 2k-dimensional subspaces of ℂ^n for the second.\n\nThe manifold can be represented as\n\noperatornameGr(nk) = bigl operatornamespan(p)  p  𝔽^n  k p^mathrmHp = I_k\n\nwhere cdot^mathrmH denotes the complex conjugate transpose or Hermitian and I_k is the k  k identity matrix. This means, that the columns of p form an unitary basis of the subspace, that is a point on operatornameGr(nk), and hence the subspace can actually be represented by a whole equivalence class of representers. Another interpretation is, that\n\noperatornameGr(nk) = operatornameSt(nk)  operatornameO(k)\n\ni.e the Grassmann manifold is the quotient of the Stiefel manifold and the orthogonal group operatornameO(k) of orthogonal k  k matrices.\n\nThe tangent space at a point (subspace) x is given by\n\nT_xmathrmGr(nk) = bigl\nX  𝔽^n  k \nX^mathrmHp + p^mathrmHX = 0_k bigr\n\nwhere 0_k is the k  k zero matrix.\n\nNote that a point p  operatornameGr(nk) might be represented by different matrices (i.e. matrices with unitary column vectors that span the same subspace). Different representations of p also lead to different representation matrices for the tangent space T_pmathrmGr(nk)\n\nThe manifold is named after Hermann G. Graßmann (1809-1877).\n\nConstructor\n\nGrassmann(n,k,field=ℝ)\n\nGenerate the Grassmann manifold operatornameGr(nk), where the real-valued case field = ℝ is the default.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann.html#Base.exp-Tuple{Grassmann, Vararg{Any, N} where N}","page":"Grassmann","title":"Base.exp","text":"exp(M::Grassmann, p, X)\n\nCompute the exponential map on the Grassmann M= mathrmGr(nk) starting in p with tangent vector (direction) X. Let X = USV denote the SVD decomposition of X. Then the exponential map is written using\n\nz = p Vcos(S)V^mathrmH + Usin(S)V^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian and the cosine and sine are applied element wise to the diagonal entries of S. A final QR decomposition z=QR is performed for numerical stability reasons, yielding the result as\n\nexp_p X = Q\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Base.log-Tuple{Grassmann, Vararg{Any, N} where N}","page":"Grassmann","title":"Base.log","text":"log(M::Grassmann, p, q)\n\nCompute the logarithmic map on the Grassmann M$ = \\mathcal M=\\mathrm{Gr}(n,k)$, i.e. the tangent vector X whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = Vcdot operatornameatan(S) cdot U^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian. The matrices U and V are the unitary matrices, and S is the diagonal matrix containing the singular values of the SVD-decomposition\n\nUSV = (q^mathrmHp)^-1 ( q^mathrmH - q^mathrmHpp^mathrmH)\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Base.rand-Tuple{Grassmann}","page":"Grassmann","title":"Base.rand","text":"rand(M::Grassmann; σ::Real=1.0, vector_at=nothing)\n\nWhen vector_at is nothing, return a random point p on Grassmann manifold M by generating a random (Gaussian) matrix with standard deviation σ in matching size, which is orthonormal.\n\nWhen vector_at is not nothing, return a (Gaussian) random vector from the tangent space T_pmathrmGr(nk) with mean zero and standard deviation σ by projecting a random Matrix onto the tangent space at vector_at.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Manifolds.uniform_distribution-Union{Tuple{k}, Tuple{n}, Tuple{Grassmann{n, k, ℝ}, Any}} where {n, k}","page":"Grassmann","title":"Manifolds.uniform_distribution","text":"uniform_distribution(M::Grassmann{n,k,ℝ}, p)\n\nUniform distribution on given (real-valued) Grassmann M. Specifically, this is the normalized Haar measure on M. Generated points will be of similar type as p.\n\nThe implementation is based on Section 2.5.1 in [Chikuse2003]; see also Theorem 2.2.2(iii) in [Chikuse2003].\n\n[Chikuse2003]: Y. Chikuse: \"Statistics on Special Manifolds\", Springer New York, 2003, doi: 10.1007/978-0-387-21540-2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.distance-Tuple{Grassmann, Any, Any}","page":"Grassmann","title":"ManifoldsBase.distance","text":"distance(M::Grassmann, p, q)\n\nCompute the Riemannian distance on Grassmann manifold M= mathrmGr(nk).\n\nLet USV = p^mathrmHq denote the SVD decomposition of p^mathrmHq, where cdot^mathrmH denotes the complex conjugate transposed or Hermitian. Then the distance is given by\n\nd_mathrmGr(nk)(pq) = operatornamenorm(operatornameRe(b))\n\nwhere\n\nb_i=begincases\n0  textif  S_i  1\narccos(S_i)   textif  S_i1\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.injectivity_radius-Tuple{Grassmann}","page":"Grassmann","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Grassmann)\ninjectivity_radius(M::Grassmann, p)\n\nReturn the injectivity radius on the Grassmann M, which is fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inner-Tuple{Grassmann, Any, Any, Any}","page":"Grassmann","title":"ManifoldsBase.inner","text":"inner(M::Grassmann, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the Grassmann manifold M. The formula reads\n\ng_p(XY) = operatornametr(X^mathrmHY)\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract-Tuple{Grassmann, Any, Any, PolarInverseRetraction}","page":"Grassmann","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Grassmann, p, q, ::PolarInverseRetraction)\n\nCompute the inverse retraction for the PolarRetraction, on the Grassmann manifold M, i.e.,\n\noperatornameretr_p^-1q = q*(p^mathrmHq)^-1 - p\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract-Tuple{Grassmann, Any, Any, QRInverseRetraction}","page":"Grassmann","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, p, q, ::QRInverseRetraction)\n\nCompute the inverse retraction for the QRRetraction, on the Grassmann manifold M, i.e.,\n\noperatornameretr_p^-1q = q(p^mathrmHq)^-1 - p\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.manifold_dimension-Union{Tuple{Grassmann{n, k, 𝔽}}, Tuple{𝔽}, Tuple{k}, Tuple{n}} where {n, k, 𝔽}","page":"Grassmann","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Grassmann)\n\nReturn the dimension of the Grassmann(n,k,𝔽) manifold M, i.e.\n\ndim operatornameGr(nk) = k(n-k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.project-Tuple{Grassmann, Vararg{Any, N} where N}","page":"Grassmann","title":"ManifoldsBase.project","text":"project(M::Grassmann, p, X)\n\nProject the n-by-k X onto the tangent space of p on the Grassmann M, which is computed by\n\noperatornameproj_p(X) = X - pp^mathrmHX\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.representation_size-Union{Tuple{Grassmann{n, k, 𝔽} where 𝔽}, Tuple{k}, Tuple{n}} where {n, k}","page":"Grassmann","title":"ManifoldsBase.representation_size","text":"representation_size(M::Grassmann{n,k})\n\nReturn the represenation size or matrix dimension of a point on the Grassmann M, i.e. (nk) for both the real-valued and the complex value case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.retract-Tuple{Grassmann, Any, Any, PolarRetraction}","page":"Grassmann","title":"ManifoldsBase.retract","text":"retract(M::Grassmann, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Grassmann M. With USV = p + X the retraction reads\n\noperatornameretr_p X = UV^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.retract-Tuple{Grassmann, Any, Any, QRRetraction}","page":"Grassmann","title":"ManifoldsBase.retract","text":"retract(M::Grassmann, p, X, ::QRRetraction )\n\nCompute the QR-based retraction QRRetraction on the Grassmann M. With QR = p + X the retraction reads\n\noperatornameretr_p X = QD\n\nwhere D is a m  n matrix with\n\nD = operatornamediagleft( operatornamesgnleft(R_ii+frac12right)_i=1^n right)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.vector_transport_to-Tuple{Grassmann, Any, Any, Any, ProjectionTransport}","page":"Grassmann","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Grassmann,p,X,q,::ProjectionTransport)\n\ncompute the projection based transport on the Grassmann M by interpreting X from the tangent space at p as a point in the embedding and projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.zero_vector-Tuple{Grassmann, Vararg{Any, N} where N}","page":"Grassmann","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Grassmann, p)\n\nReturn the zero tangent vector from the tangent space at p on the Grassmann M, which is given by a zero matrix the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Statistics.mean-Tuple{Grassmann, Vararg{Any, N} where N}","page":"Grassmann","title":"Statistics.mean","text":"mean(\n    M::Grassmann,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Essential-Manifold","page":"Essential manifold","title":"Essential Manifold","text":"","category":"section"},{"location":"manifolds/essentialmanifold.html","page":"Essential manifold","title":"Essential manifold","text":"The essential manifold is modeled as an AbstractPowerManifold  of the 3times3 Rotations and uses NestedPowerRepresentation.","category":"page"},{"location":"manifolds/essentialmanifold.html","page":"Essential manifold","title":"Essential manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/EssentialManifold.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/essentialmanifold.html#Manifolds.EssentialManifold","page":"Essential manifold","title":"Manifolds.EssentialManifold","text":"EssentialManifold <: AbstractPowerManifold{ℝ}\n\nThe essential manifold is the space of the essential matrices which is represented as a quotient space of the Rotations manifold product mathrmSO(3)^2.\n\nLet R_x(θ) R_y(θ) R_x(θ) in ℝ^xtimes 3 denote the rotation around the z, y, and x axis in ℝ^3, respectively, and further the groups\n\nH_z = bigl(R_z(θ)R_z(θ)) big θ  -ππ) bigr\n\nand\n\nH_π = bigl (II) (R_x(π) R_x(π)) (IR_z(π)) (R_x(π) R_y(π))  bigr\n\nacting elementwise on the left from mathrmSO(3)^2 (component wise).\n\nThen the unsigned Essential manifold mathcalM_textE can be identified with the quotient space\n\nmathcalM_textE = (textSO(3)textSO(3))(H_z  H_π)\n\nand for the signed Essential manifold mathcalM_textƎ, the quotient reads\n\nmathcalM_textƎ = (textSO(3)textSO(3))(H_z)\n\nAn essential matrix is defined as\n\nE = (R_1)^T T_2 - T_1_ R_2\n\nwhere the poses of two cameras (R_i T_i) i=12, are contained in the space of rigid body transformations SE(3) and the operator _colon ℝ^3 to operatornameSkewSym(3) denotes the matrix representation of the cross product operator. For more details see [TronDaniilidis2017].\n\nConstructor\n\nEssentialManifold(is_signed=true)\n\nGenerate the manifold of essential matrices, either the signed (is_signed=true) or unsigned (is_signed=false) variant.\n\n[TronDaniilidis2017]: Tron R.; Daniilidis K.; The Space of Essential Matrices as a Riemannian Quotient AbstractManifold. SIAM Journal on Imaging Sciences (2017), DOI: 10.1137/16M1091332, PDF: https://www.cis.upenn.edu/~kostas/mypub.dir/tron17siam.pdf.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/essentialmanifold.html#Functions","page":"Essential manifold","title":"Functions","text":"","category":"section"},{"location":"manifolds/essentialmanifold.html","page":"Essential manifold","title":"Essential manifold","text":"Modules = [Manifolds]\nPrivate = false\nPages = [\"manifolds/EssentialManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/essentialmanifold.html#Base.exp-Tuple{EssentialManifold, Vararg{Any, N} where N}","page":"Essential manifold","title":"Base.exp","text":"exp(M::EssentialManifold, p, X)\n\nCompute the exponential map on the EssentialManifold from p into direction X, i.e.\n\ntextexp_p(X) =textexp_g( tilde X)  quad g in text(SO)(3)^2\n\nwhere tilde X is the horizontal lift of X[TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Base.log-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"Base.log","text":"log(M::EssentialManifold, p, q)\n\nCompute the logarithmic map on the EssentialManifold M, i.e. the tangent vector, whose geodesic starting from p reaches q after time 1. Here, p=(R_p_1R_p_2) and q=(R_q_1R_q_2) are elements of SO(3)^2. We use that any essential matrix can, up to scale, be decomposed to\n\nE = R_1^T e_z_R_2\n\nwhere (R_1R_2)SO(3)^2. Two points in SO(3)^2 are equivalent iff their corresponding essential matrices are equal (up to a sign flip). To compute the logarithm, we first move q to another representative of its equivalence class. For this, we find t= t_textopt for which the function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nwhere d() is the distance function in SO(3), is minimized. Further, the group H_z acting on the left on SO(3)^2 is defined as\n\nH_z = (R_z(θ)R_z(θ))colon θ in -ππ) \n\nwhere R_z(θ) is the rotation around the z axis with angle θ. Points in H_z are denoted by S_z. Then, the logarithm is defined as\n\nlog_p (S_z(t_textopt)q) = textLog(R_p_i^T R_z(t_textopt)R_b_i)_i=12\n\nwhere textLog is the logarithm on SO(3). For more details see [TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#ManifoldsBase.check_point-Tuple{EssentialManifold, Any}","page":"Essential manifold","title":"ManifoldsBase.check_point","text":"check_point(M::EssentialManifold, p; kwargs...)\n\nCheck whether the matrix is a valid point on the EssentialManifold M, i.e. a 2-element array containing SO(3) matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#ManifoldsBase.check_vector-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.check_vector","text":"check_vector(M::EssentialManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the EssentialManifold M, i.e. X has to be a 2-element array of 3-by-3 skew-symmetric matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#ManifoldsBase.distance-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.distance","text":"distance(M::EssentialManifold, p, q)\n\nCompute the Riemannian distance between the two points p and q on the EssentialManifold. This is done by computing the distance of the equivalence classes p and q of the points p=(R_p_1R_p_2) q=(R_q_1R_q_2)  SO(3)^2, respectively. Two points in SO(3)^2 are equivalent iff their corresponding essential matrices, given by\n\nE = R_1^T e_z_R_2\n\nare equal (up to a sign flip). Using the logarithmic map, the distance is given by\n\ntextdist(pq) =  textlog_p q  =  log_p (S_z(t_textopt)q) \n\nwhere S_z  H_z = (R_z(θ)R_z(θ))colon θ in -ππ)  in which R_z(θ) is the rotation around the z axis with angle θ and t_textopt is the minimizer of the cost function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nwhere d() is the distance function in SO(3)[TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#ManifoldsBase.manifold_dimension-Tuple{EssentialManifold}","page":"Essential manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::EssentialManifold{is_signed, ℝ})\n\nReturn the manifold dimension of the EssentialManifold, which is 5[TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#ManifoldsBase.project-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.project","text":"project(M::EssentialManifold, p, X)\n\nProject the matrix X onto the tangent space\n\nT_p textSO(3)^2 = T_textvptextSO(3)^2  T_texthptextSO(3)^2\n\nby first computing its projection onto the vertical space T_textvptextSO(3)^2 using vert_proj. Then the orthogonal projection of X onto the horizontal space T_texthptextSO(3)^2 is defined as\n\nPi_h(X) = X - fractextvert_proj_p(X)2 beginbmatrix R_1^T e_z  R_2^T e_z endbmatrix\n\nwith R_i = R_0 R_i i=12 where R_i is part of the pose of camera i g_i = (R_iT_i)  textSE(3) and R_0  textSO(3) such that R_0(T_2-T_1) = e_z.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Internal-Functions","page":"Essential manifold","title":"Internal Functions","text":"","category":"section"},{"location":"manifolds/essentialmanifold.html","page":"Essential manifold","title":"Essential manifold","text":"Modules = [Manifolds]\nPublic = false\nPages = [\"manifolds/EssentialManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/essentialmanifold.html#Manifolds.dist_min_angle_pair-Tuple{Any, Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair","text":"dist_min_angle_pair(p, q)\n\nThis function computes the global minimizer of the function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nfor the given values. This is done by finding the discontinuity points t_d_i i=12 of its derivative and using Newton's method to minimize the function over the intervals t_d_1t_d_2 and t_d_2t_d_1+2π separately. Then, the minimizer for which f is minimal is chosen and given back together with the minimal value. For more details see Algorithm 1 in [TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Manifolds.dist_min_angle_pair_compute_df_break-Tuple{Any, Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair_compute_df_break","text":"dist_min_angle_pair_compute_df_break(t_break, q)\n\nThis function computes the derivatives of each term f_i i=12 at discontinuity point t_break. For more details see [TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Manifolds.dist_min_angle_pair_df_newton-NTuple{9, Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair_df_newton","text":"dist_min_angle_pair_df_newton(m1, Φ1, c1, m2, Φ2, c2, t_min, t_low, t_high)\n\nThis function computes the minimizer of the function\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\nin the interval t_low, t_high using Newton's method. For more details see [TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Manifolds.dist_min_angle_pair_discontinuity_distance-Tuple{Any}","page":"Essential manifold","title":"Manifolds.dist_min_angle_pair_discontinuity_distance","text":"dist_min_angle_pair_discontinuity_distance(q)\n\nThis function computes the point t_textdi for which the first derivative of\n\nf(t) = f_1 + f_2 quad f_i = frac12 θ^2_i(t) quad θ_i(t)=d(R_p_iR_z(t)R_b_i) text for  i=12\n\ndoes not exist. This is the case for sin(θ_i(t_textdi)) = 0. For more details see Proposition 9 and its proof, as well as Lemma 1 in [TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Manifolds.vert_proj-Tuple{EssentialManifold, Any, Any}","page":"Essential manifold","title":"Manifolds.vert_proj","text":"vert_proj(M::EssentialManifold, p, X)\n\nProject X onto the vertical space T_textvptextSO(3)^2 with\n\ntextvert_proj_p(X) = e_z^T(R_1 X_1 + R_2 X_2)\n\nwhere e_z is the third unit vector, X_i  T_ptextSO(3) for i=12 and it holds R_i = R_0 R_i i=12 where R_i is part of the pose of camera i g_i = (R_iT_i)  textSE(3) and R_0  textSO(3) such that R_0(T_2-T_1) = e_z [TronDaniilidis2017].\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#ManifoldsBase.parallel_transport_to-Tuple{EssentialManifold, Any, Any, Any}","page":"Essential manifold","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::EssentialManifold, p, X, q)\n\nCompute the vector transport of the tangent vector X at p to q on the EssentialManifold M using left translation of the ambient group.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/essentialmanifold.html#Literature","page":"Essential manifold","title":"Literature","text":"","category":"section"},{"location":"manifolds/power.html#Power-manifold","page":"Power manifold","title":"Power manifold","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"A power manifold is based on a AbstractManifold  mathcal M to build a mathcal M^n_1 times n_2 times cdots times n_m. In the case where m=1 we can represent a manifold-valued vector of data of length n_1, for example a time series. The case where m=2 is useful for representing manifold-valued matrices of data of size n_1 times n_2, for example certain types of images.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"There are three available representations for points and vectors on a power manifold:","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"ArrayPowerRepresentation (the default one), very efficient but only applicable when points on the underlying manifold are represented using plain AbstractArrays.\nNestedPowerRepresentation, applicable to any manifold. It assumes that points on the underlying manifold are represented using mutable data types.\nNestedReplacingPowerRepresentation, applicable to any manifold. It does not mutate points on the underlying manifold, replacing them instead when appropriate.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"Below are some examples of usage of these representations.","category":"page"},{"location":"manifolds/power.html#Example","page":"Power manifold","title":"Example","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"There are two ways to store the data: in a multidimensional array or in a nested array.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"Let's look at an example for both. Let mathcal M be Sphere(2) the 2-sphere and we want to look at vectors of length 4.","category":"page"},{"location":"manifolds/power.html#ArrayPowerRepresentation","page":"Power manifold","title":"ArrayPowerRepresentation","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"For the default, the ArrayPowerRepresentation, we store the data in a multidimensional array,","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), 4)\np = cat([1.0, 0.0, 0.0],\n        [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n        [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n        [0.0, 1.0, 0.0]\n    ,dims=2)","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"which is a valid point i.e.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"is_point(M, p)","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"This can also be used in combination with HybridArrays.jl and StaticArrays.jl, by setting","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using HybridArrays, StaticArrays\nq = HybridArray{Tuple{3,StaticArrays.Dynamic()},Float64,2}(p)","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"which is still a valid point on M and PowerManifold works with these, too.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"An advantage of this representation is that it is quite efficient, especially when a HybridArray (from the HybridArrays.jl package) is used to represent a point on the power manifold. A disadvantage is not being able to easily identify parts of the multidimensional array that correspond to a single point on the base manifold. Another problem is, that accessing a single point is p[:, 1] which might be unintuitive.","category":"page"},{"location":"manifolds/power.html#NestedPowerRepresentation","page":"Power manifold","title":"NestedPowerRepresentation","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"For the NestedPowerRepresentation we can now do","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), NestedPowerRepresentation(), 4)\np = [ [1.0, 0.0, 0.0],\n      [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n      [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n      [0.0, 1.0, 0.0],\n    ]","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"which is again a valid point so is_point(M, p) here also yields true. A disadvantage might be that with nested arrays one loses a little bit of performance. The data however is nicely encapsulated. Accessing the first data item is just p[1].","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"For accessing points on power manifolds in both representations you can use get_component and set_component! functions. They work work both point representations.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using Manifolds\nM = PowerManifold(Sphere(2), NestedPowerRepresentation(), 4)\np = [ [1.0, 0.0, 0.0],\n      [1/sqrt(2.0), 1/sqrt(2.0), 0.0],\n      [1/sqrt(2.0), 0.0, 1/sqrt(2.0)],\n      [0.0, 1.0, 0.0],\n    ]\nset_component!(M, p, [0.0, 0.0, 1.0], 4)\nget_component(M, p, 4)","category":"page"},{"location":"manifolds/power.html#NestedReplacingPowerRepresentation","page":"Power manifold","title":"NestedReplacingPowerRepresentation","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"The final representation is the NestedReplacingPowerRepresentation. It is similar to the NestedPowerRepresentation but it does not perform mutating operations on the points on the underlying manifold. The example below uses this representation to store points on a power manifold of the SpecialEuclidean group in-line in an Vector for improved efficiency. When having a mixture of both, i.e. an array structure that is nested (like ´NestedPowerRepresentation) in the sense that the elements of the main vector are immutable, then changing the elements can not be done in a mutating way and hence NestedReplacingPowerRepresentation has to be used.","category":"page"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"using Manifolds, StaticArrays\nR2 = Rotations(2)\n\nG = SpecialEuclidean(2)\nN = 5\nGN = PowerManifold(G, NestedReplacingPowerRepresentation(), N)\n\nq = [1.0 0.0; 0.0 1.0]\np1 = [ProductRepr(SVector{2,Float64}([i - 0.1, -i]), SMatrix{2,2,Float64}(exp(R2, q, hat(R2, q, i)))) for i in 1:N]\np2 = [ProductRepr(SVector{2,Float64}([i - 0.1, -i]), SMatrix{2,2,Float64}(exp(R2, q, hat(R2, q, -i)))) for i in 1:N]\n\nX = similar(p1);\n\nlog!(GN, X, p1, p2)","category":"page"},{"location":"manifolds/power.html#Types-and-Functions","page":"Power manifold","title":"Types and Functions","text":"","category":"section"},{"location":"manifolds/power.html","page":"Power manifold","title":"Power manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/PowerManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/power.html#Manifolds.ArrayPowerRepresentation","page":"Power manifold","title":"Manifolds.ArrayPowerRepresentation","text":"ArrayPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using multidimensional arrays where first dimensions are equal to representation_size of the wrapped manifold and the following ones are equal to the number of elements in each direction.\n\nTorus uses this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerFVectorDistribution","page":"Power manifold","title":"Manifolds.PowerFVectorDistribution","text":"PowerFVectorDistribution([type::VectorBundleFibers], [x], distr)\n\nGenerates a random vector at a point from vector space (a fiber of a tangent bundle) of type type using the power distribution of distr.\n\nVector space type and point can be automatically inferred from distribution distr.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerMetric","page":"Power manifold","title":"Manifolds.PowerMetric","text":"PowerMetric <: AbstractMetric\n\nRepresent the AbstractMetric on an AbstractPowerManifold, i.e. the inner product on the tangent space is the sum of the inner product of each elements tangent space of the power manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerPointDistribution","page":"Power manifold","title":"Manifolds.PowerPointDistribution","text":"PowerPointDistribution(M::AbstractPowerManifold, distribution)\n\nPower distribution on manifold M, based on distribution.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.change_metric-Tuple{AbstractPowerManifold, AbstractMetric, Any, Any}","page":"Power manifold","title":"Manifolds.change_metric","text":"change_metric(M::AbstractPowerManifold, ::AbstractMetric, p, X)\n\nSince the metric on a power manifold decouples, the change of metric can be done elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.change_representer-Tuple{AbstractPowerManifold, AbstractMetric, Any, Any}","page":"Power manifold","title":"Manifolds.change_representer","text":"change_representer(M::AbstractPowerManifold, ::AbstractMetric, p, X)\n\nSince the metric on a power manifold decouples, the change of a representer can be done elementwise\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.flat-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}","page":"Power manifold","title":"Manifolds.flat","text":"flat(M::AbstractPowerManifold, p, X)\n\nuse the musical isomorphism to transform the tangent vector X from the tangent space at p on an AbstractPowerManifold  M to a cotangent vector. This can be done elementwise for each entry of X (and p).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.sharp-Tuple{AbstractPowerManifold, Vararg{Any, N} where N}","page":"Power manifold","title":"Manifolds.sharp","text":"sharp(M::AbstractPowerManifold, p, ξ::RieszRepresenterCotangentVector)\n\nUse the musical isomorphism to transform the cotangent vector ξ from the tangent space at p on an AbstractPowerManifold  M to a tangent vector. This can be done elementwise for every entry of ξ (and p).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Rotations","page":"Rotations","title":"Rotations","text":"","category":"section"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"The manifold mathrmSO(n) of orthogonal matrices with determinant +1 in ℝ^n  n, i.e.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"mathrmSO(n) = biglR  ℝ^n  n big R R^mathrmT =\nR^mathrmTR = I_n det(R) = 1 bigr","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"The Lie group mathrmSO(n) is a subgroup of the orthogonal group mathrmO(n) and also known as the special orthogonal group or the set of rotations group. See also SpecialOrthogonal, which is this manifold equipped with the group operation.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"The tangent space to a point p  mathrmSO(n) is given by","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"T_pmathrmSO(n) = X  X=pYqquad Y=-Y^mathrmT","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"i.e. all vectors that are a product of a skew symmetric matrix multiplied with p.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"Since the orthogonal matrices mathrmSO(n) are a Lie group, tangent vectors can also be represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. In the notation above, this means we just store the component Y of X.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"Let L_R mathrmSO(n)  mathrmSO(n) where R  mathrmSO(n) be the left-multiplication by R, that is L_R(S) = RS. The tangent space at rotation R, T_R mathrmSO(n), is related to the tangent space at the identity rotation I_n by the differential of L_R at identity, (mathrmdL_R)_I_n  T_I_n mathrmSO(n)  T_R mathrmSO(n). To convert the tangent vector representation at the identity rotation X  T_I_n mathrmSO(n) (i.e., the default) to the matrix representation of the corresponding tangent vector Y at a rotation R use the embed which implements the following multiplication: Y = RX  T_R mathrmSO(n). You can compare the functions log and exp to see how it works in practice.","category":"page"},{"location":"manifolds/rotations.html","page":"Rotations","title":"Rotations","text":"Modules = [Manifolds]\nPages = [\"manifolds/Rotations.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/rotations.html#Manifolds.NormalRotationDistribution","page":"Rotations","title":"Manifolds.NormalRotationDistribution","text":"NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)\n\nDistribution that returns a random point on the manifold Rotations M. Random point is generated using base distribution d and the type of the result is adjusted to TResult.\n\nSee normal_rotation_distribution for details.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.Rotations","page":"Rotations","title":"Manifolds.Rotations","text":"Rotations{N} <: AbstractManifold{ℝ}\n\nThe special orthogonal manifold mathrmSO(n) represented by n  n real-valued orthogonal matrices with determinant +1 is the manifold of Rotations, since these matrices represent all rotations of points in ℝ^n.\n\nConstructor\n\nRotations(n)\n\nGenerate the mathrmSO(n) subset ℝ^n  n\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Base.exp-Tuple{Rotations, Vararg{Any, N} where N}","page":"Rotations","title":"Base.exp","text":"exp(M::Rotations, p, X)\n\nCompute the exponential map on the Rotations from p into direction X, i.e.\n\nexp_p X = p operatornameExp(X)\n\nwhere operatornameExp(X)  denotes the matrix exponential of X.\n\nexp(M::Rotations{4}, p, X)\n\nCompute the exponential map of tangent vector X at point p from mathrmSO(4) manifold M.\n\nThe algorithm used is a more numerically stable form of those proposed in [Gallier2002] and [Andrica2013].\n\n[Gallier2002]: Gallier J.; Xu D.; Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation (2002), 17(4), pp. 1-11. pdf.\n\n[Andrica2013]: Andrica D.; Rohan R.-A.; Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications (2013), 18(2), pp. 1-2. pdf.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Base.log-Tuple{Rotations, Vararg{Any, N} where N}","page":"Rotations","title":"Base.log","text":"log(M::Rotations, p, q)\n\nCompute the logarithmic map on the Rotations manifold M=mathrmSO(n), which is given by\n\nlog_p q =\n  frac12 bigl(operatornameLog(p^mathrmTq)\n  - (operatornameLog(p^mathrmTq)^mathrmT)\n\nwhere operatornameLog denotes the matrix logarithm.\n\nFor antipodal rotations the function returns deterministically one of the tangent vectors that point at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#LinearAlgebra.norm-Tuple{Rotations, Any, Any}","page":"Rotations","title":"LinearAlgebra.norm","text":"norm(M::Rotations, p, X)\n\nCompute the norm of a tangent vector X from the tangent space at p on the Rotations M. The formula reads\n\nlVert X rVert_p = lVert X rVert\n\ni.e. the Frobenius norm of X, where tangent vectors are represented by elements from the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra of Rotations(4) in ℝ^4  4, 𝔰𝔬(4), consists of 4  4 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order (corresponding to the same ordering of angles as cos_angles_4d_rotation_matrix).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles αβ of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned\ncos α + cos β = frac12 operatornametr(R)\ncos α + cos β = frac18 operatornametr(R)^2\n                 - frac116 operatornametr((R - R^T)^2) - 1\nendaligned\n\nBy convention, the returned values are sorted in increasing order. See angles_4d_skew_sym_matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N}, Any, Real}} where N","page":"Rotations","title":"Manifolds.normal_rotation_distribution","text":"normal_rotation_distribution(M::Rotations, p, σ::Real)\n\nReturn a random point on the manifold Rotations M by generating a (Gaussian) random orthogonal matrix with determinant +1. Let\n\nQR = A\n\nbe the QR decomposition of a random matrix A, then the formula reads\n\np = QD\n\nwhere D is a diagonal matrix with the signs of the diagonal entries of R, i.e.\n\nD_ij=begincases operatornamesgn(R_ij)  textif  i=j  0   textotherwise endcases\n\nIt can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.\n\nThe argument p is used to determine the type of returned points.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_point-Union{Tuple{N}, Tuple{Rotations{N}, Any}} where N","page":"Rotations","title":"ManifoldsBase.check_point","text":"check_point(M, p; kwargs...)\n\nCheck whether p is a valid point on the Rotations M, i.e. is an array of size manifold_dimension(M) and represents a valid rotation. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_vector-Union{Tuple{N}, Tuple{Rotations{N}, Any, Any}} where N","page":"Rotations","title":"ManifoldsBase.check_vector","text":"check_vector(M, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the Rotations space M, i.e. after check_point(M,p), X has to be of same dimension and orthogonal to p. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.embed-Tuple{Rotations, Any, Any}","page":"Rotations","title":"ManifoldsBase.embed","text":"embed(M::Rotations{N}, p, X)\n\nEmbed the tangent vector X at point p in M from its Lie algebra representation (set of skew matrices) into the Riemannian submanifold representation\n\nThe formula reads\n\nX_textembedded = p * X\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.get_coordinates-Tuple{Rotations, Vararg{Any, N} where N}","page":"Rotations","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::Rotations, p, X)\n\nExtract the unique tangent vector components X^i at point p on Rotations mathrmSO(n) from the matrix representation X of the tangent vector.\n\nThe basis on the Lie algebra 𝔰𝔬(n) is chosen such that for mathrmSO(2), X^1 = θ = X_21 is the angle of rotation, and for mathrmSO(3), (X^1 X^2 X^3) = (X_32 X_13 X_21) = θ u is the angular velocity and axis-angle representation, where u is the unit vector along the axis of rotation.\n\nFor mathrmSO(n) where n  4, the additional elements of X^i are X^j (j - 3)2 + k + 1 = X_jk, for j  4n k  1j).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.get_vector-Tuple{Rotations, Vararg{Any, N} where N}","page":"Rotations","title":"ManifoldsBase.get_vector","text":"get_vector(M::Rotations, p, Xⁱ, B::DefaultOrthogonalBasis)\n\nConvert the unique tangent vector components Xⁱ at point p on Rotations group mathrmSO(n) to the matrix representation X of the tangent vector. See get_coordinates for the conventions used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.injectivity_radius-Tuple{Rotations}","page":"Rotations","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Rotations)\ninjectivity_radius(M::Rotations, p)\n\nReturn the injectivity radius on the Rotations M, which is globally\n\n    operatornameinj_mathrmSO(n)(p) = πsqrt2\n\ninjectivity_radius(M::Rotations, p, ::PolarRetraction)\n\nReturn the radius of injectivity for the PolarRetraction on the Rotations M which is fracπsqrt2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inner-Tuple{Rotations, Any, Any, Any}","page":"Rotations","title":"ManifoldsBase.inner","text":"inner(M::Rotations, p, X, Y)\n\nCompute the inner product of the two tangent vectors X, Y from the tangent plane at p on the special orthogonal space M=mathrmSO(n) using the restriction of the metric from the embedding, i.e.\n\ng_p(X Y) = operatornametr(X^mathrmT Y)\n\nTangent vectors are represented by matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, PolarInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, p, q, ::PolarInverseRetraction)\n\nCompute a vector from the tangent space T_pmathrmSO(n) of the point p on the Rotations manifold M with which the point q can be reached by the PolarRetraction from the point p after time 1.\n\nThe formula reads\n\noperatornameretr^-1_p(q)\n= -frac12(p^mathrmTqs - (p^mathrmTqs)^mathrmT)\n\nwhere s is the solution to the Sylvester equation\n\np^mathrmTqs + s(p^mathrmTq)^mathrmT + 2I_n = 0\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inverse_retract-Tuple{Rotations, Any, Any, QRInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Rotations, p, q, ::QRInverseRetraction)\n\nCompute a vector from the tangent space T_pmathrmSO(n) of the point p on the Rotations manifold M with which the point q can be reached by the QRRetraction from the point q after time 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Rotations)\n\nReturn the dimension of the manifold mathrmSO(n), i.e.\n\ndim_mathrmSO(n) = fracn(n-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.parallel_transport_direction-Tuple{Rotations, Any, Any, Any}","page":"Rotations","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::Rotations, p, X, d)\n\nCompute parallel transport of vector X tangent at p on the Rotations manifold in the direction d. The formula, provided in [Rentmeesters], reads:\n\nmathcal P_qgets pX = q^mathrmTp operatornameExp(d2) X operatornameExp(d2)\n\nwhere q=exp_p d.\n\nThe formula simplifies to identity for 2-D rotations.\n\n[Rentmeesters]: Rentmeesters Q., “A gradient method for geodesic data fitting on some symmetric Riemannian manifolds,” in 2011 50th IEEE Conference on Decision and Control and European Control Conference, Dec. 2011, pp. 7141–7146. doi: 10.1109/CDC.2011.6161280.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.project-Tuple{Rotations, Any, Any}","page":"Rotations","title":"ManifoldsBase.project","text":"project(M::Rotations, p, X)\n\nProject the matrix X onto the tangent space left division by and and making the result skew symmetric,\n\noperatornameproj_p(X) = fracpX-(pX)^mathrmT2\n\nwhere tangent vectors are represented by elements from the Lie group.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.project-Tuple{Rotations, Any}","page":"Rotations","title":"ManifoldsBase.project","text":"project(M::Rotations, p; check_det = true)\n\nProject p to the nearest point on manifold M.\n\nGiven the singular value decomposition p = U Σ V^mathrmT, with the singular values sorted in descending order, the projection is\n\noperatornameproj_mathrmSO(n)(p) =\nUoperatornamediagleft11det(U V^mathrmT)right V^mathrmT\n\nThe diagonal matrix ensures that the determinant of the result is +1. If p is expected to be almost special orthogonal, then you may avoid this check with check_det = false.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.representation_size-Union{Tuple{Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"ManifoldsBase.representation_size","text":"representation_size(M::Rotations)\n\nReturn the size() of a point on the Rotations M, i.e. for the mathrmSO(n) it's (n,n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.retract-Tuple{Rotations, Any, Any, PolarRetraction}","page":"Rotations","title":"ManifoldsBase.retract","text":"retract(M::Rotations, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction on the Rotations M from p in direction X (as an element of the Lie group) and is a second-order approximation of the exponential map. Let\n\nUSV = p + pX\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_p X = UV^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.retract-Tuple{Rotations, Any, Any, QRRetraction}","page":"Rotations","title":"ManifoldsBase.retract","text":"retract(M, p, X, ::QRRetraction)\n\nCompute the QR-based retraction on the Rotations M from p in direction X (as an element of the Lie group), which is a first-order approximation of the exponential map.\n\nThis is also the default retraction on the Rotations\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.zero_vector-Tuple{Rotations, Any}","page":"Rotations","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Rotations, p)\n\nReturn the zero tangent vector from the tangent space art p on the Rotations as an element of the Lie group, i.e. the zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Statistics.mean-Tuple{Rotations, Any}","page":"Rotations","title":"Statistics.mean","text":"mean(\n    M::Rotations,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2/√2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Literature","page":"Rotations","title":"Literature","text":"","category":"section"},{"location":"manifolds/generalizedgrassmann.html#Generalized-Grassmann","page":"Generalized Grassmann","title":"Generalized Grassmann","text":"","category":"section"},{"location":"manifolds/generalizedgrassmann.html","page":"Generalized Grassmann","title":"Generalized Grassmann","text":"Modules = [Manifolds]\nPages = [\"manifolds/GeneralizedGrassmann.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/generalizedgrassmann.html#Manifolds.GeneralizedGrassmann","page":"Generalized Grassmann","title":"Manifolds.GeneralizedGrassmann","text":"GeneralizedGrassmann{n,k,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe generalized Grassmann manifold operatornameGr(nkB) consists of all subspaces spanned by k linear independent vectors 𝔽^n, where 𝔽   ℝ ℂ is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of ℝ^n for the real-valued case and all 2k-dimensional subspaces of ℂ^n for the second.\n\nThe manifold can be represented as\n\noperatornameGr(n k B) = bigl operatornamespan(p) big p  𝔽^n  k p^mathrmHBp = I_k\n\nwhere cdot^mathrmH denotes the complex conjugate (or Hermitian) transpose and I_k is the k  k identity matrix. This means, that the columns of p form an unitary basis of the subspace with respect to the scaled inner product, that is a point on operatornameGr(nkB), and hence the subspace can actually be represented by a whole equivalence class of representers. For B=I_n this simplifies to the Grassmann manifold.\n\nThe tangent space at a point (subspace) p is given by\n\nT_xmathrmGr(nkB) = bigl\nX  𝔽^n  k \nX^mathrmHBp + p^mathrmHBX = 0_k bigr\n\nwhere 0_k denotes the k  k zero matrix.\n\nNote that a point p  operatornameGr(nkB) might be represented by different matrices (i.e. matrices with B-unitary column vectors that span the same subspace). Different representations of p also lead to different representation matrices for the tangent space T_pmathrmGr(nkB)\n\nThe manifold is named after Hermann G. Graßmann (1809-1877).\n\nConstructor\n\nGeneralizedGrassmann(n, k, B=I_n, field=ℝ)\n\nGenerate the (real-valued) Generalized Grassmann manifold of ntimes k dimensional orthonormal matrices with scalar product B.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/generalizedgrassmann.html#Base.exp-Tuple{GeneralizedGrassmann, Vararg{Any, N} where N}","page":"Generalized Grassmann","title":"Base.exp","text":"exp(M::GeneralizedGrassmann, p, X)\n\nCompute the exponential map on the GeneralizedGrassmann M= mathrmGr(nkB) starting in p with tangent vector (direction) X. Let X^mathrmHBX = USV denote the SVD decomposition of X^mathrmHBX. Then the exponential map is written using\n\nexp_p X = p Vcos(S)V^mathrmH + Usin(S)V^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian and the cosine and sine are applied element wise to the diagonal entries of S.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#Base.log-Tuple{GeneralizedGrassmann, Vararg{Any, N} where N}","page":"Generalized Grassmann","title":"Base.log","text":"log(M::GeneralizedGrassmann, p, q)\n\nCompute the logarithmic map on the GeneralizedGrassmann M$ = \\mathcal M=\\mathrm{Gr}(n,k,B)$, i.e. the tangent vector X whose corresponding geodesic starting from p reaches q after time 1 on M. The formula reads\n\nlog_p q = Vcdot operatornameatan(S) cdot U^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian. The matrices U and V are the unitary matrices, and S is the diagonal matrix containing the singular values of the SVD-decomposition\n\nUSV = (q^mathrmHBp)^-1 ( q^mathrmH - q^mathrmHBpp^mathrmH)\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#Manifolds.change_metric-Tuple{GeneralizedGrassmann, EuclideanMetric, Any, Any}","page":"Generalized Grassmann","title":"Manifolds.change_metric","text":"change_metric(M::GeneralizedGrassmann, ::EuclideanMetric, p X)\n\nChange X to the corresponding vector with respect to the metric of the GeneralizedGrassmann M, i.e. let B=LL be the Cholesky decomposition of the matrix M.B, then the corresponding vector is LX.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#Manifolds.change_representer-Tuple{GeneralizedGrassmann, EuclideanMetric, Any, Any}","page":"Generalized Grassmann","title":"Manifolds.change_representer","text":"change_representer(M::GeneralizedGrassmann, ::EuclideanMetric, p, X)\n\nChange X to the corresponding representer of a cotangent vector at p with respect to the scaled metric of the GeneralizedGrassmann M, i.e, since\n\ng_p(XY) = operatornametr(Y^mathrmHBZ) = operatornametr(X^mathrmHZ) = XZ\n\nhas to hold for all Z, where the repreenter X is given, the resulting representer with respect to the metric on the GeneralizedGrassmann is given by Y = B^-1X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{GeneralizedGrassmann{n, k, 𝔽, TB} where TB<:(AbstractMatrix{T} where T), Any}} where {n, k, 𝔽}","page":"Generalized Grassmann","title":"ManifoldsBase.check_point","text":"check_point(M::GeneralizedGrassmann{n,k,𝔽}, p)\n\nCheck whether p is representing a point on the GeneralizedGrassmann M, i.e. its a n-by-k matrix of unitary column vectors with respect to the B inner prudct and of correct eltype with respect to 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.check_vector-Union{Tuple{𝔽}, Tuple{k}, Tuple{n}, Tuple{GeneralizedGrassmann{n, k, 𝔽, TB} where TB<:(AbstractMatrix{T} where T), Any, Any}} where {n, k, 𝔽}","page":"Generalized Grassmann","title":"ManifoldsBase.check_vector","text":"check_vector(M::GeneralizedGrassmann{n,k,𝔽}, p, X; kwargs...)\n\nCheck whether X is a tangent vector in the tangent space of p on the GeneralizedGrassmann M, i.e. that X is of size and type as well as that\n\n    p^mathrmHBX + overlineX^mathrmHBp = 0_k\n\nwhere cdot^mathrmH denotes the complex conjugate transpose or Hermitian, overlinecdot the (elementwise) complex conjugate, and 0_k denotes the k  k zero natrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.distance-Tuple{GeneralizedGrassmann, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.distance","text":"distance(M::GeneralizedGrassmann, p, q)\n\nCompute the Riemannian distance on GeneralizedGrassmann manifold M= mathrmGr(nkB).\n\nLet USV = p^mathrmHBq denote the SVD decomposition of p^mathrmHBq, where cdot^mathrmH denotes the complex conjugate transposed or Hermitian. Then the distance is given by\n\nd_mathrmGr(nkB)(pq) = operatornamenorm(operatornameRe(b))\n\nwhere\n\nb_i=begincases\n0  textif  S_i  1\narccos(S_i)   textif  S_i1\nendcases\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.injectivity_radius-Tuple{GeneralizedGrassmann}","page":"Generalized Grassmann","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::GeneralizedGrassmann)\ninjectivity_radius(M::GeneralizedGrassmann, p)\n\nReturn the injectivity radius on the GeneralizedGrassmann M, which is fracπ2.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.inner-Union{Tuple{k}, Tuple{n}, Tuple{GeneralizedGrassmann{n, k, 𝔽, TB} where {𝔽, TB<:(AbstractMatrix{T} where T)}, Any, Any, Any}} where {n, k}","page":"Generalized Grassmann","title":"ManifoldsBase.inner","text":"inner(M::GeneralizedGrassmann, p, X, Y)\n\nCompute the inner product for two tangent vectors X, Y from the tangent space of p on the GeneralizedGrassmann manifold M. The formula reads\n\ng_p(XY) = operatornametr(X^mathrmHBY)\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.manifold_dimension-Union{Tuple{GeneralizedGrassmann{n, k, 𝔽, TB} where TB<:(AbstractMatrix{T} where T)}, Tuple{𝔽}, Tuple{k}, Tuple{n}} where {n, k, 𝔽}","page":"Generalized Grassmann","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::GeneralizedGrassmann)\n\nReturn the dimension of the GeneralizedGrassmann(n,k,𝔽) manifold M, i.e.\n\ndim operatornameGr(nkB) = k(n-k) dim_ℝ 𝔽\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.project-Tuple{GeneralizedGrassmann, Any, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.project","text":"project(M::GeneralizedGrassmann, p, X)\n\nProject the n-by-k X onto the tangent space of p on the GeneralizedGrassmann M, which is computed by\n\noperatornameproj_p(X) = X - pp^mathrmHB^mathrmTX\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian and cdot^mathrmT the transpose.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.project-Tuple{GeneralizedGrassmann, Any}","page":"Generalized Grassmann","title":"ManifoldsBase.project","text":"project(M::GeneralizedGrassmann, p)\n\nProject p from the embedding onto the GeneralizedGrassmann M, i.e. compute q as the polar decomposition of p such that q^mathrmHBq is the identity, where cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.representation_size-Union{Tuple{GeneralizedGrassmann{n, k, 𝔽, TB} where {𝔽, TB<:(AbstractMatrix{T} where T)}}, Tuple{k}, Tuple{n}} where {n, k}","page":"Generalized Grassmann","title":"ManifoldsBase.representation_size","text":"representation_size(M::GeneralizedGrassmann{n,k})\n\nReturn the represenation size or matrix dimension of a point on the GeneralizedGrassmann M, i.e. (nk) for both the real-valued and the complex value case.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.retract-Tuple{GeneralizedGrassmann, Any, Any, PolarRetraction}","page":"Generalized Grassmann","title":"ManifoldsBase.retract","text":"retract(M::GeneralizedGrassmann, p, X, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the GeneralizedGrassmann M, by projecting p + X onto M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#ManifoldsBase.zero_vector-Tuple{GeneralizedGrassmann, Vararg{Any, N} where N}","page":"Generalized Grassmann","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::GeneralizedGrassmann, p)\n\nReturn the zero tangent vector from the tangent space at p on the GeneralizedGrassmann M, which is given by a zero matrix the same size as p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/generalizedgrassmann.html#Statistics.mean-Tuple{GeneralizedGrassmann, Vararg{Any, N} where N}","page":"Generalized Grassmann","title":"Statistics.mean","text":"mean(\n    M::GeneralizedGrassmann,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian.html#Skew-hermitian-matrices","page":"Skew-Hermitian matrices","title":"Skew-hermitian matrices","text":"","category":"section"},{"location":"manifolds/skewhermitian.html","page":"Skew-Hermitian matrices","title":"Skew-Hermitian matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/SkewHermitian.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/skewhermitian.html#Manifolds.SkewHermitianMatrices","page":"Skew-Hermitian matrices","title":"Manifolds.SkewHermitianMatrices","text":"SkewHermitianMatrices{n,𝔽} <: AbstractDecoratorManifold{𝔽}\n\nThe AbstractManifold  $ \\operatorname{SkewHerm}(n)$ consisting of the real- or complex-valued skew-hermitian matrices of size n  n, i.e. the set\n\noperatornameSkewHerm(n) = biglp   𝔽^n  n big p^mathrmH = -p bigr\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transpose, and the field 𝔽   ℝ ℂ ℍ.\n\nThough it is slightly redundant, usually the matrices are stored as n  n arrays.\n\nNote that in this representation, the real-valued part of the diagonal must be zero, which is also reflected in the manifold_dimension.\n\nConstructor\n\nSkewHermitianMatrices(n::Int, field::AbstractNumbers=ℝ)\n\nGenerate the manifold of n  n skew-hermitian matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/skewhermitian.html#Manifolds.SkewSymmetricMatrices","page":"Skew-Hermitian matrices","title":"Manifolds.SkewSymmetricMatrices","text":"SkewSymmetricMatrices{n}\n\nGenerate the manifold of n  n real skew-symmetric matrices. This is equivalent to SkewHermitianMatrices(n, ℝ).\n\nConstructor\n\nSkewSymmetricMatrices(n::Int)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/skewhermitian.html#ManifoldsBase.check_point-Union{Tuple{𝔽}, Tuple{n}, Tuple{SkewHermitianMatrices{n, 𝔽}, Any}} where {n, 𝔽}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.check_point","text":"check_point(M::SkewHermitianMatrices{n,𝔽}, p; kwargs...)\n\nCheck whether p is a valid manifold point on the SkewHermitianMatrices M, i.e. whether p is a skew-hermitian matrix of size (n,n) with values from the corresponding AbstractNumbers 𝔽.\n\nThe tolerance for the skew-symmetry of p can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian.html#ManifoldsBase.check_vector-Tuple{SkewHermitianMatrices, Any, Any}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::SkewHermitianMatrices{n}, p, X; kwargs... )\n\nCheck whether X is a tangent vector to manifold point p on the SkewHermitianMatrices M, i.e. X must be a skew-hermitian matrix of size (n,n) and its values have to be from the correct AbstractNumbers. The tolerance for the skew-symmetry of p and X can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian.html#ManifoldsBase.manifold_dimension-Union{Tuple{SkewHermitianMatrices{N, 𝔽}}, Tuple{𝔽}, Tuple{N}} where {N, 𝔽}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SkewHermitianMatrices{n,𝔽})\n\nReturn the dimension of the SkewHermitianMatrices matrix M over the number system 𝔽, i.e.\n\ndim mathrmSkewHerm(nℝ) = fracn(n+1)2 dim_ℝ 𝔽 - n\n\nwhere dim_ℝ 𝔽 is the real_dimension of 𝔽. The first term corresponds to only the upper triangular elements of the matrix being unique, and the second term corresponds to the constraint that the real part of the diagonal be zero.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian.html#ManifoldsBase.project-Tuple{SkewHermitianMatrices, Any, Any}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.project","text":"project(M::SkewHermitianMatrices, p, X)\n\nProject the matrix X onto the tangent space at p on the SkewHermitianMatrices M,\n\noperatornameproj_p(X) = frac12 bigl( X - X^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/skewhermitian.html#ManifoldsBase.project-Tuple{SkewHermitianMatrices, Any}","page":"Skew-Hermitian matrices","title":"ManifoldsBase.project","text":"project(M::SkewHermitianMatrices, p)\n\nProjects p from the embedding onto the SkewHermitianMatrices M, i.e.\n\noperatornameproj_operatornameSkewHerm(n)(p) = frac12 bigl( p - p^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the Hermitian, i.e. complex conjugate transposed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#Tucker","page":"Tucker","title":"Tucker manifold","text":"","category":"section"},{"location":"manifolds/tucker.html","page":"Tucker","title":"Tucker","text":"Modules = [Manifolds]\nPages = [\"Tucker.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/tucker.html#Manifolds.Tucker","page":"Tucker","title":"Manifolds.Tucker","text":"Tucker{N, R, D, 𝔽} <: AbstractManifold{𝔽}\n\nThe manifold of N_1 times dots times N_D real-valued or complex-valued tensors of fixed multilinear rank (R_1 dots R_D) . If R_1 = dots = R_D = 1, this is the Segre manifold, i.e., the set of rank-1 tensors.\n\nRepresentation in HOSVD format\n\nLet mathbbF be the real or complex numbers. Any tensor p on the Tucker manifold can be represented as a multilinear product in HOSVD [DeLathauwer2000] form\n\np = (U_1dotsU_D) cdot mathcalC\n\nwhere mathcal C in mathbbF^R_1 times dots times R_D and, for d=1dotsD, the matrix U_d in mathbbF^N_d times R_d contains the singular vectors of the dth unfolding of mathcalA\n\nTangent space\n\nThe tangent space to the Tucker manifold at p = (U_1dotsU_D) cdot mathcalC is [Koch2010]\n\nT_p mathcalM =\nbigl\n(U_1dotsU_D) cdot mathcalC^prime\n+ sum_d=1^D bigl(\n    (U_1 dots U_d-1 U_d^prime U_d+1 dots U_D)\n    cdot mathcalC\nbigr)\nbigr\n\nwhere mathcalC^prime is arbitrary, U_d^mathrmH is the Hermitian adjoint of U_d, and U_d^mathrmH U_d^prime = 0 for all d.\n\nConstructor\n\nTucker(N::NTuple{D, Int}, R::NTuple{D, Int}[, field = ℝ])\n\nGenerate the manifold of field-valued tensors of dimensions  N[1] × … × N[D] and multilinear rank R = (R[1], …, R[D]).\n\n[DeLathauwer2000]: Lieven De Lathauwer, Bart De Moor, Joos Vandewalle: \"A multilinear singular value decomposition\" SIAM Journal on Matrix Analysis and Applications, 21(4), pp. 1253-1278, 2000 doi: 10.1137/S0895479896305696\n\n[Koch2010]: Othmar Koch, Christian Lubic, \"Dynamical Tensor approximation\" SIAM Journal on Matrix Analysis and Applications, 31(5), pp. 2360-2375, 2010 doi: 10.1137/09076578X\n\n\n\n\n\n","category":"type"},{"location":"manifolds/tucker.html#Manifolds.TuckerPoint","page":"Tucker","title":"Manifolds.TuckerPoint","text":"TuckerPoint{T,D}\n\nAn order D tensor of fixed multilinear rank and entries of type T, which makes it a point on the Tucker manifold. The tensor is represented in HOSVD form.\n\nConstructors:\n\nTuckerPoint(core::AbstractArray{T,D}, factors::Vararg{<:AbstractMatrix{T},D}) where {T,D}\n\nConstruct an order D tensor of element type T that can be represented as the multilinear product (factors[1], …, factors[D]) ⋅ core. It is assumed that the dimensions of the core are the multilinear rank of the tensor and that the matrices factors each have full rank. No further assumptions are made.\n\nTuckerPoint(p::AbstractArray{T,D}, mlrank::NTuple{D,Int}) where {T,D}\n\nThe low-multilinear rank tensor arising from the sequentially truncated the higher-order singular value decomposition of the D-dimensional array p of type T. The singular values are truncated to get a multilinear rank mlrank [Vannieuwenhoven2012].\n\n[Vannieuwenhoven2012]: Nick Vannieuwenhoven, Raf Vandebril, Karl Meerbergen: \"A new truncation strategy for the higher-order singular value decomposition\" SIAM Journal on Scientific Computing, 34(2), pp. 1027-1052, 2012 doi: 10.1137/110836067\n\n\n\n\n\n","category":"type"},{"location":"manifolds/tucker.html#Manifolds.TuckerTVector","page":"Tucker","title":"Manifolds.TuckerTVector","text":"TuckerTVector{T, D} <: TVector\n\nTangent vector to the D-th order Tucker manifold at p = (U_1dotsU_D)  mathcalC. The numbers are of type T and the vector is represented as\n\nX =\n(U_1dotsU_D) cdot mathcalC^prime +\nsum_d=1^D (U_1dotsU_d-1U_d^primeU_d+1dotsU_D) cdot mathcalC\n\nwhere U_d^mathrmH U_d^prime = 0.\n\nConstructor\n\nTuckerTVector(C′::Array{T,D}, U′::NTuple{D,Matrix{T}}) where {T,D}\n\nConstructs a Dth order TuckerTVector of number type T with C^prime and U^prime, so that, together with a TuckerPoint p as above, the tangent vector can be represented as X in the above expression.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/tucker.html#Base.convert-Union{Tuple{D}, Tuple{T}, Tuple{𝔽}, Tuple{Type{Matrix{T}}, CachedBasis{𝔽, DefaultOrthonormalBasis{𝔽, ManifoldsBase.TangentSpaceType}, Manifolds.HOSVDBasis{T, D}}}} where {𝔽, T, D}","page":"Tucker","title":"Base.convert","text":"Base.convert(::Type{Matrix{T}}, basis::CachedBasis{𝔽,DefaultOrthonormalBasis{𝔽, TangentSpaceType},HOSVDBasis{T, D}}) where {𝔽, T, D}\nBase.convert(::Type{Matrix}, basis::CachedBasis{𝔽,DefaultOrthonormalBasis{𝔽, TangentSpaceType},HOSVDBasis{T, D}}) where {𝔽, T, D}\n\nConvert a HOSVD-derived cached basis from [Dewaele2021] of the Dth order Tucker manifold with number type T to a matrix. The columns of this matrix are the vectorisations of the embeddings of the basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#Base.foreach","page":"Tucker","title":"Base.foreach","text":"Base.foreach(f, M::Tucker, p::TuckerPoint, basis::AbstractBasis, indices=1:manifold_dimension(M))\n\nLet basis be and AbstractBasis at a point p on M. Suppose f is a function that takes an index and a vector as an argument. This function applies f to i and the ith basis vector sequentially for each i in indices. Using a CachedBasis may speed up the computation.\n\nNOTE: The i'th basis vector is overwritten in each iteration. If any information about the vector is to be stored, f must make a copy.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/tucker.html#Base.ndims-Union{Tuple{TuckerPoint{T, D}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Tucker","title":"Base.ndims","text":"Base.ndims(p::TuckerPoint{T,D}) where {T,D}\n\nThe order of the tensor corresponding to the TuckerPoint p, i.e., D.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#Base.size-Tuple{TuckerPoint}","page":"Tucker","title":"Base.size","text":"Base.size(p::TuckerPoint)\n\nThe dimensions of a TuckerPoint p, when regarded as a full tensor (see embed).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.check_point-Union{Tuple{D}, Tuple{R}, Tuple{N}, Tuple{Tucker{N, R, D, 𝔽} where 𝔽, Any}} where {N, R, D}","page":"Tucker","title":"ManifoldsBase.check_point","text":"check_point(M::Tucker{N,R,D}, p; kwargs...) where {N,R,D}\n\nCheck whether the multidimensional array or TuckerPoint p is a point on the Tucker manifold, i.e. it is a Dth order N[1] × … × N[D] tensor of multilinear rank (R[1], …, R[D]). The keyword arguments are passed to the matrix rank function applied to the unfoldings. For a TuckerPoint it is checked that the point is in correct HOSVD form.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.check_vector-Union{Tuple{D}, Tuple{T}, Tuple{R}, Tuple{N}, Tuple{Tucker{N, R, D, 𝔽} where 𝔽, TuckerPoint{T, D}, TuckerTVector}} where {N, R, T, D}","page":"Tucker","title":"ManifoldsBase.check_vector","text":"check_vector(M::Tucker{N,R,D}, p::TuckerPoint{T,D}, X::TuckerTVector) where {N,R,T,D}\n\nCheck whether a TuckerTVector X is is in the tangent space to the Dth order Tucker manifold M at the Dth order TuckerPoint p. This is the case when the dimensions of the factors in X agree with those of p and the factor matrices of X are in the orthogonal complement of the HOSVD factors of p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.embed-Tuple{Tucker, Any, TuckerPoint}","page":"Tucker","title":"ManifoldsBase.embed","text":"embed(::Tucker{N,R,D}, p::TuckerPoint) where {N,R,D}\n\nConvert a TuckerPoint p on the rank R Tucker manifold to a full N[1] × … × N[D]-array by evaluating the Tucker decomposition.\n\nembed(::Tucker{N,R,D}, p::TuckerPoint, X::TuckerTVector) where {N,R,D}\n\nConvert a tangent vector X with base point p on the rank R Tucker manifold to a full tensor, represented as an N[1] × … × N[D]-array.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.get_basis-Union{Tuple{𝔽}, Tuple{Tucker, TuckerPoint}, Tuple{Tucker, TuckerPoint, DefaultOrthonormalBasis{𝔽, ManifoldsBase.TangentSpaceType}}} where 𝔽","page":"Tucker","title":"ManifoldsBase.get_basis","text":"get_basis(:: Tucker, p::TuckerPoint, basisType::DefaultOrthonormalBasis{𝔽, TangentSpaceType}) where 𝔽\n\nAn implicitly stored basis of the tangent space to the Tucker manifold. Assume p = (U_1dotsU_D) cdot mathcalC is in HOSVD format and that, for d=1dotsD, the singular values of the d'th unfolding are sigma_dj, with j = 1dotsR_d. The basis of the tangent space is as follows: [Dewaele2021]\n\nbigl\n(U_1dotsU_D) e_i\nbigr cup bigl\n(U_1dots sigma_dj^-1 U_d^perp e_i e_j^TdotsU_D) cdot mathcalC\nbigr\n\nfor all d = 1dotsD and all canonical basis vectors e_i and e_j. Every U_d^perp is such that U_d quad U_d^perp forms an orthonormal basis of mathbbR^N_d.\n\n[Dewaele2021]: Nick Dewaele, Paul Breiding, Nick Vannieuwenhoven, \"The condition number of many tensor decompositions is invariant under Tucker compression\" arxiv: 2106.13034\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.inner-Tuple{Tucker, TuckerPoint, TuckerTVector, TuckerTVector}","page":"Tucker","title":"ManifoldsBase.inner","text":"inner(M::Tucker, p::TuckerPoint, X::TuckerTVector, Y::TuckerTVector)\n\nThe Euclidean inner product between tangent vectors X and X at the point p on the Tucker manifold. This is equal to embed(M, p, X) ⋅ embed(M, p, Y).\n\ninner(::Tucker, A::TuckerPoint, X::TuckerTVector, Y)\ninner(::Tucker, A::TuckerPoint, X, Y::TuckerTVector)\n\nThe Euclidean inner product between X and Y where X is a vector tangent to the Tucker manifold at p and Y is a vector in the ambient space or vice versa. The vector in the ambient space is represented as a full tensor, i.e., a multidimensional array.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.inverse_retract-Tuple{Tucker, Any, TuckerPoint, TuckerPoint, ProjectionInverseRetraction}","page":"Tucker","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Tucker, p::TuckerPoint, q::TuckerPoint, ::ProjectionInverseRetraction)\n\nThe projection inverse retraction on the Tucker manifold interprets q as a point in the ambient Euclidean space (see embed) and projects it onto the tangent space at to M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.manifold_dimension-Union{Tuple{Tucker{n⃗, r⃗, D, 𝔽} where {D, 𝔽}}, Tuple{r⃗}, Tuple{n⃗}} where {n⃗, r⃗}","page":"Tucker","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(::Tucker{N,R,D}) where {N,R,D}\n\nThe dimension of the manifold of N_1 times dots times N_D tensors of multilinear rank (R_1 dots R_D), i.e.\n\nmathrmdim(mathcalM) = prod_d=1^D R_d + sum_d=1^D R_d (N_d - R_d)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.project-Tuple{Tucker, Any, TuckerPoint, Any}","page":"Tucker","title":"ManifoldsBase.project","text":"project(M::Tucker, p::TuckerPoint, X)\n\nThe least-squares projection of a dense tensor X onto the tangent space to M at p.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.retract-Tuple{Tucker, Any, Any, PolarRetraction}","page":"Tucker","title":"ManifoldsBase.retract","text":"retract(::Tucker, p::TuckerPoint, X::TuckerTVector, ::PolarRetraction)\n\nThe truncated HOSVD-based retraction [Kressner2014] to the Tucker manifold, i.e. the result is the sequentially tuncated HOSVD approximation of p + X.\n\nIn the exceptional case that the multilinear rank of p + X is lower than that of p, this retraction produces a boundary point, which is outside the manifold.\n\n[Kressner2014]: Daniel Kressner, Michael Steinlechner, Bart Vandereycken: \"Low-rank tensor completion by Riemannian optimization\" BIT Numerical Mathematics, 54(2), pp. 447-468, 2014 doi: 10.1007/s10543-013-0455-z\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#ManifoldsBase.zero_vector-Tuple{Tucker, TuckerPoint}","page":"Tucker","title":"ManifoldsBase.zero_vector","text":"zero_vector(::Tucker, p::TuckerPoint)\n\nThe zero element in the tangent space to p on the Tucker manifold, represented as a TuckerTVector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/tucker.html#Literature","page":"Tucker","title":"Literature","text":"","category":"section"},{"location":"manifolds/elliptope.html#Elliptope","page":"Elliptope","title":"Elliptope","text":"","category":"section"},{"location":"manifolds/elliptope.html","page":"Elliptope","title":"Elliptope","text":"Modules = [Manifolds]\nPages = [\"manifolds/Elliptope.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/elliptope.html#Manifolds.Elliptope","page":"Elliptope","title":"Manifolds.Elliptope","text":"Elliptope{N,K} <: AbstractDecoratorManifold{ℝ}\n\nThe Elliptope manifold, also known as the set of correlation matrices, consists of all symmetric positive semidefinite matrices of rank k with unit diagonal, i.e.,\n\nbeginaligned\nmathcal E(nk) =\nbiglp  ℝ^n  n big a^mathrmTpa geq 0 text for all  a  ℝ^n\np_ii = 1 text for all  i=1ldotsn\ntextand  p = qq^mathrmT text for  q in  ℝ^n  k text with  operatornamerank(p) = operatornamerank(q) = k\nbigr\nendaligned\n\nAnd this manifold is working solely on the matrices q. Note that this q is not unique, indeed for any orthogonal matrix A we have (qA)(qA)^mathrmT = qq^mathrmT = p, so the manifold implemented here is the quotient manifold. The unit diagonal translates to unit norm columns of q.\n\nThe tangent space at p, denoted T_pmathcal E(nk), is also represented by matrices Yin ℝ^n  k and reads as\n\nT_pmathcal E(nk) = bigl\nX  ℝ^n  nX = qY^mathrmT + Yq^mathrmT text with  X_ii = 0 text for  i=1ldotsn\nbigr\n\nendowed with the Euclidean metric from the embedding, i.e. from the ℝ^n  k\n\nThis manifold was for example investigated in[JourneeBachAbsilSepulchre2010].\n\nConstructor\n\nElliptope(n,k)\n\ngenerates the manifold mathcal E(nk) subset ℝ^n  n.\n\n[JourneeBachAbsilSepulchre2010]: Journée, M., Bach, F., Absil, P.-A., and Sepulchre, R.: “Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”, SIAM Journal on Optimization (20)5, pp. 2327–2351, 2010. doi: 10.1137/080731359, arXiv: 0807.4423.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/elliptope.html#ManifoldsBase.check_point-Union{Tuple{K}, Tuple{N}, Tuple{Elliptope{N, K}, Any}} where {N, K}","page":"Elliptope","title":"ManifoldsBase.check_point","text":"check_point(M::Elliptope, q; kwargs...)\n\nchecks, whether q is a valid reprsentation of a point p=qq^mathrmT on the Elliptope M, i.e. is a matrix of size (N,K), such that p is symmetric positive semidefinite and has unit trace. Since by construction p is symmetric, this is not explicitly checked. Since p is by construction positive semidefinite, this is not checked. The tolerances for positive semidefiniteness and unit trace can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.check_vector-Union{Tuple{K}, Tuple{N}, Tuple{Elliptope{N, K}, Any, Any}} where {N, K}","page":"Elliptope","title":"ManifoldsBase.check_vector","text":"check_vector(M::Elliptope, q, Y; kwargs... )\n\nCheck whether X = qY^mathrmT + Yq^mathrmT is a tangent vector to p=qq^mathrmT on the Elliptope M, i.e. Y has to be of same dimension as q and a X has to be a symmetric matrix with zero diagonal.\n\nThe tolerance for the base point check and zero diagonal can be set using the kwargs.... Note that symmetric of X holds by construction an is not explicitly checked.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.manifold_dimension-Union{Tuple{Elliptope{N, K}}, Tuple{K}, Tuple{N}} where {N, K}","page":"Elliptope","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Elliptope)\n\nreturns the dimension of Elliptope M=mathcal E(nk) nk  ℕ, i.e.\n\ndim mathcal E(nk) = n(k-1) - frack(k-1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.project-Tuple{Elliptope, Any}","page":"Elliptope","title":"ManifoldsBase.project","text":"project(M::Elliptope, q)\n\nproject q onto the manifold Elliptope M, by normalizing the rows of q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.project-Tuple{Elliptope, Vararg{Any, N} where N}","page":"Elliptope","title":"ManifoldsBase.project","text":"project(M::Elliptope, q, Y)\n\nProject Y onto the tangent space at q, i.e. row-wise onto the oblique manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.representation_size-Union{Tuple{Elliptope{N, K}}, Tuple{K}, Tuple{N}} where {N, K}","page":"Elliptope","title":"ManifoldsBase.representation_size","text":"representation_size(M::Elliptope)\n\nReturn the size of an array representing an element on the Elliptope manifold M, i.e. n  k, the size of such factor of p=qq^mathrmT on mathcal M = mathcal E(nk).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.retract-Tuple{Elliptope, Any, Any, ProjectionRetraction}","page":"Elliptope","title":"ManifoldsBase.retract","text":"retract(M::Elliptope, q, Y, ::ProjectionRetraction)\n\ncompute a projection based retraction by projecting q+Y back onto the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.vector_transport_to-Tuple{Elliptope, Any, Any, Any, ProjectionTransport}","page":"Elliptope","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Elliptope, p, X, q)\n\ntransport the tangent vector X at p to q by projecting it onto the tangent space at q.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#ManifoldsBase.zero_vector-Tuple{Elliptope, Vararg{Any, N} where N}","page":"Elliptope","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::Elliptope,p)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix p on the Elliptope manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/elliptope.html#Literature","page":"Elliptope","title":"Literature","text":"","category":"section"},{"location":"manifolds/multinomial.html#Multinomial-matrices","page":"Multinomial matrices","title":"Multinomial matrices","text":"","category":"section"},{"location":"manifolds/multinomial.html","page":"Multinomial matrices","title":"Multinomial matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/Multinomial.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/multinomial.html#Manifolds.MultinomialMatrices","page":"Multinomial matrices","title":"Manifolds.MultinomialMatrices","text":"MultinomialMatrices{n,m} <: AbstractPowerManifold{ℝ}\n\nThe multinomial manifold consists of m column vectors, where each column is of length n and unit norm, i.e.\n\nmathcalMN(nm) coloneqq bigl p  ℝ^nm big p_ij  0 text for all  i=1n j=1m text and  p^mathrmTmathbb1_m = mathbb1_nbigr\n\nwhere mathbb1_k is the vector of length k containing ones.\n\nThis yields exactly the same metric as considering the product metric of the probablity vectors, i.e. PowerManifold of the (n-1)-dimensional ProbabilitySimplex.\n\nThe ProbabilitySimplex is stored internally within M.manifold, such that all functions of AbstractPowerManifold  can be used directly.\n\nConstructor\n\nMultinomialMatrices(n, m)\n\nGenerate the manifold of matrices mathbb R^nm such that the m columns are discrete probability distributions, i.e. sum up to one.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/multinomial.html#Functions","page":"Multinomial matrices","title":"Functions","text":"","category":"section"},{"location":"manifolds/multinomial.html","page":"Multinomial matrices","title":"Multinomial matrices","text":"Most functions are directly implemented for an AbstractPowerManifold  with ArrayPowerRepresentation except the following special cases:","category":"page"},{"location":"manifolds/multinomial.html","page":"Multinomial matrices","title":"Multinomial matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/Multinomial.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/multinomial.html#ManifoldsBase.check_point-Tuple{MultinomialMatrices, Any}","page":"Multinomial matrices","title":"ManifoldsBase.check_point","text":"check_point(M::MultinomialMatrices, p)\n\nChecks whether p is a valid point on the MultinomialMatrices(m,n) M, i.e. is a matrix of m discrete probability distributions as columns from mathbb R^n, i.e. each column is a point from ProbabilitySimplex(n-1).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/multinomial.html#ManifoldsBase.check_vector-Union{Tuple{m}, Tuple{n}, Tuple{MultinomialMatrices{n, m, S} where S, Any, Any}} where {n, m}","page":"Multinomial matrices","title":"ManifoldsBase.check_vector","text":"check_vector(M::MultinomialMatrices p, X; kwargs...)\n\nChecks whether X is a valid tangent vector to p on the MultinomialMatrices M. This means, that p is valid, that X is of correct dimension and columnswise a tangent vector to the columns of p on the ProbabilitySimplex.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Symplectic","page":"Symplectic","title":"Symplectic","text":"","category":"section"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"The Symplectic manifold, denoted operatornameSp(2n mathbbF), is a closed, embedded, submanifold of  mathbbF^2n times 2n that represents transformations into symplectic subspaces which keep the canonical symplectic form over mathbbF^2n times 2n  invariant under the standard embedding inner product. The canonical symplectic form is a non-degenerate bilinear and skew symmetric map  omegacolon mathbbF^2n times mathbbF^2n  rightarrow mathbbF, given by omega(x y) = x^T Q_2n y for elements x y in mathbbF^2n, with","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"    Q_2n = \n    beginbmatrix\n     0_n    I_n \n    -I_n    0_n\n    endbmatrix","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"That means that an element p in operatornameSp(2n) must fulfill the requirement that ","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"    omega (p x p y) = x^T(p^TQp)y = x^TQy = omega(x y)","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"leading to the requirement on p that p^TQp = Q.","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"The symplectic manifold also forms a group under matrix multiplication, called the textitsymplectic group.  Since all the symplectic matrices necessarily have determinant one, the symplectic group  operatornameSp(2n mathbbF) is a subgroup of the special linear group, operatornameSL(2n mathbbF). When the underlying  field is either mathbbR or mathbbC the symplectic group with a manifold structure constitutes a Lie group, with the Lie Algebra ","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"    mathfraksp(2nF) = H in mathbbF^2n times 2n  Q H + H^T Q = 0","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"This set is also known as the Hamiltonian matrices, which have the  property that (QH)^T = QH and are commonly used in physics.","category":"page"},{"location":"manifolds/symplectic.html","page":"Symplectic","title":"Symplectic","text":"Modules = [Manifolds]\nPages = [\"manifolds/Symplectic.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symplectic.html#Manifolds.ExtendedSymplecticMetric","page":"Symplectic","title":"Manifolds.ExtendedSymplecticMetric","text":"ExtendedSymplecticMetric <: AbstractMetric\n\nThe extension of the RealSymplecticMetric at a point p \\in \\operatorname{Sp}(2n) as an inner product over the embedding space ℝ^2n times 2n, i.e.\n\n    langle x y rangle_p = langle p^-1x p^-1rangle_operatornameFr\n    = operatornametr(x^T(pp^T)^-1y) forall x y in ℝ^2n times 2n\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic.html#Manifolds.RealSymplecticMetric","page":"Symplectic","title":"Manifolds.RealSymplecticMetric","text":"RealSymplecticMetric <: RiemannianMetric\n\nThe canonical Riemannian metric on the symplectic manifold, defined pointwise for p in operatornameSp(2n) by [FioriSimone2011]\n\nbeginalign*\n     g_p colon T_poperatornameSp(2n) times T_poperatornameSp(2n) rightarrow ℝ \n     g_p(Z_1 Z_2) = operatornametr((p^-1Z_1)^T (p^-1Z_2))\nendalign*\n\nThis metric is also the default metric for the Symplectic manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic.html#Manifolds.Symplectic","page":"Symplectic","title":"Manifolds.Symplectic","text":"Symplectic{n, 𝔽} <: AbstractEmbeddedManifold{𝔽, DefaultIsometricEmbeddingType}\n\nThe symplectic manifold consists of all 2n times 2n matrices which preserve the canonical symplectic form over 𝔽^2n  2n times 𝔽^2n  2n,\n\n    omegacolon 𝔽^2n  2n times 𝔽^2n  2n rightarrow 𝔽\n    quad omega(x y) = p^T Q_2n q  x y in 𝔽^2n  2n\n\nwhere\n\nQ_2n =\nbeginbmatrix\n  0_n  I_n \n -I_n  0_n\nendbmatrix\n\nThat is, the symplectic manifold consists of\n\noperatornameSp(2n ℝ) = bigl p  ℝ^2n  2n  big  p^TQ_2np = Q_2n bigr\n\nwith 0_n and I_n denoting the n  n zero-matrix and indentity matrix in ℝ^n times n respectively.\n\nThe tangent space at a point p is given by [Bendokat2021]\n\nbeginalign*\n    T_poperatornameSp(2n)\n        = X in mathbbR^2n times 2n  p^TQ_2nX + X^TQ_2np = 0  \n        = X = pQS  S  R^2n  2n S^T = S \nendalign*\n\nConstructor\n\nSymplectic(2n, field=ℝ) -> Symplectic{div(2n, 2), field}()\n\nGenerate the (real-valued) symplectic manifold of 2n times 2n symplectic matrices. The constructor for the Symplectic manifold accepts the even column/row embedding dimension 2n for the real symplectic manifold, ℝ^2n  2n.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic.html#Manifolds.SymplecticMatrix","page":"Symplectic","title":"Manifolds.SymplecticMatrix","text":"SymplecticMatrix{T}\n\nA lightweight structure to represent the action of the matrix representation of the canonical symplectic form,\n\nQ_2n(λ) = λ\nbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix quad in ℝ^2n times 2n\n\nsuch that the canonical symplectic form is represented by\n\nomega_2n(x y) = x^TQ_2n(1)y quad x y in ℝ^2n\n\nThe entire matrix is however not instantiated in memory, instead a scalar λ of type T is stored, which is used to keep track of scaling and transpose operations applied  to each SymplecticMatrix. For example, given Q = SymplecticMatrix(1.0) represented as 1.0*[0 I; -I 0], the adjoint Q' returns SymplecticMatrix(-1.0) = (-1.0)*[0 I; -I 0].\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symplectic.html#Base.exp-Tuple{Symplectic, Vararg{Any, N} where N}","page":"Symplectic","title":"Base.exp","text":"exp(M::Symplectic, p, X)\nexp!(M::Symplectic, q, p, X)\n\nThe Exponential mapping on the Symplectic manifold with the RealSymplecticMetric Riemannian metric.\n\nFor the point p in operatornameSp(2n) the exponential mapping along the tangent vector X in T_poperatornameSp(2n) is computed as [WangRealSymplecticGroup]\n\n    operatornameexp_p(X) = p operatornameExp((p^-1X)^T)\n                                operatornameExp(p^-1X - (p^-1X)^T)\n\nwhere operatornameExp(cdot) denotes the matrix exponential.\n\n[WangRealSymplecticGroup]: Wang, Jing and Sun, Huafei and Fiori, Simone: A Riemannian-steepest-descent approach for optimization on the real symplectic group, Mathematical Methods in the Applied Sciences, 41(11) pp. 4273-4286, 2018 doi 10.1002/mma.4890\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Base.inv-Union{Tuple{n}, Tuple{Symplectic{n, ℝ}, Any}} where n","page":"Symplectic","title":"Base.inv","text":"inv(::Symplectic, A)\ninv!(::Symplectic, A)\n\nCompute the symplectic inverse A^+ of matrix A  ℝ^2n  2n. Given a matrix\n\nA  ℝ^2n  2nquad\nA =\nbeginbmatrix\nA_11  A_12 \nA_21  A_2 2\nendbmatrix\n\nthe symplectic inverse is defined as:\n\nA^+ = Q_2n^T A^T Q_2n\n\nwhere\n\nQ_2n =\nbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix\n\nThe symplectic inverse of A can be expressed explicitly as:\n\nA^+ =\nbeginbmatrix\n  A_2 2^T  -A_1 2^T 12mm\n -A_2 1^T   A_1 1^T\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Base.rand-Tuple{Symplectic}","page":"Symplectic","title":"Base.rand","text":"rand(::SymplecticStiefel; vector_at=nothing,\n    hamiltonian_norm = (vector_at === nothing ? 1/2 : 1.0))\n\nGenerate a random point on operatornameSp(2n) or a random tangent vector X in T_poperatornameSp(2n) if vector_at is set to a point p in operatornameSp(2n).\n\nA random point on operatornameSp(2n) is constructed by generating a random Hamiltonian matrix Ω in mathfraksp(2nF) with norm hamiltonian_norm, and then transforming it to a symplectic matrix by applying the Cayley transform\n\n    operatornamecaycolon mathfraksp(2nF) rightarrow operatornameSp(2n)\n     Omega mapsto (I - Omega)^-1(I + Omega)\n\nTo generate a random tangent vector in T_poperatornameSp(2n), this code employs the second tangent vector space parametrization of Symplectic. It first generates a random symmetric matrix S by S = randn(2n, 2n) and then symmetrizes it as S = S + S'. Then S is normalized to have Frobenius norm of hamiltonian_norm and X = pQS is returned, where Q is the SymplecticMatrix.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Manifolds.change_representer-Tuple{Symplectic, EuclideanMetric, Any, Any}","page":"Symplectic","title":"Manifolds.change_representer","text":"change_representer(::Symplectic, ::EuclideanMetric, p, X)\nchange_representer!(::Symplectic, Y, ::EuclideanMetric, p, X)\n\nCompute the representation of a tangent vector ξ  T_poperatornameSp(2n ℝ) s.t.\n\n    g_p(c_p(ξ) η) = ξ η^textEuc  η  T_poperatornameSp(2n ℝ)\n\nwith the conversion function\n\n    c_p  T_poperatornameSp(2n ℝ) rightarrow T_poperatornameSp(2n ℝ) quad\n    c_p(ξ) = frac12 pp^T ξ + frac12 pQ ξ^T pQ\n\nEach of the terms c_p^1(ξ) = p p^T ξ and c_p^2(ξ) = pQ ξ^T pQ from the above definition of c_p(η) are themselves metric compatible in the sense that\n\n    c_p^i  T_poperatornameSp(2n ℝ) rightarrow mathbbR^2n times 2nquad\n    g_p^i(c_p(ξ) η) = ξ η^textEuc  η  T_poperatornameSp(2n ℝ)\n\nfor i in 1 2. However the range of each function alone is not confined to T_poperatornameSp(2n ℝ), but the convex combination\n\n    c_p(ξ) = frac12c_p^1(ξ) + frac12c_p^2(ξ)\n\ndoes have the correct range T_poperatornameSp(2n ℝ).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Manifolds.change_representer-Union{Tuple{n}, Tuple{m}, Tuple{𝔽}, Tuple{MetricManifold{𝔽, Euclidean{Tuple{m, n}, 𝔽}, ExtendedSymplecticMetric}, EuclideanMetric, Any, Any}} where {𝔽, m, n}","page":"Symplectic","title":"Manifolds.change_representer","text":"change_representer(MetMan::MetricManifold{𝔽, Euclidean{Tuple{m, n}, 𝔽}, ExtendedSymplecticMetric},\n                   EucMet::EuclideanMetric, p, X)\nchange_representer!(MetMan::MetricManifold{𝔽, Euclidean{Tuple{m, n}, 𝔽}, ExtendedSymplecticMetric},\n                    Y, EucMet::EuclideanMetric, p, X)\n\nChange the representation of a matrix ξ  mathbbR^2n times 2n into the inner product space (ℝ^2n times 2n g_p) where the inner product is given by g_p(ξ η) = langle p^-1ξ p^-1η rangle = operatornametr(ξ^T(pp^T)^-1η), as the extension of the RealSymplecticMetric onto the entire embedding space.\n\nBy changing the representation we mean to apply a mapping\n\n    c_p  mathbbR^2n times 2n rightarrow mathbbR^2n times 2n\n\ndefined by requiring that it satisfy the metric compatibility condition\n\n    g_p(c_p(ξ) η) = p^-1c_p(ξ) p^-1η = ξ η^textEuc\n         η  T_poperatornameSp(2n ℝ)\n\nIn this case, we compute the mapping\n\n    c_p(ξ) = pp^T ξ\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Manifolds.gradient-Tuple{Symplectic, Any, Any, Manifolds.RiemannianProjectionBackend}","page":"Symplectic","title":"Manifolds.gradient","text":"gradient(M::Symplectic, f, p, backend::RiemannianProjectionBackend;\n         extended_metric=true)\ngradient!(M::Symplectic, f, p, backend::RiemannianProjectionBackend;\n         extended_metric=true)\n\nCompute the manifold gradient textgradf(p) of a scalar function f colon operatornameSp(2n) rightarrow ℝ at p in operatornameSp(2n).\n\nThe element textgradf(p) is found as the Riesz representer of the differential textDf(p) colon T_poperatornameSp(2n) rightarrow ℝ w.r.t. the Riemannian metric inner product at p [FioriSimone2011]. That is, textgradf(p) in T_poperatornameSp(2n) solves the relation\n\n    g_p(textgradf(p) X) = textDf(p) quadforall X in T_poperatornameSp(2n)\n\nThe default behaviour is to first change the representation of the Euclidean gradient from the Euclidean metric to the RealSymplecticMetric at p, and then we projecting the result onto the correct tangent tangent space T_poperatornameSp(2n ℝ) w.r.t the Riemannian metric g_p extended to the entire embedding space.\n\nArguments:\n\nextended_metric = true: If true, compute the gradient textgradf(p) by   first changing the representer of the Euclidean gradient of a smooth extension   of f, f(p), w.r.t. the RealSymplecticMetric at p   extended to the entire embedding space, before projecting onto the correct   tangent vector space w.r.t. the same extended metric g_p.   If false, compute the gradient by first projecting f(p) onto the   tangent vector space, before changing the representer in the tangent   vector space to comply with the RealSymplecticMetric.\n\n[FioriSimone2011]: Simone Fiori: Solving minimal-distance problems over the manifold of real-symplectic matrices, SIAM Journal on Matrix Analysis and Applications 32(3), pp. 938-968, 2011. doi 10.1137/100817115.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Manifolds.project_normal!-Union{Tuple{𝔽}, Tuple{n}, Tuple{m}, Tuple{MetricManifold{𝔽, Euclidean{Tuple{m, n}, 𝔽}, ExtendedSymplecticMetric}, Any, Any, Any}} where {m, n, 𝔽}","page":"Symplectic","title":"Manifolds.project_normal!","text":"project_normal!(::MetricManifold{𝔽,Euclidean,ExtendedSymplecticMetric}, Y, p, X)\n\nProject onto the normal of the tangent space (T_poperatornameSp(2n))^perp_g at a point p  operatornameSp(2n), relative to the riemannian metric g RealSymplecticMetric. That is,\n\n(T_poperatornameSp(2n))^perp_g = Y in mathbbR^2n times 2n \n                        g_p(Y X) = 0 forall X in T_poperatornameSp(2n)\n\nThe closed form projection operator onto the normal space is given by [Gao2021Riemannian]\n\noperatornameP^(T_poperatornameSp(2n))perp_g_p(X) = pQoperatornameskew(p^TQ^TX)\n\nwhere operatornameskew(A) = frac12(A - A^T). This function is not exported.\n\n[Gao2021Riemannian]: Gao, Bin and Son, Nguyen Thanh and Absil, P-A and Stykel, Tatjana: Riemannian optimization on the symplectic Stiefel manifold, SIAM Journal on Optimization 31(2), pp. 1546-1575, 2021. doi 10.1137/20M1348522\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Manifolds.symplectic_inverse_times-Union{Tuple{n}, Tuple{Symplectic{n, 𝔽} where 𝔽, Any, Any}} where n","page":"Symplectic","title":"Manifolds.symplectic_inverse_times","text":"symplectic_inverse_times(::Symplectic, p, q)\nsymplectic_inverse_times!(::Symplectic, A, p, q)\n\nDirectly compute the symplectic inverse of p in operatornameSp(2n), multiplied with q in operatornameSp(2n). That is, this function efficiently computes p^+q = (Q_2np^TQ_2n)q in ℝ^2n times 2n, where Q_2n is the SymplecticMatrix of size 2n times 2n.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.check_point-Union{Tuple{ℝ}, Tuple{n}, Tuple{Symplectic{n, ℝ}, Any}} where {n, ℝ}","page":"Symplectic","title":"ManifoldsBase.check_point","text":"check_point(M::Symplectic, p; kwargs...)\n\nCheck whether p is a valid point on the Symplectic M=operatornameSp(2n), i.e. that it has the right AbstractNumbers type and p^+p is (approximately) the identity, where A^+ = Q_2n^TA^TQ_2n is the symplectic inverse, with\n\nQ_2n =\nbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix\n\nThe tolerance can be set with kwargs... (e.g. atol = 1.0e-14).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.check_vector-Tuple{Symplectic, Vararg{Any, N} where N}","page":"Symplectic","title":"ManifoldsBase.check_vector","text":"check_vector(M::Symplectic, p, X; kwargs...)\n\nChecks whether X is a valid tangent vector at p on the Symplectic M=operatornameSp(2n), i.e. the AbstractNumbers fits and it (approximately) holds that p^TQ_2nX + X^TQ_2np = 0, where\n\nQ_2n =\nbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix\n\nThe tolerance can be set with kwargs... (e.g. atol = 1.0e-14).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.distance-Union{Tuple{n}, Tuple{Symplectic{n, 𝔽} where 𝔽, Any, Any}} where n","page":"Symplectic","title":"ManifoldsBase.distance","text":"distance(M::Symplectic, p, q)\n\nCompute an approximate geodesic distance between two Symplectic matrices p q in operatornameSp(2n), as done in [WangRealSymplecticGroup].\n\n    operatornamedist(p q)\n         operatornameLog(p^+q)_operatornameFr\n\nwhere the operatornameLog(cdot) operator is the matrix logarithm.\n\nThis approximation is justified by first recalling the Baker-Campbell-Hausdorf formula,\n\noperatornameLog(operatornameExp(A)operatornameExp(B))\n = A + B + frac12A B + frac112A A B + frac112B B A\n    + ldots \n\nThen we write the expression for the exponential map from p to q as\n\n    q =\n    operatornameexp_p(X)\n    =\n    p operatornameExp((p^+X)^T)\n    operatornameExp(p^+X - (p^+X)^T)\n    X in T_poperatornameSp\n\nand with the geodesic distance between p and q given by operatornamedist(p q) = X_p = p^+X_operatornameFr we see that\n\n    beginalign*\n    operatornameLog(p^+q)_operatornameFr\n    = operatornameLogleft(\n        operatornameExp((p^+X)^T)\n        operatornameExp(p^+X - (p^+X)^T)\n    right)_operatornameFr \n    = p^+X + frac12(p^+X)^T p^+X - (p^+X)^T\n            + ldots _operatornameFr \n     p^+X_operatornameFr = operatornamedist(p q)\n    endalign*\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.inner-Union{Tuple{n}, Tuple{Symplectic{n, ℝ}, Any, Any, Any}} where n","page":"Symplectic","title":"ManifoldsBase.inner","text":"inner(::Symplectic{n, ℝ}, p, X, Y)\n\nCompute the canonical Riemannian inner product RealSymplecticMetric\n\n    g_p(X Y) = operatornametr((p^-1X)^T (p^-1Y))\n\nbetween the two tangent vectors X Y in T_poperatornameSp(2n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.inverse_retract-Tuple{Symplectic, Any, Any, CayleyInverseRetraction}","page":"Symplectic","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Symplectic, p, q, ::CayleyInverseRetraction)\n\nCompute the Cayley Inverse Retraction X = mathcalL_p^operatornameSp(q) such that the Cayley Retraction from p along X lands at q, i.e. mathcalR_p(X) = q [Bendokat2021].\n\nFirst, recall the definition the standard symplectic matrix\n\nQ =\nbeginbmatrix\n 0     I \n-I   0\nendbmatrix\n\nas well as the symplectic inverse of a matrix A, A^+ = Q^T A^T Q.\n\nFor p q  operatornameSp(2n ℝ) then, we can then define the inverse cayley retraction as long as the following matrices exist.\n\n    U = (I + p^+ q)^-1 quad V = (I + q^+ p)^-1\n\nIf that is the case, the inverse cayley retration at p applied to q is\n\nmathcalL_p^operatornameSp(q) = 2pbigl(V - Ubigr) + 2bigl((p + q)U - pbigr)\n                                         T_poperatornameSp(2n)\n\n[Bendokat2021]: Bendokat, Thomas and Zimmermann, Ralf: The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications arXiv preprint arXiv:2108.12447, 2021 (https://arxiv.org/abs/2108.12447)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.manifold_dimension-Union{Tuple{Symplectic{n, 𝔽} where 𝔽}, Tuple{n}} where n","page":"Symplectic","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(::Symplectic{n})\n\nReturns the dimension of the symplectic manifold embedded in ℝ^2n times 2n, i.e.\n\n    operatornamedim(operatornameSp(2n)) = (2n + 1)n\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.project!-Union{Tuple{𝔽}, Tuple{n}, Tuple{m}, Tuple{MetricManifold{𝔽, Euclidean{Tuple{m, n}, 𝔽}, ExtendedSymplecticMetric}, Any, Any, Any}} where {m, n, 𝔽}","page":"Symplectic","title":"ManifoldsBase.project!","text":"project!(::MetricManifold{𝔽,Euclidean,ExtendedSymplecticMetric}, Y, p, X) where {𝔽}\n\nCompute the projection of X  R^2n  2n onto T_poperatornameSp(2n ℝ) w.r.t. the Riemannian metric g RealSymplecticMetric. The closed form projection mapping is given by [Gao2021Riemannian]\n\n    operatornameP^T_poperatornameSp(2n)_g_p(X) = pQoperatornamesym(p^TQ^TX)\n\nwhere operatornamesym(A) = frac12(A + A^T). This function is not exported.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.project-Tuple{Symplectic, Any, Any}","page":"Symplectic","title":"ManifoldsBase.project","text":"project(::Symplectic, p, A)\nproject!(::Symplectic, Y, p, A)\n\nGiven a point p in operatornameSp(2n), project an element A in mathbbR^2n times 2n onto the tangent space T_poperatornameSp(2n) relative to the euclidean metric of the embedding mathbbR^2n times 2n.\n\nThat is, we find the element X in T_poperatornameSpSt(2n 2k) which solves the constrained optimization problem\n\n    operatornamemin_X in mathbbR^2n times 2n frac12X - A^2 quad\n    textst\n    h(X) colon= X^T Q p + p^T Q X = 0\n\nwhere hcolonmathbbR^2n times 2n rightarrow operatornameskew(2n) defines the restriction of X onto the tangent space T_poperatornameSpSt(2n 2k).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#ManifoldsBase.retract-Tuple{Symplectic, Any, Any}","page":"Symplectic","title":"ManifoldsBase.retract","text":"retract(::Symplectic, p, X, ::CayleyRetraction)\nretract!(::Symplectic, q, p, X, ::CayleyRetraction)\n\nCompute the Cayley retraction on p  operatornameSp(2n ℝ) in the direction of tangent vector X  T_poperatornameSp(2n ℝ), as defined in by Birtea et al in proposition 2 [birtea2020optimization].\n\nUsing the symplectic inverse of a matrix A in ℝ^2n times 2n, A^+ = Q_2n^T A^T Q_2n where\n\nQ_2n =\nbeginbmatrix\n0_n  I_n \n -I_n  0_n\nendbmatrix\n\nthe retraction mathcalRcolon ToperatornameSp(2n) rightarrow operatornameSp(2n) is defined pointwise as\n\nbeginalign*\nmathcalR_p(X) = p operatornamecayleft(frac12p^+Xright) \n                 = p operatornameexp_11(p^+X) \n                 = p (2I - p^+X)^-1(2I + p^+X)\nendalign*\n\nHere operatornameexp_11(z) = (2 - z)^-1(2 + z) denotes the Padé (1, 1) approximation to operatornameexp(z).\n\n[birtea2020optimization]: Birtea, Petre and Ca{\\c{s}}u, Ioan and Com{\\u{a}}nescu, Dan: Optimization on the real symplectic group, Monatshefte f{\"u}r Mathematik, Springer doi 10.1007/s00605-020-01369-9\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symplectic.html#Literature","page":"Symplectic","title":"Literature","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#Symmetric-positive-definite-matrices","page":"Symmetric positive definite","title":"Symmetric positive definite matrices","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"SymmetricPositiveDefinite","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite","page":"Symmetric positive definite","title":"Manifolds.SymmetricPositiveDefinite","text":"SymmetricPositiveDefinite{N} <: AbstractDecoratorManifold{𝔽}\n\nThe manifold of symmetric positive definite matrices, i.e.\n\nmathcal P(n) =\nbigl\np  ℝ^n  n big a^mathrmTpa  0 text for all  a  ℝ^nbackslash0\nbigr\n\nThe tangent space at T_pmathcal P(n) reads\n\n    T_pmathcal P(n) =\n    bigl\n        X in mathbb R^nn big X=X^mathrmT\n    bigr\n\ni.e. the set of symmetric matrices,\n\nConstructor\n\nSymmetricPositiveDefinite(n)\n\ngenerates the manifold mathcal P(n) subset ℝ^n  n\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"This manifold can – for example – be illustrated as ellipsoids:  since the eigenvalues are all positive they can be taken as lengths of the axes of an ellipsoids while the directions are given by the eigenvectors.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"(Image: An example set of data)","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"The manifold can be equipped with different metrics","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Common-and-metric-independent-functions","page":"Symmetric positive definite","title":"Common and metric independent functions","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefinite.jl\"]\nOrder = [:function]\n Filter = t -> t !== mean","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Base.rand-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"Base.rand","text":"rand(M::SymmetricPositiveDefinite; σ::Real=1)\n\nGenerate a random symmetric positive definite matrix on the SymmetricPositiveDefinite manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_point-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N}, Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.check_point","text":"check_point(M::SymmetricPositiveDefinite, p; kwargs...)\n\nchecks, whether p is a valid point on the SymmetricPositiveDefinite M, i.e. is a matrix of size (N,N), symmetric and positive definite. The tolerance for the second to last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_vector-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N}, Any, Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.check_vector","text":"check_vector(M::SymmetricPositiveDefinite, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the SymmetricPositiveDefinite M, i.e. atfer check_point(M,p), X has to be of same dimension as p and a symmetric matrix, i.e. this stores tangent vetors as elements of the corresponding Lie group. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.injectivity_radius-Tuple{SymmetricPositiveDefinite}","page":"Symmetric positive definite","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::SymmetricPositiveDefinite[, p])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}[, p])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}[, p])\n\nReturn the injectivity radius of the SymmetricPositiveDefinite. Since M is a Hadamard manifold with respect to the LinearAffineMetric and the LogCholeskyMetric, the injectivity radius is globally .\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricPositiveDefinite)\n\nreturns the dimension of SymmetricPositiveDefinite M=mathcal P(n) n  ℕ, i.e.\n\ndim mathcal P(n) = fracn(n+1)2\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.project-Tuple{SymmetricPositiveDefinite, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.project","text":"project(M::SymmetricPositiveDefinite, p, X)\n\nproject a matrix from the embedding onto the tangent space T_pmathcal P(n) of the SymmetricPositiveDefinite matrices, i.e. the set of symmetric matrices.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.representation_size-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.representation_size","text":"representation_size(M::SymmetricPositiveDefinite)\n\nReturn the size of an array representing an element on the SymmetricPositiveDefinite manifold M, i.e. n  n, the size of such a symmetric positive definite matrix on mathcal M = mathcal P(n).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.zero_vector-Tuple{SymmetricPositiveDefinite, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::SymmetricPositiveDefinite,x)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix x on the SymmetricPositiveDefinite manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Default-metric:-the-linear-affine-metric","page":"Symmetric positive definite","title":"Default metric: the linear affine metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLinearAffine.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LinearAffineMetric","page":"Symmetric positive definite","title":"Manifolds.LinearAffineMetric","text":"LinearAffineMetric <: AbstractMetric\n\nThe linear affine metric is the metric for symmetric positive definite matrices, that employs matrix logarithms and exponentials, which yields a linear and affine metric.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"This metric is also the default metric, i.e. any call of the following functions with P=SymmetricPositiveDefinite(3) will result in MetricManifold(P,LinearAffineMetric())and hence yield the formulae described in this seciton.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLinearAffine.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{SymmetricPositiveDefinite, Vararg{Any, N} where N}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::SymmetricPositiveDefinite, p, X)\nexp(M::MetricManifold{SymmetricPositiveDefinite{N},LinearAffineMetric}, p, X)\n\nCompute the exponential map from p with tangent vector X on the SymmetricPositiveDefinite M with its default MetricManifold having the LinearAffineMetric. The formula reads\n\nexp_p X = p^frac12operatornameExp(p^-frac12 X p^-frac12)p^frac12\n\nwhere operatornameExp denotes to the matrix exponential.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{SymmetricPositiveDefinite, Vararg{Any, N} where N}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::SymmetricPositiveDefinite, p, q)\nlog(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, q)\n\nCompute the logarithmic map from p to q on the SymmetricPositiveDefinite as a MetricManifold with LinearAffineMetric. The formula reads\n\nlog_p q =\np^frac12operatornameLog(p^-frac12qp^-frac12)p^frac12\n\nwhere operatornameLog denotes to the matrix logarithm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.change_metric-Tuple{SymmetricPositiveDefinite, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"Manifolds.change_metric","text":"change_metric(M::SymmetricPositiveDefinite{n}, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal P(n) with respect to the EuclideanMetric g_E, this function changes into the LinearAffineMetric (default) metric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ccolon T_pmathcal P(n) to T_pmathcal P(n) such that for all YZ  T_pmathcal P(n)` it holds\n\nYZ = operatornametr(YZ) = operatornametr(p^-1c(Y)p^-1c(Z)) = g_p(c(Z)c(Y))\n\nand hence c(X) = pX is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.change_representer-Tuple{SymmetricPositiveDefinite, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"Manifolds.change_representer","text":"change_representer(M::SymmetricPositiveDefinite, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function on the tangent space at p with respect to the EuclideanMetric g_E, this is turned into the representer with respect to the (default) metric, the LinearAffineMetric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ZT_pmathcal P(n) such that for all YT_pmathcal P(n)` it holds\n\nXY = operatornametr(XY) = operatornametr(p^-1Zp^-1Y) = g_p(ZY)\n\nand hence Z = pXp.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N}, Any, Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::SymmetricPositiveDefinite, p, q)\ndistance(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, q)\n\nCompute the distance on the SymmetricPositiveDefinite manifold between p and q, as a MetricManifold with LinearAffineMetric. The formula reads\n\nd_mathcal P(n)(pq)\n= lVert operatornameLog(p^-frac12qp^-frac12)rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.get_basis-Tuple{SymmetricPositiveDefinite, Any, DefaultOrthonormalBasis}","page":"Symmetric positive definite","title":"ManifoldsBase.get_basis","text":"[Ξ,κ] = get_basis(M::SymmetricPositiveDefinite, p, B::DefaultOrthonormalBasis)\n[Ξ,κ] = get_basis(M::MetricManifold{SymmetricPositiveDefinite{N},LinearAffineMetric}, p, B::DefaultOrthonormalBasis)\n\nReturn a default ONB for the tangent space T_pmathcal P(n) of the SymmetricPositiveDefinite with respect to the LinearAffineMetric.\n\n    g_p(XY) = operatornametr(p^-1 X p^-1 Y)\n\nThe basis constructed here is based on the ONB for symmetric matrices constructed as follows. Let\n\nDelta_ij = (a_kl)_kl=1^n quad text with \na_kl =\nbegincases\n  1  mbox for  k=l text if  i=j\n  frac1sqrt2  mbox for  k=i l=j text or  k=j l=i\n  0  text else\nendcases\n\nwhich forms an ONB for the space of symmetric matrices.\n\nWe then form the ONB by\n\n   Xi_ij = p^frac12Delta_ijp^frac12qquad i=1ldotsn j=ildotsn\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.get_basis_diagonalizing-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N}, Any, DiagonalizingOrthonormalBasis}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.get_basis_diagonalizing","text":"[Ξ,κ] = get_basis_diagonalizing(M::SymmetricPositiveDefinite, p, B::DiagonalizingOrthonormalBasis)\n[Ξ,κ] = get_basis_diagonalizing(M::MetricManifold{SymmetricPositiveDefinite{N},LinearAffineMetric}, p, B::DiagonalizingOrthonormalBasis)\n\nReturn a orthonormal basis Ξ as a vector of tangent vectors (of length manifold_dimension of M) in the tangent space of p on the MetricManifold of SymmetricPositiveDefinite manifold M with LinearAffineMetric that diagonalizes the curvature tensor R(uv)w with eigenvalues κ and where the direction B.frame_direction V has curvature 0.\n\nThe construction is based on an ONB for the symmetric matrices similar to get_basis(::SymmetricPositiveDefinite, p, ::DefaultOrthonormalBasis just that the ONB here is build from the eigen vectors of p^frac12Vp^frac12.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.get_coordinates-Tuple{SymmetricPositiveDefinite, Any, Any, Any, DefaultOrthonormalBasis}","page":"Symmetric positive definite","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(::SymmetricPositiveDefinite, p, X, ::DefaultOrthonormalBasis)\n\nUsing the basis from get_basis the coordinates with respect to this ONB can be simplified to\n\n   c_k = mathrmtr(p^-frac12Delta_ij X)\n\nwhere k is trhe linearized index of the i=1ldotsn j=ildotsn.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.get_vector-Tuple{SymmetricPositiveDefinite, Any, Any, Any, DefaultOrthonormalBasis}","page":"Symmetric positive definite","title":"ManifoldsBase.get_vector","text":"get_vector(::SymmetricPositiveDefinite, p, c, ::DefaultOrthonormalBasis)\n\nUsing the basis from get_basis the vector reconstruction with respect to this ONB can be simplified to\n\n   X = p^frac12 Biggl( sum_i=1j=i^n c_k Delta_ij Biggr) p^frac12\n\nwhere k is the linearized index of the i=1ldotsn j=ildotsn.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Tuple{SymmetricPositiveDefinite, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::SymmetricPositiveDefinite, p, X, Y)\ninner(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, X, Y)\n\nCompute the inner product of X, Y in the tangent space of p on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LinearAffineMetric. The formula reads\n\ng_p(XY) = operatornametr(p^-1 X p^-1 Y)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.parallel_transport_to-Tuple{SymmetricPositiveDefinite, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::SymmetricPositiveDefinite, p, X, q)\nparallel_transport_to(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, p, X, y)\n\nCompute the parallel transport of X from the tangent space at p to the tangent space at q on the SymmetricPositiveDefinite as a MetricManifold with the LinearAffineMetric. The formula reads\n\nmathcal P_qpX = p^frac12\noperatornameExpbigl(\nfrac12p^-frac12log_p(q)p^-frac12\nbigr)\np^-frac12X p^-frac12\noperatornameExpbigl(\nfrac12p^-frac12log_p(q)p^-frac12\nbigr)\np^frac12\n\nwhere operatornameExp denotes the matrix exponential and log the logarithmic map on SymmetricPositiveDefinite (again with respect to the LinearAffineMetric).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Bures-Wasserstein-metric","page":"Symmetric positive definite","title":"Bures-Wasserstein metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteBuresWasserstein.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.BuresWassersteinMetric","page":"Symmetric positive definite","title":"Manifolds.BuresWassersteinMetric","text":"BurresWassertseinMetric <: AbstractMetric\n\nThe Bures Wasserstein metric for symmetric positive definite matrices[MalagoMontruccioPistone2018].\n\n[MalagoMontruccioPistone2018]: Malagò, L., Montrucchio, L., Pistone, G.: Wasserstein Riemannian geometry of Gaussian densities. Information Geometry, 1, pp. 137–179, 2018. doi: 10.1007/s41884-018-0014-4\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, BuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(::MatricManifold{ℝ,SymmetricPositiveDefinite,BuresWassersteinMetric}, p, X)\n\nCompute the exponential map on SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    exp_p(X) = p+X+L_p(X)pL_p(X)\n\nwhere q=L_p(X) denotes the Lyapunov operator, i.e. it solves pq + qp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, BuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.log","text":"log(::MatricManifold{SymmetricPositiveDefinite,BuresWassersteinMetric}, p, q)\n\nCompute the logarithmic map on SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    log_p(q) = (pq)^frac12 + (qp)^frac12 - 2 p\n\nwhere q=L_p(X) denotes the Lyapunov operator, i.e. it solves pq + qp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.change_representer-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, BuresWassersteinMetric}, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"Manifolds.change_representer","text":"change_representer(M::MetricManifold{ℝ,SymmetricPositiveDefinite,BuresWassersteinMetric}, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function on the tangent space at p with respect to the EuclideanMetric g_E, this is turned into the representer with respect to the (default) metric, the BuresWassersteinMetric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ZT_pmathcal P(n) such that for all YT_pmathcal P(n)` it holds\n\nXY = operatornametr(XY) = ZY_mathrmBW\n\nfor all Y and hence we get Z= 2(A+A^{\\mathrm{T}})withA=Xp``.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Tuple{MetricManifold{ℝ, var\"#s107\", BuresWassersteinMetric} where var\"#s107\"<:SymmetricPositiveDefinite, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(::MatricManifold{SymmetricPositiveDefinite,BuresWassersteinMetric}, p, q)\n\nCompute the distance with respect to the BuresWassersteinMetric on SymmetricPositiveDefinite matrices, i.e.\n\nd(pq) =\n    operatornametr(p) + operatornametr(q) - 2operatornametrBigl( (p^frac12qp^frac12 bigr)^frac12 Bigr)\n\nwhere the last trace can be simplified (by rotating the matrix products in the trace) to operatornametr(pq).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Tuple{MetricManifold{ℝ, var\"#s107\", BuresWassersteinMetric} where var\"#s107\"<:SymmetricPositiveDefinite, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(::MetricManifold{ℝ,SymmetricPositiveDefinite,BuresWassersteinMetric}, p, X, Y)\n\nCompute the inner product SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    XY = frac12operatornametr(L_p(X)Y)\n\nwhere q=L_p(X) denotes the Lyapunov operator, i.e. it solves pq + qp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Generalized-Bures-Wasserstein-metric","page":"Symmetric positive definite","title":"Generalized Bures-Wasserstein metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteGeneralizedBuresWasserstein.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.GeneralizedBuresWassersteinMetric","page":"Symmetric positive definite","title":"Manifolds.GeneralizedBuresWassersteinMetric","text":"GeneralizedBurresWassertseinMetric{T<:AbstractMatrix} <: AbstractMetric\n\nThe generalized Bures Wasserstein metric for symmetric positive definite matrices, see[HanMishraJawanpuriaGao2021].\n\nThis metric internally stores the symmetric positive definite matrix M to generalise the metric, where the name also follows the mentioned preprint.\n\n[HanMishraJawanpuriaGao2021]: Han, A., Mishra, B., Jawanpuria, P., Gao, J.: Generalized Bures-Wasserstein geometry for positive definite matrices. arXiv: 2110.10464.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, GeneralizedBuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(::MatricManifold{ℝ,SymmetricPositiveDefinite,GeneralizedBuresWassersteinMetric}, p, X)\n\nCompute the exponential map on SymmetricPositiveDefinite with respect to the GeneralizedBuresWassersteinMetric given by\n\n    exp_p(X) = p+X+mathcal ML_pM(X)pML_pM(X)\n\nwhere q=L_Mp(X) denotes the generalized Lyapunov operator, i.e. it solves pqM + Mqp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, GeneralizedBuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"Base.log","text":"log(::MatricManifold{SymmetricPositiveDefinite,GeneralizedBuresWassersteinMetric}, p, q)\n\nCompute the logarithmic map on SymmetricPositiveDefinite with respect to the BuresWassersteinMetric given by\n\n    log_p(q) = M(M^-1pM^-1q)^frac12 + (qM^-1pM^-1)^frac12M - 2 p\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.change_representer-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, GeneralizedBuresWassersteinMetric}, EuclideanMetric, Any, Any}","page":"Symmetric positive definite","title":"Manifolds.change_representer","text":"change_representer(M::MetricManifold{ℝ,SymmetricPositiveDefinite,GeneralizedBuresWassersteinMetric}, E::EuclideanMetric, p, X)\n\nGiven a tangent vector X  T_pmathcal M representing a linear function on the tangent space at p with respect to the EuclideanMetric g_E, this is turned into the representer with respect to the (default) metric, the GeneralizedBuresWassersteinMetric on the SymmetricPositiveDefinite M.\n\nTo be precise we are looking for ZT_pmathcal P(n) such that for all YT_pmathcal P(n) it holds\n\nXY = operatornametr(XY) = ZY_mathrmBW\n\nfor all Y and hence we get Z = 2pXM + 2MXp.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Tuple{MetricManifold{ℝ, var\"#s79\", var\"#s78\"} where {var\"#s79\"<:SymmetricPositiveDefinite, var\"#s78\"<:GeneralizedBuresWassersteinMetric}, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(::MatricManifold{SymmetricPositiveDefinite,GeneralizedBuresWassersteinMetric}, p, q)\n\nCompute the distance with respect to the BuresWassersteinMetric on SymmetricPositiveDefinite matrices, i.e.\n\nd(pq) = operatornametr(M^-1p) + operatornametr(M^-1q)\n       - 2operatornametrbigl( (p^frac12M^-1qM^-1p^frac12 bigr)^frac12\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Tuple{MetricManifold{ℝ, var\"#s79\", var\"#s78\"} where {var\"#s79\"<:SymmetricPositiveDefinite, var\"#s78\"<:GeneralizedBuresWassersteinMetric}, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(::MetricManifold{ℝ,SymmetricPositiveDefinite,GeneralizedBuresWassersteinMetric}, p, X, Y)\n\nCompute the inner product SymmetricPositiveDefinite with respect to the GeneralizedBuresWassersteinMetric given by\n\n    XY = frac12operatornametr(L_pM(X)Y)\n\nwhere q=L_Mp(X) denotes the generalized Lyapunov operator, i.e. it solves pqM + Mqp = X.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Log-Euclidean-metric","page":"Symmetric positive definite","title":"Log-Euclidean metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLogEuclidean.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogEuclideanMetric","page":"Symmetric positive definite","title":"Manifolds.LogEuclideanMetric","text":"LogEuclideanMetric <: RiemannianMetric\n\nThe LogEuclidean Metric consists of the Euclidean metric applied to all elements after mapping them into the Lie Algebra, i.e. performing a matrix logarithm beforehand.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite{N}, LogEuclideanMetric}, Any, Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{SymmetricPositiveDefinite{N},LogEuclideanMetric}, p, q)\n\nCompute the distance on the SymmetricPositiveDefinite manifold between p and q as a MetricManifold with LogEuclideanMetric. The formula reads\n\n    d_mathcal P(n)(pq) = lVert operatornameLog p - operatornameLog q rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Log-Cholesky-metric","page":"Symmetric positive definite","title":"Log-Cholesky metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLogCholesky.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogCholeskyMetric","page":"Symmetric positive definite","title":"Manifolds.LogCholeskyMetric","text":"LogCholeskyMetric <: RiemannianMetric\n\nThe Log-Cholesky metric imposes a metric based on the Cholesky decomposition as introduced by [Lin2019].\n\n[Lin2019]: Lin, Zenhua: \"Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition\", arXiv: 1908.09326.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, LogCholeskyMetric}, Vararg{Any, N} where N}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, X)\n\nCompute the exponential map on the SymmetricPositiveDefinite M with LogCholeskyMetric from p into direction X. The formula reads\n\nexp_p X = (exp_y W)(exp_y W)^mathrmT\n\nwhere exp_xW is the exponential map on CholeskySpace, y is the cholesky decomposition of p, W = y(y^-1Xy^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, LogCholeskyMetric}, Vararg{Any, N} where N}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, q)\n\nCompute the logarithmic map on SymmetricPositiveDefinite M with respect to the LogCholeskyMetric emanating from p to q. The formula can be adapted from the CholeskySpace as\n\nlog_p q = xW^mathrmT + Wx^mathrmT\n\nwhere x is the cholesky factor of p and W=log_x y for y the cholesky factor of q and the just mentioned logarithmic map is the one on CholeskySpace.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite{N}, LogCholeskyMetric}, Any, Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, p, q)\n\nCompute the distance on the manifold of SymmetricPositiveDefinite nmatrices, i.e. between two symmetric positive definite matrices p and q with respect to the LogCholeskyMetric. The formula reads\n\nd_mathcal P(n)(pq) = sqrt\n lVert  x  -  y  rVert_mathrmF^2\n + lVert log(operatornamediag(x)) - log(operatornamediag(y))rVert_mathrmF^2   \n\nwhere x and y are the cholesky factors of p and q, respectively, cdot denbotes the strictly lower triangular matrix of its argument, and lVertcdotrVert_mathrmF the Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Union{Tuple{N}, Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite{N}, LogCholeskyMetric}, Any, Any, Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{LogCholeskyMetric,ℝ,SymmetricPositiveDefinite}, p, X, Y)\n\nCompute the inner product of two matrices X, Y in the tangent space of p on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LogCholeskyMetric. The formula reads\n\n    g_p(XY) = a_z(X)a_z(Y)_z\n\nwhere cdotcdot_x denotes inner product on the CholeskySpace, z is the cholesky factor of p, a_z(W) = z (z^-1Wz^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.parallel_transport_to-Tuple{MetricManifold{ℝ, SymmetricPositiveDefinite, LogCholeskyMetric}, Any, Any, Any}","page":"Symmetric positive definite","title":"ManifoldsBase.parallel_transport_to","text":"vector_transport_to(\n    M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric},\n    p,\n    X,\n    q,\n    ::ParallelTransport,\n)\n\nParallel transport the tangent vector X at p along the geodesic to q with respect to the SymmetricPositiveDefinite manifold M and LogCholeskyMetric. The parallel transport is based on the parallel transport on CholeskySpace: Let x and y denote the cholesky factors of p and q, respectively and W = x(x^-1Xx^-mathrmT)_frac12, where (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12. With V the parallel transport on CholeskySpace from x to y. The formula hear reads\n\nmathcal P_qpX = yV^mathrmT + Vy^mathrmT\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics","page":"Symmetric positive definite","title":"Statistics","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages   = [\"SymmetricPositiveDefinite.jl\"]\nOrder = [:function]\nFilter = t -> t === mean","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics.mean-Tuple{SymmetricPositiveDefinite, Any}","page":"Symmetric positive definite","title":"Statistics.mean","text":"mean(\n    M::SymmetricPositiveDefinite,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Literature","page":"Symmetric positive definite","title":"Literature","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/JuliaManifolds/Manifolds.jl/blob/master/CONTRIBUTING.md\"","category":"page"},{"location":"misc/contributing.html#Contributing-to-Manifolds.jl","page":"Contributing","title":"Contributing to Manifolds.jl","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"First, thanks for taking the time to contribute. Any contribution is appreciated and welcome.","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"The following is a set of guidelines to Manifolds.jl.","category":"page"},{"location":"misc/contributing.html#Table-of-Contents","page":"Contributing","title":"Table of Contents","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"Contributing to Manifolds.jl     - Table of Contents\nI just have a question\nHow can I file an issue?\nHow can I contribute?\nAdd a missing method\nProvide a new manifold\nCode style","category":"page"},{"location":"misc/contributing.html#I-just-have-a-question","page":"Contributing","title":"I just have a question","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"The developers can most easily be reached in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"misc/contributing.html#How-can-I-file-an-issue?","page":"Contributing","title":"How can I file an issue?","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"If you found a bug or want to propose a feature, we track our issues within the GitHub repository.","category":"page"},{"location":"misc/contributing.html#How-can-I-contribute?","page":"Contributing","title":"How can I contribute?","text":"","category":"section"},{"location":"misc/contributing.html#Add-a-missing-method","page":"Contributing","title":"Add a missing method","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"Not all methods from our interface ManifoldsBase.jl have been implemented for every manifold. If you notice a method missing and can contribute an implementation, please do so! Even providing a single new method is a good contribution.","category":"page"},{"location":"misc/contributing.html#Provide-a-new-manifold","page":"Contributing","title":"Provide a new manifold","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"A main contribution you can provide is another manifold that is not yet included in the package. A manifold is a concrete type of AbstractManifold from ManifoldsBase.jl. This package also provides the main set of functions a manifold can/should implement. Don't worry if you can only implement some of the functions. If the application you have in mind only requires a subset of these functions, implement those. The ManifoldsBase.jl interface provides concrete error messages for the remaining unimplemented functions.","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"One important detail is that the interface usually provides a mutating as well as a non-mutating variant See for example exp! and exp. The non-mutating one (e.g. exp) always falls back to use the mutating one, so in most cases it should suffice to implement the mutating one (e.g. exp!).","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"Note that since the first argument is always the AbstractManifold, the mutated argument is always the second one in the signature. In the example we have exp(M, p, X) for the exponential map and exp!(M, q, X, p) for the mutating one, which stores the result in q.","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"On the other hand, the user will most likely look for the documentation of the non-mutating version, so we recommend adding the docstring for the non-mutating one, where all different signatures should be collected in one string when reasonable. This can best be achieved by adding a docstring to the method with a general signature with the first argument being your manifold:","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"struct MyManifold <: AbstractManifold end\n\n@doc raw\"\"\"\n    exp(M::MyManifold, p, X)\n\nDescribe the function.\n\"\"\"\nexp(::MyManifold, ::Any...)","category":"page"},{"location":"misc/contributing.html#Code-style","page":"Contributing","title":"Code style","text":"","category":"section"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"We try to follow the documentation guidelines from the Julia documentation as well as Blue Style. We run JuliaFormatter.jl on the repo in the way set in the .JuliaFormatter.toml file, which enforces a number of conventions consistent with the Blue Style.","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"We also follow a few internal conventions:","category":"page"},{"location":"misc/contributing.html","page":"Contributing","title":"Contributing","text":"It is preferred that the AbstractManifold's struct contain a reference to the general theory.\nAny implemented function should be accompanied by its mathematical formulae if a closed form exists.\nWithin the source code of one manifold, the type of the manifold should be the first element of the file, and an alphabetical order of the functions is preferable.\nThe above implies that the mutating variant of a function follows the non-mutating variant.\nThere should be no dangling = signs.\nAlways add a newline between things of different types (struct/method/const).\nAlways add a newline between methods for different functions (including mutating/nonmutating variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the docstrings.\nAll import/using/include should be in the main module file.","category":"page"}]
}
