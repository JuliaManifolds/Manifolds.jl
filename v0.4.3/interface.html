<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ManifoldsBase.jl · Manifolds.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manifolds.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="interface.html">ManifoldsBase.jl</a><ul class="internal"><li><a class="tocitem" href="#Types-and-functions"><span>Types and functions</span></a></li><li><a class="tocitem" href="#Number-systems"><span>Number systems</span></a></li><li><a class="tocitem" href="#Allocation"><span>Allocation</span></a></li><li><a class="tocitem" href="#Bases"><span>Bases</span></a></li><li><a class="tocitem" href="#Vector-transport"><span>Vector transport</span></a></li><li><a class="tocitem" href="#A-Decorator-for-manifolds"><span>A Decorator for manifolds</span></a></li><li><a class="tocitem" href="#ValidationManifold"><span>ValidationManifold</span></a></li><li><a class="tocitem" href="#EmbeddedManifold"><span>EmbeddedManifold</span></a></li><li><a class="tocitem" href="#DefaultManifold"><span>DefaultManifold</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/manifold.html">How to implement a Manifold</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/centeredmatrices.html">Centered matrices</a></li><li><a class="tocitem" href="manifolds/choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="manifolds/elliptope.html">Elliptope</a></li><li><a class="tocitem" href="manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="manifolds/fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="manifolds/generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="manifolds/generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="manifolds/grassmann.html">Grassmann</a></li><li><a class="tocitem" href="manifolds/hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="manifolds/lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="manifolds/multinomialdoublystochastic.html">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="manifolds/multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="manifolds/multinomialsymmetric.html">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="manifolds/oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="manifolds/probabilitysimplex.html">Probability simplex</a></li><li><a class="tocitem" href="manifolds/positivenumbers.html">Positive numbers</a></li><li><a class="tocitem" href="manifolds/projectivespace.html">Projective space</a></li><li><a class="tocitem" href="manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="manifolds/skewsymmetric.html">Skew-symmetric matrices</a></li><li><a class="tocitem" href="manifolds/spectrahedron.html">Spectrahedron</a></li><li><a class="tocitem" href="manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="manifolds/symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="manifolds/symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="manifolds/symmetricpsdfixedrank.html">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="manifolds/torus.html">Torus</a></li><li><a class="tocitem" href="manifolds/spheresymmetricmatrices.html">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/graph.html">Graph manifold</a></li><li><a class="tocitem" href="manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/metric.html">Metric manifold</a></li><li><a class="tocitem" href="manifolds/group.html">Group manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="features/differentiation.html">Differentiation</a></li><li><a class="tocitem" href="features/distributions.html">Distributions</a></li><li><a class="tocitem" href="features/statistics.html">Statistics</a></li><li><a class="tocitem" href="features/testing.html">Testing</a></li><li><a class="tocitem" href="features/utilities.html">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="misc/about.html">About</a></li><li><a class="tocitem" href="misc/contributing.html">Contributing</a></li><li><a class="tocitem" href="misc/internals.html">Internals</a></li><li><a class="tocitem" href="misc/notation.html">Notation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ManifoldsBase.jl-–-an-interface-for-manifolds"><a class="docs-heading-anchor" href="#ManifoldsBase.jl-–-an-interface-for-manifolds"><code>ManifoldsBase.jl</code> – an interface for manifolds</a><a id="ManifoldsBase.jl-–-an-interface-for-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#ManifoldsBase.jl-–-an-interface-for-manifolds" title="Permalink"></a></h1><p>The interface for a manifold is provided in the lightweight package <a href="https://github.com/JuliaManifolds/ManifoldsBase.jl">ManifoldsBase.jl</a>. You can easily implement your algorithms and even your own manifolds just using the interface. All manifolds from the package here are also based on this interface, so any project based on the interface can benefit from all manifolds, as soon as a certain manifold provides implementations of the functions a project requires.</p><ul><li><a href="interface.html#ManifoldsBase.jl-–-an-interface-for-manifolds"><code>ManifoldsBase.jl</code> – an interface for manifolds</a></li><ul><li><a href="interface.html#Types-and-functions">Types and functions</a></li><li><a href="interface.html#Number-systems">Number systems</a></li><li><a href="interface.html#Allocation">Allocation</a></li><li><a href="interface.html#Bases">Bases</a></li><li><a href="interface.html#Vector-transport">Vector transport</a></li><li><a href="interface.html#A-Decorator-for-manifolds">A Decorator for manifolds</a></li><li><a href="interface.html#ValidationManifold">ValidationManifold</a></li><li><a href="interface.html#EmbeddedManifold">EmbeddedManifold</a></li><li><a href="interface.html#DefaultManifold">DefaultManifold</a></li></ul></ul><p>Additionally the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> is provided as well as the <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> as a specific example of such a decorator.</p><h2 id="Types-and-functions"><a class="docs-heading-anchor" href="#Types-and-functions">Types and functions</a><a id="Types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-functions" title="Permalink"></a></h2><p>The following functions are currently available from the interface. If a manifold that you implement for your own package fits this interface, we happily look forward to a <a href="https://github.com/JuliaManifolds/Manifolds.jl/compare">Pull Request</a> to add it here.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractEstimationMethod" href="#ManifoldsBase.AbstractEstimationMethod"><code>ManifoldsBase.AbstractEstimationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEstimationMethod</code></pre><p>Abstract type for defining statistical estimation methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractInverseRetractionMethod" href="#ManifoldsBase.AbstractInverseRetractionMethod"><code>ManifoldsBase.AbstractInverseRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractInverseRetractionMethod</code></pre><p>Abstract type for methods for inverting a retraction (see <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>inverse_retract</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractRetractionMethod" href="#ManifoldsBase.AbstractRetractionMethod"><code>ManifoldsBase.AbstractRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractRetractionMethod</code></pre><p>Abstract type for methods for <a href="interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>retract</code></a>ing a tangent vector to a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CoTVector" href="#ManifoldsBase.CoTVector"><code>ManifoldsBase.CoTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoTVector</code></pre><p>Type for a cotangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ExponentialRetraction" href="#ManifoldsBase.ExponentialRetraction"><code>ManifoldsBase.ExponentialRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExponentialRetraction</code></pre><p>Retraction using the exponential map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.LogarithmicInverseRetraction" href="#ManifoldsBase.LogarithmicInverseRetraction"><code>ManifoldsBase.LogarithmicInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogarithmicInverseRetraction</code></pre><p>Inverse retraction using the <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.MPoint" href="#ManifoldsBase.MPoint"><code>ManifoldsBase.MPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPoint</code></pre><p>Type for a point on a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of points on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.Manifold" href="#ManifoldsBase.Manifold"><code>ManifoldsBase.Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Manifold{F}</code></pre><p>A manifold type. The <code>Manifold</code> is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential and <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic maps as well as more general functions that are built on them like the <a href="interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>geodesic</code></a>.</p><p>The manifold is parametrized by an <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> to distinguish for example real (ℝ) and complex (ℂ) manifolds.</p><p>For subtypes the preferred order of parameters is: size and simple value parameters, followed by the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> <code>field</code>, followed by data type parameters, which might depend on the abstract number field type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.OutOfInjectivityRadiusError" href="#ManifoldsBase.OutOfInjectivityRadiusError"><code>ManifoldsBase.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map or <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>inverse_retract</code></a>) is given arguments outside of its <a href="interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold}"><code>injectivity_radius</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PolarInverseRetraction" href="#ManifoldsBase.PolarInverseRetraction"><code>ManifoldsBase.PolarInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PolarInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PolarRetraction" href="#ManifoldsBase.PolarRetraction"><code>ManifoldsBase.PolarRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PolarRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on singular value decompositions of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionInverseRetraction" href="#ManifoldsBase.ProjectionInverseRetraction"><code>ManifoldsBase.ProjectionInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectionInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a projection (or its inversion).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionRetraction" href="#ManifoldsBase.ProjectionRetraction"><code>ManifoldsBase.ProjectionRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectionRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on projection and usually addition in the embedding.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QRInverseRetraction" href="#ManifoldsBase.QRInverseRetraction"><code>ManifoldsBase.QRInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QRInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QRRetraction" href="#ManifoldsBase.QRRetraction"><code>ManifoldsBase.QRRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QRRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TVector" href="#ManifoldsBase.TVector"><code>ManifoldsBase.TVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TVector</code></pre><p>Type for a tangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{Manifold,Any,Any,Any}" href="#Base.angle-Tuple{Manifold,Any,Any,Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle(M::Manifold, p, X, Y)</code></pre><p>Compute the angle between tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> with respect to the inner product from <a href="interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{Manifold,Any,Any}" href="#Base.exp-Tuple{Manifold,Any,Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(M::Manifold, p, X)
exp(M::Manifold, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from manifold the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapprox(M::Manifold, p, X, Y; kwargs...)</code></pre><p>Check if vectors <code>X</code> and <code>Y</code> tangent at <code>p</code> from <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapprox(M::Manifold, p, q; kwargs...)</code></pre><p>Check if points <code>p</code> and <code>q</code> from <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{Manifold,Any,Any}" href="#Base.log-Tuple{Manifold,Any,Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log(M::Manifold, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Manifold,Any,Any}" href="#LinearAlgebra.norm-Tuple{Manifold,Any,Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(M::Manifold, p, X)</code></pre><p>Compute the norm of tangent vector <code>X</code> at point <code>p</code> from a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. By default this is computed using <a href="interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}" href="#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}"><code>ManifoldsBase.allocate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allocate(a)
allocate(a, dims::Integer...)
allocate(a, dims::Tuple)
allocate(a, T::Type)
allocate(a, T::Type, dims::Integer...)
allocate(a, T::Type, dims::Tuple)</code></pre><p>Allocate an object similar to <code>a</code>. It is similar to function <code>similar</code>, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls <code>similar</code> on the innermost array-like object only. Type <code>T</code> is the new number element type <a href="interface.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a>, if it is not given the element type of <code>a</code> is retained. The <code>dims</code> argument can be given for non-nested allocation and is forwarded to the function <code>similar</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}" href="#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>ManifoldsBase.allocate_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allocate_result(M::Manifold, f, x...)</code></pre><p>Allocate an array for the result of function <code>f</code> on <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N" href="#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N"><code>ManifoldsBase.allocate_result_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allocate_result_type(M::Manifold, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> and the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> on given arguments <code>args</code> (passed as a tuple).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold" href="#ManifoldsBase.base_manifold"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">base_manifold(M::Manifold, depth = Val(-1))</code></pre><p>Return the internally stored <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> for decorated manifold <code>M</code> and the base manifold for vector bundles or power manifolds. The optional parameter <code>depth</code> can be used to remove only the first <code>depth</code> many decorators and return the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> from that level, whether its decorated or not. Any negative value deactivates this depth limit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}" href="#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>ManifoldsBase.check_manifold_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_manifold_point(M::Manifold, p; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>p</code> is a point on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Otherwise, return an error with description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_manifold_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="interface.html#ManifoldsBase.MPoint"><code>MPoint</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_size-Tuple{Manifold,Any}" href="#ManifoldsBase.check_size-Tuple{Manifold,Any}"><code>ManifoldsBase.check_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_size(M::Manifold, p)
check_size(M::Manifold, p, X)</code></pre><p>Check whether <code>p</code> has the right <a href="interface.html#ManifoldsBase.representation_size-Tuple{Manifold}"><code>representation_size</code></a> for a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Additionally if a tangent vector is given, both <code>p</code> and <code>X</code> are checked to be of corresponding correct representation sizes for points and tangent vectors on <code>M</code>.</p><p>By default, <code>check_size</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.check_tangent_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_tangent_vector(M::Manifold, p, X; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>X</code> is a valid tangent vector in the tangent space of <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. An implementation should first call <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point(M, p; kwargs...)</code></a> and then validate <code>X</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_tangent_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="interface.html#ManifoldsBase.TVector"><code>TVector</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(M::Manifold, p, q)</code></pre><p>Shortest distance between the points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.embed!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embed!(M::Manifold, Y, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> into the ambient space and return the result in <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project!-Tuple{Manifold,Any,Any,Any}"><code>project!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.embed!-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embed!(M::Manifold, q, p)</code></pre><p>Embed point <code>p</code> from the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if points on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>If you have more than one embedding, see <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your point <code>p</code> is already represented in some embedding, see <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project!-Tuple{Manifold,Any,Any}"><code>project!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.embed-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embed(M::Manifold, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).</p><p>Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if tangent vectors on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>If you have more than one embedding, see <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your tangent vector <code>X</code> is already represented in some embedding, see <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project-Tuple{Manifold,Any,Any}"><code>project</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{Manifold,Any}" href="#ManifoldsBase.embed-Tuple{Manifold,Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embed(M::Manifold, p)</code></pre><p>Embed point <code>p</code> from the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed</code> includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.project-Tuple{Manifold,Any}"><code>project</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.exp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp!(M::Manifold, q, p, X)
exp!(M::Manifold, q, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from manifold the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The result is saved to <code>q</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geodesic(M::Manifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.  The geodesic is the curve of constant velocity that is locally distance-minimizing.  This function returns a function of (time) <code>t</code>.</p><pre><code class="language-none">geodesic(M::Manifold, x, v, t::Real)
geodesic(M::Manifold, x, v, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the geodesic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{Manifold}" href="#ManifoldsBase.injectivity_radius-Tuple{Manifold}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">injectivity_radius(M::Manifold, p)</code></pre><p>Return the distance <span>$d$</span> such that <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp(M, p, X)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse).</p><pre><code class="language-none">injectivity_radius(M::Manifold)</code></pre><p>Infimum of the injectivity radius of all manifold points.</p><pre><code class="language-none">injectivity_radius(M::Manifold[, x], method::AbstractRetractionMethod)
injectivity_radius(M::Manifold, x, method::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <a href="interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>retract(M, p, X, method)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse) for point <code>p</code> if provided or all manifold points otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner(M::Manifold, p, X, Y)</code></pre><p>Compute the inner product of tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>See also: <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.inverse_retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract!(M::Manifold, X, p, q[, method::AbstractInverseRetractionMethod])</code></pre><p>Compute the inverse retraction, a cheaper, approximate version of the <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map), of points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Result is saved to <code>X</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.inverse_retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract(M::Manifold, x, y)
inverse_retract(M::Manifold, x, y, method::AbstractInverseRetractionMethod</code></pre><p>Compute the inverse retraction, a cheaper, approximate version of the <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map), of points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_manifold_point" href="#ManifoldsBase.is_manifold_point"><code>ManifoldsBase.is_manifold_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_manifold_point(M::Manifold, p, throw_error = false; kwargs...)</code></pre><p>Return whether <code>p</code> is a valid point on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point(M, p; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_tangent_vector" href="#ManifoldsBase.is_tangent_vector"><code>ManifoldsBase.is_tangent_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_tangent_vector(M::Manifold, p, X, throw_error = false; kwargs...)</code></pre><p>Return whether <code>X</code> is a valid tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>check_tangent_vector(M, p, X; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.log!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log!(M::Manifold, X, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The result is saved to <code>X</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{Manifold}" href="#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">manifold_dimension(M::Manifold)</code></pre><p>The dimension <span>$n=\dim_{\mathcal M}$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> is homeomorphic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.mid_point!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.mid_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mid_point!(M::Manifold, q, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="interface.html#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}"><code>exp!</code></a>. Saves the result in <code>q</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.mid_point-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.mid_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mid_point(M::Manifold, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_eltype-Tuple{Any}" href="#ManifoldsBase.number_eltype-Tuple{Any}"><code>ManifoldsBase.number_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number_eltype(x)</code></pre><p>Numeric element type of the a nested representation of a point or a vector. To be used in conjuntion with <a href="interface.html#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}"><code>allocate</code></a> or <a href="interface.html#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>allocate_result</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.project!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project!(M::Manifold, Y, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The result is saved in vector <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>project!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed!-Tuple{Manifold,Any,Any,Any}"><code>embed!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project!-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.project!-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project!(M::Manifold, q, p)</code></pre><p>Project point <code>p</code> from the ambient space onto the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The result is storedin <code>q</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same array data, the data is changed accordingly.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed!-Tuple{Manifold,Any,Any}"><code>embed!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.project-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(M::Manifold, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>project</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed-Tuple{Manifold,Any,Any}"><code>embed</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{Manifold,Any}" href="#ManifoldsBase.project-Tuple{Manifold,Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(M::Manifold, p)</code></pre><p>Project point <code>p</code> from the ambient space of the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> to <code>M</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same array data, the data is changed accordingly.</p><p>See also: <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="interface.html#ManifoldsBase.embed-Tuple{Manifold,Any}"><code>embed</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Tuple{Manifold}" href="#ManifoldsBase.representation_size-Tuple{Manifold}"><code>ManifoldsBase.representation_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representation_size(M::Manifold)</code></pre><p>The size of an array representing a point on <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Returns <code>nothing</code> by default indicating that points are not represented using an <code>AbstractArray</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract!(M::Manifold, q, p, X)
retract!(M::Manifold, q, p, X, t::Real=1)
retract!(M::Manifold, q, p, X, method::AbstractRetractionMethod)
retract!(M::Manifold, q, p, X, t::Real=1, method::AbstractRetractionMethod)</code></pre><p>Compute a retraction, a cheaper, approximate version of the <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential map, from <code>p</code> into direction <code>X</code>, scaled by <code>t</code>, on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> manifold <code>M</code>. Result is saved to <code>q</code>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract(M::Manifold, p, X)
retract(M::Manifold, p, X, t::Real=1)
retract(M::Manifold, p, X, method::AbstractRetractionMethod)
retract(M::Manifold, p, X, t::Real=1, method::AbstractRetractionMethod)</code></pre><p>Compute a retraction, a cheaper, approximate version of the <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential map, from <code>p</code> into direction <code>X</code>, scaled by <code>t</code>, on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shortest_geodesic(M::Manifold, p, q) -&gt; Function</code></pre><p>Get a <a href="interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>geodesic</code></a> <span>$\gamma_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$\gamma_{p,q}(0)=p$</span> and <span>$\gamma_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, there is no guarantee which will be returned.</p><p>This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p><pre><code class="language-none">shortest_geodesic(M::Manifold, p, q, t::Real)
shortest_geodesic(M::Manifold, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the shortest geodesic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.zero_tangent_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_tangent_vector!(M::Manifold, X, p)</code></pre><p>Save to <code>X</code> a vector such that retracting <code>X</code> to the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> at <code>p</code> produces <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}" href="#ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}"><code>ManifoldsBase.zero_tangent_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_tangent_vector(M::Manifold, p)</code></pre><p>Return the tangent vector from the tangent space at <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, that represents the zero vector, i.e. such that a retraction at <code>p</code> produces <code>p</code>.</p></div></section></article><h2 id="Number-systems"><a class="docs-heading-anchor" href="#Number-systems">Number systems</a><a id="Number-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Number-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractNumbers" href="#ManifoldsBase.AbstractNumbers"><code>ManifoldsBase.AbstractNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractNumbers</code></pre><p>An abstract type to represent the number system on which a manifold is built.</p><p>This provides concrete number types for dispatch. The two most common number types are the fields <a href="interface.html#ManifoldsBase.RealNumbers"><code>RealNumbers</code></a> (<code>ℝ</code> for short) and <a href="interface.html#ManifoldsBase.ComplexNumbers"><code>ComplexNumbers</code></a> (<code>ℂ</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ComplexNumbers" href="#ManifoldsBase.ComplexNumbers"><code>ManifoldsBase.ComplexNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ComplexNumbers &lt;: AbstractNumbers
ℂ = ComplexNumbers()</code></pre><p>The field of complex numbers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QuaternionNumbers" href="#ManifoldsBase.QuaternionNumbers"><code>ManifoldsBase.QuaternionNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuaternionNumbers &lt;: AbstractNumbers
ℍ = QuaternionNumbers()</code></pre><p>The division algebra of quaternions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.RealNumbers" href="#ManifoldsBase.RealNumbers"><code>ManifoldsBase.RealNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RealNumbers &lt;: AbstractNumbers
ℝ = RealNumbers()</code></pre><p>The field of real numbers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._unify_number_systems-Tuple{AbstractNumbers,Vararg{AbstractNumbers,N} where N}" href="#ManifoldsBase._unify_number_systems-Tuple{AbstractNumbers,Vararg{AbstractNumbers,N} where N}"><code>ManifoldsBase._unify_number_systems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_unify_number_systems(𝔽s::AbstractNumbers...)</code></pre><p>Compute a number system that includes all given number systems (as sub-systems) and is closed under addition and multiplication.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_system-Union{Tuple{Manifold{𝔽}}, Tuple{𝔽}} where 𝔽" href="#ManifoldsBase.number_system-Union{Tuple{Manifold{𝔽}}, Tuple{𝔽}} where 𝔽"><code>ManifoldsBase.number_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number_system(M::Manifold{𝔽})</code></pre><p>Return the number system the manifold <code>M</code> is based on, i.e. the parameter <code>𝔽</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.real_dimension-Tuple{AbstractNumbers}" href="#ManifoldsBase.real_dimension-Tuple{AbstractNumbers}"><code>ManifoldsBase.real_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">real_dimension(𝔽::AbstractNumbers)</code></pre><p>Return the real dimension <span>$\dim_ℝ 𝔽$</span> of the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> system <code>𝔽</code>. The real dimension is the dimension of a real vector space with which a number in <code>𝔽</code> can be identified. For example, <a href="interface.html#ManifoldsBase.ComplexNumbers"><code>ComplexNumbers</code></a> have a real dimension of 2, and <a href="interface.html#ManifoldsBase.QuaternionNumbers"><code>QuaternionNumbers</code></a> have a real dimension of 4.</p></div></section></article><h2 id="Allocation"><a class="docs-heading-anchor" href="#Allocation">Allocation</a><a id="Allocation-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation" title="Permalink"></a></h2><p>Non-mutating functions in <code>ManifoldsBase.jl</code> are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:</p><ul><li><a href="interface.html#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}"><code>allocate</code></a> that allocates a new point or vector similar to the given one. This function behaves like <code>similar</code> for simple representations of points and vectors (for example <code>Array{Float64}</code>). For more complex types, such as nested representations of <a href="manifolds/power.html#Manifolds.PowerManifold"><code>PowerManifold</code></a> (see <a href="manifolds/power.html#Manifolds.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a>), <a href="manifolds/vector_bundle.html#Manifolds.FVector"><code>FVector</code></a> types, checked types like <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a> and more it operates differently. While <code>similar</code> only concerns itself with the higher level of nested structures, <code>allocate</code> maps itself through all levels of nesting until a simple array of numbers is reached and then calls <code>similar</code>. The difference can be most easily seen in the following example:</li></ul><pre><code class="language-julia">julia&gt; x = similar([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 #undef
 #undef

julia&gt; y = Manifolds.allocate([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 [6.90031725726027e-310]
 [6.9003678131654e-310]

julia&gt; x[1]
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744
 [2] top-level scope at REPL[12]:1

julia&gt; y[1]
1-element Array{Float64,1}:
 6.90031725726027e-310</code></pre><ul><li><a href="interface.html#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>allocate_result</code></a> allocates a result of a particular function (for example [<code>exp</code>], [<code>flat</code>], etc.) on a particular manifold with particular arguments. It takes into account the possibility that different arguments may have different numeric <a href="interface.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a> types thorough the <a href="interface.html#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N"><code>ManifoldsBase.allocate_result_type</code></a> function.</li></ul><h2 id="Bases"><a class="docs-heading-anchor" href="#Bases">Bases</a><a id="Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Bases" title="Permalink"></a></h2><p>The following functions and types provide support for bases of the tangent space of different manifolds. An orthonormal basis of the tangent space <span>$T_p \mathcal M$</span> of (real) dimension <span>$n$</span> has a real-coefficient basis <span>$e_1, e_2, …, e_n$</span> if <span>$\mathrm{Re}(g_p(e_i, e_j)) = δ_{ij}$</span> for each <span>$i,j ∈ \{1, 2, …, n\}$</span> where <span>$g_p$</span> is the Riemannian metric at point <span>$p$</span>. A vector <span>$X$</span> from the tangent space <span>$T_p \mathcal M$</span> can be expressed in Einstein notation as a sum <span>$X = X^i e_i$</span>, where (real) coefficients <span>$X^i$</span> are calculated as <span>$X^i = \mathrm{Re}(g_p(X, e_i))$</span>.</p><p>The main types are:</p><ul><li><a href="interface.html#ManifoldsBase.DefaultOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a>, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_coordinates</code></a> and <a href="interface.html#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_vector</code></a> fast.</li><li><a href="interface.html#ManifoldsBase.DiagonalizingOrthonormalBasis"><code>DiagonalizingOrthonormalBasis</code></a>, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.</li><li><a href="interface.html#ManifoldsBase.ProjectedOrthonormalBasis"><code>ProjectedOrthonormalBasis</code></a>, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.</li><li><a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a>, which stores (explicitly or implicitly) a precomputed basis at a certain point.</li></ul><p>The main functions are:</p><ul><li><a href="interface.html#ManifoldsBase.get_basis-Tuple{Manifold,Any,AbstractBasis}"><code>get_basis</code></a> precomputes a basis at a certain point.</li><li><a href="interface.html#ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_coordinates</code></a> returns coordinates of a tangent vector.</li><li><a href="interface.html#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_vector</code></a> returns a vector for the specified coordinates.</li><li><a href="interface.html#ManifoldsBase.get_vectors-Tuple{Manifold,Any,AbstractBasis}"><code>get_vectors</code></a> returns a vector of basis vectors. Calling it should be avoided for high-dimensional manifolds.</li></ul><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractBasis" href="#ManifoldsBase.AbstractBasis"><code>ManifoldsBase.AbstractBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBasis{𝔽}</code></pre><p>Abstract type that represents a basis on a manifold or a subset of it.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractOrthogonalBasis" href="#ManifoldsBase.AbstractOrthogonalBasis"><code>ManifoldsBase.AbstractOrthogonalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractOrthogonalBasis{𝔽}</code></pre><p>Abstract type that represents an orthonormal basis on a manifold or a subset of it.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractOrthonormalBasis" href="#ManifoldsBase.AbstractOrthonormalBasis"><code>ManifoldsBase.AbstractOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractOrthonormalBasis{𝔽}</code></pre><p>Abstract type that represents an orthonormal basis on a manifold or a subset of it.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CachedBasis" href="#ManifoldsBase.CachedBasis"><code>ManifoldsBase.CachedBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CachedBasis{𝔽,V,&lt;:AbstractBasis{𝔽}} &lt;: AbstractBasis{𝔽}</code></pre><p>A cached version of the given <code>basis</code> with precomputed basis vectors. The basis vectors are stored in <code>data</code>, either explicitly (like in cached variants of <a href="interface.html#ManifoldsBase.ProjectedOrthonormalBasis"><code>ProjectedOrthonormalBasis</code></a>) or implicitly.</p><p><strong>Constructor</strong></p><pre><code class="language-none">CachedBasis(basis::AbstractBasis, data)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultBasis" href="#ManifoldsBase.DefaultBasis"><code>ManifoldsBase.DefaultBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultBasis{𝔽}</code></pre><p>An arbitrary basis on a manifold. This will usually be the fastest basis available for a manifold.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultOrthogonalBasis" href="#ManifoldsBase.DefaultOrthogonalBasis"><code>ManifoldsBase.DefaultOrthogonalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultOrthogonalBasis{𝔽}</code></pre><p>An arbitrary orthogonal basis on a manifold. This will usually be the fastest orthogonal basis available for a manifold.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultOrthonormalBasis" href="#ManifoldsBase.DefaultOrthonormalBasis"><code>ManifoldsBase.DefaultOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultOrthonormalBasis(𝔽::AbstractNumbers = ℝ)</code></pre><p>An arbitrary orthonormal basis on a manifold. This will usually be the fastest orthonormal basis available for a manifold.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DiagonalizingOrthonormalBasis" href="#ManifoldsBase.DiagonalizingOrthonormalBasis"><code>ManifoldsBase.DiagonalizingOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiagonalizingOrthonormalBasis{𝔽,TV} &lt;: AbstractOrthonormalBasis{𝔽}</code></pre><p>An orthonormal basis <code>Ξ</code> as a vector of tangent vectors (of length determined by <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>manifold_dimension</code></a>) in the tangent space that diagonalizes the curvature tensor <span>$R(u,v)w$</span> and where the direction <code>frame_direction</code> <span>$v$</span> has curvature <code>0</code>.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p><strong>Constructor</strong></p><pre><code class="language-none">DiagonalizingOrthonormalBasis(frame_direction, 𝔽::AbstractNumbers = ℝ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectedOrthonormalBasis" href="#ManifoldsBase.ProjectedOrthonormalBasis"><code>ManifoldsBase.ProjectedOrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectedOrthonormalBasis(method::Symbol, 𝔽::AbstractNumbers = ℝ)</code></pre><p>An orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.</p><p>The type parameter <code>𝔽</code> denotes the <a href="interface.html#ManifoldsBase.AbstractNumbers"><code>AbstractNumbers</code></a> that will be used for the vectors elements.</p><p>Available methods:</p><ul><li><code>:gram_schmidt</code> uses a modified Gram-Schmidt orthonormalization.</li><li><code>:svd</code> uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocation_promotion_function-Tuple{Manifold,Any,Tuple}" href="#ManifoldsBase.allocation_promotion_function-Tuple{Manifold,Any,Tuple}"><code>ManifoldsBase.allocation_promotion_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allocation_promotion_function(M::Manifold, f, args::Tuple)</code></pre><p>Determine the function that must be used to ensure that the allocated representation is of the right type. This is needed for <a href="interface.html#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_vector</code></a> when a point on a complex manifold is represented by a real-valued vectors with a real-coefficient basis, so that a complex-valued vector representation is allocated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_basis-Tuple{Manifold,Any,AbstractBasis}" href="#ManifoldsBase.get_basis-Tuple{Manifold,Any,AbstractBasis}"><code>ManifoldsBase.get_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_basis(M::Manifold, p, B::AbstractBasis) -&gt; CachedBasis</code></pre><p>Compute the basis vectors of the tangent space at a point on manifold <code>M</code> represented by <code>p</code>.</p><p>Returned object derives from <a href="interface.html#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> and may have a field <code>.vectors</code> that stores tangent vectors or it may store them implicitly, in which case the function <a href="interface.html#ManifoldsBase.get_vectors-Tuple{Manifold,Any,AbstractBasis}"><code>get_vectors</code></a> needs to be used to retrieve the basis vectors.</p><p>See also: <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_coordinates</code></a>, <a href="interface.html#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_vector</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}" href="#ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}"><code>ManifoldsBase.get_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_coordinates(M::Manifold, p, X, B::AbstractBasis)
get_coordinates(M::Manifold, p, X, B::CachedBasis)</code></pre><p>Compute a one-dimensional vector of coefficients of the tangent vector <code>X</code> at point denoted by <code>p</code> on manifold <code>M</code> in basis <code>B</code>.</p><p>Depending on the basis, <code>p</code> may not directly represent a point on the manifold. For example if a basis transported along a curve is used, <code>p</code> may be the coordinate along the curve. If a <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a> is provided, their stored vectors are used, otherwise the user has to provide a method to compute the coordinates.</p><p>For the <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a> keep in mind that the reconstruction with <a href="interface.html#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_vector</code></a> requires either a dual basis or the cached basis to be selfdual, for example orthonormal</p><p>See also: <a href="interface.html#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_vector</code></a>, <a href="interface.html#ManifoldsBase.get_basis-Tuple{Manifold,Any,AbstractBasis}"><code>get_basis</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}" href="#ManifoldsBase.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}"><code>ManifoldsBase.get_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_vector(M::Manifold, p, X, B::AbstractBasis)</code></pre><p>Convert a one-dimensional vector of coefficients in a basis <code>B</code> of the tangent space at <code>p</code> on manifold <code>M</code> to a tangent vector <code>X</code> at <code>p</code>.</p><p>Depending on the basis, <code>p</code> may not directly represent a point on the manifold. For example if a basis transported along a curve is used, <code>p</code> may be the coordinate along the curve.</p><p>For the <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a> keep in mind that the reconstruction from <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_coordinates</code></a> requires either a dual basis or the cached basis to be selfdual, for example orthonormal</p><p>See also: <a href="interface.html#ManifoldsBase.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}"><code>get_coordinates</code></a>, <a href="interface.html#ManifoldsBase.get_basis-Tuple{Manifold,Any,AbstractBasis}"><code>get_basis</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_vectors-Tuple{Manifold,Any,AbstractBasis}" href="#ManifoldsBase.get_vectors-Tuple{Manifold,Any,AbstractBasis}"><code>ManifoldsBase.get_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_vectors(M::Manifold, p, B::AbstractBasis)</code></pre><p>Get the basis vectors of basis <code>B</code> of the tangent space at point <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.hat-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.hat-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.hat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hat(M::Manifold, p, Xⁱ)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <code>p</code> and tangent component vector <span>$X^i$</span>, compute the equivalent vector representation <span>$X=X^i e_i$</span>, where Einstein summation notation is used:</p><div>\[∧ : X^i ↦ X^i e_i\]</div><p>For array manifolds, this converts a vector representation of the tangent vector to an array representation. The <a href="interface.html#ManifoldsBase.vee-Tuple{Manifold,Any,Any}"><code>vee</code></a> map is the <code>hat</code> map&#39;s inverse.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_of_coordinates-Union{Tuple{𝔾}, Tuple{𝔽}, Tuple{Manifold{𝔽},AbstractBasis{𝔾}}} where 𝔾 where 𝔽" href="#ManifoldsBase.number_of_coordinates-Union{Tuple{𝔾}, Tuple{𝔽}, Tuple{Manifold{𝔽},AbstractBasis{𝔾}}} where 𝔾 where 𝔽"><code>ManifoldsBase.number_of_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number_of_coordinates(M::Manifold, B::AbstractBasis)</code></pre><p>Compute the number of coordinates in basis <code>B</code> of manifold <code>M</code>. This also corresponds to the number of vectors represented by <code>B</code>, or stored within <code>B</code> in case of a <a href="interface.html#ManifoldsBase.CachedBasis"><code>CachedBasis</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_system-Union{Tuple{AbstractBasis{𝔽}}, Tuple{𝔽}} where 𝔽" href="#ManifoldsBase.number_system-Union{Tuple{AbstractBasis{𝔽}}, Tuple{𝔽}} where 𝔽"><code>ManifoldsBase.number_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number_system(::AbstractBasis)</code></pre><p>The number system for the vectors of the given basis.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vee-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.vee-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.vee</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vee(M::Manifold, p, X)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <code>p</code> and tangent vector <code>X</code>, compute the vector components <span>$X^i$</span>, such that <span>$X = X^i e_i$</span>, where Einstein summation notation is used:</p><div>\[\vee : X^i e_i ↦ X^i\]</div><p>For array manifolds, this converts an array representation of the tangent vector to a vector representation. The <a href="interface.html#ManifoldsBase.hat-Tuple{Manifold,Any,Any}"><code>hat</code></a> map is the <code>vee</code> map&#39;s inverse.</p></div></section></article><h2 id="Vector-transport"><a class="docs-heading-anchor" href="#Vector-transport">Vector transport</a><a id="Vector-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-transport" title="Permalink"></a></h2><p>There are three main functions for vector transport:</p><ul><li><a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a></li><li><a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a></li><li><a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a></li></ul><p>Different types of vector transport are implemented using subtypes of <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>:</p><ul><li><a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a></li><li><a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a></li><li><a href="interface.html#ManifoldsBase.ProjectionTransport"><code>ProjectionTransport</code></a></li><li><a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractVectorTransportMethod" href="#ManifoldsBase.AbstractVectorTransportMethod"><code>ManifoldsBase.AbstractVectorTransportMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractVectorTransportMethod</code></pre><p>Abstract type for methods for transporting vectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ParallelTransport" href="#ManifoldsBase.ParallelTransport"><code>ManifoldsBase.ParallelTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParallelTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use parallel transport as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PoleLadderTransport" href="#ManifoldsBase.PoleLadderTransport"><code>ManifoldsBase.PoleLadderTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PoleLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X\in T_p\mathcal M$</span> be a tangent vector at <span>$p\in\mathcal M$</span> and <span>$q\in\mathcal M$</span> the point to transport to. Then <span>$x = \exp_pX$</span> is used to call <code>y =</code><a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a><code>(M, p, x, q)</code> and the resulting vector is obtained by computing <span>$Y = -\log_qy$</span>.</p><p>The <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> posesses two advantages compared to <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>:</p><ul><li>it is cheaper to evaluate, if you want to transport several vectors, since the mid point <span>$c$</span> then stays unchanged.</li><li>while both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds<sup class="footnote-reference"><a id="citeref-Pennec2018" href="#footnote-Pennec2018">[Pennec2018]</a></sup></li></ul><p>The pole ladder was was proposed in <sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">PoleLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical pole ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. For an even cheaper transport the inner operations can be changed to an <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionTransport" href="#ManifoldsBase.ProjectionTransport"><code>ManifoldsBase.ProjectionTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectionTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use projection onto tangent space as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>. See <a href="interface.html#ManifoldsBase.project-Tuple{Manifold,Any,Any}"><code>project</code></a> for details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.SchildsLadderTransport" href="#ManifoldsBase.SchildsLadderTransport"><code>ManifoldsBase.SchildsLadderTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SchildsLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X\in T_p\mathcal M$</span> be a tangent vector at <span>$p\in\mathcal M$</span> and <span>$q\in\mathcal M$</span> the point to transport to. Then</p><div>\[P^{\mathrm{S}}_{q\gets p}(X) =
    \log_q\bigl( \operatorname{retr}_p ( 2\operatorname{retr}_p^{-1}c ) \bigr),\]</div><p>where <span>$c$</span> is the mid point between <span>$q$</span> and <span>$d=\exp_pX$</span>.</p><p>This method employs the internal function <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a><code>(M, p, d, q)</code> that avoids leaving the manifold.</p><p>The name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in <sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">SchildsLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical Schilds ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>. For an even cheaper transport these inner operations can be changed to an <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder" href="#ManifoldsBase.pole_ladder"><code>ManifoldsBase.pole_ladder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pole_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, p, q);
    retraction=ExponentialRetraction(),
    inverse_retraction=LogarithmicInverseRetraction()
)</code></pre><p>Compute an inner step of the pole ladder, that can be used as a <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>. Let <span>$c = \gamma_{p,q}(\frac{1}{2})$</span> mid point between <code>p</code> and <code>q</code>, then the pole ladder is given by</p><div>\[    \operatorname{Pl}(p,d,q) = \operatorname{retr}_d (2\operatorname{retr}_d^{-1}c)\]</div><p>Where the classical pole ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = -\log_q \operatorname{Pl}(p,d,q)$</span>, you will obtain the <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. When performing multiple steps, this method avoidsd the switching to the tangent space. Keep in mind that after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = (-1)^n\log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p><p>It is cheaper to evaluate than <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a>, sinc if you want to form multiple ladder steps between <code>p</code> and <code>q</code>, but with different <code>d</code>, there is just one evaluation of a geodesic each., since the center <code>c</code> can be reused.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder!" href="#ManifoldsBase.pole_ladder!"><code>ManifoldsBase.pole_ladder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pole_ladder(
    M,
    pl,
    p,
    d,
    q,
    c = mid_point(M, p, q),
    X = allocate_result_type(M, log, d, c);
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction()
)</code></pre><p>Compute the <a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a>, i.e. the result is saved in <code>pl</code>. <code>X</code> is used for storing intermediate inverse retraction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder" href="#ManifoldsBase.schilds_ladder"><code>ManifoldsBase.schilds_ladder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">schilds_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, q, d);
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Perform an inner step of schilds ladder, which can be used as a <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, see <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>. Let <span>$c = \gamma_{q,d}(\frac{1}{2})$</span> denote the mid point on the shortest geodesic connecting <span>$q$</span> and the point <span>$d$</span>. Then Schild&#39;s ladder reads as</p><div>\[\operatorname{Sl}(p,d,q) = \operatorname{retr}_x( 2\operatorname{retr}_p^{-1} c)\]</div><p>Where the classical Schilds ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="interface.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="interface.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>In consistency with <a href="interface.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> you can change the way the mid point is computed using the optional parameter <code>c</code>, but note that here it&#39;s the mid point between <code>q</code> and <code>d</code>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = \log_q \operatorname{Sl}(p,d,q)$</span>, you will obtain the <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. Then the approximation to the transported vector is given by <span>$\log_q\operatorname{Sl}(p,d,q)$</span>.</p><p>When performing multiple steps, this method avoidsd the switching to the tangent space. Hence after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = \log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder!" href="#ManifoldsBase.schilds_ladder!"><code>ManifoldsBase.schilds_ladder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">schilds_ladder!(
    M,
    sl
    p,
    d,
    q,
    c = mid_point(M, q, d),
    X = allocate_result_type(M, log, d, c);
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction()
)</code></pre><p>Compute <a href="interface.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> and return the value in the parameter <code>sl</code>. If the required mid point <code>c</code> was computed before, it can be passed using <code>c</code>, and the allocation of new memory can be avoided providing a tangent vector <code>X</code> for the interims result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,AbstractVectorTransportMethod}" href="#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,AbstractVectorTransportMethod}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along!(
    M::Manifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::AbstractVectorTransportMethod
) where {T}</code></pre><p>Compute the vector transport along a discretized curve <code>c</code> using an <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> succesively along the sampled curve.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,PoleLadderTransport}" href="#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,PoleLadderTransport}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function vector_transport_along!(
    M::Manifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::PoleLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,SchildsLadderTransport}" href="#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,AbstractArray{T,1} where T,SchildsLadderTransport}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along!(
    M::Manifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::SchildsLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along!(M::Manifold, Y, p, X, c)
vector_transport_along!(M::Manifold, Y, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>. The result is saved to <code>Y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_along</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along(M::Manifold, p, X, c)
vector_transport_along(M::Manifold, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_direction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_direction!(M::Manifold, Y, p, X, d)
vector_transport_direction!(M::Manifold, Y, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,PoleLadderTransport}"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>. The result is saved to <code>Y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_direction(M::Manifold, p, X, d)
vector_transport_direction(M::Manifold, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,PoleLadderTransport}"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,PoleLadderTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,PoleLadderTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, Y, p, X, q, method::PoleLadderTransport)</code></pre><p>Perform a vector transport by using <a href="interface.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, Y, p, X, q, method::ProjectionTransport)</code></pre><p>Transport a vector <code>X</code> from the tangent space at <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> by interpreting it as an element of the embedding and then projecting it onto the tangent space at <code>q</code>. This function needs to be separately implemented for each manifold because projection <a href="interface.html#ManifoldsBase.project-Tuple{Manifold,Any,Any}"><code>project</code></a> may also change vector representation (if it&#39;s different than in the embedding) and it is assumed that the vector <code>X</code> already has the correct representation for <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,SchildsLadderTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,SchildsLadderTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, Y, p, X, q, method::SchildsLadderTransport)</code></pre><p>Perform a vector transport by using <a href="interface.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, Y, p, X, q)
vector_transport_to!(M::Manifold, Y, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> along the <a href="interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>shortest_geodesic</code></a> to the tangent space at another point <code>q</code>. By default, the <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>. The result is saved to <code>Y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to(M::Manifold, p, X, q)
vector_transport_to(M::Manifold, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> along the <a href="interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>shortest_geodesic</code></a> to the tangent space at another point <code>q</code>. By default, the <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><h2 id="A-Decorator-for-manifolds"><a class="docs-heading-anchor" href="#A-Decorator-for-manifolds">A Decorator for manifolds</a><a id="A-Decorator-for-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#A-Decorator-for-manifolds" title="Permalink"></a></h2><p>A decorator manifold extends the functionality of a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> in a semi-transparent way. It internally stores the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> it extends and by default for functions defined in the <a href="interface.html"><code>ManifoldsBase</code></a> it acts transparently in the sense that it passes all functions through to the base except those that it actually affects. For example, because the <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> affects nearly all functions, it overwrites nearly all functions, except a few like <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>manifold_dimension</code></a>. On the other hand, the <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a> only affects functions that involve metrics, especially <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a> but not the <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>manifold_dimension</code></a>. Contrary to the previous decorator, the <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a> does not overwrite functions. The decorator sets functions like <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a> to be implemented anew but required to be implemented when specifying a new metric. An exception is not issued if a metric is additionally set to be the default metric (see <a href="manifolds/metric.html#Manifolds.is_default_metric-Tuple{Manifold,Metric}"><code>is_default_metric</code></a>, since this makes all functions act transparently. this last case assumes that the newly specified metric type is actually the one already implemented on a manifold initially.</p><p>By default, i.e. for a plain new decorator, all functions are passed down. To implement a method for a decorator that behaves differently from the method of the same function for the internal manifold, two steps are required. Let&#39;s assume the function is called <code>f(M, arg1, arg2)</code>, and our decorator manifold <code>DM</code> of type <code>OurDecoratorManifold</code> decorates <code>M</code>. Then</p><ol><li>set <code>decorator_transparent_dispatch(f, M::OurDecoratorManifold, args...) = Val(:intransparent)</code></li><li>implement <code>f(DM::OurDecoratorManifold, arg1, arg2)</code></li></ol><p>This makes it possible to extend a manifold or all manifolds with a feature or replace a feature of the original manifold. The <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a> is the best example of the second case, since the default metric indicates for which metric the manifold was originally implemented, such that those functions are just passed through. This can best be seen in the <a href="manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite"><code>SymmetricPositiveDefinite</code></a> manifold with its <a href="manifolds/symmetricpositivedefinite.html#Manifolds.LinearAffineMetric"><code>LinearAffineMetric</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_fallback</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@decorator_transparent_fallback(ex)
@decorator_transparent_fallback(fallback_case = :intransparent, ex)</code></pre><p>This macro introduces an additional implementation for a certain additional case. This can especially be used if for an already transparent function and an abstract intermediate type a change in the default is required. For implementing a concrete type, neither this nor any other trick is necessary. One just implements the function as before. Note that a decorator that <a href="interface.html#ManifoldsBase.is_default_decorator-Tuple{Manifold}"><code>is_default_decorator</code></a> still dispatches to the transparent case.</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="interface.html#ManifoldsBase.decorated_manifold-Tuple{Manifold}"><code>decorated_manifold</code></a>.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold.</li></ul><p>Inline definitions are not supported. The function signature however may contain keyword arguments and a where clause. It does not allow for parameters with default values.</p><p><strong>Examples</strong></p><pre><code class="language-julia">@decorator_transparent_fallback function log!(M::AbstractGroupManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end
@decorator_transparent_fallback :transparent function log!(M::AbstractGroupManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_function-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_function</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@decorator_transparent_function(ex)
@decorator_transparent_function(fallback_case = :intransparent, ex)</code></pre><p>Introduce the function specified by <code>ex</code> to act transparently with respect to <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>s. This introduces the possibility to modify the kind of transparency the implementation is done for. This optional first argument, the <code>Symbol</code> within <code>fallback_case</code>. This macro can be used to define a function and introduce it as transparent to other decorators. Note that a decorator that <a href="interface.html#ManifoldsBase.is_default_decorator-Tuple{Manifold}"><code>is_default_decorator</code></a> still dispatches to the transparent case.</p><p>The cases of transparency are</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="interface.html#ManifoldsBase.decorated_manifold-Tuple{Manifold}"><code>decorated_manifold</code></a>.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold. Passing is performed using the <code>invoke</code> function where the type of manifold is replaced by its supertype.</li></ul><p>Innkoline-definitions are not yet covered – the function signature however may contain keyword arguments and a where clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia">@decorator_transparent_function log!(M::AbstractDecoratorManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end
@decorator_transparent_function :parent log!(M::AbstractDecoratorManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_signature-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_signature-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_signature</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@decorator_transparent_signature(ex)</code></pre><p>Introduces a given function to be transparent with respect to all decorators. The function is adressed by its signature in <code>ex</code>.</p><p>Supports standard, keyword arguments and <code>where</code> clauses. Doesn&#39;t support parameters with default values. It introduces a dispatch on several transparency modes</p><p>The cases of transparency are</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="interface.html#ManifoldsBase.decorated_manifold-Tuple{Manifold}"><code>decorated_manifold</code></a>. This is the default.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold.</li></ul><p>Inline definitions are not supported. The function signature however may contain keyword arguments and a where clause.</p><p>The dispatch kind can later still be set to something different, see <a href="interface.html#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any,Manifold,Vararg{Any,N} where N}"><code>decorator_transparent_dispatch</code></a></p><p><strong>Examples:</strong></p><pre><code class="language-julia">@decorator_transparent_signature log!(M::AbstractDecoratorManifold, X, p, q)
@decorator_transparent_signature log!(M::TD, X, p, q) where {TD&lt;:AbstractDecoratorManifold}
@decorator_transparent_signature isapprox(M::AbstractDecoratorManifold, p, q; kwargs...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractDecoratorManifold" href="#ManifoldsBase.AbstractDecoratorManifold"><code>ManifoldsBase.AbstractDecoratorManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractDecoratorManifold{𝔽} &lt;: Manifold{𝔽}</code></pre><p>An <code>AbstractDecoratorManifold</code> indicates that to some extent a manifold subtype decorates another <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> in the sense that it either</p><ul><li>it extends the functionality of a manifold with further features</li><li>it defines a new manifold that internally uses functions from the decorated manifold</li></ul><p>with the main intent that several or most functions of <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> are transparently passed through to the manifold that is decorated. This way a function implemented for a decorator acts transparent on all other decorators, i.e. they just pass them through. If the decorator the function is implemented for is not among the decorators, an error is issued. By default all base manifold functions, for example <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a> are transparent for all decorators.</p><p>Transparency of functions with respect to decorators can be specified using the macros <a href="interface.html#ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}"><code>@decorator_transparent_fallback</code></a>, <a href="interface.html#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>@decorator_transparent_function</code></a> and <a href="interface.html#ManifoldsBase.@decorator_transparent_signature-Tuple{Any}"><code>@decorator_transparent_signature</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.decorated_manifold-Tuple{Manifold}" href="#ManifoldsBase.decorated_manifold-Tuple{Manifold}"><code>ManifoldsBase.decorated_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decorated_manifold(M::AbstractDecoratorManifold)</code></pre><p>Return the manifold decorated by the decorator <code>M</code>. Defaults to <code>M.manifold</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.decorator_transparent_dispatch-Tuple{Any,Manifold,Vararg{Any,N} where N}" href="#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any,Manifold,Vararg{Any,N} where N}"><code>ManifoldsBase.decorator_transparent_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decorator_transparent_dispatch(f, M::Manifold, args...) -&gt; Val</code></pre><p>Given a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> and a function <code>f(M,args...)</code>, indicate, whether a function is <code>Val(:transparent)</code> or <code>Val(:intransparent)</code> for the (decorated) <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Another possibility is, that for <code>M</code> and given <code>args...</code> the function <code>f</code> should invoke <code>M</code>s <code>Val(:parent)</code> implementation, see <a href="interface.html#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>@decorator_transparent_function</code></a> for details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_decorator_dispatch-Tuple{Manifold}" href="#ManifoldsBase.default_decorator_dispatch-Tuple{Manifold}"><code>ManifoldsBase.default_decorator_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">default_decorator_dispatch(M) -&gt; Val</code></pre><p>Return whether by default to dispatch the the inner manifold of a decorator (<code>Val(true)</code>) or not (<code>Val(false</code>). For more details see <a href="interface.html#ManifoldsBase.is_decorator_transparent-Tuple{Any,Manifold,Vararg{Any,N} where N}"><code>is_decorator_transparent</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_decorator_transparent-Tuple{Any,Manifold,Vararg{Any,N} where N}" href="#ManifoldsBase.is_decorator_transparent-Tuple{Any,Manifold,Vararg{Any,N} where N}"><code>ManifoldsBase.is_decorator_transparent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_decorator_transparent(f, M::Manifold, args...) -&gt; Bool</code></pre><p>Given a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> and a function <code>f(M, args...)</code>, indicate, whether an <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> acts transparently for <code>f</code>. This means, it just passes through down to the internally stored manifold. Transparency is only defined for decorator manifolds and by default all decorators are transparent. A function that is affected by the decorator indicates this by returning <code>false</code>. To change this behaviour, see <a href="interface.html#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any,Manifold,Vararg{Any,N} where N}"><code>decorator_transparent_dispatch</code></a>.</p><p>If a decorator manifold is not in general transparent, it might still pass down for the case that a decorator is the default decorator, see <a href="interface.html#ManifoldsBase.is_default_decorator-Tuple{Manifold}"><code>is_default_decorator</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_default_decorator-Tuple{Manifold}" href="#ManifoldsBase.is_default_decorator-Tuple{Manifold}"><code>ManifoldsBase.is_default_decorator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_default_decorator(M) -&gt; Bool</code></pre><p>For any manifold that is a subtype of <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>, this function indicates whether a certain manifold <code>M</code> acts as a default decorator.</p><p>This yields that <em>all</em> functions are passed through to the decorated <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> if <code>M</code> is indicated as default. This overwrites all <a href="interface.html#ManifoldsBase.is_decorator_transparent-Tuple{Any,Manifold,Vararg{Any,N} where N}"><code>is_decorator_transparent</code></a> values.</p><p>This yields the following advantange: For a manifold one usually implicitly assumes for example a metric. To avoid reimplementation of this metric when introducing a second metric, the first metric can be set to be the default, i.e. its implementaion is already given by the undecorated case.</p><p>Value returned by this function is determined by <a href="interface.html#ManifoldsBase.default_decorator_dispatch-Tuple{Manifold}"><code>default_decorator_dispatch</code></a>, which returns a <code>Val</code>-wrapped boolean for type stability of certain functions.</p></div></section></article><h2 id="ValidationManifold"><a class="docs-heading-anchor" href="#ValidationManifold">ValidationManifold</a><a id="ValidationManifold-1"></a><a class="docs-heading-anchor-permalink" href="#ValidationManifold" title="Permalink"></a></h2><p><a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> is a simple decorator that “decorates” a manifold with tests that all involved arrays are correct. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling <a href="interface.html#ManifoldsBase.is_manifold_point"><code>is_manifold_point</code></a> or <a href="interface.html#ManifoldsBase.is_tangent_vector"><code>is_tangent_vector</code></a> whenever applicable.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationCoTVector" href="#ManifoldsBase.ValidationCoTVector"><code>ManifoldsBase.ValidationCoTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ValidationCoTVector &lt;: CoTVector</code></pre><p>Represent a cotangent vector to a point on an <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s and <a href="interface.html#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationMPoint" href="#ManifoldsBase.ValidationMPoint"><code>ManifoldsBase.ValidationMPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ValidationMPoint &lt;: MPoint</code></pre><p>Represent a point on an <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="interface.html#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>s and <a href="interface.html#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationManifold" href="#ManifoldsBase.ValidationManifold"><code>ManifoldsBase.ValidationManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ValidationManifold{𝔽,M&lt;:Manifold{𝔽}} &lt;: AbstractDecoratorManifold{𝔽}</code></pre><p>A manifold to encapsulate manifolds working on array representations of <a href="interface.html#ManifoldsBase.MPoint"><code>MPoint</code></a>s and <a href="interface.html#ManifoldsBase.TVector"><code>TVector</code></a>s in a transparent way, such that for these manifolds it&#39;s not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.</p><p>This manifold is a decorator for a manifold, i.e. it decorates a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> with types points, vectors, and covectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationTVector" href="#ManifoldsBase.ValidationTVector"><code>ManifoldsBase.ValidationTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ValidationTVector &lt;: TVector</code></pre><p>Represent a tangent vector to a point on an <a href="interface.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s and <a href="interface.html#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.array_value-Tuple{AbstractArray}" href="#ManifoldsBase.array_value-Tuple{AbstractArray}"><code>ManifoldsBase.array_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">array_value(p)</code></pre><p>Return the internal array value of an <a href="interface.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>, <a href="interface.html#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>, or <a href="interface.html#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a> if the value <code>p</code> is encapsulated as such. Return <code>p</code> if it is already an array.</p></div></section></article><h2 id="EmbeddedManifold"><a class="docs-heading-anchor" href="#EmbeddedManifold">EmbeddedManifold</a><a id="EmbeddedManifold-1"></a><a class="docs-heading-anchor-permalink" href="#EmbeddedManifold" title="Permalink"></a></h2><p>Some manifolds can easily be defined by using a certain embedding. For example the <a href="manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a><code>(n)</code> is embedded in <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a><code>(n+1)</code>. Similar to the metric and <a href="manifolds/metric.html#Manifolds.MetricManifold"><code>MetricManifold</code></a>, an embedding is often implicitly assumed. We introduce the embedded manifolds hence as an <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>.</p><p>This decorator enables to use such an embedding in an transparent way. Different types of embeddings can be distinguished using the <a href="interface.html#ManifoldsBase.AbstractEmbeddingType"><code>AbstractEmbeddingType</code></a>.</p><h3 id="Isometric-Embeddings"><a class="docs-heading-anchor" href="#Isometric-Embeddings">Isometric Embeddings</a><a id="Isometric-Embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Isometric-Embeddings" title="Permalink"></a></h3><p>For isometric embeddings the type <a href="interface.html#ManifoldsBase.AbstractIsometricEmbeddingType"><code>AbstractIsometricEmbeddingType</code></a> can be used to avoid reimplementing the metric. See <a href="manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a> or <a href="manifolds/hyperbolic.html#Manifolds.Hyperbolic"><code>Hyperbolic</code></a> for example. Here, the exponential map, the logarithmic map, the retraction and its inverse are set to <code>:intransparent</code>, i.e. they have to be implemented.</p><p>Furthermore, the <a href="interface.html#ManifoldsBase.TransparentIsometricEmbedding"><code>TransparentIsometricEmbedding</code></a> type even states that the exponential and logarithmic maps as well as retractions and vector transports of the embedding can be used for the embedded manifold as well. See <a href="manifolds/symmetric.html#Manifolds.SymmetricMatrices"><code>SymmetricMatrices</code></a> for an example.</p><p>In both cases of course <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point</code></a> and <a href="interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>check_tangent_vector</code></a> have to be implemented.</p><h3 id="Further-Embeddings"><a class="docs-heading-anchor" href="#Further-Embeddings">Further Embeddings</a><a id="Further-Embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Embeddings" title="Permalink"></a></h3><p>A first embedding can also just be given implementing <a href="interface.html#ManifoldsBase.embed!-Tuple{Manifold,Any,Any,Any}"><code>embed!</code></a> ann <a href="interface.html#ManifoldsBase.project!-Tuple{Manifold,Any,Any,Any}"><code>project!</code></a> for a manifold. This is considered to be the most usual or default embedding.</p><p>If you have two different embeddings for your manifold, a second one can be specified using the <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, a type that “couples” two manifolds, more precisely a manifold and its embedding, to define embedding and projection functions between these two manifolds.</p><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractEmbeddedManifold" href="#ManifoldsBase.AbstractEmbeddedManifold"><code>ManifoldsBase.AbstractEmbeddedManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEmbeddedManifold{𝔽,T&lt;:AbstractEmbeddingType,𝔽} &lt;: AbstractDecoratorManifold{𝔽}</code></pre><p>This abstract type indicates that a concrete subtype is an embedded manifold with the additional property, that its points are given in the embedding. This also means, that the default implementation of <a href="interface.html#ManifoldsBase.embed-Tuple{Manifold,Any,Any}"><code>embed</code></a> is just the identity, since the points are already stored in the form suitable for this embedding specified. This also holds true for tangent vectors.</p><p>Furthermore, depending on the <a href="interface.html#ManifoldsBase.AbstractEmbeddingType"><code>AbstractEmbeddingType</code></a> different methods are transparently used from the embedding, for example the <a href="interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a> product or even the <a href="interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>distance</code></a> function. Specifying such an embedding type transparently passes the compuation onwards to the embedding (note again, that no <a href="interface.html#ManifoldsBase.embed-Tuple{Manifold,Any,Any}"><code>embed</code></a> is required) and hence avoids to reimplement these methods in the manifold that is embedded.</p><p>This should be used for example for <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point</code></a> or <a href="interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>check_tangent_vector</code></a>, which should first invoke the test of the embedding and then test further constraints the representation in the embedding has for these points to be valid.</p><p>Technically this is realised by making the <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> is a decorator for the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a>s that are subtypes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractEmbeddingType" href="#ManifoldsBase.AbstractEmbeddingType"><code>ManifoldsBase.AbstractEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEmbeddingType</code></pre><p>A type used to specify properties of an <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractIsometricEmbeddingType" href="#ManifoldsBase.AbstractIsometricEmbeddingType"><code>ManifoldsBase.AbstractIsometricEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractIsometricEmbeddingType &lt;: AbstractEmbeddingType</code></pre><p>Characterizes an embedding as isometric. For this case the <a href="interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a> product is passed from the embedded manifold to the embedding.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultEmbeddingType" href="#ManifoldsBase.DefaultEmbeddingType"><code>ManifoldsBase.DefaultEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultEmbeddingType &lt;: AbstractEmbeddingType</code></pre><p>A type of default embedding that does not have any special properties.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultIsometricEmbeddingType" href="#ManifoldsBase.DefaultIsometricEmbeddingType"><code>ManifoldsBase.DefaultIsometricEmbeddingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultIsometricEmbeddingType &lt;: AbstractIsometricEmbeddingType</code></pre><p>An isometric embedding type that acts as a default, i.e. it has no specifig properties beyond its isometric property.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.EmbeddedManifold" href="#ManifoldsBase.EmbeddedManifold"><code>ManifoldsBase.EmbeddedManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EmbeddedManifold{𝔽, MT &lt;: Manifold, NT &lt;: Manifold} &lt;: AbstractDecoratorManifold{𝔽}</code></pre><p>A type to represent an explicit embedding of a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> of type <code>MT</code> embedded into a manifold <code>N</code> of type <code>NT</code>.</p><p>!!!note     This type is not required if a manifold <code>M</code> is to be embedded in one specific manifold <code>N</code>. One can then just implement     <a href="interface.html#ManifoldsBase.embed!-Tuple{Manifold,Any,Any,Any}"><code>embed!</code></a> and <a href="interface.html#ManifoldsBase.project!-Tuple{Manifold,Any,Any,Any}"><code>project!</code></a>. Only for a second –maybe considered non-default–     embedding, this type should be considered in order to dispatch on different embed     and project methods for different embeddings <code>N</code>.</p><p><strong>Fields</strong></p><ul><li><code>manifold</code> the manifold that is an embedded manifold</li><li><code>embedding</code> a second manifold, the first one is embedded into</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">EmbeddedManifold(M, N)</code></pre><p>Generate the <code>EmbeddedManifold</code> of the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> into the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>N</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TransparentIsometricEmbedding" href="#ManifoldsBase.TransparentIsometricEmbedding"><code>ManifoldsBase.TransparentIsometricEmbedding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TransparentIsometricEmbedding &lt;: AbstractIsometricEmbeddingType</code></pre><p>Specify that an embedding is the default isometric embedding. This even inherits logarithmic and exponential map as well as retraction and inverse retractions from the embedding.</p><p>For an example, see <a href="manifolds/symmetric.html#Manifolds.SymmetricMatrices"><code>SymmetricMatrices</code></a> which are isometrically embedded in the Euclidean space of matrices but also inherit exponential and logarithmic maps.</p></div></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold-Union{Tuple{AbstractEmbeddedManifold}, Tuple{N}, Tuple{AbstractEmbeddedManifold,Val{N}}} where N" href="#ManifoldsBase.base_manifold-Union{Tuple{AbstractEmbeddedManifold}, Tuple{N}, Tuple{AbstractEmbeddedManifold,Val{N}}} where N"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">base_manifold(M::AbstractEmbeddedManifold, d::Val{N} = Val(-1))</code></pre><p>Return the base manifold of <code>M</code> that is enhanced with its embedding. While functions like <code>inner</code> might be overwritten to use the (decorated) manifold representing the embedding, the base<em>manifold is the manifold itself in the sense that detemining e.g. the [`is</em>default_metric<code>](@ref) does not fall back to check with the embedding but with the manifold itself. For this abstract case, just</code>M` is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold-Union{Tuple{EmbeddedManifold}, Tuple{N}, Tuple{EmbeddedManifold,Val{N}}} where N" href="#ManifoldsBase.base_manifold-Union{Tuple{EmbeddedManifold}, Tuple{N}, Tuple{EmbeddedManifold,Val{N}}} where N"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">base_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))</code></pre><p>Return the base manifold of <code>M</code> that is enhanced with its embedding. For this specific type the internally stored enhanced manifold <code>M.manifold</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_manifold_point-Tuple{AbstractEmbeddedManifold,Any}" href="#ManifoldsBase.check_manifold_point-Tuple{AbstractEmbeddedManifold,Any}"><code>ManifoldsBase.check_manifold_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_manifold_point(M::AbstractEmbeddedManifold, p; kwargs)</code></pre><p>check whether a point <code>p</code> is a valid point on the <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a>, i.e. that <code>embed(M, p)</code> is a valid point on the embedded manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_tangent_vector-Tuple{AbstractEmbeddedManifold,Any,Any}" href="#ManifoldsBase.check_tangent_vector-Tuple{AbstractEmbeddedManifold,Any,Any}"><code>ManifoldsBase.check_tangent_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_tangent_vector(M::AbstractEmbeddedManifold, p, X; check_base_point = true, kwargs...)</code></pre><p>check that <code>embed(M, p, X)</code> is a valid tangent to <code>embed(M, p)</code>, where <code>check_base_point</code> determines whether the validity of <code>p</code> is checked, too.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_embedding_dispatch-Tuple{AbstractEmbeddedManifold}" href="#ManifoldsBase.default_embedding_dispatch-Tuple{AbstractEmbeddedManifold}"><code>ManifoldsBase.default_embedding_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">default_embedding_dispatch(M::AbstractEmbeddedManifold)</code></pre><p>This method indicates that an <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> is the default and hence acts completely transparently and passes all functions transparently onwards. This is used by the <a href="interface.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> within <a href="interface.html#ManifoldsBase.default_decorator_dispatch-Tuple{Manifold}"><code>default_decorator_dispatch</code></a>. By default this is set to <code>Val(false)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_embedding-Tuple{AbstractEmbeddedManifold}" href="#ManifoldsBase.get_embedding-Tuple{AbstractEmbeddedManifold}"><code>ManifoldsBase.get_embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_embedding(M::AbstractEmbeddedManifold)</code></pre><p>Return the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>N</code> an <a href="interface.html#ManifoldsBase.AbstractEmbeddedManifold"><code>AbstractEmbeddedManifold</code></a> is embedded into.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}" href="#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}"><code>ManifoldsBase.get_embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_embedding(M::EmbeddedManifold)</code></pre><p>Return the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>N</code> an <a href="interface.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> is embedded into.</p></div></section></article><h2 id="DefaultManifold"><a class="docs-heading-anchor" href="#DefaultManifold">DefaultManifold</a><a id="DefaultManifold-1"></a><a class="docs-heading-anchor-permalink" href="#DefaultManifold" title="Permalink"></a></h2><p><a href="interface.html#ManifoldsBase.DefaultManifold"><code>DefaultManifold</code></a> is a simplified version of <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using <code>Manifolds.jl</code> the <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> is available, the <code>DefaultManifold</code> itself is not exported.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultManifold" href="#ManifoldsBase.DefaultManifold"><code>ManifoldsBase.DefaultManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultManifold &lt;: Manifold</code></pre><p>This default manifold illustrates the main features of the interface and provides a skeleton to build one&#39;s own manifold. It is a simplified/shortened variant of <code>Euclidean</code> from <code>Manifolds.jl</code>.</p><p>This manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-LorenziPennec2014"><a class="tag is-link" href="#citeref-LorenziPennec2014">LorenziPennec2014</a><blockquote><p>Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild’s to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5–17 doi <a href="https://doi.org/10.1007/s10851-013-0470-3">10.1007/s10851-013-0470-3</a>, hal: <a href="https://hal.inria.fr/hal-00870489">hal-00870489</a></p></blockquote></li><li class="footnote" id="footnote-Pennec2018"><a class="tag is-link" href="#citeref-Pennec2018">Pennec2018</a><blockquote><p>Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: <a href="https://arxiv.org/abs/1805.11436">1805.11436</a></p></blockquote></li><li class="footnote" id="footnote-EhlersPiraniSchild1972"><a class="tag is-link" href="#citeref-EhlersPiraniSchild1972">EhlersPiraniSchild1972</a><blockquote><p>Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O’Raifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63–84. Clarendon Press, Oxford (1972). reprint doi: <a href="https://doi.org/10.1007/s10714-012-1353-4">10.1007/s10714-012-1353-4</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="examples/manifold.html">How to implement a Manifold »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 23 October 2020 13:08">Friday 23 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
