<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>🚀 Get Started with Manifolds.jl · Manifolds.jl</title><meta name="title" content="🚀 Get Started with Manifolds.jl · Manifolds.jl"/><meta property="og:title" content="🚀 Get Started with Manifolds.jl · Manifolds.jl"/><meta property="twitter:title" content="🚀 Get Started with Manifolds.jl · Manifolds.jl"/><meta name="description" content="Documentation for Manifolds.jl."/><meta property="og:description" content="Documentation for Manifolds.jl."/><meta property="twitter:description" content="Documentation for Manifolds.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Manifolds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">How to...</span><ul><li class="is-active"><a class="tocitem" href="getstarted.html">🚀 Get Started with <code>Manifolds.jl</code></a><ul class="internal"><li><a class="tocitem" href="#Using-the-Library-of-Manifolds"><span>Using the Library of Manifolds</span></a></li><li><a class="tocitem" href="#Implementing-generic-Functions"><span>Implementing generic Functions</span></a></li><li><a class="tocitem" href="#Allocating-and-in-place-computations"><span>Allocating and in-place computations</span></a></li><li><a class="tocitem" href="#Decorating-a-manifold"><span>Decorating a manifold</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="working-in-charts.html">work in charts</a></li><li><a class="tocitem" href="hand-gestures.html">perform Hand gesture analysis</a></li><li><a class="tocitem" href="integration.html">integrate on manifolds and handle probability densities</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/centeredmatrices.html">Centered matrices</a></li><li><a class="tocitem" href="../manifolds/choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="../manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="../manifolds/elliptope.html">Elliptope</a></li><li><a class="tocitem" href="../manifolds/essentialmanifold.html">Essential manifold</a></li><li><a class="tocitem" href="../manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="../manifolds/fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="../manifolds/flag.html">Flag</a></li><li><a class="tocitem" href="../manifolds/generalizedstiefel.html">Generalized Stiefel</a></li><li><a class="tocitem" href="../manifolds/generalizedgrassmann.html">Generalized Grassmann</a></li><li><a class="tocitem" href="../manifolds/grassmann.html">Grassmann</a></li><li><a class="tocitem" href="../manifolds/hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="../manifolds/lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="../manifolds/multinomialdoublystochastic.html">Multinomial doubly stochastic matrices</a></li><li><a class="tocitem" href="../manifolds/multinomial.html">Multinomial matrices</a></li><li><a class="tocitem" href="../manifolds/multinomialsymmetric.html">Multinomial symmetric matrices</a></li><li><a class="tocitem" href="../manifolds/oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="../manifolds/probabilitysimplex.html">Probability simplex</a></li><li><a class="tocitem" href="../manifolds/positivenumbers.html">Positive numbers</a></li><li><a class="tocitem" href="../manifolds/projectivespace.html">Projective space</a></li><li><a class="tocitem" href="../manifolds/generalunitary.html">Orthogonal and Unitary Matrices</a></li><li><a class="tocitem" href="../manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="../manifolds/shapespace.html">Shape spaces</a></li><li><a class="tocitem" href="../manifolds/skewhermitian.html">Skew-Hermitian matrices</a></li><li><a class="tocitem" href="../manifolds/spectrahedron.html">Spectrahedron</a></li><li><a class="tocitem" href="../manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="../manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="../manifolds/symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="../manifolds/symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="../manifolds/spdfixeddeterminant.html">SPD, fixed determinant</a></li><li><a class="tocitem" href="../manifolds/symmetricpsdfixedrank.html">Symmetric positive semidefinite fixed rank</a></li><li><a class="tocitem" href="../manifolds/symplectic.html">Symplectic</a></li><li><a class="tocitem" href="../manifolds/symplecticstiefel.html">Symplectic Stiefel</a></li><li><a class="tocitem" href="../manifolds/torus.html">Torus</a></li><li><a class="tocitem" href="../manifolds/tucker.html">Tucker</a></li><li><a class="tocitem" href="../manifolds/spheresymmetricmatrices.html">Unit-norm symmetric matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/graph.html">Graph manifold</a></li><li><a class="tocitem" href="../manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="../manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="../manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manifolds/connection.html">Connection manifold</a></li><li><a class="tocitem" href="../manifolds/group.html">Group manifold</a></li><li><a class="tocitem" href="../manifolds/metric.html">Metric manifold</a></li><li><a class="tocitem" href="../manifolds/quotient.html">Quotient manifold</a></li></ul></li></ul></li><li><span class="tocitem">Features on Manifolds</span><ul><li><a class="tocitem" href="../features/atlases.html">Atlases and charts</a></li><li><a class="tocitem" href="../features/differentiation.html">Differentiation</a></li><li><a class="tocitem" href="../features/distributions.html">Distributions</a></li><li><a class="tocitem" href="../features/integration.html">Integration</a></li><li><a class="tocitem" href="../features/statistics.html">Statistics</a></li><li><a class="tocitem" href="../features/testing.html">Testing</a></li><li><a class="tocitem" href="../features/utilities.html">Utilities</a></li></ul></li><li><span class="tocitem">Miscellanea</span><ul><li><a class="tocitem" href="../misc/about.html">About</a></li><li><a class="tocitem" href="../misc/contributing.html">Contributing</a></li><li><a class="tocitem" href="../misc/internals.html">Internals</a></li><li><a class="tocitem" href="../misc/notation.html">Notation</a></li><li><a class="tocitem" href="../misc/references.html">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to...</a></li><li class="is-active"><a href="getstarted.html">🚀 Get Started with <code>Manifolds.jl</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="getstarted.html">🚀 Get Started with <code>Manifolds.jl</code></a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manifolds.jl/blob/master/docs/src/tutorials/getstarted.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Get-Started-with-Manifolds.jl"><a class="docs-heading-anchor" href="#Get-Started-with-Manifolds.jl">🚀 Get Started with <code>Manifolds.jl</code></a><a id="Get-Started-with-Manifolds.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Get-Started-with-Manifolds.jl" title="Permalink"></a></h1><p>This is a short overview of <a href="https://juliamanifolds.github.io/Manifolds.jl/"><code>Manifolds.jl</code></a> and how to get started working with your first Manifold. we first need to install the package, using for example</p><pre><code class="language-julia hljs">using Pkg; Pkg.add(&quot;Manifolds&quot;)</code></pre><p>Then you can load the package with</p><pre><code class="language-julia hljs">using Manifolds</code></pre><pre><code class="nohighlight hljs">[ Info: Precompiling ManifoldsRecipesBaseExt [37da849e-34ab-54fd-a5a4-b22599bd6cb0]</code></pre><h2 id="Using-the-Library-of-Manifolds"><a class="docs-heading-anchor" href="#Using-the-Library-of-Manifolds">Using the Library of Manifolds</a><a id="Using-the-Library-of-Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-Library-of-Manifolds" title="Permalink"></a></h2><p><code>Manifolds.jl</code> is first of all a library of manifolds, see the list in the menu <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/">here</a> under “basic manifolds”.</p><p>Let’s look at three examples together with the first few functions on manifolds.</p><h4 id=".-[The-Euclidean-space](https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html)"><a class="docs-heading-anchor" href="#.-[The-Euclidean-space](https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html)">1. <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html">The Euclidean space</a></a><a id=".-[The-Euclidean-space](https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html)-1"></a><a class="docs-heading-anchor-permalink" href="#.-[The-Euclidean-space](https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html)" title="Permalink"></a></h4><p>The Euclidean Space <a href="../manifolds/euclidean.html#EuclideanSection">Euclidean</a> brings us (back) into linear case of vectors, so in terms of manifolds, this is a very simple one. It is often useful to compare to classical algorithms, or implementations.</p><pre><code class="language-julia hljs">M₁ = Euclidean(3)</code></pre><pre><code class="nohighlight hljs">Euclidean(3; field = ℝ)</code></pre><p>Since a manifold is a type in Julia, we write it in CamelCase. Its parameters are first a dimension or size parameter of the manifold, sometimes optional is a field the manifold is defined over.</p><p>For example the above definition is the same as the real-valued case</p><pre><code class="language-julia hljs">M₁ === Euclidean(3, field=ℝ)</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>But we even introduced a short hand notation, since ℝ is also just a symbol/variable to use”</p><pre><code class="language-julia hljs">M₁ === ℝ^3</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>And similarly here are two ways to create the manifold of vectors of length two with complex entries – or mathematically the space <span>$\mathbb C^2$</span></p><pre><code class="language-julia hljs">Euclidean(2, field=ℂ) === ℂ^2</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>The easiest to check is the dimension of a manifold. Here we have three “directions to walk into” at every point <span>$p\in \mathbb R ^3$</span> so <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.maniold_dimension-Tuple%7BAbstractManifold%7D">🔗 <code>manifold_dimension</code></a>) is</p><pre><code class="language-julia hljs">manifold_dimension(M₁)</code></pre><pre><code class="nohighlight hljs">3</code></pre><h4 id=".-[The-hyperpolic-space](@ref-HyperbolicSpace)"><a class="docs-heading-anchor" href="#.-[The-hyperpolic-space](@ref-HyperbolicSpace)">2. <a href="../manifolds/hyperbolic.html#HyperbolicSpace">The hyperpolic space</a></a><a id=".-[The-hyperpolic-space](@ref-HyperbolicSpace)-1"></a><a class="docs-heading-anchor-permalink" href="#.-[The-hyperpolic-space](@ref-HyperbolicSpace)" title="Permalink"></a></h4><p>The <span>$d$</span>-dimensional <a href="../manifolds/hyperbolic.html#HyperbolicSpace">hyperbolic space</a> is usually represented in <span>$\mathbb R^{d+1}$</span> as the set of points <span>$p\in\mathbb R^3$</span> fulfilling</p><p class="math-container">\[p_1^2+p_2^2+\cdots+p_d^2-p_{d+1}^2 = -1.\]</p><p>We define the manifold using</p><pre><code class="language-julia hljs">M₂ = Hyperbolic(2)</code></pre><pre><code class="nohighlight hljs">Hyperbolic(2)</code></pre><p>And we can again just start with looking at the manifold dimension of <code>M₂</code></p><pre><code class="language-julia hljs">manifold_dimension(M₂)</code></pre><pre><code class="nohighlight hljs">2</code></pre><p>A next useful function is to check, whether some <span>$p∈\mathbb R^3$</span> is a point on the manifold <code>M₂</code>. We can check</p><pre><code class="language-julia hljs">is_point(M₂, [0, 0, 1])</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>or</p><pre><code class="language-julia hljs">is_point(M₂, [1, 0, 1])</code></pre><pre><code class="nohighlight hljs">false</code></pre><p>Keyword arguments are passed on to any numerical checks, for example an absolute tolerance when checking the above equiality.</p><p>But in an interactive session an error message might be helpful. A positional (third) argument is present to activate this. Setting this parameter to true, we obtain an error message that gives insight into why the point is not a point on <code>M₂</code>. Note that the <code>LoadError:</code> is due to quarto, on <code>REPL</code> you would just get the <code>DomainError</code>.</p><pre><code class="language-julia hljs">is_point(M₂, [0, 0, 1.001], true)</code></pre><pre><code class="nohighlight hljs">LoadError: DomainError with -1.0020009999999997:
The point [0.0, 0.0, 1.001] does not lie on Hyperbolic(2) since its Minkowski inner product is not -1.</code></pre><h4 id=".-[The-sphere](@ref-SphereSection)"><a class="docs-heading-anchor" href="#.-[The-sphere](@ref-SphereSection)">3. <a href="../manifolds/sphere.html#SphereSection">The sphere</a></a><a id=".-[The-sphere](@ref-SphereSection)-1"></a><a class="docs-heading-anchor-permalink" href="#.-[The-sphere](@ref-SphereSection)" title="Permalink"></a></h4><p><a href="../manifolds/sphere.html#SphereSection">The sphere</a> <span>$\mathbb S^d$</span> is the <span>$d$</span>-dimensional sphere represented in its embedded form, that is unit vectors <span>$p \in \mathbb R^{d+1}$</span> with unit norm <span>$\lVert p \rVert_2 = 1$</span>.</p><pre><code class="language-julia hljs">M₃ = Sphere(2)</code></pre><pre><code class="nohighlight hljs">Sphere(2, ℝ)</code></pre><p>If we only have a point that is approximately on the manifold, we can allow for a tolerance. Usually these are the same values of <code>atol</code> and <code>rtol</code> alowed in <code>isapprox</code>, i.e. we get</p><pre><code class="language-julia hljs">is_point(M₃, [0, 0, 1.001]; atol=1e-3)</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>Here we can show a last nice check: <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.is_vector">🔗 <code>is_vector</code></a> to check whether a tangent vector <code>X</code> is a representation of a tangent vector <span>$X∈T_p\mathcal M$</span> to a point <code>p</code> on the manifold.</p><p>This function has two positional asrguments, the first to again indicate whether to throw an error, the second to disable the check that <code>p</code> is a valid point on the manifold. Usually this validity is essential for the tangent check, but if it was for example performed before, it can be turned off to spare time.</p><p>For example in our first example the point is not of unit norm</p><pre><code class="language-julia hljs">is_vector(M₃, [2, 0, 0], [0, 1, 1])</code></pre><pre><code class="nohighlight hljs">false</code></pre><p>But the orthogonality of <code>p</code> and <code>X</code> is still valid, we can disable the point check, but even setting the error to true we get here</p><pre><code class="language-julia hljs">is_vector(M₃, [2, 0, 0], [0, 1, 1], true, false)</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>But of course it is better to use a valid point in the first place</p><pre><code class="language-julia hljs">is_vector(M₃, [1, 0, 0], [0, 1, 1])</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>and for these we again get informative error messages</p><pre><code class="language-julia hljs">@expect_error is_vector(M₃, [1, 0, 0], [0.1, 1, 1], true) DomainError</code></pre><pre><code class="nohighlight hljs">LoadError: LoadError: UndefVarError: `@expect_error` not defined
in expression starting at In[19]:1</code></pre><p>To learn about how to define a manifold youself check out the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/example.html">🔗 How to define your own manifold</a> tutorial of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/">🔗 <code>ManifoldsBase.jl</code></a>.”</p><h3 id="Building-more-advanced-manifolds"><a class="docs-heading-anchor" href="#Building-more-advanced-manifolds">Building more advanced manifolds</a><a id="Building-more-advanced-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Building-more-advanced-manifolds" title="Permalink"></a></h3><p>Based on these basic manifolds we can directly build more advanced manifolds.</p><p>The first one concerns vectors or matrices of data on a manifold, the <a href="../manifolds/power.html#PowerManifoldSection">PowerManifold</a>.</p><pre><code class="language-julia hljs">M₄ = M₂^2</code></pre><pre><code class="nohighlight hljs">PowerManifold(Hyperbolic(2), 2)</code></pre><p>Then points are represented by arrays, where the power manifold dimension is added in the end. In other words – for the hyperbolic manifold here, we have a matrix with 2 columns, where each column is a valid point on hyperbolic space.</p><pre><code class="language-julia hljs">p = [0 0; 0 1; 1 sqrt(2)]</code></pre><pre><code class="nohighlight hljs">3×2 Matrix{Float64}:
 0.0  0.0
 0.0  1.0
 1.0  1.41421</code></pre><pre><code class="language-julia hljs">[is_point(M₂, p[:, 1]), is_point(M₂, p[:, 2])]</code></pre><pre><code class="nohighlight hljs">2-element Vector{Bool}:
 1
 1</code></pre><p>But of course the method we used previously also works for power manifolds:</p><pre><code class="language-julia hljs">is_point(M₄, p)</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>Note that nested power manifolds are combined into one as in</p><pre><code class="language-julia hljs">M₄₂ = M₄^4</code></pre><pre><code class="nohighlight hljs">PowerManifold(Hyperbolic(2), 2, 4)</code></pre><p>which represents <span>$2\times 4$</span> – matrices of hyperbolic points represented in <span>$3\times 2\times 4$</span> arrays.</p><p>We can – alternatively – use a power manifold with nested arrays</p><pre><code class="language-julia hljs">M₅ = PowerManifold(M₃, NestedPowerRepresentation(), 2)</code></pre><pre><code class="nohighlight hljs">PowerManifold(Sphere(2, ℝ), NestedPowerRepresentation(), 2)</code></pre><p>which emphasizes that we have vectors of length 2 that contain points, so we store them that way.</p><pre><code class="language-julia hljs">p₂ = [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]</code></pre><pre><code class="nohighlight hljs">2-element Vector{Vector{Float64}}:
 [0.0, 0.0, 1.0]
 [0.0, 1.0, 0.0]</code></pre><p>To unify both representations, elements of the power manifold can also be accessed in the classical indexing fashion, if we start with the corresponding manifold first. This way one can implement algorithms also independent of which representation is used.”</p><pre><code class="language-julia hljs">p[M₄, 1]</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 0.0
 0.0
 1.0</code></pre><pre><code class="language-julia hljs">p₂[M₅, 2]</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 0.0
 1.0
 0.0</code></pre><p>Another construtor is the <a href="../manifolds/product.html#ProductManifoldSection">ProductManifold</a> to combine different manifolds. Here of course the order matters. First we construct these using <span>$×$</span></p><pre><code class="language-julia hljs">M₆ = M₂ × M₃</code></pre><pre><code class="nohighlight hljs">ProductManifold with 2 submanifolds:
 Hyperbolic(2)
 Sphere(2, ℝ)</code></pre><p>Since now the representations might differ from element to element, we have to encapsulate these in their own type.</p><pre><code class="language-julia hljs">p₃ = Manifolds.ArrayPartition([0, 0, 1], [0, 1, 0])</code></pre><pre><code class="nohighlight hljs">([0, 0, 1], [0, 1, 0])</code></pre><p>Here <code>ArrayPartition</code> taken from <a href="https://github.com/SciML/RecursiveArrayTools.jl">🔗 <code>RecursiveArrayTools.jl</code></a> to store the point on the product manifold efficiently in one array, still allowing efficient access to the product elements.</p><pre><code class="language-julia hljs">is_point(M₆, p₃, true)</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>But accessing single components still works the same.”</p><pre><code class="language-julia hljs">p₃[M₆, 1]</code></pre><pre><code class="nohighlight hljs">3-element Vector{Int64}:
 0
 0
 1</code></pre><p>Finally, also the <a href="../manifolds/vector_bundle.html#Manifolds.TangentBundle"><code>TangentBundle</code></a>, the manifold collecting all tangent spaces on a manifold is available as”</p><pre><code class="language-julia hljs">M₇ = TangentBundle(M₃)</code></pre><pre><code class="nohighlight hljs">TangentBundle(Sphere(2, ℝ))</code></pre><h2 id="Implementing-generic-Functions"><a class="docs-heading-anchor" href="#Implementing-generic-Functions">Implementing generic Functions</a><a id="Implementing-generic-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-generic-Functions" title="Permalink"></a></h2><p>In this section we take a look how to implement generic functions on manifolds.</p><p>For our example here, we want to implement the so-called <a href="https://en.wikipedia.org%20/wiki/Bézier_curve">📖 Bézier curve</a> using the so-called <a href="https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm">📖 de-Casteljau algorithm</a>. The linked algorithm can easily be generalised to manifolds by replacing lines with geodesics. This was for example used in <a href="../misc/references.html#BergmannGousenbourger:2018">[BG18]</a> and the following example is an extended version of an example from <a href="../misc/references.html#AxenBaranBergmannRzecki:2023">[ABBR23]</a>.</p><p>The algorithm works recursively. For the case that we have a Bézier curve with just two points, the algorithm just evaluates the geodesic connecting both at some time point <span>$t∈[0,1]$</span>. The function to evaluate a shortest geodesic (it might not be unique, but then a deterministic choice is taken) between two points <code>p</code> and <code>q</code> on a manifold <code>M</code> <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.shortest_geodesic-Tuple%7BAbstractManifold,%20Any,%20Any%7D">🔗 <code>shortest_geodesic(M, p, q, t)</code></a>.</p><pre><code class="language-julia hljs">function de_Casteljau(M::AbstractManifold, t, pts::NTuple{2})
    return shortest_geodesic(M, pts[1], pts[2], t)
end</code></pre><pre><code class="nohighlight hljs">de_Casteljau (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">function de_Casteljau(M::AbstractManifold, t, pts::NTuple)
    p = de_Casteljau(M, t, pts[1:(end - 1)])
    q = de_Casteljau(M, t, pts[2:end])
    return shortest_geodesic(M, p, q, t)
end</code></pre><pre><code class="nohighlight hljs">de_Casteljau (generic function with 2 methods)</code></pre><p>Which can now be used on any manifold where the shortest geodesic is implemented</p><p>Now on several manifolds the <a href="https://en.wikipedia.org/wiki/Exponential_map_(Riemannian_geometry)">📖 exponential map</a> and its (locally defined) inverse, the logarithmic map might not be available in an implementation. So one way to generalise this, is the use of a retraction (see <a href="../misc/references.html#AbsilMahonySepulchre:2008">[AMS08]</a>, Def. 4.1.1 for details) and its (local) inverse.</p><p>The function itself is quite similar to the expponential map, just that <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html#ManifoldsBase.retract">🔗 <code>retract(M, p, X, m)</code></a> has one further parameter, the type of retraction to take, so <code>m</code> is a subtype of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code>, the same for the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html#ManifoldsBase.inverse_retract">🔗 <code>inverse_retract(M, p, q, n)</code></a> with an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>n</code>.</p><p>Thinking of a generic implementation, we would like to have a way to specify one, that is available. This can be done by using <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D">🔗 <code>default_retraction_method</code></a> and <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html#ManifoldsBase.default_inverse_retraction_method-Tuple%7BAbstractManifold%7D">🔗 <code>default_inverse_retraction_method</code></a>, respectively. We implement</p><pre><code class="language-julia hljs">function generic_de_Casteljau(
    M::AbstractManifold,
    t,
    pts::NTuple{2};
    m::AbstractRetractionMethod=default_retraction_method(M),
    n::AbstractInverseRetractionMethod=default_inverse_retraction_method(M),
)
    X = inverse_retract(M, pts[1], pts[2], n)
    return retract(M, pts[1], X, t, m)
end</code></pre><pre><code class="nohighlight hljs">generic_de_Casteljau (generic function with 1 method)</code></pre><p>and for the recursion</p><pre><code class="language-julia hljs">function generic_de_Casteljau(
    M::AbstractManifold,
    t,
    pts::NTuple;
    m::AbstractRetractionMethod=default_retraction_method(M),
    n::AbstractInverseRetractionMethod=default_inverse_retraction_method(M),
)
    p = generic_de_Casteljau(M, t, pts[1:(end - 1)]; m=m, n=n)
    q = generic_de_Casteljau(M, t, pts[2:end]; m=m, n=n)
    X = inverse_retract(M, p, q, n)
    return retract(M, p, X, t, m)
end</code></pre><pre><code class="nohighlight hljs">generic_de_Casteljau (generic function with 2 methods)</code></pre><p>Note that on a manifold <code>M</code> where the exponential map is implemented, the <code>default_retraction_method(M)</code> returns <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html#ManifoldsBase.ExponentialRetraction">🔗 <code>ExponentialRetraction</code></a>, which yields that the <code>retract</code> function falls back to calling <code>exp</code>.</p><p>The same mechanism exists for <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.parallel_transport_to-Tuple%7BAbstractManifold,%20Any,%20Any,%20Any%7D">🔗 <code>parallel_transport_to(M, p, X, q)</code></a> and the more general <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports.html#ManifoldsBase.vector_transport_to">🔗 <code>vector_transport_to(M, p, X, q, m)</code></a> whose <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod">🔗 <code>AbstractVectorTransportMethod</code></a> <code>m</code> has a default defined by <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports.html#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D">🔗 <code>default_vector_transport_method(M)</code></a>.</p><h2 id="Allocating-and-in-place-computations"><a class="docs-heading-anchor" href="#Allocating-and-in-place-computations">Allocating and in-place computations</a><a id="Allocating-and-in-place-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Allocating-and-in-place-computations" title="Permalink"></a></h2><p>Memory allocation is a <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Measure-performance-with-%5B@time%5D(@ref)-and-pay-attention-to-memory-allocation">🔗 critical performace issue</a> when programming in Julia. To take this into account, <code>Manifolds.jl</code> provides special functions to reduce the amount of allocations.</p><p>We again look at the <a href="https://en.wikip%20edia.org/wiki/Exponential_map_(Riemannian_geometry)">📖 exponential map</a>. On a manifold <code>M</code> the exponential map needs a point <code>p</code> (to start from) and a tangent vector <code>X</code>, which can be seen as direction to “walk into” as well as the length to walk into this direction. In <code>Manifolds.jl</code> the function can then be called with <code>q = exp(M, p, X)</code> (see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#Base.exp-Tuple%7BAbstractManifold,%20Any,%20Any%7D">🔗 <code>exp(M, p, X)</code></a>). This function returns the resulting point <code>q</code>, which requires to allocate new memory.</p><p>To avoid this allocation, the function <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.exp!-Tuple%7BAbstractManifold,%20Any,%20Any,%20Any%7D">🔗 <code>exp!(M, q, p, X)</code></a> can be called. Here <code>q</code> is allocated beforehand and is passed as the memory, where the result is returned in. It might be used even for interims computations, as long as it does not introduce side effects. Thas means that even with <code>exp!(M, p, p, X)</code> the result is correct.</p><p>Let’s look at an example.</p><p>We take another look at the <a href="../manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a>, but now a high-dimensional one. We can also illustrate how to generate radnom points and tangent vectors.</p><pre><code class="language-julia hljs">M = Sphere(10000)
p₄ = rand(M)
X = rand(M; vector_at=p₄)</code></pre><p>Looking at the allocations required we get</p><pre><code class="language-julia hljs">@allocated exp(M, p₄, X)</code></pre><pre><code class="nohighlight hljs">9928999</code></pre><p>While if we have already allocated memory for the resulting point on the manifold, for example</p><pre><code class="language-julia hljs">q₂ = zero(p₄);</code></pre><p>There are no new memory allocations necessary if we use the in-place function.”</p><pre><code class="language-julia hljs">@allocated exp!(M, q₂, p₄, X)</code></pre><pre><code class="nohighlight hljs">0</code></pre><p>This methodology is used for all functions that compute a new point or tangent vector. By default all allocating functions allocate memory and call the in-place function. This also means that if you implement a new manifold, you just have to implement the in-place version.</p><h2 id="Decorating-a-manifold"><a class="docs-heading-anchor" href="#Decorating-a-manifold">Decorating a manifold</a><a id="Decorating-a-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#Decorating-a-manifold" title="Permalink"></a></h2><p>As you saw until now, an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#The-AbstractManifold">🔗 <code>AbstractManifold</code></a> describes a Riemannian manifold. For completeness, this also includes the chosen <a href="https://en.wikipedia.org/wiki/Metric_tensor">📖 Riemannian metric tensor</a> or inner product on the tangent spaces.</p><p>In <code>Manifolds.jl</code> these are assumed to be a “reasonable default”. For example on the <a href="../manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a><code>(n)</code> we used above, the default metric is the one inherited from restricting the inner product from the embedding space onto each tangent space.</p><p>Consider a manifold like</p><pre><code class="language-julia hljs">M₈ = SymmetricPositiveDefinite(3)</code></pre><pre><code class="nohighlight hljs">SymmetricPositiveDefinite(3)</code></pre><p>which is the manifold of <span>$3×3$</span> matrices that are <a href="../manifolds/symmetricpositivedefinite.html#SymmetricPositiveDefiniteSection">symmetric and positive definite</a>. which has a default as well, the affine invariant <a href="../manifolds/symmetricpositivedefinite.html#Manifolds.AffineInvariantMetric"><code>AffineInvariantMetric</code></a>, but also has several different metrics.</p><p>To switch the metric, we use the idea of a <a href="https://en.wikipedia.org/wiki/Decorator_pattern">📖 decorator pattern</a> approach. Defining</p><pre><code class="language-julia hljs">M₈₂ = MetricManifold(M₈, BuresWassersteinMetric())</code></pre><pre><code class="nohighlight hljs">MetricManifold(SymmetricPositiveDefinite(3), BuresWassersteinMetric())</code></pre><p>changes the manifold to use the <a href="../manifolds/symmetricpositivedefinite.html#BuresWassersteinMetricSection"><code>BuresWassersteinMetric</code></a>.</p><p>This changes all functions that depend on the metric, most prominently the Riemannian matric, but also the exponential and logarithmic map and hence also geodesics.</p><p>All functions that are not dependent on a metric – for example the manifold dimension, the tests of points and vectors we already looked at, but also all retractions – stay unchanged. This means that for example</p><pre><code class="language-julia hljs">[manifold_dimension(M₈₂), manifold_dimension(M₈)]</code></pre><pre><code class="nohighlight hljs">2-element Vector{Int64}:
 6
 6</code></pre><p>both calls the same underlying function. On the other hand with</p><pre><code class="language-julia hljs">p₅, X₅ = one(zeros(3, 3)), [1.0 0.0 1.0; 0.0 1.0 0.0; 1.0 0.0 1.0]</code></pre><pre><code class="nohighlight hljs">([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [1.0 0.0 1.0; 0.0 1.0 0.0; 1.0 0.0 1.0])</code></pre><p>but for example the exponential map and the norm yield different results</p><pre><code class="language-julia hljs">[exp(M₈, p₅, X₅), exp(M₈₂, p₅, X₅)]</code></pre><pre><code class="nohighlight hljs">2-element Vector{Matrix{Float64}}:
 [4.194528049465325 0.0 3.194528049465325; 0.0 2.718281828459045 0.0; 3.194528049465325 0.0 4.194528049465328]
 [2.5 0.0 1.5; 0.0 2.25 0.0; 1.5 0.0 2.5]</code></pre><pre><code class="language-julia hljs">[norm(M₈, p₅, X₅), norm(M₈₂, p₅, X₅)]</code></pre><pre><code class="nohighlight hljs">2-element Vector{Float64}:
 2.23606797749979
 1.118033988749895</code></pre><p>Technically this done using Traits – the trait here is the <a href="../manifolds/metric.html#Manifolds.IsMetricManifold"><code>IsMetricManifold</code></a> trait. Our trait system allows to combine traits but also to inherit properties in a hierarchical way, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/decorator.html#Traits-with-an-inheritance-hierarchy">🔗 here</a> for the technical details.</p><p>The same approach is used for</p><ul><li>specifying a different <a href="../manifolds/connection.html#ConnectionSection">connection</a></li><li>specifying a manifold as a certain <a href="../manifolds/quotient.html#QuotientManifoldSection">quotient manifold</a></li><li>specifying a certain <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/decorator.html#The-Manifold-decorator">🔗 embedding</a>s</li><li>specify a certain <a href="../manifolds/group.html#GroupManifoldSection">group action</a></li></ul><p>Again, for all of these, the concrete types only have to be used if you want to do a second, different from the details, property, for example a second way to embed a manfiold. If a manifold is (in its usual representation) an embedded manifold, this works with the default manifold type already, since then it is again set as the reasonable default.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[AMS08]</dt>
<dd>
<div id="AbsilMahonySepulchre:2008">P.-A. Absil, R. Mahony and R. Sepulchre. <i>Optimization Algorithms on Matrix Manifolds</i>. <a href='https://doi.org/10.1515/9781400830244'>Princeton University Press (2008)</a>, available online at [press.princeton.edu/chapters/absil/](http://press.princeton.edu/chapters/absil/).</div>
</dd><dt>[ABBR23]</dt>
<dd>
<div id="AxenBaranBergmannRzecki:2023">S. D. Axen, M. Baran, R. Bergmann and K. Rzecki. <i>Manifolds.jl: An Extensible Julia Framework for Data Analysis on Manifolds</i>. AMS Transactions on Mathematical Software (2023), <a href='https://arxiv.org/abs/2021.08777'>arXiv:2021.08777</a>, accepted for publication.</div>
</dd><dt>[BG18]</dt>
<dd>
<div id="BergmannGousenbourger:2018">R. Bergmann and P.-Y. Gousenbourger. <i>A variational model for data fitting on manifolds by minimizing the acceleration of a Bézier curve</i>. <a href='https://doi.org/10.3389/fams.2018.00059'>Frontiers in Applied Mathematics and Statistics <b>4</b> (2018)</a>, <a href='https://arxiv.org/abs/1807.10090'>arXiv:1807.10090</a>.</div>
</dd>
</dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">« Home</a><a class="docs-footer-nextpage" href="working-in-charts.html">work in charts »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Tuesday 26 September 2023 21:24">Tuesday 26 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
