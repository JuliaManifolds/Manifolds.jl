---
title: Rigid body dynamics
---

In this tutorial we will learn how rigid body dynamics relates to concepts from Riemannian geometry and Lie groups.

```{julia}
#| echo: false
#| code-fold: true
#| output: false
using Pkg;
cd(@__DIR__)
Pkg.activate("."); # for reproducibility use the local tutorial environment.
using Markdown
```

In this tutorial we need to load a few libraries:
```{julia}
using Manifolds, LinearAlgebra, StaticArrays, RecursiveArrayTools, Plots
```

## 2-dimensional introduction

We will start by considering 2-D rigid bodies. They are characterized by three numbers: position along $x$ and $x$ axes and an angle.
Geometrically it can be represented by elements of the special euclidean group in 2 dimensions, $\operatorname{SE}(2)$:

```{julia}
SE2 = SpecialEuclidean(2)
se2_id = identity_element(SE2)
R2 = Euclidean(2)
```

For example, an object at $(2, 5)$ and at angle $\pi/3$ is represented by
```{julia}
p = exp(SE2, se2_id, hat(SE2, se2_id, [2.0, 5.0, pi/3]))
```

What does it do, exactly? This is one of many ways of creating a points on $\operatorname{SE}(2)$.
We can clearly recognize the numbers representing position and orientation of our object.
The `hat` function converts them to the Lie algebra of $\operatorname{SE}(2)$, denoted $\mathfrak{se}(2)$, while `exp` turns an element of $\mathfrak{se}(2)$ to an element of $\operatorname{SE}(2)$.
There are many ways of mapping between these two structures but `exp` is the one we need at the moment.

Now we will draw our object as an arrow, with position represented by the central-left point in the default orientation.

```{julia}
function draw_arrow_at(p; plt=nothing, arrow_kwargs=(;))
    if plt === nothing
        plt = plot(; aspect_ratio=:equal)
    end
    # constructing matrix where columns are vertices of our arrow
    pts = reduce(hcat, [[0.0, -0.125], [0.5, -0.125], [0.5, -0.25], [1.0, 0.0], [0.5, 0.25], [0.5, 0.125], [0.0, 0.125], [0.0, -0.125]])
    # action that transforms the arrow
    A = Manifolds.ColumnwiseSpecialEuclideanAction(R2, SE2)
    # applying the transformation
    pts_pos = apply(A, p, pts)
    # drawing the arrow
    arr = Shape(pts_pos[1, :], pts_pos[2, :])
    plot!(plt, arr; arrow_kwargs...)
end
plt1 = plot(; aspect_ratio=:equal)
draw_arrow_at(se2_id; plt=plt1, arrow_kwargs=(; label="default position"))
draw_arrow_at(p; plt=plt1, arrow_kwargs=(; label="arrow at p"))
plt1
```

### Simple transformations in global coordinates

There are several ways of transforming position and orientation of an object.
The first one translates and rotates an object by composition.
In the following example, translation by $(-1, -2)$ and rotation by $-\pi/6$ are applied.

```{julia}
p_tr = exp(SE2, se2_id, hat(SE2, se2_id, [-1.0, -2.0, -pi/6]))
p_transformed = compose(SE2, p_tr, p)
plt2 = plot(; aspect_ratio=:equal)
draw_arrow_at(p; plt=plt2, arrow_kwargs=(; label="arrow at p"))
draw_arrow_at(p_transformed; plt=plt2, arrow_kwargs=(; label="arrow after transformation"))
plt2
```

Transformation is applied using group composition operation of $\operatorname{SE}(2)$.
`p_transformed` corresponds to active transformation, represented also by [left-forward](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.LeftForwardAction) [group operation action](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.GroupOperationAction):

```{julia}
G_LF = GroupOperationAction(SE2, LeftForwardAction())
p_transformed_2 = apply(G_LF, p_tr, p)
isapprox(p_transformed, p_transformed_2)
```

Note that translation and rotation happen in the global coordinates, not local ones.
We will cover local coordinates later.

Basis transformation in the passive transformation can be understood as [right-forward](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.RightForwardAction) group operation action.
First we need to get vectors constituting the orthonormal basis of tangent space to $\operatorname{SE}(2)$ at $p$.
These vectors are elements of the special Euclidean Lie algebra $\mathfrak{se}(2)$.
```{julia}
B_SE2 = get_basis(SE2, p, DefaultOrthonormalBasis())
B_SE2_vecs = get_vectors(SE2, p, B_SE2)
```

Next we can use the right-forward action to transform these vectors.

```{julia}
G_RF = GroupOperationAction(SE2, RightForwardAction())
B_transformed = [apply(G_LF, p_tr, X_i) for X_i in B_SE2_vecs]
```

Notice that active transformation does not require a basis of the tangent space while the passive one does.

### Local transformations

Performing local transformations of an object requires different geometric tools.
Moving and rotating an object from its current position can be performed using an exponential map.
Its input are the current position and rotation (a point on $\operatorname{SE}(2)$) and a tangent vector that corresponds to the desired change.

```{julia}
X = hat(SE2, se2_id, [-1.0, -2.0, -pi/6])
```

Let's see how it affects our arrow:

```{julia}
p_exp = exp(SE2, p, X)
println("Old position: ", p)
println("New position: ", p_exp)
plt3 = plot(; aspect_ratio=:equal)
draw_arrow_at(p; plt=plt3, arrow_kwargs=(; label="arrow at p"))
draw_arrow_at(p_exp; plt=plt3, arrow_kwargs=(; label="arrow at exp(M, p, X)"))
plt3
```

As we can see, the arrow moved exactly as expected.

The inverse problem, i.e. figuring out what transformation needs to be applied to transform one position and orientation to another one, is solved by a logarithmic map.
Additionally, we can use [`vee`](@ref) to get back the coordinates of a tangent vector:
```{julia}
X_from_log = log(SE2, p, p_exp)
vee(SE2, p, X_from_log)
```

which gives us back the same coordinates that we used for `X`.

### A freely moving object

A freely moving object moves at a constant velocity and rotates with a constant angular velocity.
Both velocity and angular velocity can be represented by tangent vectors.
The following plot shows what happens to an object in such conditions.

```{julia}
ts = 0.0:0.5:10.0
pts = [exp(SE2, p, t * X) for t in ts]
plt4 = plot(; aspect_ratio=:equal)
for (t, p) in zip(ts, pts)
    draw_arrow_at(p; plt=plt4, arrow_kwargs=(; label="arrow at t=$t"))
end
plt4
```

As we can see, the arrow moves at velocity defined by `X`: -1 space units per time unit in the $x$ direction, -2 space units per time unit in the $y$ direction and rotates by $\pi/6$ clockwise per time unit.
Any kind of free movement can be expressed using a tangent vector.
You may notice that our object actually follows a geodesic in the special Euclidean group.

### Effects of external forces

::: {.callout-caution}

This tutorial, but most importantly this section, does not aim to follow a particular physical model of forces.
The aim is to get a description that can be reasonably used for motion estimation from noisy sensors.
However, the language used here is fairly close to what geometric descriptions of physical models use so likely it could be developed much futher.
Original author of this tutorial is not a physicist though so take it with a grain of salt.

:::

An external force acting upon a rigid body makes it accelerate or changes its angular velocity.
There are many possible geometric descriptions of these phenomena.
In this tutorial we will use the most simple one, i.e. representing acceleration as an additional tangent vector.
This ignores a lot of geometric content that could be exploited but it lets us move forward towards representing and analysing uncertainties caused by measurement inaccuracy.

The freely moving object followed a trajectory $\gamma(t)=\exp_p(tX)$
We can think of it as an object in the tangent bundle $T\operatorname{SE}(2)$ (though see technical note about cotangent bundle).
We could do again the trick with representing change as a tangent vector $(X_p, X_X) \in T_{(p, X)} T\operatorname{SE}(2)$ but it is a redundant representation: $X_p$ describes change in $p$ which is already described by $X$.
So all we need is the $X_X$ part of the tangent vector (to the tangent bundle).
Using the metric of $\operatorname{SE}(2)$ we can construct an isomorphism between the space in which $X_X$ lives in and the tangent space $T_p\operatorname{SE}(2)$.

Finally we determined that an accelerating object can be described by a triple $(p, X, X_X)$.
We do not yet have a complete description of the dynamics: how does the triple evolve with time?
A freely moving object followed a geodesic.
An accelerating object could also just follow a geodesic but we would have to manufacture an appropriate affine connection (see: [ðŸ“– general relativity](https://en.wikipedia.org/wiki/General_relativity)).
We are trying to keep things relatively simple so we will use the following ODE:
```math
\begin{aligned}
\dot{p} &= X \\
\dot{X} &= X_X\\
\dot{X_X} &= 0
\end{aligned}
```

To solve the ODE we still need an affine connection on the manifold $(p, X, X_X)$ lives on.
A nice way of describing that manifold in `Manifolds.jl` is by using a vector bundle where each fiber corresponds to direct sum of tangent spaces.
There is, however, one small caveat: `X_X` was brought from the double tangent bundle and depends on the connection we (should have) selected for the tangent bundle $T\operatorname{SE}(2)$.
So we may use the connection from $\operatorname{SE}(2)$ but we may also use the Levi-Civita connection of the Sasaki metric on $T\operatorname{SE}(2)$.
We shall explore this choice later in the tutorial.

For simplicity again we will use a first order forward Euler discretization to solve our ODE (see [technical note](@sec-forward-euler) if you disapprove).

## Technical notes

These technical notes elaborate on some aspects of the tutorial that a curious reader may find interesting but are not necessary to effectively work with `Manifolds.jl`

### Different exponential maps and connections

The exponential map we used in this tutorial is not the only one available on Lie groups.
Another choice is the so-called ``[Lie group exponential](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.exp_lie-Tuple{SpecialEuclidean,%20Any})``{=commonmark}.
In the case of the special Euclidean group, Lie group exponential mixes the translation and rotation parts of a tangent vector:

```{julia}
ts = 0.0:0.25:1.0
pts = [exp_lie(SE2, t * X) for t in ts]
plt5 = plot(; aspect_ratio=:equal)
for (t, p) in zip(ts, pts)
    draw_arrow_at(p; plt=plt5, arrow_kwargs=(; label="arrow at t=$t"))
end
plt5
```

Note also that the default choice of connection for Lie groups is not the only one.
There are also ``[Cartan-Schouten connections](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Cartan-Schouten-connections)``{=commonmark}.
They give the same exponential and logarithmic maps but a different parallel transport.

### Jet bundles?

Yes, [ðŸ“– jet bundles](https://en.wikipedia.org/wiki/Jet_bundle) are more mathematically enticing objects for describing dynamics but practical details of their implementation haven't been worked out yet.

### Phase space as a contangent bundle

Phase space in classical mechanics is typically defined as a contangent bundle.
Cotangent bundles are, however, hard to use for computation.
So we select Riesz representers of cotangent vectors according to the metric of our manifold.
In this way we get an isomorphism between tangent and cotangent bundles.

Note that a generic description of a phase space doesn't require a Riemannian metric.
Generic tools come from symplectic geometry which imposes a less rich structure.

### Forward Euler? Really? {#sec-forward-euler}

Yes, for simplicity. For a start. I may try a higher order or a symplectic solver later. You can do that too!
