---
title: Rigid body dynamics
---

In this tutorial we will learn how rigid body dynamics relates to concepts from Riemannian geometry and Lie groups.

```{julia}
#| echo: false
#| code-fold: true
#| output: false
using Pkg;
cd(@__DIR__)
Pkg.activate("."); # for reproducibility use the local tutorial environment.
using Markdown
```

In this tutorial we need to load a few libraries:
```{julia}
using Manifolds, LinearAlgebra, StaticArrays, RecursiveArrayTools, Plots
```

## 2-dimensional introduction

We will start by considering 2-D rigid bodies. They are characterized by three numbers: position along $x$ and $x$ axes and an angle.
Geometrically it can be represented by elements of the special euclidean group in 2 dimensions, $\operatorname{SE}(2)$:

```{julia}
SE2 = SpecialEuclidean(2)
se2_id = identity_element(SE2)
R2 = Euclidean(2)
```

For example, an object at $(2, 5)$ and at angle $\pi/3$ is represented by
```{julia}
p = exp(SE2, se2_id, hat(SE2, se2_id, [2.0, 5.0, pi/3]))
```

What does it do, exactly? This is one of many ways of creating a points on $\operatorname{SE}(2)$.
We can clearly recognize the numbers representing position and orientation of our object.
The `hat` function converts them to the Lie algebra of $\operatorname{SE}(2)$, denoted $\mathfrak{se}(2)$, while `exp` turns an element of $\mathfrak{se}(2)$ to an element of $\operatorname{SE}(2)$.
There are many ways of mapping between these two structures but `exp` is the one we need at the moment.

Now we will draw our object as an arrow, with position represented by the central-left point in the default orientation.

```{julia}
function draw_arrow_at(p; plt=nothing, arrow_kwargs=(;))
    if plt === nothing
        plt = plot(; aspect_ratio=:equal)
    end
    # constructing matrix where columns are vertices of our arrow
    pts = reduce(hcat, [[0.0, -0.125], [0.5, -0.125], [0.5, -0.25], [1.0, 0.0], [0.5, 0.25], [0.5, 0.125], [0.0, 0.125], [0.0, -0.125]])
    # action that transforms the arrow
    A = Manifolds.ColumnwiseSpecialEuclideanAction(R2, SE2)
    # applying the transformation
    pts_pos = apply(A, p, pts)
    # drawing the arrow
    arr = Shape(pts_pos[1, :], pts_pos[2, :])
    plot!(plt, arr; arrow_kwargs...)
end
plt1 = plot(; aspect_ratio=:equal)
draw_arrow_at(se2_id; plt=plt1, arrow_kwargs=(; label="default position"))
draw_arrow_at(p; plt=plt1, arrow_kwargs=(; label="arrow at p"))
plt1
```

### Simple transformations in global coordinates

There are several ways of transforming position and orientation of an object.
The first one translates and rotates an object by composition.
In the following example, translation by $(-1, -2)$ and rotation by $-\pi/6$ are applied.

```{julia}
p_tr = exp(SE2, se2_id, hat(SE2, se2_id, [-1.0, -2.0, -pi/6]))
p_transformed = compose(SE2, p_tr, p)
plt2 = plot(; aspect_ratio=:equal)
draw_arrow_at(p; plt=plt2, arrow_kwargs=(; label="arrow at p"))
draw_arrow_at(p_transformed; plt=plt2, arrow_kwargs=(; label="arrow after transformation"))
plt2
```

Transformation is applied using group composition operation of $\operatorname{SE}(2)$.
`p_transformed` corresponds to active transformation, represented also by [left-forward](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.LeftForwardAction) [group operation action](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.GroupOperationAction):

```{julia}
G_LF = GroupOperationAction(SE2, LeftForwardAction())
p_transformed_2 = apply(G_LF, p_tr, p)
isapprox(p_transformed, p_transformed_2)
```

Note that translation and rotation happen in the global coordinates, not local ones.
We will cover local coordinates later.

Basis transformation in the passive transformation can be understood as [right-forward](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.RightForwardAction) group operation action.
First we need to get vectors constituting the orthonormal basis of tangent space to $\operatorname{SE}(2)$ at $p$.
These vectors are elements of the special Euclidean Lie algebra $\mathfrak{se}(2)$.
```{julia}
B_SE2 = get_basis(SE2, p, DefaultOrthonormalBasis())
B_SE2_vecs = get_vectors(SE2, p, B_SE2)
```

Next we can use the right-forward action to transform these vectors.

```{julia}
G_RF = GroupOperationAction(SE2, RightForwardAction())
B_transformed = [apply(G_LF, p_tr, X_i) for X_i in B_SE2_vecs]
```

Notice that active transformation does not require a basis of the tangent space while the passive one does.

### Local transformations

Performing local transformations of an object requires different geometric tools.
Moving and rotating an object from its current position can be performed using an exponential map.
Its input are the current position and rotation (a point on $\operatorname{SE}(2)$) and a tangent vector that corresponds to the desired change.

```{julia}
X = hat(SE2, se2_id, [-1.0, -2.0, -pi/6])
```

Let's see how it affects our arrow:

```{julia}
p_exp = exp(SE2, p, X)
println("Old position: ", p)
println("New position: ", p_exp)
plt3 = plot(; aspect_ratio=:equal)
draw_arrow_at(p; plt=plt3, arrow_kwargs=(; label="arrow at p"))
draw_arrow_at(p_exp; plt=plt3, arrow_kwargs=(; label="arrow at exp(M, p, X)"))
plt3
```

As we can see, the arrow moved exactly as expected.

The inverse problem, i.e. figuring out what transformation needs to be applied to transform one position and orientation to another one, is solved by a logarithmic map.
Additionally, we can use [`vee`](@ref) to get back the coordinates of a tangent vector:
```{julia}
X_from_log = log(SE2, p, p_exp)
vee(SE2, p, X_from_log)
```

which gives us back the same coordinates that we used for `X`.

### A freely moving object

A freely moving object moves at a constant velocity and rotates with a constant angular velocity.
Both velocity and angular velocity can be represented by tangent vectors.
The following plot shows what happens to an object in such conditions.

```{julia}
ts = 0.0:0.5:10.0
pts = [exp(SE2, p, t * X) for t in ts]
plt4 = plot(; aspect_ratio=:equal)
for (t, p) in zip(ts, pts)
    draw_arrow_at(p; plt=plt4, arrow_kwargs=(; label="arrow at t=$t"))
end
plt4
```

As we can see, the arrow moves at velocity defined by `X`: -1 space units per time unit in the $x$ direction, -2 space units per time unit in the $y$ direction and rotates by $\pi/6$ clockwise per time unit.
Any kind of free movement can be expressed using a tangent vector.
You may notice that our object actually follows a geodesic in the special Euclidean group.

### Effects of external forces



## Technical notes

These technical notes elaborate on some aspects of the tutorial that a curious reader may find interesting but are not necessary to effectively work with `Manifolds.jl`

### Different exponential maps and connections

The exponential map we used in this tutorial is not the only one available on Lie groups.
Another choice is the so-called ``[Lie group exponential](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Manifolds.exp_lie-Tuple{SpecialEuclidean,%20Any})``{=commonmark}.
In the case of the special Euclidean group, Lie group exponential mixes the translation and rotation parts of a tangent vector:

```{julia}
ts = 0.0:0.25:1.0
pts = [exp_lie(SE2, t * X) for t in ts]
plt5 = plot(; aspect_ratio=:equal)
for (t, p) in zip(ts, pts)
    draw_arrow_at(p; plt=plt5, arrow_kwargs=(; label="arrow at t=$t"))
end
plt5
```

Note also that the default choice of connection for Lie groups is not the only one.
There are also ``[Cartan-Schouten connections](https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/group.html#Cartan-Schouten-connections)``{=commonmark}.
They give the same exponential and logarithmic maps but a different parallel transport.

### Jet bundles?

Yes, [ðŸ“– jet bundles](https://en.wikipedia.org/wiki/Jet_bundle) are more mathematically enticing objects for describing dynamics but practical details of their application haven't been worked out yet.
