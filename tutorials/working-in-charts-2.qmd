---
title: Working in charts II
---

In this tutorial we will learn how to use charts to solve a basic problems when the metric is defined using `inner` product.

```{julia}
#| echo: false
#| code-fold: true
#| output: false
using Pkg;
cd(@__DIR__)
Pkg.activate("."); # for reproducibility use the local tutorial environment.
using Markdown
```


We start by loading the necessary libraries.

```{julia}
#| output: false
using Manifolds, RecursiveArrayTools, OrdinaryDiffEq, DiffEqCallbacks, WGLMakie

```


We will work with the exterior of a [Schwarzschild black hole](https://en.wikipedia.org/wiki/Schwarzschild_metric) with Schwarzschild radius $r_s$. It is a 4-dimensional manifold represented using vectors of length 4.

```{julia}
struct BlackHoleOutside <: AbstractManifold{ℝ}
    rₛ::Float64
end

struct SchwarzschildAtlas <: AbstractAtlas{ℝ} end

Manifolds.manifold_dimension(::BlackHoleOutside) = 4
Manifolds.representation_size(::BlackHoleOutside) = (4,)

```

To work with this manifold, we need to define a metric. However, we first need to introduce an atlas. For this example let's use an atlas with one chart defined by [Schwarzschild coordinates](https://en.wikipedia.org/wiki/Schwarzschild_coordinates). We also indicate that we will use the Levi-Civita affine connection.

```{julia}

struct SchwarzschildAtlas <: AbstractAtlas{ℝ} end

function Manifolds.get_parameters!(M::BlackHoleOutside, x, ::SchwarzschildAtlas, i, p)
    x[1] = p[1] # t
    r = norm(p[2:4])
    x[2] = r
    x[3] = acos(p[4] / r) # θ
    x[4] = atan(p[3], p[2]) # ϕ
    return x
end

function Manifolds.get_point!(M::BlackHoleOutside, p, ::SchwarzschildAtlas, i, x)
    p[1] = x[1]
    p[2] = x[2] * sin(x[3]) * cos(x[4])
    p[3] = x[2] * sin(x[3]) * sin(x[4])
    p[4] = x[2] * cos(x[3])
    return p
end

function Manifolds.affine_connection!(M::BlackHoleOutside, Zc, A::SchwarzschildAtlas, i, a, Xc, Yc)
    return Manifolds.levi_civita_affine_connection!(M, Zc, A, i, a, Xc, Yc)
end

```

Since we use only one chart, we can switch off chart switching functionality:

```{julia}

function Manifolds.check_chart_switch(::BlackHoleOutside, A::SchwarzschildAtlas, i, a)
    return false
end
function Manifolds.get_chart_index(::BlackHoleOutside, ::SchwarzschildAtlas, p)
    return nothing
end
function Manifolds.get_chart_index(::BlackHoleOutside, ::SchwarzschildAtlas, i, a)
    return nothing
end
```


The metric implemented below is the Schwarzschild metric (signature +, −, −, −, and geometric units $c = G = 1$). In Schwarzschild coordinates (t, r, θ, φ) the inner product is

$$
g_{\mu\nu} = \operatorname{diag}\!\left(1-\frac{r_s}{r},\; -\frac{1}{1-r_s/r},\; -r^2,\; -r^2\sin^2\theta\right).
$$

where $r_s$ is the Schwarzschild radius.
The method `inner` in this tutorial computes the inner product of two tangent vectors expressed in the chart coordinate basis ∂/∂t, ∂/∂r, ∂/∂θ, ∂/∂φ.

```{julia}

function Manifolds.inner(M::BlackHoleOutside, ::SchwarzschildAtlas, i, a, Xc, Yc)
    t, r, θ, ϕ = a
    r_block = (1 - M.rₛ / r)
    # assuming c = 1
    return Xc[1] * r_block * Yc[1] - Xc[2] * Yc[2] / r_block - r^2 * (Xc[3] * Yc[3] + (sin(θ)^2) * Xc[4] * Yc[4])
end

```

And this is enough to compute geodesics

```{julia}
M = BlackHoleOutside(1.0)
p0 = [0.0, 10.0, 0.0, 0.0]

A = SchwarzschildAtlas()
i = nothing

X0 =  [1.0, 0.0, 0.18, 0.0]
a_p0 = get_parameters(M, A, i, p0)
B = induced_basis(M, A, a_p0)
c_X0 = get_coordinates(M, p0, X0, B)
final_time = 5000.0
sol = Manifolds.solve_chart_exp_ode(M, a_p0, c_X0, A, i; final_time=final_time, solver=Tsit5())

sampled_solution = sol(range(0.0, final_time; length=20000))

# plotting
x_values = [s[1][2] for s in sampled_solution]
y_values = [s[1][3] for s in sampled_solution]

fig = Figure(; size=(800, 800))
ax = Axis(fig[1, 1]; title="2D Plot of Sampled Solution", xlabel="x", ylabel="y", aspect = AxisAspect(1))
lines!(ax, x_values, y_values, color=:blue, label="movement")

arc!(Point2f(0), M.rₛ, -π, π)
axislegend(ax)
display(fig)
```

Below is a pre-recorded animation:

{{< video black_hole_orbit.mp4 >}}
